<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Storybound</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Montserrat:wght@300;400&family=Playfair+Display:wght@400;700&family=Open+Sans:wght@400;600&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Grenze+Gotisch:wght@400;700&family=Allura&family=Glass+Antiqua&family=Eagle+Lake&family=Smooch+Sans:wght@300;500&family=Pinyon+Script&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://use.typekit.net/bzl3zth.css">

  <style>
    /* GLOBAL VARS */
    :root{ 
        --bg1:#0a001f; --bg2:#2a0033; --pink:#ff69b4; --hot:#ff1493; --gold:#ffd700; --ink:#f0e6ff; --panel:rgba(20,0,40,.6); 
        --btn-bg: linear-gradient(145deg,#8b008b,var(--hot)); --btn-txt: var(--gold);
        --p1-color: #B0E0E6; --p2-color: #FFB6C1;
        --font-main: 'Lora', serif; 
        --font-story: 'Lora', serif;
        --story-size: 1.15em;
        --line-height: 1.8; 
        --letter-spacing: 0.02em;
        --cursor-url: url('https://raw.githubusercontent.com/rrrandr/storybound-app/1347ea65b81435cf03275d95aab21db4b1af8579/cursor-dollar-plane-64.png') 2 2;
    }
    
    /* THEMES */
    body.theme-sepia { --bg1:#2c2218; --bg2:#3e2f22; --pink:#d2b48c; --hot:#8b4513; --gold:#ffa500; --ink:#f5deb3; --panel:rgba(40,30,20,0.8); --btn-bg:#5c4033; --btn-txt:#f5deb3; --p1-color:#00008b; --p2-color:#8b0000; }
    body.theme-midnight { --bg1:#000000; --bg2:#111111; --pink:#444; --hot:#666; --gold:#888; --ink:#ccc; --panel:rgba(20,20,20,0.9); --btn-bg:#333; --btn-txt:#aaa; }
    body.theme-print { --bg1:#e0e0e0; --bg2:#f0f0f0; --pink:#333; --hot:#000; --gold:#444; --ink:#111; --panel:rgba(255,255,255,0.95); --btn-bg:#ccc; --btn-txt:#000; --p1-color:#00008b; --p2-color:#8b0000; }
    body.theme-easy { --bg1:#fffdd0; --bg2:#fff8c0; --pink:#333; --hot:#000; --gold:#555; --ink:#000; --panel:rgba(255,255,240,0.95); --btn-bg:#000; --btn-txt:#fff; --p1-color:#00008b; --p2-color:#8b0000; }

    /* Print Fixes */
    body.theme-print .fate-card h3, body.theme-easy .fate-card h3 { color: #fff !important; text-shadow: 0 0 3px #000; }

    html, body { margin:0; padding:0; background:linear-gradient(135deg,var(--bg1),var(--bg2)); color:var(--ink); font-family:var(--font-main); overflow-x:hidden; min-height:100vh; }
    body { text-align:center; padding:10px; transition: background 0.3s, color 0.3s; }
    
    /* TYPOGRAPHY */
    h1, h2, .section-title { font-family:'lust-script-display','lust-script',serif !important; color:var(--pink); text-shadow:0 0 15px var(--hot); font-weight:400; }
    .section-title { font-size:2.2em; margin:35px 0 15px; border-top:1px solid rgba(255,105,180,0.2); padding-top:20px; }
    
    .instruction-text { font-family: 'Lora', serif; font-size: 0.5em; color: var(--ink); opacity: 0.7; vertical-align: middle; margin-left: 12px; letter-spacing: 0; text-shadow: none; font-weight: normal; }
    
    .subtitle { font-size: 1.2em; color: var(--gold); font-style: italic; opacity: 0.9; margin-bottom: 30px; }

    /* STORY READING EXPERIENCE */
    #storyText { 
        text-align: left; 
        max-width: 100%; 
        min-height: 300px; 
        margin-bottom: 20px; 
        font-size: var(--story-size); 
        line-height: var(--line-height); 
        letter-spacing: var(--letter-spacing);
        font-family: var(--font-story);
    }
    #storyText p { margin-bottom: 1.5em; }
    
    .story-image {
        max-width: 100%;
        border-radius: 10px;
        margin: 14px 0;
        border: 1px solid rgba(255,105,180,0.25);
        box-shadow: 0 0 18px rgba(0,0,0,0.35);
    }

    /* DIALOGUE */
    .dialogue-block { display: block; margin: 15px 0; padding-left: 20px; border-left: 3px solid rgba(255,255,255,0.2); font-style: italic; font-weight: 500; font-size: 1.1em; }
    .p1-dia { color: var(--p1-color); border-color: var(--p1-color); }
    .p2-dia { color: var(--p2-color); border-color: var(--p2-color); }

    /* BUTTONS */
    button { background:var(--btn-bg); color:var(--btn-txt); padding:10px 30px; border:none; border-radius:25px; font-size:1em; cursor:pointer; box-shadow:0 0 18px rgba(0,0,0,0.2); transition:.3s; font-family:var(--font-main); position:relative; }
    button:hover { transform:scale(1.05); filter:brightness(1.2); }
    button:disabled { opacity:0.5; cursor:not-allowed; transform:none; }
    .small-btn { font-size: 0.9em; padding: 8px 16px; background: #444; color:#fff; box-shadow:none; }

    /* UTILS */
    .box { max-width:600px; margin:20px auto; padding:25px; background:var(--panel); border:1px solid var(--pink); border-radius:15px; box-shadow:0 0 20px rgba(0,0,0,0.2); }
    
    /* CHOICE BUTTONS - Mobile Fix */
    .choice-buttons { display:flex; flex-wrap:wrap; gap:20px; justify-content:center; margin:30px auto; max-width:800px; }
    @media (max-width: 600px) {
        .choice-buttons { flex-direction: column; align-items: center; }
        .choice-buttons > div { width: 100%; max-width: 300px; }
    }
    
    .choice { padding:15px 40px; font-size:1.4em; border-radius:30px; font-family:'lust-script-display',serif; width: 100%; box-sizing: border-box; }
    .hidden { display:none !important; }
    
    /* INPUTS & LOCKS */
    .input-wrapper { position: relative; width: 95%; margin: 0 auto 15px; overflow:hidden; }
    .input-wrapper label { display:block; text-align:center; color:var(--gold); margin-bottom:5px; font-size:0.9em; font-family:var(--font-main); text-transform:uppercase; letter-spacing:1px; }
    textarea, input, select { width:100%; padding:15px; background:rgba(0,0,0,0.3); color:var(--ink); border:1px solid var(--pink); border-radius:8px; font-size:1em; font-family:var(--font-main); box-sizing:border-box; }
    
    /* GHOST TEXT / PILL GRID */
    .ghost-overlay {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; overflow: hidden; padding: 10px;
        background: rgba(0,0,0,0.2);
    }
    .ghost-grid {
        display: flex; flex-wrap: wrap; align-content: flex-start; gap: 6px;
        height: 100%; width: 100%;
    }
    .ghost-item {
        background: rgba(255,255,255,0.05); padding: 4px 10px; border-radius: 4px;
        color: rgba(255,255,255,0.4); font-size: 0.8em; 
        border: 1px solid rgba(255,105,180,0.1);
        transition: all 0.5s; cursor: default;
    }
    .ghost-item.highlight {
        color: var(--pink); border-color: var(--pink); opacity: 1;
        box-shadow: 0 0 10px rgba(255,105,180,0.4);
    }

    /* LOCKS & CURSOR */
    .locked-input textarea, .locked-style, .card.locked, .fate-card.locked { 
        opacity:0.6; filter:grayscale(0.9); 
        cursor: var(--cursor-url), pointer !important; 
        pointer-events: auto; 
    }
    .locked-input, .locked-style, .card.locked, .fate-card.locked {
        position: relative;
    }
    .locked-style { display: inline-block; }

    /* HANDCUFF OVERLAY - Updated to SVG for better quality/transparency */
    .locked-input::after, .locked-style::after, .card.locked::after, .fate-card.locked::after { 
        content:""; position:absolute; 
        top:5px; right:5px; 
        width:24px; height:24px; 
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17.5 13.5a3.5 3.5 0 1 0-2.5-5.9l-1.5 1.5'%3E%3C/path%3E%3Cpath d='M6.5 10.5a3.5 3.5 0 1 0 2.5 5.9l1.5-1.5'%3E%3C/path%3E%3Cpath d='M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0'%3E%3C/path%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: center;
        background-size: contain;
        opacity:0.9; 
        pointer-events:none; 
        z-index: 10; 
        filter: drop-shadow(0 0 2px black);
    }
    .locked-input::after { top: 40px; right: 10px; } 

    /* STYLE CARDS */
    .style-cards { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:15px; margin:15px 0; }
    .card { background:#252525; border-radius:12px; padding:15px; cursor:pointer; text-align:left; border:2px solid transparent; position:relative; transition:.2s; }
    .card:hover { transform:translateY(-3px); border-color:#ff6b6b; }
    .card.selected { border-color:#ff69b4; background:#333; box-shadow:0 0 15px rgba(255,105,180,0.3); }
    .card h3 { margin:0 0 5px; color:#ff6b6b; font-size:1.1em; font-family:'lust-script-display',serif; }
    .card p { font-size:0.9em; opacity:0.9; margin:0; font-family:var(--font-main); }
    .preview-btn { margin-top:10px; font-size:0.75em; padding:4px 10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); box-shadow:none; z-index:5; position:relative; pointer-events: auto !important; cursor: pointer !important;}
    .preview-btn:hover { background:rgba(255,255,255,0.2); }

    /* FATE CARDS */
    .fate-grid { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin:20px auto; max-width:500px; perspective:1000px; }
    .fate-card { width:100%; aspect-ratio:2/3; position:relative; cursor:pointer; background:none; border:none; padding:0; transform-style:preserve-3d; transition:transform 0.6s; }
    .fate-card .inner { position:absolute; inset:0; border-radius:8px; transform-style:preserve-3d; transition:transform 0.6s; box-shadow:0 5px 15px rgba(0,0,0,0.5); }
    .fate-card.flipped .inner { transform:rotateY(180deg); }
    .fate-card .front, .fate-card .back { position:absolute; inset:0; backface-visibility:hidden; border-radius:8px; display:flex; align-items:center; justify-content:center; border:1px solid rgba(255,215,0,0.3); }
    .fate-card .front { background:#111; z-index:2; } 
    .fate-card .back { background:#2a0033; transform:rotateY(180deg); z-index:1; }
    .fate-card.poof { animation: smokePoof 0.6s forwards; }
    @keyframes smokePoof { 0%{ opacity:1; transform:scale(1); } 100%{ opacity:0; transform:scale(0.5); } }

    /* INTENSITY BUTTONS */
    .intensity-wrap { margin: 10px 0; }
    .intensity-btn { margin: 5px; opacity: 0.6; }
    .intensity-btn.active { opacity: 1; border: 2px solid var(--gold); box-shadow: 0 0 15px var(--hot); }
    .intensity-mini { display:flex; gap:5px; justify-content:center; margin: 15px 0; }
    .intensity-mini button { padding: 5px 15px; font-size: 0.8em; opacity: 0.6; }
    .intensity-mini button.active { opacity: 1; border: 1px solid var(--gold); }

    /* LOADING BAR */
    #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 200; flex-direction: column;}
    #loadingOverlayInner { background: rgba(10, 0, 30, 0.95); padding: 18px 26px 14px 26px; border-radius: 14px; box-shadow: 0 0 35px rgba(255, 20, 147, 0.8); min-width: 280px; text-align: left; font-size: 0.95em; }
    #loadingOverlayBar { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.12); border-radius: 999px; overflow: hidden; margin-top: 8px; }
    #loadingOverlayFill { width: 0%; height: 100%; background: var(--pink); transition: width 0.25s; }

    /* BURGER */
    #burgerBtn { position:fixed; top:15px; right:15px; z-index:5000; font-size:1.8em; background:none; border:none; color:var(--pink); padding:0; cursor:pointer; text-shadow: 0 0 5px var(--hot); box-shadow:none; }
    #burgerBtn:hover { transform: scale(1.1); box-shadow:none; }

    /* VISUALIZE MODAL */
    .viz-modal-content { text-align: center; max-width: 600px; width: 90%; max-height:90vh; overflow-y:auto; }
    .viz-controls { display:flex; gap:10px; justify-content:center; margin-top:15px; flex-wrap:wrap; }
    #vizPreviewImg { width: 100%; border-radius: 8px; margin-top: 10px; max-height: 400px; object-fit: contain; background:#000; min-height:200px; display:none; }
    #vizPlaceholder { width: 100%; height:200px; display:flex; align-items:center; justify-content:center; border:1px dashed #444; margin-top:10px; color:#666; font-style:italic;}
    #vizPromptInput { width: 100%; height: 60px; font-size: 0.85em; margin-bottom: 10px; color: var(--gold); border: 1px solid var(--pink); background: rgba(0,0,0,0.5); }

    /* SETTING SHOT */
    #settingShotWrap { 
        margin-bottom: 30px; animation: fadeIn 2s ease; border-radius: 12px; overflow: hidden; 
        border: 1px solid var(--pink); box-shadow: 0 0 20px rgba(255,20,147,0.3); 
        position:relative; min-height:250px; background: rgba(0,0,0,0.3);
        display: flex; align-items: center; justify-content: center;
    }
    #settingShotImg { width: 100%; display: none; }
    .img-error-msg { font-size:0.9em; color:#ff6b6b; padding:20px; font-style: italic; z-index:5; text-align:center; }
    
    /* FATE META UI */
    #metaControls .meta-stance { opacity: 0.5; border: 1px solid transparent; }
    #metaControls .meta-stance.active { opacity: 1; border: 1px solid var(--gold); box-shadow: 0 0 5px var(--gold); }

    /* COUPLE UI */
    #coupleRoomCodeWrap { display: flex; align-items: center; justify-content: center; gap: 10px; }
    #btnCopyCode { background: none; border: 1px solid var(--pink); padding: 5px; border-radius: 5px; cursor: pointer; color: var(--gold); }

    /* GOD MODE UI */
    #godModeToggle { margin-top:10px; font-size:0.8em; display:flex; align-items:center; justify-content:center; gap:8px; opacity:0.8; cursor:pointer; }
    #godModeToggle input { width:auto; margin:0; cursor:pointer; }
    #godModeLabel { color: var(--gold); font-family:var(--font-main); letter-spacing:1px; }

    @keyframes fadeIn { from{opacity:0;} to{opacity:1;} }

    @media (max-width:700px) { .fate-grid { grid-template-columns:repeat(3,1fr); } .fate-card:nth-child(4), .fate-card:nth-child(5) { grid-column:span 1; } }
  </style>
</head>

<body>

<div id="auth-panel" style="position:fixed;top:10px;right:10px;z-index:9999;background:rgba(0,0,0,0.8);padding:10px;border:1px solid #444;border-radius:5px;display:flex;flex-direction:column;gap:5px;">
  <input id="auth-email" placeholder="Email" style="padding:5px;" />
  <input id="auth-password" type="password" placeholder="Password" style="padding:5px;" />
  <button id="btn-signin" style="padding:5px;cursor:pointer;">Sign in</button>
  <div id="auth-status" style="font-size:12px;margin-top:6px;color:#fff;"></div>
</div>

<button id="burgerBtn">☰</button>
<div id="menuOverlay" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:4999; align-items:center; justify-content:center; display:flex;">
  <div class="box">
    <h3>Menu</h3>
    <button onclick="restart()">Restart Story</button>
    <button onclick="changeTier()">Change Tier</button>
    <button id="continueStoryBtn" class="hidden" onclick="window.continueStory()">Continue Saved Story</button>
    <hr style="border:0; border-top:1px solid #444; margin: 15px 0;">
    
    <label style="color:var(--gold); display:block; margin-bottom:5px;">Theme</label>
    <div style="display:flex; gap:5px; justify-content:center; flex-wrap:wrap; margin-bottom:15px;">
        <button class="small-btn" onclick="setTheme('default')">Default</button>
        <button class="small-btn" onclick="setTheme('sepia')">Sepia</button>
        <button class="small-btn" onclick="setTheme('midnight')">Midnight</button>
        <button class="small-btn" onclick="setTheme('print')">Print</button>
        <button class="small-btn" onclick="setTheme('easy')">Easy</button>
    </div>

    <label style="color:var(--gold); display:block; margin-bottom:5px;">Font</label>
    <select id="fontSelect" onchange="setFont(this.value)" style="margin-bottom:15px;">
        <option value="'Lora', serif">Lora (Default)</option>
        <option value="'Grenze Gotisch', cursive">Grenze Gotisch</option>
        <option value="'Allura', cursive">Allura</option>
        <option value="'Glass Antiqua', cursive">Glass Antiqua</option>
        <option value="'Eagle Lake', cursive">Eagle Lake</option>
        <option value="'Smooch Sans', sans-serif">Smooch Sans</option>
        <option value="'Pinyon Script', cursive">Pinyon Script</option>
        <option value="'Merriweather', serif">Merriweather</option>
        <option value="'Roboto', sans-serif">Roboto</option>
    </select>

    <label style="color:var(--gold); display:block; margin-bottom:5px;">Font Size</label>
    <input type="range" min="16" max="72" value="18" oninput="setFontSize(this.value)">

    <br><br>
    <button onclick="document.getElementById('menuOverlay').classList.add('hidden')" style="background:#444">Close</button>
  </div>
</div>

<div id="loadingOverlay">
  <div id="loadingOverlayInner">
    <div id="loadingText" style="font-style:italic; color:var(--gold);">Stoking the embers...</div>
    <div id="loadingOverlayBar"><div id="loadingOverlayFill"></div></div>
  </div>
</div>

<div id="vizModal" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:3000; align-items:center; justify-content:center; display:flex;">
  <div class="box viz-modal-content">
    <h3>Visualization</h3>
    <textarea id="vizPromptInput" placeholder="Prompt will appear here..."></textarea>
    <div id="vizPlaceholder">Generating...</div>
    
    <div id="vizImgContainer" style="position:relative; min-height:200px; display:flex; align-items:center; justify-content:center;">
        <img id="vizPreviewImg" alt="Scene" style="display:none">
        <div id="vizError" class="img-error-msg hidden"></div>
    </div>

    <div class="viz-controls">
        <select id="vizModel" style="width:auto; padding:5px;">
            <option value="auto">Auto (Best Available)</option>
            <option value="grok-2-image-1212">Grok 2</option>
            <option value="openai">OpenAI (DALL-E 3)</option>
            <option value="gemini">Gemini (Fantasy)</option>
        </select>
        <button class="small-btn" onclick="visualize(true)">Re-Visualize</button>
        <button onclick="insertImage()">Insert</button>
        <button class="small-btn" style="background:#555" onclick="closeViz()">Cancel</button>
    </div>
  </div>
</div>

<div id="coupleInvite" class="hidden" style="position:fixed; inset:0; background:#000; z-index:9990; align-items:center; justify-content:center; display:flex;">
  <div class="box" style="max-width:520px; text-align:center;">
    <h3>Open a Private Chamber</h3>

    <div style="text-align:left; margin:10px 0 15px; font-size:0.95em; border-bottom:1px solid #444; padding-bottom:10px;">
      <div><strong>Your nickname:</strong> <span id="sbNickLabel" style="color:var(--gold)">…</span></div>
      <div><strong>Status:</strong> <span id="coupleStatus" style="font-style:italic">Not connected</span></div>
      <div><strong>Room Code:</strong> <span id="coupleRoomCodeLabel" style="font-family:monospace; color:var(--pink)">—</span></div>
    </div>

    <div style="display:flex; gap:10px; justify-content:center; margin-bottom:15px;">
      <button id="btnCreateRoom">Create Room</button>
      <button id="btnJoinRoom" style="background:#444">Join Room</button>
    </div>

    <div id="joinRow" class="hidden" style="margin-bottom:15px; display:flex; gap:10px; justify-content:center;">
      <input id="joinCodeInput" placeholder="Enter 6-char Code" style="text-transform:uppercase; text-align:center; width:150px;">
      <button id="btnJoinGo">Enter</button>
    </div>

    <div id="roomCodeWrap" class="hidden" style="margin-bottom:15px;">
      <p style="margin:0 0 5px; font-size:0.9em; opacity:0.8;">Share this code with your partner:</p>
      <div id="coupleRoomCodeWrap">
         <div id="roomCodeBig" style="font-size:2.5em; letter-spacing:6px; color:var(--gold); border:2px dashed var(--pink); padding:10px; background:rgba(255,105,180,0.1);">—</div>
         <button id="btnCopyCode" title="Copy Code">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
         </button>
      </div>
    </div>

    <div>
      <button id="btnEnterCoupleGame" class="hidden" style="width:100%; margin-bottom:10px;">Enter Together</button>
      <button onclick="coupleCleanup(); showScreen('modeSelect')" style="background:transparent; border:1px solid #444; font-size:0.9em;">Back</button>
    </div>
  </div>
</div>

<div id="coupleConsentModal" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:9995; align-items:center; justify-content:center; display:flex;">
  <div class="box" style="max-width:450px; text-align:center;">
    <h3 style="color:var(--gold);">Shared Intensity Agreement</h3>
    <p>You are entering a shared hallucination. Before you begin:</p>
    <ul style="text-align:left; font-size:0.9em; line-height:1.5; color:var(--ink); margin: 20px auto; max-width: 350px;">
        <li><strong>Intensity is a hard ceiling.</strong> What the story depicts is limited by the setting, regardless of what you type.</li>
        <li><strong>Inputs are requests.</strong> If you type explicit acts in 'Naughty', they will be rendered as suggestive tension.</li>
        <li><strong>Upgrades required.</strong> You can only raise the ceiling if your access tier allows it.</li>
    </ul>
    <div style="display:flex; gap:10px; justify-content:center;">
        <button id="btnCoupleAgree">Agree & Enter</button>
        <button onclick="showScreen('setup'); document.getElementById('coupleConsentModal').classList.add('hidden');" style="background:#444">Change Settings</button>
    </div>
  </div>
</div>

<div id="strangerModal" class="hidden" style="position:fixed; inset:0; background:#000; z-index:9990; align-items:center; justify-content:center; display:flex;">
  <div class="box">
    <h3>How Daring...</h3>
    <p><span id="strangerCount">12,408</span> others are seeking a connection right now.</p>
    <p style="font-style:italic; color:var(--gold)">Matching is currently unavailable in this version.</p>
    <button onclick="showScreen('modeSelect')" style="background:#444">Return</button>
  </div>
</div>

<div id="ageGate" style="position:fixed; inset:0; background:#000; z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center;">
  <h2>Storybound</h2>
  <p style="font-size:1.2em; max-width:500px; margin:20px;">Explicit adult themes. 18+ Only.</p>
  <button id="ageYes">I am 18+</button>
  <button onclick="location.href='https://google.com'" style="background:#333">Exit</button>
</div>

<div id="tosGate" class="hidden" style="position:fixed; inset:0; background:#000; z-index:9998; flex-direction:column; align-items:center; justify-content:center; display:flex;">
  <h2>Terms of Service</h2>
  <div class="box" style="text-align:left; height:60vh; overflow-y:auto; font-size:0.85em; line-height:1.5;">
    <p><strong>TERMS OF SERVICE</strong></p>
    <p>1. <strong>Age Requirement:</strong> You must be 18+.</p>
    <p>2. <strong>Content Policy:</strong> Adult fantasy roleplay only. Content must be consensual. Optional power play/roleplay is permitted only if explicitly opted-in by user. No depiction of non-consensual sexual acts, sexual violence, or minors.</p>
    <p>3. <strong>Data & AI:</strong> Content generated by third-party AI models. We may anonymize and aggregate data to improve the Service.</p>
    <p>4. <strong>Liability:</strong> Use at your own risk. Entertainment purposes only.</p>
    <p><em>(Full text abbreviated for display, but legally binding).</em></p>
  </div>
  <label><input type="checkbox" id="tosCheck"> I agree to the Terms</label>
  <br>
  <button id="tosBtn" disabled>Enter Storybound</button>
</div>

<div id="tierGate" class="hidden" style="position:fixed; inset:0; background:#000; z-index:9997; flex-direction:column; align-items:center; justify-content:center; display:flex;">
  <h2>Storybound</h2>
  <div class="choice-buttons">
    <div style="text-align:center">
      <button class="choice" id="btnTease">Tease</button>
      <p style="opacity:0.7; max-width:250px; margin:10px auto;">A playful warmup—gentle choices, tension, and atmosphere.<br><br><strong>From $Free</strong></p>
    </div>
    <div style="text-align:center">
      <button class="choice" id="btnIndulge">Indulge</button>
      <p style="opacity:0.7; max-width:250px; margin:10px auto;">Longer openings, deeper memory, full control, saved stories.<br><br><strong>From $6/mo</strong></p>
    </div>
  </div>
  <button id="continueFromTierBtn" class="choice hidden" style="margin-top:20px; width:80%" onclick="window.continueStory()">Continue Saved Story</button>
</div>

<div id="payModal" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:10000; align-items:center; justify-content:center; display:flex;">
  <div class="box" style="text-align:center; max-width: 500px;">
    <h3>Unshackle Your Fate</h3>
    
    <div id="godModePay" class="hidden">
       <h4 style="color:var(--gold); margin-top:0; font-size:1.4em;">Unlock God Mode</h4>
       <p style="font-size:0.9em; opacity:0.8; margin-bottom:20px;">
         Sandbox power. No cooldowns. No safety.
         <br><strong>$50 One-time purchase.</strong>
       </p>
       <button id="payGodMode" style="width:100%; margin-top:10px; background:var(--gold); color:black;">Unlock Forever ($50)</button>
    </div>

    <div id="standardPay">
        <div style="display:flex; gap:20px; justify-content:center; flex-wrap:wrap; margin:20px 0;">
            <div id="optUnlock" class="hidden" style="background:#222; padding:15px; border-radius:10px; border:1px solid #ff69b4; width:220px; text-align:left;">
                <h4 style="color:var(--pink); margin-top:0;">Story Pass</h4>
                <p id="passCopy" style="font-size:0.85em; opacity:0.8; min-height:1.2em; font-style:italic;">A light commitment.</p>
                <ul style="font-size:0.8em; padding-left:15px; opacity:0.9; line-height:1.4;">
                    <li>Unlock this story up to 25k words</li>
                    <li>Continue your current arc</li>
                    <li>One-time unlock for this story</li>
                    <li>Subscription required past 25k</li>
                </ul>
                <button id="payOneTime" style="width:100%; margin-top:10px;">Unlock This Story — $2</button>
            </div>

            <div id="optSub" style="background:linear-gradient(145deg, #400020, #200010); padding:15px; border-radius:10px; border:1px solid gold; width:220px; text-align:left;">
                <h4 style="color:var(--gold); margin-top:0;">Indulge — $6/mo</h4>
                <p style="font-size:0.85em; opacity:0.8; min-height:1.2em; font-style:italic;">Complete access.</p>
                <ul style="font-size:0.8em; padding-left:15px; opacity:0.9; line-height:1.4;">
                    <li>Dirty unlocked</li>
                    <li>Unlimited stories</li>
                    <li>Change intensity anytime</li>
                    <li>Save, return, deepen</li>
                </ul>
                <button id="paySub" style="width:100%; margin-top:10px; background:var(--gold); color:black;">Take Control — Subscribe for $6</button>
            </div>
        </div>
        <p style="font-size:0.7em; opacity:0.5; margin-top:20px;">Optional sandbox power modes sold separately.</p>
    </div>
    
    <button onclick="document.getElementById('payModal').classList.add('hidden')" style="background:#444; margin-top:15px;">Cancel</button>
  </div>
</div>

<div id="previewModal" class="hidden" style="position:fixed; inset:0; background:rgba(0,0,0,0.85); z-index:5000; align-items:center; justify-content:center; display:flex;">
  <div class="box">
    <p id="previewText" style="font-size:1.3em; font-style:italic; line-height:1.6"></p>
    <button onclick="document.getElementById('previewModal').classList.add('hidden')">Close</button>
  </div>
</div>

<div id="app" class="hidden">

  <div id="modeSelect">
    <h1 style="margin-top:40px">Storybound</h1>
    
    <div class="choice-buttons">
      <div style="text-align:center">
          <button class="choice" onclick="setMode('solo')">Solo</button>
          <p style="opacity:0.7; max-width:200px; margin:10px auto;">Your private laboratory—intentional, charged.</p>
      </div>
      <div style="text-align:center">
          <button class="choice" id="btnCoupleMode" onclick="setMode('couple')">Couple</button>
          <p style="opacity:0.7; max-width:200px; margin:10px auto;">Link devices and co-create a shared seduction.</p>
      </div>
      <div style="text-align:center">
          <button class="choice" onclick="setMode('stranger')">Stranger</button>
          <p style="opacity:0.7; max-width:200px; margin:10px auto;">Tempt fate with a random encounter.</p>
      </div>
    </div>
  </div>

  <div id="setup" class="hidden" style="max-width:800px; margin:0 auto; padding-bottom:50px;">
    
    <div class="section-title">Shape Your Story</div>
    
    <div class="input-wrapper" style="width: 95%; margin: 10px auto;">
        <label style="color:var(--gold);">Your Character's Name</label>
        <input id="playerNameInput" type="text" placeholder="e.g. Elara Vance">
    </div>

    <div class="input-wrapper" style="width: 95%; margin: 10px auto;">
        <label style="color:var(--gold);">Your Love Interest's Name</label>
        <input id="partnerNameInput" type="text" placeholder="e.g. Lord Blackwood">
    </div>
    
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px; width:95%; margin:20px auto 0;">
        <div>
            <label style="color:var(--gold);">Your Gender</label>
            <select id="playerGender" onchange="checkCustom(this, 'customPlayerGender')">
                <option value="Female">Female</option>
                <option value="Male">Male</option>
                <option value="Non-Binary">Non-Binary</option>
                <option value="Custom">Custom</option>
            </select>
            <input id="customPlayerGender" type="text" placeholder="Enter gender..." class="hidden" style="margin-top:5px;">
            
            <label style="color:var(--gold); margin-top:10px;">Pronouns</label>
            <select id="playerPronouns" onchange="checkCustom(this, 'customPlayerPronouns')">
                <option value="She/Her">She/Her</option>
                <option value="He/Him">He/Him</option>
                <option value="They/Them">They/Them</option>
                <option value="Custom">Custom</option>
            </select>
            <input id="customPlayerPronouns" type="text" placeholder="Enter pronouns..." class="hidden" style="margin-top:5px;">

            <label style="color:var(--gold); margin-top:10px;">Ancestry / Nature</label>
            <div class="input-wrapper relative" style="height: 140px;">
                <textarea id="playerAncestry" style="color:transparent; background:transparent; z-index:2; position:relative; height:100%;"></textarea>
                <div class="ghost-overlay" id="ghost1">
                    <div class="ghost-grid"></div>
                </div>
            </div>
        </div>

        <div>
            <label style="color:var(--gold);">Love Interest Gender</label>
            <select id="loveInterestGender" onchange="checkCustom(this, 'customLoveInterest')">
                <option value="Male">Male</option>
                <option value="Female">Female</option>
                <option value="Non-Binary">Non-Binary</option>
                <option value="Custom">Custom</option>
            </select>
            <input id="customLoveInterest" type="text" placeholder="Enter gender..." class="hidden" style="margin-top:5px;">
            
            <label style="color:var(--gold); margin-top:10px;">Pronouns</label>
            <select id="lovePronouns" onchange="checkCustom(this, 'customLovePronouns')">
                <option value="He/Him">He/Him</option>
                <option value="She/Her">She/Her</option>
                <option value="They/Them">They/Them</option>
                <option value="Custom">Custom</option>
            </select>
            <input id="customLovePronouns" type="text" placeholder="Enter pronouns..." class="hidden" style="margin-top:5px;">

            <label style="color:var(--gold); margin-top:10px;">Ancestry / Nature</label>
            <div class="input-wrapper relative" style="height: 140px;">
                <textarea id="loveAncestry" style="color:transparent; background:transparent; z-index:2; position:relative; height:100%;"></textarea>
                <div class="ghost-overlay" id="ghost2">
                    <div class="ghost-grid"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="section-title">Intensity <span class="instruction-text">(Rendering Ceiling)</span></div>
    <div id="intensityBtns" class="intensity-wrap">
      <button data-val="Clean" class="intensity-btn">Clean</button>
      <button data-val="Naughty" class="intensity-btn active">Naughty</button>
      <button data-val="Erotic" class="intensity-btn locked-tease">Erotic</button>
      <button data-val="Dirty" class="intensity-btn locked-pass">Dirty</button>
    </div>
    <p id="intensityDesc" style="color:var(--gold); font-style:italic; margin-top:10px; min-height:40px;">
        (Naughty) Suggestive tension; no explicit anatomy.
    </p>
    
    <div class="section-title">Story Length</div>
    <div class="style-cards" id="lengthGrid">
      <div class="card selected" data-grp="length" data-val="10000">
        <h3>Short Story (10k)</h3>
        <p>Free in Tease. A complete arc in one sitting.</p>
      </div>

      <div class="card locked" data-grp="length" data-val="25000" data-locked="pass">
        <h3>Novella (25k)</h3>
        <p>$1 Story Pass. Unlocks controls + options, but capped at 25k.</p>
      </div>

      <div class="card locked" data-grp="length" data-val="50000" data-locked="sub">
        <h3>Short Novel (50k)</h3>
        <p>Subscribe to continue past Tease/Pass limits.</p>
      </div>

      <div class="card locked" data-grp="length" data-val="100000" data-locked="sub">
        <h3>Full Novel (100k+)</h3>
        <p>Subscribe for long-form arcs and deeper continuity.</p>
      </div>
    </div>

    <p style="font-size:0.85em; color:var(--gold); opacity:0.85; margin-top:10px;">
      Tease and Story Pass stories will pause at their length cap. Subscribe to continue.
    </p>

    <div class="section-title">Genres <span class="instruction-text">(Select up to 3)</span></div>
    <div class="style-cards" id="genreGrid">
      <div class="card" data-grp="genre" data-val="Romantasy"><h3>Romantasy</h3><p>High fantasy worlds, magic, and intense romantic stakes.</p></div>
      <div class="card" data-grp="genre" data-val="Contemporary"><h3>Contemporary Romance</h3><p>Modern settings and present-day relationships.</p></div>
      <div class="card" data-grp="genre" data-val="Historical"><h3>Historical Romance</h3><p>Period romance and forbidden rules.</p></div>
      <div class="card" data-grp="genre" data-val="Paranormal"><h3>Paranormal Modern Romance</h3><p>Vampires, shifters, witches in today’s world.</p></div>
      <div class="card" data-grp="genre" data-val="Dark"><h3>Dark Romance</h3><p>Morally gray heat; player defines boundaries.</p></div>
      <div class="card" data-grp="genre" data-val="Suspense"><h3>Romantic Suspense</h3><p>Romance entangled with danger and mystery.</p></div>
      <div class="card" data-grp="genre" data-val="Sports"><h3>Sports Romance</h3><p>Athletes and competitive tension.</p></div>
      <div class="card" data-grp="genre" data-val="Crime"><h3>Organized Crime Romance</h3><p>Forbidden love in criminal worlds.</p></div>
    </div>
    
    <button class="small-btn" onclick="toggle('moreGenres')">More Genres</button>
    <div id="moreGenres" class="style-cards hidden">
       <div class="card" data-grp="genre" data-val="Billionaire"><h3>Billionaire Romance</h3><p>Ultra-wealthy leads, power, polish.</p></div>
       <div class="card" data-grp="genre" data-val="Gothic"><h3>Gothic Romance</h3><p>Moody, haunted settings.</p></div>
       <div class="card" data-grp="genre" data-val="LGBTQ"><h3>Queer LGBTQ+</h3><p>Inclusive love stories.</p></div>
       <div class="card" data-grp="genre" data-val="SecondChance"><h3>Second Chance</h3><p>Ex-lovers reunited with baggage.</p></div>
       <div class="card" data-grp="genre" data-val="SmallTown"><h3>Small Town</h3><p>Cozy community vibes.</p></div>
       <div class="card" data-grp="genre" data-val="Romcom"><h3>Romantic Comedy</h3><p>Bantery, light chaos.</p></div>
    </div>

    <div class="section-title">Dynamics <span class="instruction-text">(Select up to 3)</span></div>
    <div class="style-cards" id="dynamicGrid">
      <div class="card" data-grp="dynamic" data-val="Enemies"><h3>Enemies → Lovers</h3><p>Rivals whose friction turns to heat.</p></div>
      <div class="card" data-grp="dynamic" data-val="Forbidden"><h3>Forbidden Love</h3><p>Desire under rules and taboo.</p></div>
      <div class="card" data-grp="dynamic" data-val="Power"><h3>Power Imbalance</h3><p>Player defines boundaries and limits.</p></div>
      <div class="card" data-grp="dynamic" data-val="SlowBurn"><h3>Slow Burn</h3><p>High restraint, earned payoff.</p></div>
      <div class="card" data-grp="dynamic" data-val="Friends"><h3>Friends → Lovers</h3><p>Safety tipping into heat.</p></div>
      <div class="card" data-grp="dynamic" data-val="Proximity"><h3>Forced Proximity</h3><p>Close quarters, rising tension.</p></div>
      <div class="card" data-grp="dynamic" data-val="Secret"><h3>Secret Identity</h3><p>Truths revealed at the worst time.</p></div>
      <div class="card" data-grp="dynamic" data-val="Obsessive"><h3>Obsessive Devotion</h3><p>Intense focus, player sets bounds.</p></div>
      <div class="card" data-grp="dynamic" data-val="Fated"><h3>Fated Mates / Soulbond</h3><p>Destined bond, fast intensity.</p></div>
      <div class="card" data-grp="dynamic" data-val="Caretaker"><h3>Caretaker / Wounded One</h3><p>Vulnerability and steady support.</p></div>
    </div>

    <div class="section-title">Story POV</div>
    <div class="style-cards" id="povGrid">
      <div class="card selected" data-grp="pov" data-val="First"><h3>1st Person (I)</h3><p>Intimate, confessional, inside your pulse.</p><button class="preview-btn" data-txt="I held my breath as the door clicked shut behind him.">Preview</button></div>
      <div class="card" data-grp="pov" data-val="Second"><h3>2nd Person (You)</h3><p>Immediate, immersive, hands-on tension.</p><button class="preview-btn" data-txt="You feel the room shift the moment he looks at you.">Preview</button></div>
      <div class="card" data-grp="pov" data-val="Third"><h3>3rd Person (They)</h3><p>Wider lens, cinematic, controlled heat.</p><button class="preview-btn" data-txt="He kept his voice calm, but the way his gaze lingered betrayed the hunger.">Preview</button></div>
      <div class="card" data-grp="pov" data-val="Fourth"><h3>4th Person (We)</h3><p>Choral, conspiratorial, shared gaze.</p><button class="preview-btn" data-txt="We watched them circle each other—two storms pretending to be weather.">Preview</button></div>
      <div class="card" data-grp="pov" data-val="Fifth"><h3>5th Person (Author)</h3><p>Playful narrator with a hand on the page.</p><button class="preview-btn" data-txt="The Author hesitated—then smiled—and offered them a door.">Preview</button></div>
    </div>

    <div class="section-title">Story Style <span class="instruction-text">(Select up to 3)</span></div>
    <div class="style-cards" id="styleGrid">
      <div class="card selected" data-grp="style" data-val="Breathless"><h3>Breathless Romance</h3><p>Fast tension, close POV, lush romantic heat.</p><button class="preview-btn" data-txt="His attention was a slow hand. It didn’t touch her—yet she felt it everywhere.">Preview</button></div>
      <div class="card locked" data-grp="style" data-val="Epic" data-locked="true"><h3>Epic Fantasy</h3><p>Grand stakes, wonder, danger, sweeping romance.</p><button class="preview-btn" data-txt="The city burned like a crown—and someone inside it was waiting to claim her.">Preview</button></div>
      <div class="card locked" data-grp="style" data-val="Playful" data-locked="true"><h3>Playful Heat</h3><p>Flirty banter, teasing humor, spark-first chemistry.</p><button class="preview-btn" data-txt="“You’re staring.” “I’m appreciating.”">Preview</button></div>
      <div class="card locked" data-grp="style" data-val="Dark" data-locked="true"><h3>Dark Desire</h3><p>Moody, dangerous tension with boundaries respected.</p><button class="preview-btn" data-txt="He smiled like a promise with teeth.">Preview</button></div>
      <div class="card locked" data-grp="style" data-val="Raw" data-locked="true"><h3>Raw Passion</h3><p>Direct emotion, embodied desire, grounded intensity.</p><button class="preview-btn" data-txt="He didn't ask twice.">Preview</button></div>
      <div class="card locked" data-grp="style" data-val="Regency" data-locked="true"><h3>Regency Restraint</h3><p>Polite knives, forbidden longing, exquisite restraint.</p><button class="preview-btn" data-txt="“Your reputation is in danger,” she murmured.">Preview</button></div>
    </div>
    
    <button class="small-btn" onclick="toggle('moreStyles')">More Styles</button>
    <div id="moreStyles" class="style-cards hidden">
       <div class="card locked" data-grp="style" data-val="Wry" data-locked="true"><h3>Wry Confession</h3><p>Dry wit, sharp honesty, intimate tension.</p><button class="preview-btn" data-txt="She lied. He admired it.">Preview</button></div>
       <div class="card locked" data-grp="style" data-val="Strategic" data-locked="true"><h3>Strategic Intensity</h3><p>Calculated seduction, power games.</p><button class="preview-btn" data-txt="Silence did the flirting.">Preview</button></div>
       <div class="card locked" data-grp="style" data-val="Surreal" data-locked="true"><h3>Surreal Bloom</h3><p>Dreamlike imagery, symbolic heat.</p><button class="preview-btn" data-txt="The candles leaned in to listen.">Preview</button></div>
       <div class="card locked" data-grp="style" data-val="Brutal" data-locked="true"><h3>Brutal Edge</h3><p>Blunt honesty, razor tension.</p><button class="preview-btn" data-txt="No soft words. Just truth.">Preview</button></div>
       <div class="card locked" data-grp="style" data-val="Satirical" data-locked="true"><h3>Satirical Fantasy</h3><p>Witty fantasy, playful stakes.</p><button class="preview-btn" data-txt="The prophecy was inconvenient.">Preview</button></div>
       <div class="card locked" data-grp="style" data-val="Shakespearean" data-locked="true"><h3>Shakespearean</h3><p>Elevated cadence, poetic desire.</p><button class="preview-btn" data-txt="Speak low, sweet peril.">Preview</button></div>
       <div class="card locked" data-grp="style" data-val="SciFi" data-locked="true"><h3>SciFi Opera</h3><p>Grand futuristic worlds, high stakes.</p><button class="preview-btn" data-txt="Stars like spilled ink.">Preview</button></div>
    </div>

    <div class="section-title">Story Controls</div>
    <div id="storyControlsBox" class="input-wrapper locked-input" style="height: 140px;" onclick="showPaywall('unlock')">
       <textarea id="storyControls" rows="3" style="color:transparent; background:transparent; z-index:2; position:relative; height:100%;"></textarea>
       <div class="ghost-overlay" id="ctrlGhost">
           <div class="ghost-grid"></div>
       </div>
    </div>
    <div style="display:flex; flex-direction:column; align-items:center; margin-top:5px; font-size:0.8em; color:var(--gold);">
        <div style="display:flex; width:100%; justify-content:space-between; margin-bottom:5px;">
            <span id="quillStatus">Quill: Ready</span>
            <button id="btnCommitQuill" class="small-btn" style="padding:4px 10px; font-size:0.85em; opacity:0.5;" disabled>Commit Quill Edit</button>
        </div>
        <div id="godModeToggle" class="hidden">
            <label id="godModeLabel"><input type="checkbox" id="godModeCheck"> Enable God Mode (Sandbox)</label>
        </div>
    </div>
    <p style="font-size:0.8em; color:var(--gold); opacity:0.8; margin-top:5px;">It's your story, add or take away whatever you like.</p>

    <br>
    <button id="beginBtn" style="font-size:1.5em; margin-top:20px;">Begin Story</button>
  </div>

  <div id="game" class="hidden" style="max-width:900px; margin:0 auto; padding-bottom:60px;">
    <h2 id="storyTitle"></h2>
    <p id="storySynopsis" style="color:var(--gold); font-style:italic; margin-bottom:20px;"></p>
    
    <div id="partnerStatusLine" class="hidden" style="text-align:center; font-size:0.85em; color:var(--pink); margin-bottom:15px; height:20px;"></div>

    <div id="settingShotWrap">
        <div id="settingError" class="img-error-msg hidden"></div>
        <img id="settingShotImg" src="" alt="Setting" style="display:none; width:100%;">
    </div>

    <div id="storyText" class="box"></div>

    <div style="text-align:center; margin-bottom:10px;">
        <button onclick="visualize()" style="font-size:0.9em; background:#444;">✨ Visualize This Scene</button>
    </div>
    
    <div id="metaControls" class="hidden" style="margin: 10px auto; padding: 10px; border: 1px dashed var(--gold); border-radius: 8px; max-width: 600px;">
      <div style="font-size: 0.8em; color: var(--gold); margin-bottom: 5px;">AUTHOR IS FATE (Meta System)</div>
      <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 5px;">
        <button class="small-btn meta-stance" onclick="setMetaStance('aid')">Aid</button>
        <button class="small-btn meta-stance" onclick="setMetaStance('rebel')">Rebel</button>
        <button class="small-btn meta-stance" onclick="setMetaStance('seduce')">Seduce</button>
      </div>
      <div id="metaReadout" style="font-size: 0.7em; color: var(--ink); opacity: 0.8;">Awareness: 0/3 | Pressure: 1/3</div>
    </div>

    <div class="section-title" style="font-size:1.8em; margin-top:0; display:flex; justify-content:center;">Let Fate Guide You</div>
    
    <div id="cardMount" class="fate-grid"></div>

    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:20px;">
      <div class="input-wrapper locked-input" id="actionWrapper" onclick="showPaywall('unlock')">
          <label>What do you do?</label>
          <textarea id="actionInput" rows="3" placeholder="Action..." disabled></textarea>
      </div>
      <div class="input-wrapper locked-input" id="dialogueWrapper" onclick="showPaywall('unlock')">
          <label>What do you say?</label>
          <textarea id="dialogueInput" rows="3" placeholder="Dialogue..." disabled></textarea>
      </div>
    </div>

    <div class="intensity-mini" id="gameIntensity">
        <button onclick="setGameIntensity('Clean')">Clean</button>
        <button onclick="setGameIntensity('Naughty')" class="active">Naughty</button>
        <button onclick="setGameIntensity('Erotic')">Erotic</button>
        <button onclick="setGameIntensity('Dirty')">Dirty</button>
    </div>

    <div style="margin-top:10px; display:flex; gap:10px; justify-content:center; align-items:center;">
       <button id="saveBtn" class="small-btn locked-style" onclick="showPaywall('unlock')">Save</button>
       <button id="submitBtn" style="font-size:1.3em;">Submit Turn</button>
    </div>
    
    <div style="margin-top:10px;">
       <button id="gameControlsBtn" class="small-btn locked-style" onclick="showPaywall('unlock')">Story Controls</button>
    </div>

  </div>

</div>

<script src="/fatecards/storybound-cards.js"></script>
<script>
(function(){
  let tempImgUrl = null;
  // --- CONFIG ---
  var PROXY_URL = 'https://storybound-proxy.vercel.app/api/proxy';
  var IMAGE_PROXY_URL = 'https://storybound-proxy.vercel.app/api/image';
  const STORY_MODEL = 'grok-4-1-fast-reasoning'; 
  
  // =========================
  // SUPABASE CONFIG (COUPLE MODE)
  // =========================
  const SUPABASE_URL = "https://riutipkrnfyvvghzlrwe.supabase.co"; 
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJpdXRpcGtybmZ5dnZnaHpscndlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc0NzEyMjQsImV4cCI6MjA4MzA0NzIyNH0.-YCYDxM8OUybL75B0S4JE9HBgXV-K8Bhog6A-nPxUKQ"; 
  // create once, reuse forever
  window.supabaseClient = window.supabaseClient || supabase.createClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY
  // Presence Constants
  const PRESENCE_HEARTBEAT_MS = 15000;
  const ONLINE_THRESHOLD_MS = 45000;
  const TYPING_THROTTLE_MS = 900;
  const TYPING_IDLE_OFF_MS = 1600;

  const sb = window.supabase ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

  async function ensureAnonSession(){
    if(!sb) return null;
    const { data: { session } } = await sb.auth.getSession();
    if(session?.user?.id) return session.user.id;
    const { data, error } = await sb.auth.signInAnonymously();
    if(error) { console.error(error); return null; }
    return data.user.id;
  }

  function getNickname(){
    let n = localStorage.getItem("sb_nickname");
    if(!n){
      n = prompt("Enter a nickname for Couple Mode:", "Guest") || "Guest";
      localStorage.setItem("sb_nickname", n);
    }
    return n;
  }

  const META_DIRECTIVES = {
      aid: [
          "Include a brief beat where the characters sense an unseen guidance and choose to follow the offered path—like accepting an omen. Keep it understated.",
          "Let the characters notice the scene tightening as though arranged; they quietly lean into it, trusting the pressure as permission.",
          "Add a small moment of recognition: the world seems to 'nudge' them, and they consent to be led—curious, willing, unafraid."
      ],
      rebel: [
          "Include a brief beat where the characters feel the scene being steered and deliberately choose a resisting move—an inconvenient truth, a refusal, a delay.",
          "Let the characters sense a pattern closing around them and try to break it—one quiet defiance that alters the rhythm.",
          "Add a small moment where they realize something is arranging them and they push back—choosing the harder option on purpose."
      ],
      seduce: [
          "Include a brief beat where the characters treat the unseen influence as an intimate interlocutor—offering a bargain or a dare.",
          "Let the characters sense the hand behind events and respond with a quiet, provocative negotiation—'if you want this, then give me that.'",
          "Add a small moment where they acknowledge the manipulation and try to entice it into a kinder or sharper turn—flirtation as bargaining with destiny."
      ]
  };

  var state = { 
      tier:'free', 
      picks:{ genre:[], dynamic:[], pov:'First', style:['Breathless'] }, 
      gender:'Female', 
      loveInterest:'Male', 
      intensity:'Naughty', 
      turnCount:0,
      sysPrompt: "",
      fateOptions: [],
      fatePressure: 1, 
      awareness: 0, 
      stance: 'aid', 
      metaChance: 0.10, 
      consecutiveFate: 0, 
      consecutiveAid: 0,
      storyId: null,
      access: 'free',
      subscribed: false,
      authorGender: 'Female',
      authorPronouns: 'She/Her',
      storyTargetWords: 10000,
      unlockedFateIdx: [0, 1],
      lastFate: null,
      mode: 'solo',
      roomId: null,
      roomCode: null,
      roomTurn: 1,
      roomDriver: null,
      roomAccess: 'free',
      myUid: null,
      myNick: null,
      turnsChannel: null,
      roomChannel: null,
      membersChannel: null,
      presenceInterval: null,
      typingTimer: null,
      lastTypingSentAt: 0,
      partnerStatus: { online:false, lastSeenAt:null, typing:false, typingAt:null, uid:null },
      _lastTurnId: null,
      selectedFateIndex: null,
      selectedFatePayload: null,
      // PATCH: Sex Push & Quill State
      sexPushCount: 0,
      lastSexPushAt: null,
      veto: { bannedWords: [], bannedNames: [], excluded: [], tone: [] },
      quill: { uses: 0, nextReadyAtWords: 0, baseCooldown: 3000, multiplier: 1.6 },
      quillCommittedThisTurn: false,
      // PATCH: Solo -> Couple Branching
      storyStage: 'pre-intimacy',
      // PATCH: Sandbox & Stats State
      sandbox: false,
      godModeActive: false,
      authorChairActive: false,
      lastSavedWordCount: 0
  };
  
  const cheapNames = ["Thrifton", "Pennywise", "McMiser", "Scrooge", "Tightwad", "Pinchpenny"];
  const ancestries = ["Dwarven", "Demonkin", "Asgardian", "Fae-Touched", "Cyber-Construct", "Deep One", "Star-Born", "Cambion", "Orc", "Siren", "Angel", "Lycanthrope", "Titan-Blooded", "Shadow-Weaver", "Void-Walker", "Nymph", "Dryad", "High Elf", "Dark Elf", "Moon-Child", "Sun-Touched", "Water-Genasi", "Fire-Genasi", "Earth-Genasi", "Air-Genasi", "Any culture, faith, or lineage you can imagine"];
  const controlsList = ["Ban 'moist'", "Rhyming dialogue", "Start in bathhouse", "Villain named Bob", "Make me an Emperor", "Force Proximity", "Setting: Atlantis", "Superpowers", "Start w/ explosion", "Include Dragon", "Make it Musical", "No Magic", "I am the Villain", "Extreme Slow Burn", "Love interest is Ghost", "Love Triangle", "Enemies to Lovers", "Only one bed", "Secret Baby", "Fake Dating", "Marriage of Convenience"];

  // --- HELPERS ---
  function $(id){ return document.getElementById(id); }
  function toggle(id){ const el = document.getElementById(id); if(el) el.classList.toggle('hidden'); }
  window.toggle = toggle;
  
  // NAV HELPER
  function showScreen(id){
      ['ageGate','tosGate','tierGate','modeSelect','setup','game','coupleInvite','strangerModal'].forEach(s => {
          const el = document.getElementById(s);
          if(el) el.classList.add('hidden');
      });
      const target = document.getElementById(id);
      if(target) target.classList.remove('hidden');
      
      const app = document.getElementById('app');
      if(['modeSelect','setup','game'].includes(id)){
          app.classList.remove('hidden');
      } else {
          app.classList.add('hidden');
      }
      
      // Auto-scroll top on screen change
      window.scrollTo(0,0);
  }
  
  function pickTwoIndices(){
      const pool = [0,1,2,3,4];
      for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool.slice(0, 2);
  }

  // --- ACCESS HELPERS ---
  function resolveAccess(){
    if (state.mode === 'couple') {
        // In Couple mode, access is strictly room-scoped
        return state.roomAccess || 'free';
    }
    if(state.subscribed) return 'sub';
    if(state.storyId && hasStoryPass(state.storyId)) return 'pass';
    return 'free';
  }

  function syncTierFromAccess(){
    state.access = resolveAccess();
    state.tier = (state.access === 'free') ? 'free' : 'paid';
  }

  function getCapForAccess(){
    if(state.godModeActive) return Infinity; // PATCH: God Mode no cap
    if(state.access === 'sub') return Infinity;
    if(state.access === 'pass') return 25000;
    return 10000;
  }

  function currentStoryWordCount(){
    const txt = ($('storyText')?.innerText || '').trim();
    if(!txt) return 0;
    return txt.split(/\s+/).filter(Boolean).length;
  }

  // PATCH: Elastic Sex Threshold Helper
  function getSexAllowedAtWordCount() {
    if(state.godModeActive) return 0; // PATCH: God Mode always allows sex
    const target = state.storyTargetWords;
    switch(state.intensity){
        case "Clean":   return Infinity;
        case "Naughty": return Math.floor(target * 0.55);
        case "Erotic":  return Math.floor(target * 0.30);
        case "Dirty":   return Math.floor(target * 0.20);
        default: return Math.floor(target * 0.55);
    }
  }

  // PATCH: Consummation Logic
  function maybeFlipConsummation(text){
     if(state.godModeActive) return; // God Mode ignores this
     if(state.mode !== 'solo') return;
     if(state.storyStage !== 'pre-intimacy') return; 

     let flipped = false;

     // 1. Timing
     const wc = currentStoryWordCount();
     const sexAt = getSexAllowedAtWordCount();
     if(wc >= sexAt) flipped = true;

     // 2. Language (Exclusivity)
     const pattern = /(only you|forever with you|no one else|we belong to each other|I am yours|yours forever|eternal vow|marry me|my wife|my husband)/i;
     if(pattern.test(text)) flipped = true;

     // 3. Dirty Intensity
     if(state.intensity === 'Dirty') flipped = true;

     if(flipped){
         state.storyStage = 'post-consummation';
         saveStorySnapshot(); 
     }
  }

  // PATCH: Quill Helpers with Author's Chair Mod
  function getQuillReady() {
      if(state.godModeActive) return true; // God Mode always ready
      return currentStoryWordCount() >= (state.quill.nextReadyAtWords || 0);
  }

  function computeNextCooldownWords() {
      if(state.godModeActive) return 0;
      // PATCH: Author's Chair Buff
      const base = state.authorChairActive ? 2000 : 3000;
      const mult = state.authorChairActive ? 1.4 : 1.6;
      return Math.round(base * Math.pow(mult, state.quill.uses));
  }

  // PATCH: Author's Chair / Badge Logic
  function checkAuthorChairUnlock() {
      const totalWords = Number(localStorage.getItem('sb_global_word_count') || 0);
      if(totalWords >= 250000) return true;

      // Check Badges (distinct sets)
      try {
          const stats = JSON.parse(localStorage.getItem('sb_history_distinct') || '{"genres":[],"povs":[],"styles":[]}');
          // Proxy rule: "Tried 5 distinct" of each type counts as "All" for simplified logic
          if(stats.genres.length >= 5 && stats.povs.length >= 3 && stats.styles.length >= 5) {
              return true;
          }
      } catch(e) {}
      return false;
  }

  function updateHistoryStats() {
      try {
          const stats = JSON.parse(localStorage.getItem('sb_history_distinct') || '{"genres":[],"povs":[],"styles":[]}');
          // Add current picks if new
          state.picks.genre.forEach(g => { if(!stats.genres.includes(g)) stats.genres.push(g); });
          if(!stats.povs.includes(state.picks.pov)) stats.povs.push(state.picks.pov);
          state.picks.style.forEach(s => { if(!stats.styles.includes(s)) stats.styles.push(s); });
          
          localStorage.setItem('sb_history_distinct', JSON.stringify(stats));
      } catch(e) {}
  }

  function parseStoryControls(rawText) {
      if(!rawText) return { veto: {bannedWords:[], bannedNames:[], excluded:[], tone:[]}, quillDraft: "" };
      
      const lines = rawText.split('\n');
      const veto = { bannedWords:[], bannedNames:[], excluded:[], tone:[] };
      const draftLines = [];

      lines.forEach(line => {
          const l = line.trim();
          if(!l) return;
          const lower = l.toLowerCase();
          
          if(lower.startsWith('ban:') || lower.startsWith('banned:')) {
              veto.bannedWords.push(l.replace(/^(ban:|banned:)\s*/i, ''));
          } else if(lower.startsWith('no names:') || lower.startsWith('ban names:')) {
              veto.bannedNames.push(l.replace(/^(no names:|ban names:)\s*/i, ''));
          } else if(lower.startsWith('exclude:') || lower.startsWith('no:')) {
              veto.excluded.push(l.replace(/^(exclude:|no:)\s*/i, ''));
          } else if(lower.startsWith('tone:')) {
              veto.tone.push(l.replace(/^tone:\s*/i, ''));
          } else {
              draftLines.push(l);
          }
      });
      return { veto, quillDraft: draftLines.join('\n') };
  }

  function applyVetoFromControls() {
      const el = $('storyControls');
      if(el) {
          const { veto } = parseStoryControls(el.value);
          state.veto = veto;
      }
  }

  function updateQuillUI() {
      const btn = $('btnCommitQuill');
      const status = $('quillStatus');
      const godToggle = $('godModeToggle');
      if(!btn || !status) return;

      // God Mode Logic UI
      if(state.mode === 'solo') {
          godToggle.classList.remove('hidden');
          const chk = $('godModeCheck');
          if(state.godModeActive) {
              chk.checked = true;
              chk.disabled = true; // Permanent
              document.getElementById('godModeLabel').innerHTML = "GOD MODE ACTIVE (SANDBOXED)";
              document.getElementById('godModeLabel').style.color = "var(--hot)";
          } else {
              chk.checked = false;
              chk.disabled = false;
          }
      } else {
          godToggle.classList.add('hidden'); // No God Mode in Couple
      }

      const ready = getQuillReady();
      const wc = currentStoryWordCount();
      const needed = state.quill.nextReadyAtWords;
      
      // Update badge if Author Chair active
      if(state.authorChairActive && !status.textContent.includes('🪑')) {
          status.innerHTML = `<span title="Author's Chair Active">🪑</span> ` + status.textContent;
      }

      if(ready) {
          status.textContent = state.authorChairActive ? "🪑 Quill: Ready" : "Quill: Ready";
          status.style.color = "var(--pink)";
          btn.disabled = false;
          btn.style.opacity = "1";
          btn.style.borderColor = "var(--pink)";
          if(state.godModeActive) btn.textContent = "Commit Quill (God Mode)";
          else btn.textContent = "Commit Quill Edit";
      } else {
          const remain = Math.max(0, needed - wc);
          status.textContent = `Quill recharges in: ${remain} words`;
          status.style.color = "var(--gold)";
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.borderColor = "transparent";
      }
  }

  // 🔒 AUTH LOGIC START
  async function signIn() {
    const email = document.getElementById("auth-email").value;
    const password = document.getElementById("auth-password").value;
    const status = document.getElementById("auth-status");

    status.textContent = "Signing in...";

    const { data, error } = await sb.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      status.textContent = "Sign-in failed: " + error.message;
      return;
    }

    if (data?.user) {
       status.textContent = "Signed in: " + data.user.email;
       state.myUid = data.user.id;
    }
  }

  document.getElementById("btn-signin")?.addEventListener("click", signIn);

  sb.auth.onAuthStateChange((event, session) => {
    if (session?.user) {
      console.log("AUTH READY:", session.user.id);
      document.getElementById("auth-status").textContent = "Session: " + session.user.email;
      state.myUid = session.user.id; 
    } else {
      console.log("NO AUTH SESSION");
    }
  });
  // 🔒 AUTH LOGIC END

  // PATCH: God Mode Toggle Handler
  $('godModeCheck')?.addEventListener('change', (e) => {
      if(!e.target.checked) return; // Cannot uncheck
      
      e.target.checked = false; // Reset visually until confirmed
      
      const unlocked = localStorage.getItem('sb_god_mode_owned') === '1';
      
      if(!unlocked) {
          // Open $50 Paywall
          showPaywall('god');
      } else {
          // Show Irreversible Warning
          if(confirm("WARNING: God Mode permanently removes this story from canon.\n\n- No emotional safeguards\n- No Couple Mode eligibility\n- No achievement progress\n\nThis cannot be undone. Enter Sandbox?")) {
              activateGodMode();
          }
      }
  });

  function activateGodMode() {
      state.sandbox = true;
      state.godModeActive = true;
      state.storyStage = 'sandbox'; // Force state
      updateQuillUI();
      // Disable Couple button logic handled in setMode
      alert("God Mode Active. Narrative safeguards removed.");
  }

  // --- STORY PASS & PERSISTENCE ---
  function makeStoryId(){
    const existing = localStorage.getItem('sb_current_story_id');
    if(existing) return existing;
    const id = 'sb_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
    localStorage.setItem('sb_current_story_id', id);
    return id;
  }

  function getStoryPassKey(storyId){
    return `sb_storypass_${storyId}`;
  }

  function hasStoryPass(storyId){
    if(!storyId) return false;
    return localStorage.getItem(getStoryPassKey(storyId)) === '1';
  }

  function grantStoryPass(storyId){
    if(!storyId) return;
    localStorage.setItem(getStoryPassKey(storyId), '1');
  }

  function clearCurrentStoryId(){
    localStorage.removeItem('sb_current_story_id');
  }

  function hasSavedStory(){
    return !!localStorage.getItem('sb_saved_story');
  }

  // Set-based used names to prevent duplicates
  const usedNamesSet = new Set(
    (() => {
      try { return JSON.parse(localStorage.getItem('sb_used_names') || '[]'); }
      catch(e){ return []; }
    })()
  );

  function getUsedNames(){
    return Array.from(usedNamesSet);
  }

  function addUsedName(name){
    const n = (name || '').toString().trim();
    if(!n) return;
    if(!usedNamesSet.has(n)){
      usedNamesSet.add(n);
      try { localStorage.setItem('sb_used_names', JSON.stringify(Array.from(usedNamesSet))); } catch(e){}
    }
  }

  function saveStorySnapshot(){
    const el = document.getElementById('storyText');
    if(!el) return;

    // PATCH: Global Word Count Tracking (Author's Chair)
    const currentWc = currentStoryWordCount();
    const delta = Math.max(0, currentWc - (state.lastSavedWordCount || 0));
    if(delta > 0) {
        const globalWc = Number(localStorage.getItem('sb_global_word_count') || 0);
        localStorage.setItem('sb_global_word_count', globalWc + delta);
        state.lastSavedWordCount = currentWc;
    }

    const snapshot = {
      storyId: state.storyId,
      subscribed: !!state.subscribed,
      tier: state.tier,
      sysPrompt: state.sysPrompt,
      title: document.getElementById('storyTitle')?.textContent || '',
      synopsis: document.getElementById('storySynopsis')?.textContent || '',
      storyHTML: el.innerHTML,
      stateSnapshot: {
        picks: state.picks,
        gender: state.gender,
        loveInterest: state.loveInterest,
        intensity: state.intensity,
        turnCount: state.turnCount,
        fateOptions: state.fateOptions,
        fatePressure: state.fatePressure,
        awareness: state.awareness,
        stance: state.stance,
        metaChance: state.metaChance,
        consecutiveFate: state.consecutiveFate,
        consecutiveAid: state.consecutiveAid,
        authorGender: state.authorGender,
        authorPronouns: state.authorPronouns,
        storyTargetWords: state.storyTargetWords,
        unlockedFateIdx: state.unlockedFateIdx,
        // PATCH: Persist new state
        sexPushCount: state.sexPushCount,
        lastSexPushAt: state.lastSexPushAt,
        veto: state.veto,
        quill: state.quill,
        storyStage: state.storyStage,
        sandbox: state.sandbox,
        godModeActive: state.godModeActive
      }
    };

    localStorage.setItem('sb_saved_story', JSON.stringify(snapshot));
    updateContinueButtons();
  }

  window.continueStory = function(){
    const raw = localStorage.getItem('sb_saved_story');
    if(!raw) return;

    const data = JSON.parse(raw);
    if(!data || !data.storyId) return;

    state.storyId = data.storyId;
    localStorage.setItem('sb_current_story_id', state.storyId);

    if(data.stateSnapshot){
      Object.assign(state, data.stateSnapshot);
      // Ensure defaults for new fields if loading old save
      if(!state.quill) state.quill = { uses: 0, nextReadyAtWords: 0, baseCooldown: 3000, multiplier: 1.6 };
      if(!state.veto) state.veto = { bannedWords:[], bannedNames:[], excluded:[], tone:[] };
      if(!state.storyStage) state.storyStage = 'pre-intimacy'; // PATCH: Default stage
      state.lastSavedWordCount = currentStoryWordCount(); // Sync baseline
    }

    state.sysPrompt = data.sysPrompt || state.sysPrompt;
    state.subscribed = !!data.subscribed;

    // PATCH: Check Author's Chair on load
    state.authorChairActive = checkAuthorChairUnlock();

    syncTierFromAccess();

    document.getElementById('storyTitle').textContent = data.title || '';
    document.getElementById('storySynopsis').textContent = data.synopsis || '';
    document.getElementById('storyText').innerHTML = data.storyHTML || '';
    
    // Fallback setting shot if none exists
    const img = document.getElementById('settingShotImg');
    if(!img.src || img.style.display === 'none'){
       // Force a fallback reload if empty
       generateSettingShot(data.synopsis || "Fantasy Landscape");
    }

    showScreen('game');
    applyTierUI();
    applyLengthLocks();
    initCards(); // ensure correct unlocks
    updateQuillUI();
  }

  function updateContinueButtons(){
    const show = hasSavedStory();
    document.getElementById('continueStoryBtn')?.classList.toggle('hidden', !show);
    document.getElementById('continueFromTierBtn')?.classList.toggle('hidden', !show);
  }

  // =========================
  // COUPLE MODE HELPERS
  // =========================

  function makeRoomCode(){
    const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
    return Array.from({length:6},()=>chars[Math.floor(Math.random()*chars.length)]).join('');
  }
  
  async function coupleGetRoom(){
    // Fetch room state + text prompts + access
    const { data: room, error } = await sb.from('sb_rooms')
      .select('id, code, turn, current_driver, updated_at, access_level, title, synopsis, sys_prompt, setting_img_prompt')
      .eq('id', state.roomId)
      .single();
    if(error) throw error;
    return room;
  }
  
  // Compare-and-swap: only advance turn if we still own the driver seat at this turn.
  async function coupleAdvanceTurnCAS(nextDriver){
    const expectedTurn = state.roomTurn;
    const expectedDriver = state.myUid;

    const { data, error } = await sb.from('sb_rooms')
      .update({
        current_driver: nextDriver,
        turn: expectedTurn + 1,
        updated_at: new Date().toISOString()
      })
      .eq('id', state.roomId)
      .eq('turn', expectedTurn)
      .eq('current_driver', expectedDriver)
      .select('turn,current_driver')
      .maybeSingle();

    if(error) throw error;

    // If no row updated, someone else advanced or we lost driver.
    if(!data){
      // Refresh authoritative room state
      const room = await coupleGetRoom();
      state.roomTurn = room.turn;
      state.roomDriver = room.current_driver;
      applyCoupleDriverUI();
      throw new Error("Turn conflict: room advanced elsewhere. Resynced.");
    }

    // Success
    state.roomTurn = data.turn;
    state.roomDriver = data.current_driver;
  }
  
  async function coupleBootstrap(){
    if(!state.roomId) return;

    // 1) Fetch room authoritative state
    const room = await coupleGetRoom();
    state.roomTurn = room.turn;
    state.roomDriver = room.current_driver;
    state.roomAccess = room.access_level || 'free';
    
    // Sync setup/title if joined late
    if(room.sys_prompt) state.sysPrompt = room.sys_prompt;
    if(room.title) $('storyTitle').textContent = room.title;
    if(room.synopsis) $('storySynopsis').textContent = room.synopsis;
    if(room.setting_img_prompt && $('settingShotImg').style.display === 'none') {
        generateSettingShot(room.synopsis || "Fantasy Landscape"); // Uses synopsis if prompt field logic not fully implemented, or implement full hydration
    }

    // 2) Load last N turns and render them (avoid duplicates)
    const { data: turns, error } = await sb.from('sb_turns')
      .select('id, turn, story_delta, created_at')
      .eq('room_id', state.roomId)
      .order('turn', { ascending: true })
      .limit(200);

    if(error) throw error;

    // 🔄 COUPLE BOOTSTRAP: Render Guard
    // If storyText already has content (e.g. from local generation before reload), don't nuke it.
    // BUT in couple mode, authoritative source is DB. We should clear and re-render to ensure sync.
    const storyEl = $('storyText');
    storyEl.innerHTML = ''; // CLEAR FIRST to ensure clean slate from DB state
    
    if(turns && turns.length > 0){
      turns.forEach(t => {
        const div = document.createElement('div');
        div.innerHTML = formatStory(t.story_delta || "");
        storyEl.appendChild(div);
        const sep = document.createElement('div');
        sep.className = 'separator';
        sep.innerHTML = "⚜";
        storyEl.appendChild(sep);
      });
    }
    
    // *** OPENING GENERATION CHECK ***
    // If turns are empty AND I am the host (driver), generate opening
    if((!turns || turns.length === 0) && state.myUid === state.roomDriver) {
        // Trigger opening generation logic here
        // We reuse logic from 'beginBtn' essentially, but targeted
        // This is handled in btnCoupleAgree usually, but if we refresh, we might need to check.
        // Actually, btnCoupleAgree calls this. Let's handle generation there or trigger it if needed.
        // For robustness: if turns=0, we likely haven't started. The "Agree" button action will handle it.
    }

    // Track last seen turn id to prevent double-appends on resubscribe
    state._lastTurnId = (turns && turns.length) ? turns[turns.length - 1].id : null;

    // 3) Initial Presence Fetch (Fix for empty partner status)
    const { data: members } = await sb
      .from('sb_room_members')
      .select('user_id,last_seen_at,typing,typing_at')
      .eq('room_id', state.roomId);

    const partner = (members || []).find(m => m.user_id !== state.myUid);
    if(partner){
      state.partnerStatus = {
        uid: partner.user_id,
        lastSeenAt: partner.last_seen_at,
        typing: partner.typing,
        typingAt: partner.typing_at
      };
      updatePartnerUI(state.partnerStatus);
    }

    applyCoupleDriverUI();
    startPresence();
  }
  
  function coupleCleanup(){
    try {
      if(state.turnsChannel) sb.removeChannel(state.turnsChannel);
      if(state.roomChannel) sb.removeChannel(state.roomChannel);
      if(state.membersChannel) sb.removeChannel(state.membersChannel);
    } catch(e){}
    stopPresence();
    stopTyping(false);
    state.turnsChannel = null;
    state.roomChannel = null;
    state.membersChannel = null;
    state.roomId = null;
    state.roomCode = null;
    state.roomTurn = 1;
    state.roomDriver = null;
    state._lastTurnId = null;
  }

  function wireCoupleInviteUI(){
    if(window._coupleWired) return;
    window._coupleWired = true;

    const btnCreate = document.getElementById('btnCreateRoom');
    const btnJoin = document.getElementById('btnJoinRoom');
    const btnJoinGo = document.getElementById('btnJoinGo');
    const btnEnter = document.getElementById('btnEnterCoupleGame');
    const joinRow = document.getElementById('joinRow');
    const roomCodeWrap = document.getElementById('roomCodeWrap');
    const roomCodeBig = document.getElementById('roomCodeBig');
    const joinInput = document.getElementById('joinCodeInput');
    const btnCopy = document.getElementById('btnCopyCode');

    // Attach typing listeners once
    ['actionInput', 'dialogueInput'].forEach(id => {
       const el = document.getElementById(id);
       if(el){
           el.addEventListener('input', markTyping);
           el.addEventListener('keydown', markTyping);
       }
    });

    // Copy Handler
    if(btnCopy){
        btnCopy.onclick = () => {
             const code = state.roomCode || roomCodeBig.textContent;
             if(code && code !== '—') {
                 navigator.clipboard.writeText(code).then(() => {
                     const original = btnCopy.innerHTML;
                     btnCopy.innerHTML = "✓";
                     setTimeout(() => btnCopy.innerHTML = original, 2000);
                 });
             }
        };
    }

    btnCreate.onclick = async ()=>{
      startLoading();
      const code = makeRoomCode();
      const { data: room, error } = await sb.from('sb_rooms')
        .insert([{ code, created_by: state.myUid, current_driver: state.myUid, turn: 1, access_level: 'free' }])
        .select().single();
      
      if(error){ alert(error.message); stopLoading(); return; }

      await sb.from('sb_room_members').insert([{ room_id: room.id, user_id: state.myUid, role:'host', last_seen_at: new Date().toISOString() }]);

      state.roomId = room.id;
      state.roomCode = code;
      state.roomDriver = state.myUid;
      
      roomCodeBig.textContent = code;
      document.getElementById('coupleRoomCodeLabel').textContent = code;
      
      roomCodeWrap.classList.remove('hidden');
      btnEnter.classList.remove('hidden');
      stopLoading();
    };

    btnJoin.onclick = ()=> joinRow.classList.toggle('hidden');

    btnJoinGo.onclick = async ()=>{
      const code = joinInput.value.trim().toUpperCase();
      if(!code) return;
      startLoading();
      
      const { data: room, error } = await sb.from('sb_rooms').select('*').eq('code',code).single();
      if(error || !room){ alert("Room not found or error."); stopLoading(); return; }

      await sb.from('sb_room_members').insert([{ room_id: room.id, user_id: state.myUid, role:'member', last_seen_at: new Date().toISOString() }]);
      
      state.roomId = room.id;
      state.roomCode = code;
      state.roomDriver = room.current_driver;

      document.getElementById('coupleRoomCodeLabel').textContent = code;
      btnEnter.classList.remove('hidden');
      alert("Joined! Wait for host to start.");
      stopLoading();
    };

    // 🔒 PAYWALL UPDATE: Couple Consent Flow + Opening Generation
    btnEnter.onclick = () => {
        document.getElementById('coupleInvite').classList.add('hidden');
        document.getElementById('coupleConsentModal').classList.remove('hidden');
    };

    document.getElementById('btnCoupleAgree').onclick = async () => {
        document.getElementById('coupleConsentModal').classList.add('hidden');
        showScreen('game');
        applyTierUI();
        await coupleBootstrap();
        subscribeCoupleRealtime();
        applyCoupleDriverUI();
        
        // Host Opening Generation Logic
        if(state.myUid === state.roomDriver){
            // Check if turns exist
            const { count } = await sb.from('sb_turns').select('*', { count: 'exact', head: true }).eq('room_id', state.roomId);
            if(count === 0){
                // Generate opening
                await generateCoupleOpening();
            }
        }
    };
  }
  
  // Couple Opening Generator (Mirrors beginBtn logic)
  async function generateCoupleOpening(){
      startLoading();
      
      // Build basic prompt if not already set (Host path)
      if(!state.sysPrompt){
          // We assume setups are in state from the setup screen since we are the host coming from there
          // Or we construct a default
          let p1Name = $('playerNameInput').value.trim() || "Player 1";
          let p2Name = $('partnerNameInput').value.trim() || "Player 2";
          
          state.sysPrompt = `You are a master storyteller. 
          Genre: ${state.picks.genre.join(',') || 'Romantasy'}. 
          Style: ${state.picks.style.join(',') || 'Breathless'}.
          POV: ${state.picks.pov}.
          Player 1 is ${p1Name} (${state.gender}, ${state.pronouns1 || 'She/Her'}).
          Player 2 is ${p2Name} (${state.loveInterest}, ${state.pronouns2 || 'He/Him'}).
          Intensity: ${state.intensity}.
          IMPORTANT: This is the OPENING. NO sex acts yet. Focus on PLOT, WORLD-BUILDING, and TENSION.
          Formatting: Write in lush, novelistic prose. Use complete sentences.
          Dialogue Formatting: Wrap Player 1's dialogue in [P1]...[/P1]. Wrap Partner's dialogue in [P2]...[/P2].
          AT THE END OF RESPONSE, append a JSON block with 5 new Fate Card options based on the scene:
          ///FATE_JSON_START///
          [{"action":"...", "dialogue":"..."}, ...] (5 objects)
          ///FATE_JSON_END///
          Output format (STRICT): First line must be exactly "Title: …". Second line must be exactly "Synopsis: …". Then a blank line. Then story body.`;
      }
      
      applyVetoFromControls(); // Apply controls before generating opening

      // Generate
      try {
          let raw = await callChat([{role:'system', content: state.sysPrompt}, {role:'user', content: "Begin the story. Start with Title: [Title] and Synopsis: [Synopsis]."}]);
          
          if(raw.includes("///FATE_JSON_START///")){
             const parts = raw.split("///FATE_JSON_START///");
             raw = parts[0]; 
             const jsonRaw = parts[1].split("///FATE_JSON_END///")[0];
             try { state.fateOptions = JSON.parse(jsonRaw); } catch(e){}
          }
          
          const { title, syn, body } = extractMeta(raw);
          
          // 🔄 COUPLE OPENING: Persistence
          
          // Save Shared Room Data
          await sb.from('sb_rooms').update({
              title: title.replace(/\*\*/g, ''),
              synopsis: syn.replace(/\*\*/g, ''),
              sys_prompt: state.sysPrompt,
              // If schema supports it, save access level if defined
          }).eq('id', state.roomId);
          
          // Insert Turn 0 (Idempotent check ideally, or rely on constraint)
          // We check if turn 0 exists first to be safe, or just try insert
          const { error: turnErr } = await sb.from('sb_turns').insert([{
                room_id: state.roomId,
                turn: 0, 
                driver_id: state.myUid,
                story_delta: body,
                player_action: "OPENING", // Sentinel
                player_dialogue: "",
                fate_choice: null
          }]);
          
          if(!turnErr){
              // If successful insert, render locally
              $('storyText').innerHTML = formatStory(body);
          } else {
              // If duplication error, likely race condition or already exists; fetch and render
              // For robustness, coupleBootstrap handles rendering on join/reload
          }
          
      } catch(e){
          console.error("Couple opening failed", e);
          alert("Opening generation failed. Please retry.");
      }
      stopLoading();
  }

  // --- PRESENCE & TYPING ---
  async function presenceBeat(extraFields={}){
    if(!state.roomId || !state.myUid) return;
    await sb.from('sb_room_members')
      .update({ last_seen_at: new Date().toISOString(), ...extraFields })
      .eq('room_id', state.roomId)
      .eq('user_id', state.myUid);
  }

  function startPresence(){
    if(state.presenceInterval) clearInterval(state.presenceInterval);
    presenceBeat();
    state.presenceInterval = setInterval(() => presenceBeat(), PRESENCE_HEARTBEAT_MS);
  }

  function stopPresence(){
    if(state.presenceInterval) clearInterval(state.presenceInterval);
    state.presenceInterval = null;
  }

  function markTyping(){
    if(state.mode !== 'couple' || !state.roomId) return;
    const now = Date.now();
    if(now - state.lastTypingSentAt > TYPING_THROTTLE_MS){
       state.lastTypingSentAt = now;
       presenceBeat({ typing: true, typing_at: new Date().toISOString() });
    }
    if(state.typingTimer) clearTimeout(state.typingTimer);
    state.typingTimer = setTimeout(() => stopTyping(true), TYPING_IDLE_OFF_MS);
  }

  function stopTyping(send=true){
    if(state.typingTimer) clearTimeout(state.typingTimer);
    state.typingTimer = null;
    if(send && state.mode === 'couple') presenceBeat({ typing: false });
  }

  function updatePartnerUI(status){
    const el = document.getElementById('partnerStatusLine');
    if(!el) return; // Fix crash if el missing
    
    if(state.mode !== 'couple') {
        el.classList.add('hidden');
        return;
    }
    
    // Partner is only "Online" if lastSeenAt is recent
    const now = new Date();
    const seen = status.lastSeenAt ? new Date(status.lastSeenAt) : null;
    const isOnline = seen && (now - seen < ONLINE_THRESHOLD_MS);
    
    // Partner is "Typing" if typing=true AND typed recently (stale typing prevention)
    const typedAt = status.typingAt ? new Date(status.typingAt) : null;
    const isTyping = status.typing && typedAt && (now - typedAt < ONLINE_THRESHOLD_MS);

    if(isTyping){
        el.textContent = "Partner is writing...";
        el.classList.remove('hidden');
    } else if (isOnline){
        el.textContent = "Partner: Online";
        el.classList.remove('hidden');
    } else if (seen) {
        // Simple diff
        const mins = Math.floor((now - seen) / 60000);
        el.textContent = `Partner: Last seen ${mins}m ago`;
        el.classList.remove('hidden');
    } else {
        el.textContent = "Partner: Offline";
        el.classList.remove('hidden');
    }
  }

  function applyCoupleDriverUI(){
    const isDriver = (state.myUid === state.roomDriver);
    const submit = $('submitBtn');
    
    // Re-run applyTierUI to enforce driver input locking
    applyTierUI();

    if(isDriver){
        submit.disabled = false;
        submit.textContent = "Submit Turn (Your Turn)";
        $('game').style.opacity = "1";
    } else {
        submit.disabled = true;
        submit.textContent = "Waiting for Partner...";
        $('game').style.opacity = "0.7";
    }
  }

  function subscribeCoupleRealtime(){
    if(state.turnsChannel || state.roomChannel) return;
    if(!state.roomId) return;

    // TURNS
    state.turnsChannel = sb.channel('turns_' + state.roomId)
      .on('postgres_changes', {event:'INSERT', schema:'public', table:'sb_turns', filter:`room_id=eq.${state.roomId}`},
        (payload) => {
           if(state._lastTurnId && payload.new.id === state._lastTurnId) return;
           state._lastTurnId = payload.new.id;

           const delta = payload.new.story_delta || "";
           const div = document.createElement('div');
           div.innerHTML = formatStory(delta);
           $('storyText').appendChild(div);
           
           const sep = document.createElement('div');
           sep.className = 'separator';
           sep.innerHTML = "⚜";
           $('storyText').appendChild(sep);

           sep.scrollIntoView({behavior:'smooth'});
        }
      )
      .subscribe();

    // ROOM STATE (Access Level Updates)
    state.roomChannel = sb.channel('room_' + state.roomId)
      .on('postgres_changes', {event:'UPDATE', schema:'public', table:'sb_rooms', filter:`id=eq.${state.roomId}`},
        (payload) => {
           if(payload.new.access_level) state.roomAccess = payload.new.access_level;
           if(payload.new.title) $('storyTitle').textContent = payload.new.title;
           if(payload.new.synopsis) $('storySynopsis').textContent = payload.new.synopsis;
           
           state.roomDriver = payload.new.current_driver;
           state.roomTurn = payload.new.turn;
           applyCoupleDriverUI();
           syncTierFromAccess();
        }
      )
      .subscribe();

    // MEMBERS / PRESENCE
    state.membersChannel = sb.channel('members_' + state.roomId)
      .on('postgres_changes', {event:'*', schema:'public', table:'sb_room_members', filter:`room_id=eq.${state.roomId}`},
        (payload) => {
           // We only care about the row that ISN'T us
           const row = payload.new || payload.old; // handle updates
           if(!row) return;
           if(row.user_id === state.myUid) return;

           state.partnerStatus = {
             uid: row.user_id,
             lastSeenAt: row.last_seen_at,
             typing: row.typing,
             typingAt: row.typing_at
           };
           updatePartnerUI(state.partnerStatus);
        }
      )
      .subscribe();
  }

  // =========================
  // UI LOGIC
  // =========================

  function setPaywallClickGuard(el, enabled){
    if(!el) return;
    if(enabled){
      el.setAttribute('onclick', "showPaywall('unlock')");
      el.onclick = () => showPaywall('unlock');
    } else {
      el.removeAttribute('onclick');
      el.onclick = null;
    }
  }

  function applyTierUI(){
      const paid = (state.tier === 'paid');
      const couple = (state.mode === 'couple');

      // 🔒 COUPLE UI: Paid vs Free Gating
      // Inputs Loop
      ['actionInput','dialogueInput','storyControls'].forEach(id => {
        const el = $(id);
        if(!el) return;
        
        if(couple){
            const access = state.roomAccess || 'free';
            const isDriver = (state.myUid && state.roomDriver && state.myUid === state.roomDriver);
            
            // Rule: If Free, inputs are locked regardless of driver (must use Fate or upgrade)
            // Rule: If Paid (Pass/Sub), inputs open for Driver only
            if (access === 'free') {
                el.disabled = true; // Locked behind paywall like Solo Tease
            } else {
                el.disabled = !isDriver; // Unlocked but Driver-gated
            }
        } else {
            el.disabled = !paid;
        }
      });

      // Wrappers (Visual Locks)
      ['actionWrapper','dialogueWrapper','storyControlsBox'].forEach(id => {
        const wrap = $(id);
        if(!wrap) return;

        if(couple){
          const access = state.roomAccess || 'free';
          const isLocked = (access === 'free'); // Visually lock if free
          
          if(isLocked) wrap.classList.add('locked-input');
          else wrap.classList.remove('locked-input');
          
          // Click guard opens paywall if free
          setPaywallClickGuard(wrap, isLocked);
          return;
        }

        if(paid) wrap.classList.remove('locked-input');
        else wrap.classList.add('locked-input');

        setPaywallClickGuard(wrap, !paid);
      });

      // Style cards
      document.querySelectorAll('.card[data-locked="true"]').forEach(card => {
        if(couple) return;
        if(paid) card.classList.remove('locked');
        else card.classList.add('locked');
      });

      // Buttons
      const saveBtn = $('saveBtn');
      const gameControlsBtn = $('gameControlsBtn');

      if(saveBtn){
        if(couple || paid){
          saveBtn.classList.remove('locked-style');
          saveBtn.onclick = () => saveStorySnapshot();
        } else {
          saveBtn.classList.add('locked-style');
          saveBtn.onclick = () => showPaywall('unlock');
        }
      }

      if(gameControlsBtn){
        if(couple || paid){
          gameControlsBtn.classList.remove('locked-style');
          gameControlsBtn.onclick = () => alert("Story Controls (stub).");
        } else {
          gameControlsBtn.classList.add('locked-style');
          gameControlsBtn.onclick = () => showPaywall('unlock');
        }
      }
  }

  function applyLengthLocks(){
    syncTierFromAccess();
    const cards = document.querySelectorAll('#lengthGrid .card[data-grp="length"]');
    cards.forEach(card => {
      const lockType = card.dataset.locked; 
      let locked = false;
      if(lockType === 'pass') locked = (state.access === 'free');
      if(lockType === 'sub')  locked = (state.access !== 'sub');
      card.classList.toggle('locked', locked);
    });
    
    const cap = getCapForAccess();
    if(state.storyTargetWords > cap) state.storyTargetWords = cap;
    
    document.querySelectorAll('#lengthGrid .card[data-grp="length"]').forEach(c => {
      c.classList.toggle('selected', Number(c.dataset.val) === Number(state.storyTargetWords));
    });
  }

  // 💰 PAY MODAL FIX: Dynamic pricing & text updates
  window.showPaywall = function(mode){
    const pm = $('payModal');
    if(!pm) return;

    // PATCH: God Mode Paywall View
    if(mode === 'god') {
        $('godModePay').classList.remove('hidden');
        $('standardPay').classList.add('hidden');
    } else {
        $('godModePay').classList.add('hidden');
        $('standardPay').classList.remove('hidden');
    }

    // Pricing Logic
    const passCount = Number(localStorage.getItem('sb_storypass_count') || 0);
    const isFirst = passCount === 0;
    const price = isFirst ? 2 : 4;

    // UI Updates
    const btn = document.getElementById('payOneTime');
    const txt = document.getElementById('passCopy');

    if(btn) btn.textContent = `Unlock This Story — $${price}`;
    if(txt) txt.textContent = isFirst ? "A light commitment." : "One story at a time.";

    // Visibility Logic
    let hideUnlock = false;
    
    if(state.mode === 'couple'){
        // Couple Logic: if room is passed, hide pass. if sub, hide pass.
        // We only show Pass if room is 'free'.
        if(state.roomAccess === 'pass' || state.roomAccess === 'sub') hideUnlock = true;
    } else {
        const hasPass = state.storyId && hasStoryPass(state.storyId);
        hideUnlock = (mode === 'sub') || state.subscribed || hasPass;
    }

    $('optUnlock')?.classList.toggle('hidden', !!hideUnlock);
    pm.classList.remove('hidden');
  };

  // 💰 COUPLE PAYWALL: Room Updates
  $('payOneTime')?.addEventListener('click', async () => {
    // Shared: Counter logic for Solo progressive pricing display (optional but good)
    const currentCount = Number(localStorage.getItem('sb_storypass_count') || 0);
    localStorage.setItem('sb_storypass_count', currentCount + 1);

    if(state.mode === 'couple'){
        // Couple Unlock: Write to Room
        if(!state.roomId) return alert("Error: No room context.");
        const { error } = await sb.from('sb_rooms')
            .update({ access_level: 'pass' })
            .eq('id', state.roomId);
        
        if(error) { console.error(error); alert("Payment sync failed."); return; }
        state.roomAccess = 'pass';
    } else {
        // Solo Unlock: Local
        state.storyId = state.storyId || makeStoryId();
        grantStoryPass(state.storyId);
    }

    syncTierFromAccess();
    $('payModal').classList.add('hidden');
    applyTierUI();
    applyLengthLocks();
    initCards(); 
    saveStorySnapshot();
  });

  $('paySub')?.addEventListener('click', async () => {
    if(state.mode === 'couple'){
        // Couple Sub: Write to Room
        if(!state.roomId) return alert("Error: No room context.");
        const { error } = await sb.from('sb_rooms')
            .update({ access_level: 'sub' })
            .eq('id', state.roomId);
            
        if(error) { console.error(error); alert("Payment sync failed."); return; }
        state.roomAccess = 'sub';
    } else {
        // Solo Sub: Local
        state.subscribed = true;
    }
    
    syncTierFromAccess();
    $('payModal').classList.add('hidden');
    applyTierUI();
    applyLengthLocks();
    initCards(); 
    saveStorySnapshot();
    if(state.mode !== 'couple') showScreen('modeSelect'); 
  });

  // PATCH: God Mode Pay Handler
  $('payGodMode')?.addEventListener('click', () => {
      localStorage.setItem('sb_god_mode_owned', '1');
      alert("God Mode Unlocked. You may now activate it in Story Controls.");
      $('payModal').classList.add('hidden');
      // Re-trigger the check to update UI
      $('godModeCheck').click(); // Simulate user trying again, now they own it
  });

  // PATCH: Quill Button Handler
  $('btnCommitQuill')?.addEventListener('click', () => {
      state.quillCommittedThisTurn = true;
      const btn = $('btnCommitQuill');
      const origText = btn.textContent;
      btn.textContent = "Quill Armed ✓";
      btn.style.borderColor = "var(--hot)";
      
      setTimeout(() => {
          btn.textContent = origText;
          // Visual revert happens on next updateQuillUI cycle
      }, 1500);
  });

  window.restart = function(){
    if(state.mode === 'couple') coupleCleanup();
    state.mode = 'solo';
    clearCurrentStoryId();
    state.storyId = null;
    if(!state.subscribed) state.tier = 'free';
    localStorage.removeItem('sb_saved_story');
    
    state.turnCount = 0;
    state.unlockedFateIdx = [0, 1];
    state.lastFate = null;
    // PATCH: Reset new state
    state.sexPushCount = 0;
    state.lastSexPushAt = null;
    state.quill = { uses: 0, nextReadyAtWords: 0, baseCooldown: 3000, multiplier: 1.6 };
    state.quillCommittedThisTurn = false;
    // PATCH: Reset story stage & sandbox
    state.storyStage = 'pre-intimacy';
    state.sandbox = false;
    state.godModeActive = false;
    
    $('storyText').innerHTML = '';
    $('storyTitle').textContent = '';
    $('storySynopsis').textContent = '';
    $('settingShotImg').style.display = 'none';
    $('settingError').classList.add('hidden');
    syncTierFromAccess();
    updateContinueButtons();
    showScreen('setup');
    window.scrollTo(0,0);
    updateQuillUI();
  };

  window.changeTier = function(){
    showScreen('tierGate');
  };

  // Burger menu toggle
  $('burgerBtn')?.addEventListener('click', () => {
    const mo = $('menuOverlay');
    if(!mo) return;
    mo.classList.toggle('hidden');
  });

  // Age gate -> TOS -> Tier
  $('ageYes')?.addEventListener('click', () => showScreen('tosGate'));

  $('tosCheck')?.addEventListener('change', (e) => {
    $('tosBtn').disabled = !e.target.checked;
  });

  $('tosBtn')?.addEventListener('click', () => showScreen('tierGate'));

  // Tier buttons
  $('btnTease')?.addEventListener('click', () => {
    state.tier = 'free';
    state.access = 'free';
    applyTierUI();
    showScreen('modeSelect');
    initCards();
  });

  $('btnIndulge')?.addEventListener('click', () => {
    // Indulge opens pay modal, doesn't grant paid immediately
    showPaywall('sub');
  });

  // 🔒 PAYWALL UPDATE: In-Game Intensity Selector
  window.setGameIntensity = function(level){
    if (state.godModeActive) { state.intensity = level; return; } // PATCH: God Mode Bypass

    // Rule: $1 Pass cannot change intensity mid-game
    if (state.access === 'pass' && state.turnCount > 0) {
        if (confirm("Changing intensity mid-story is a Subscriber feature. Subscribe?")) {
            showPaywall('sub');
        }
        return; 
    }

    // Rule: Dirty is Sub Only
    if (level === 'Dirty' && state.access !== 'sub') {
        showPaywall('sub');
        return;
    }

    // Rule: Erotic is Locked for Free
    if (level === 'Erotic' && state.access === 'free') {
        showPaywall('unlock');
        return;
    }

    state.intensity = level;
    // PATCH: Reset Sex Push on intensity change
    state.sexPushCount = 0;
    
    document.querySelectorAll('#gameIntensity button').forEach(b => {
      b.classList.toggle('active', b.textContent.trim() === level);
    });
  };

  // 🔒 PAYWALL UPDATE: Intensity Gating Logic (Setup)
  document.querySelectorAll('#intensityBtns .intensity-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const val = btn.dataset.val;
      
      // Gating Rules
      if (val === 'Erotic' && state.access === 'free') {
          showPaywall('unlock'); // $1 Pass allows Erotic
          return;
      }
      if (val === 'Dirty' && state.access !== 'sub') {
          showPaywall('sub'); // Dirty is Sub ONLY
          return;
      }

      document.querySelectorAll('#intensityBtns .intensity-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      state.intensity = val;
      
      // Updated Descriptions (Ceiling Logic)
      const descs = {
          "Clean": "Romance, chemistry, and implication only.",
          "Naughty": "Suggestive tension; no explicit anatomy.",
          "Erotic": "Explicit intimacy with literary restraint.",
          "Dirty": "Explicit actions and language, rendered in the chosen style."
      };
      $('intensityDesc').textContent = `(${val}) ${descs[val]}`;
    });
  });

  // 🔒 PAYWALL UPDATE: Preview Logic (Dirty Block)
  document.querySelectorAll('.preview-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Specific check: If generating a preview for a Dirty card (future proofing)
      /* if (btn.closest('.card').dataset.val === 'Dirty' && state.access !== 'sub') {
          showPaywall('sub');
          return;
      } 
      */

      $('previewText').textContent = btn.dataset.txt || '';
      $('previewModal').classList.remove('hidden');
    });
  });

  // --- SELECTION HANDLER ---
  function initSelectionHandlers(){
    document.querySelectorAll('.card[data-grp]').forEach(card => {
      if(card.dataset.bound === '1') return;
      card.dataset.bound = '1';

      card.addEventListener('click', (e) => {
        if(e.target && e.target.classList && e.target.classList.contains('preview-btn')) return;

        const grp = card.dataset.grp;
        const val = card.dataset.val;
        if(!grp || !val) return;

        // Length Handling
        if(grp === 'length'){
           const lockType = card.dataset.locked;
           if(lockType === 'pass' && state.access === 'free'){ showPaywall('unlock'); return; }
           if(lockType === 'sub' && state.access !== 'sub'){ showPaywall('sub'); return; }
           
           state.storyTargetWords = Number(val);
           document.querySelectorAll('.card[data-grp="length"]').forEach(c => c.classList.remove('selected'));
           card.classList.add('selected');
           return;
        }

        // Enforce locked style cards in free tier
        const isLocked = card.dataset.locked === 'true' || card.classList.contains('locked');
        const paid = (state.tier === 'paid');
        if(grp === 'style' && isLocked && !paid){
          showPaywall('unlock');
          return;
        }

        // POV: single select
        if(grp === 'pov'){
          state.picks.pov = val;
          document.querySelectorAll('.card[data-grp="pov"]').forEach(c => c.classList.remove('selected'));
          card.classList.add('selected');
          return;
        }

        // Multi-select groups with max 3
        const key = grp; 
        if(!state.picks[key]) state.picks[key] = [];
        const arr = state.picks[key];

        const idx = arr.indexOf(val);
        if(idx >= 0){
          arr.splice(idx, 1);
          card.classList.remove('selected');
        } else {
          if(arr.length >= 3) return alert("Select up to 3 only."); 
          arr.push(val);
          card.classList.add('selected');
        }
      });
    });
  }
  
  // STRANGER COUNT & TRACKING
  async function trackStrangerClick(){
      const visitorId = localStorage.getItem('sb_visitor_id') || 'v_' + Date.now() + Math.random().toString(36).slice(2);
      localStorage.setItem('sb_visitor_id', visitorId);

      // Local Increment
      let clicks = parseInt(localStorage.getItem('sb_stranger_clicks') || '0');
      clicks++;
      localStorage.setItem('sb_stranger_clicks', clicks);

      // Supabase metric if available
      if(sb){
         try {
             // Best effort - fire and forget
             await sb.from('sb_metrics').insert([{ type: 'stranger_click', visitor_id: visitorId }]);
         } catch(e) { /* ignore tracking error */ }
      }
  }

  function updateStrangerCount(){
      const el = document.getElementById('strangerCount');
      if(!el) return;
      let n = localStorage.getItem('sb_stranger_count');
      if(!n){
        const base = 9000 + Math.floor(Math.random() * 12000); 
        n = String(base);
        localStorage.setItem('sb_stranger_count', n);
      }
      el.textContent = Number(n).toLocaleString();
  }
  
  window.setMode = async function(m){
      // PATCH: Check Solo → Couple transition
      if(m === 'couple') {
          if(state.storyStage === 'post-consummation') {
              alert("This story has crossed into private intimacy and can no longer be shared.");
              return;
          }
          if(state.sandbox) {
              alert("Sandbox stories cannot be shared.");
              return;
          }
      }

      state.mode = m; 

      if(m === 'solo') {
          showScreen('setup');
          return;
      }

      if(m === 'couple'){
          showScreen('coupleInvite');
          
          if(sb){
              state.myNick = getNickname();
              document.getElementById('sbNickLabel').textContent = state.myNick;
              document.getElementById('coupleStatus').textContent = "Connecting to auth...";
              
              state.myUid = await ensureAnonSession();
              
              if(state.myUid){
                  document.getElementById('coupleStatus').textContent = "Connected (Anon)";
                  wireCoupleInviteUI();
              } else {
                  document.getElementById('coupleStatus').textContent = "Auth Failed (Check Config)";
              }
          } else {
               document.getElementById('coupleStatus').textContent = "Supabase Not Configured";
          }
          return;
      }

      if(m === 'stranger'){
          updateStrangerCount();
          trackStrangerClick();
          showScreen('strangerModal');
      }
  };

  window.setTheme = function(t){
      document.body.className = '';
      if (t !== 'default') document.body.classList.add('theme-' + t);
  };

  window.setFont = function(font){ document.documentElement.style.setProperty('--font-story', font); }
  window.setFontSize = function(size){ document.documentElement.style.setProperty('--story-size', size + "px"); }

  // --- COLORS FOR DIALOGUE ---
  // Returns hex codes based on pairings
  function determineDialogueColors(){
      // Normalization helpers
      const isM = (g) => g === 'Male';
      const isF = (g) => g === 'Female';
      const p1 = state.gender;
      const p2 = state.loveInterest;

      // P1 Male, P2 Male -> Blue / DarkBlue
      if(isM(p1) && isM(p2)) return { p1: '#B0E0E6', p2: '#87CEEB' };
      
      // P1 Female, P2 Female -> Pink / HotPink
      if(isF(p1) && isF(p2)) return { p1: '#FFB6C1', p2: '#FF69B4' };
      
      // Mixed M/F
      if(isM(p1) && isF(p2)) return { p1: '#B0E0E6', p2: '#FFB6C1' };
      if(isF(p1) && isM(p2)) return { p1: '#FFB6C1', p2: '#B0E0E6' };
      
      // Queer / NB / Custom fallback
      return { p1: '#8A2BE2', p2: '#FF7F00' };
  }

  // --- API CALL ---
  async function callChat(messages){
    const res = await fetch(PROXY_URL, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ model: STORY_MODEL, messages })
    });

    let data = null;
    try { data = await res.json(); } catch(e){}

    if(!res.ok){
        const msg = data?.error || data?.message || `HTTP ${res.status}`;
        throw new Error(msg);
    }

    const out = data?.choices?.[0]?.message?.content;
    if(!out) throw new Error("No model output.");
    return out;
  }

  // --- LOADING ---
  const loadingPhrases = ["Stoking the embers...", "Consulting your desires...", "Sharpening tension...", "Weaving fate...", "Bribing the muse...", "Checking for traps...", "Summoning the stars...", "Opening the void...", "Setting the hook...", "Negotiating with destiny..."];
  let loadInt;
  let isLoading = false;

  function startLoading(){
    if(isLoading) return;
    $('loadingOverlay').style.display = 'flex';
    isLoading = true;
    let i=0;
    $('loadingText').innerText = loadingPhrases[0];
    $('loadingOverlayFill').style.width = '10%';
    loadInt = setInterval(() => {
        i++;
        $('loadingText').innerText = loadingPhrases[i % loadingPhrases.length];
        // Cap at 90% until done
        const w = Math.min(90, i*20);
        $('loadingOverlayFill').style.width = w + '%';
    }, 1200);
  }

  function stopLoading(){
    if(loadInt) clearInterval(loadInt);
    isLoading = false;
    $('loadingOverlay').style.display = 'none';
    $('loadingOverlayFill').style.width = '0%';
  }

  // --- GHOST PILLS LOGIC (Cycling Grid) ---
  function setupGhostGrid(containerId, listItems){
      const container = $(containerId).querySelector('.ghost-grid');
      const count = 20; 
      for(let i=0; i<count; i++){
          const span = document.createElement('span');
          span.className = 'ghost-item';
          span.innerText = listItems[Math.floor(Math.random() * listItems.length)];
          container.appendChild(span);
      }
      
      setInterval(() => {
          const idx = Math.floor(Math.random() * count);
          const el = container.children[idx];
          if(el) {
              el.style.opacity = 0;
              setTimeout(() => {
                  el.innerText = listItems[Math.floor(Math.random() * listItems.length)];
                  el.style.opacity = 0.5;
                  el.classList.add('highlight');
                  setTimeout(() => el.classList.remove('highlight'), 1000);
              }, 500);
          }
      }, 3000);

      const input = $(containerId).parentElement.querySelector('textarea, input');
      if(input){
          input.onfocus = () => { $(containerId).style.display='none'; input.style.background='rgba(30,0,50,0.9)'; input.style.color='#fff'; };
          input.onblur = () => { if(!input.value) { $(containerId).style.display='flex'; input.style.background='transparent'; } };
      }
  }
  
  if(!window._ghostInit){
      window._ghostInit = true;
      setupGhostGrid('ghost1', ancestries);
      setupGhostGrid('ghost2', ancestries);
      setupGhostGrid('ctrlGhost', controlsList);
  }

  window.checkCustom = function(select, inputId){
      const input = document.getElementById(inputId);
      if(select.value === 'Custom') input.classList.remove('hidden');
      else input.classList.add('hidden');
  }

  // --- META STATE (5th Person / Author=Fate system) ---
  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
  
  window.setMetaStance = function(s){
      state.stance = s;
      document.querySelectorAll('.meta-stance').forEach(b => {
         b.classList.remove('active');
         if(b.innerText.trim().toLowerCase() === s) b.classList.add('active');
      });
      updateMetaReadout();
  };

  function updateMetaReadout(){
    const r = $('metaReadout');
    if(!r) return;
    r.textContent = `Awareness: ${state.awareness}/3 | Pressure: ${state.fatePressure}/3`;
  }

  function updateMetaState(evt){
    // evt: {type:'fate'|'input', card?, text?}
    const stance = state.stance || 'aid';

    if(evt && evt.type === 'fate'){
      state.consecutiveFate = (state.consecutiveFate || 0) + 1;
      if(state.consecutiveFate >= 1) state.fatePressure = clamp((state.fatePressure || 1) + 1, 1, 3);
      if(state.consecutiveFate >= 2) state.awareness = clamp((state.awareness || 0) + 1, 0, 3);
      state.metaChance = clamp((state.metaChance || 0.10) + 0.08, 0.05, 0.60);
      if(stance === 'aid')    state.metaChance = clamp(state.metaChance + 0.02, 0.05, 0.60);
      if(stance === 'rebel')  state.awareness  = clamp(state.awareness + 0.1, 0, 3);
      if(stance === 'seduce') state.metaChance = clamp(state.metaChance + 0.01, 0.05, 0.60);
    }

    if(evt && evt.type === 'input'){
      state.consecutiveFate = clamp((state.consecutiveFate || 0) - 1, 0, 999);
      if((state.fatePressure || 1) > 1) state.fatePressure = clamp(state.fatePressure - 1, 1, 3);
      
      const baseline = 0.10;
      const cur = (state.metaChance || baseline);
      state.metaChance = clamp(cur - 0.05, 0.05, 0.60);
      if(state.metaChance < baseline) state.metaChance = baseline;

      if(stance === 'rebel') state.metaChance = clamp(state.metaChance + 0.01, 0.05, 0.60);
      if(stance === 'aid')   state.metaChance = clamp(state.metaChance - 0.01, 0.05, 0.60);
    }

    state.awareness = clamp(state.awareness || 0, 0, 3);
    state.fatePressure = clamp(state.fatePressure || 1, 1, 3);
    state.metaChance = clamp(state.metaChance || 0.10, 0.05, 0.60);

    updateMetaReadout();
  }

  // --- FATE CARDS RENDER ---
  function initCards(){
      const m = $('cardMount');
      m.innerHTML = '';
      const labels = ["FATE", "FATE", "FATE", "FATE", "FATE"];
      const names = ["Temptation", "Confession", "Boundary", "Power Shift", "Silence"];
      const backs = ["🍷", "🔥", "⚔️", "👑", "🕊️"];
      
      const verbs = ["risks", "elicits", "tests", "forces", "imposes"];
      let actions = ["You feel a sudden, reckless need to close the distance.", "You can't hold back the truth any longer.", "You instinctively draw a hard line.", "You seize control of the situation.", "You find yourself unable to speak."];
      let dialogues = ["Tell me.", "I want this.", "Stop.", "Kneel.", "(Silence)"];

      if(state.fateOptions && state.fateOptions.length === 5){
          state.fateOptions.forEach((opt, i) => {
              if(opt.action) actions[i] = opt.action;
              if(opt.dialogue) dialogues[i] = opt.dialogue;
          });
      }
      
      labels.forEach((l, i) => {
          const btn = document.createElement('button');
          btn.className = 'fate-card';
          
          let locked = false;

          // In COUPLE mode: Fate is always available (no paywall)
          if(state.mode !== 'couple'){
            if (state.access === 'free' && state.unlockedFateIdx && !state.unlockedFateIdx.includes(i)) locked = true;
          }

          if (locked) btn.classList.add('locked');

          btn.innerHTML = `<div class="inner"><div class="front"><h3>${l}</h3></div><div class="back"><div style="font-size:30px">${backs[i]}</div></div></div>`;
          btn.onclick = () => {
              if(btn.classList.contains('locked')){
                  window.showPaywall('unlock');
                  return;
              }

              document.querySelectorAll('.fate-card').forEach((c, idx) => {
                  c.classList.add('flipped'); 
                  if(idx !== i) c.style.opacity = '0.5'; 
                  else c.style.opacity = '1';
              });
              
              let prefixAction = `Fate ${verbs[i]} ${names[i]}:`;
              let prefixDia = `Fate ${verbs[i]} ${names[i]}:`; 
              
              if(state.picks.pov === "Fifth") {
                  // Author POV Phrasing (Short & Decisive)
                  const authorActions = [
                    "The Author's pen fills the moment with Temptation:", 
                    "The Author writes Confession into the subtext:", 
                    "The Author inks a Boundary across the scene:", 
                    "The Author drafts a Power Shift in your posture:", 
                    "The Author edits you into Silence:" 
                  ];
                  prefixAction = authorActions[i];
                  prefixDia = "The Author writes:";
              }
              
              let cleanDia = dialogues[i];
              if(cleanDia !== "(Silence)" && !cleanDia.startsWith('"')) cleanDia = `"${cleanDia}"`;

              const finalAct = `${prefixAction} ${actions[i]}`;
              const finalDia = `${prefixDia} ${cleanDia}`;

              // Store selection for Tease mode
              state.lastFate = { action: finalAct, dialogue: finalDia };

              // Persist selection for DB (Couple mode)
              state.selectedFateIndex = i;
              state.selectedFatePayload = { index: i, name: names[i], action: finalAct, dialogue: finalDia };

              // Visual update
              $('actionInput').value = finalAct;
              $('dialogueInput').value = finalDia;
              
              // Trigger typing if couple mode
              markTyping();

              if(state.picks.pov === 'Fifth') updateMetaState({ type: 'fate', card: names[i] });
          };
          m.appendChild(btn);
      });
  }

  // --- FORMATTING (Sanitized) ---
  function escapeHTML(s){
      return String(s)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#039;');
  }

  function formatStory(text){
      const colors = determineDialogueColors();
      document.documentElement.style.setProperty('--p1-color', colors.p1);
      document.documentElement.style.setProperty('--p2-color', colors.p2);

      let safe = escapeHTML(text);
      // Strip Markdown headers/bold
      let clean = safe.replace(/#+\s/g, '').replace(/\*\*/g, '');
      // Strip meta-tags from body
      clean = clean.replace(/^Title:.*$/gm, "").replace(/^Synopsis:.*$/gm, "");
      
      let html = clean.replace(/\n\n+/g, '</p><p>').replace(/\n/g, '<br>');
      if(!html.startsWith('<p>')) html = '<p>' + html + '</p>';
      
      html = html.replace(/\[P1\]([\s\S]*?)\[\/P1\]/g, '<span class="dialogue-block p1-dia">$1</span>');
      html = html.replace(/\[P2\]([\s\S]*?)\[\/P2\]/g, '<span class="dialogue-block p2-dia">$1</span>');
      html = html.replace(/Player Action:|What do you do\?/gi, "");
      return html;
  }

  // --- META EXTRACTION ---
  function extractMeta(raw) {
      const titleMatch = raw.match(/^\s*Title:\s*(.+)\s*$/m);
      const synMatch   = raw.match(/^\s*Synopsis:\s*(.+)\s*$/m);

      const title = titleMatch ? titleMatch[1].trim() : "Storybound";
      const syn   = synMatch ? synMatch[1].trim() : "A tale of desire...";

      let body = raw
        .replace(/^\s*Title:\s*.*\s*$/gmi, "")
        .replace(/^\s*Synopsis:\s*.*\s*$/gmi, "")
        .trim();

      return { title, syn, body };
  }

  // --- BEGIN STORY ---
  $('beginBtn').onclick = async function(){
      applyVetoFromControls(); // PATCH: Apply Veto before start
      updateHistoryStats(); // PATCH: Track stats
      
      state.storyId = makeStoryId();
      if(!state.subscribed && hasStoryPass(state.storyId) && state.tier === 'free'){
        state.tier = 'paid';
        applyTierUI();
      }
      
      syncTierFromAccess();

      state.gender = $('playerGender').value === 'Custom' ? $('customPlayerGender').value : $('playerGender').value;
      state.loveInterest = $('loveInterestGender').value === 'Custom' ? $('customLoveInterest').value : $('loveInterestGender').value;
      state.ancestry1 = $('playerAncestry').value || "Unspecified";
      state.ancestry2 = $('loveAncestry').value || "Unspecified";
      state.pronouns1 = $('playerPronouns').value === 'Custom' ? $('customPlayerPronouns').value : $('playerPronouns').value;
      state.pronouns2 = $('lovePronouns').value === 'Custom' ? $('customLovePronouns').value : $('lovePronouns').value;
      
      let p1Name = $('playerNameInput').value.trim();
      let p2Name = $('partnerNameInput').value.trim();

      if(state.picks.genre.includes('Gothic')) setFont("'Grenze Gotisch', cursive");
      else if(state.picks.genre.includes('Romantasy')) setFont("'Glass Antiqua', cursive");
      else if(state.picks.style.includes('Regency')) setFont("'Allura', cursive");
      else if(state.picks.style.includes('SciFi')) setFont("'Smooch Sans', sans-serif");
      
      if(state.tier === 'free'){
          if(!p1Name) p1Name = "Alex";
          const surname = cheapNames[Math.floor(Math.random() * cheapNames.length)];
          p1Name += " " + surname;
      }
      if(!p1Name) p1Name = "The Protagonist";
      if(!p2Name) p2Name = "The Stranger";
      
      // MIRROR AUTHOR IDENTITY
      state.authorGender = state.gender;
      state.authorPronouns = state.pronouns1;

      if(state.picks.pov === 'Fifth'){
          $('metaControls').classList.remove('hidden');
          // Default stance
          window.setMetaStance('aid');
      }

      startLoading();
      showScreen('game');
      window.scrollTo(0,0);
      initCards();
      
      // PATCH: Check Author's Chair on start
      state.authorChairActive = checkAuthorChairUnlock();
      updateQuillUI(); // PATCH: update UI state
      
      let povInstruction = `POV: ${state.picks.pov}.`;
      if(state.picks.pov === "Fifth"){
          povInstruction = `Write in 5th Person (Author POV). The Author exists as a character (3rd person) in the story. Narration describes story + Author's decisions. Protagonists are 3rd person. Include frequent brief interiority for the Author (desires, doubts). Author Gender: ${state.authorGender}, Pronouns: ${state.authorPronouns}. Tone: sensual, confident, literary.`;
      }

      // ELASTIC PACING
      const target = Number(state.storyTargetWords || 10000);
      let sexAt = Math.floor(target * 0.55); // Naughty default
      if(state.intensity === "Clean")   sexAt = 999999999;
      if(state.intensity === "Erotic")  sexAt = Math.floor(target * 0.30);
      if(state.intensity === "Dirty")   sexAt = Math.floor(target * 0.20);
      
      const arcInstruction = `ARC LENGTH: Structure this story to feel complete within ~${target} words. Keep pacing appropriate—setup, rising tension, escalation, climax.`;
      let sexBan = `STRICT RULE: NO sex between Main Characters until at least ${sexAt} words. Build tension first.`;

      // PATCH: Veto Rules Injection
      const vetoRules = `
      BANNED WORDS: ${state.veto.bannedWords.join(', ') || 'None'}. Never output these.
      BANNED NAMES: ${state.veto.bannedNames.join(', ') || 'None'}.
      EXCLUDED THEMES: ${state.veto.excluded.join(', ') || 'None'}.
      TONE NUDGES: ${state.veto.tone.join(', ') || 'Default'}.
      `;

      state.sysPrompt = `You are a master storyteller. 
      Genre: ${state.picks.genre.join(',')}. 
      Style: ${state.picks.style.join(',')}.
      ${povInstruction}
      Player 1 is ${p1Name} (${state.gender}, ${state.pronouns1}), Ancestry: ${state.ancestry1}.
      Player 2 (Partner) is ${p2Name} (${state.loveInterest}, ${state.pronouns2}), Ancestry: ${state.ancestry2}.
      Intensity: ${state.intensity}.
      Constraints: Do NOT use names: ${getUsedNames().join(', ')}. Never refer to the love interest as 'the love interest'. Use Show Don't Tell.
      The AI must not invent or assign real-world ethnicities, religions, or nationalities to any character unless the player explicitly specifies them in inputs.
      If the player specifies culture/faith/lineage, portray it respectfully and avoid stereotypes, slurs, fetish framing.
      ${arcInstruction}
      ${sexBan}
      ${vetoRules}
      IMPORTANT: This is the OPENING. NO sex acts yet. Focus on PLOT, WORLD-BUILDING, and TENSION. Establish a nemesis and high stakes. Characters must have agendas.
      Formatting: Write in lush, novelistic prose. Use complete sentences with articles (The, A, An). NO telegram style. Use strict paragraph breaks (\\n\\n). Minimum 6-10 paragraphs for Intro.
      Dialogue Formatting: Wrap Player 1's dialogue in [P1]...[/P1]. Wrap Partner's dialogue in [P2]...[/P2].
      AT THE END OF RESPONSE, append a JSON block with 5 new Fate Card options based on the scene:
      ///FATE_JSON_START///
      [{"action":"...", "dialogue":"..."}, ...] (5 objects)
      ///FATE_JSON_END///
      Output format (STRICT): First line must be exactly "Title: …". Second line must be exactly "Synopsis: …". Then a blank line. Then story body ONLY (do NOT repeat Title or Synopsis again).
      If the player's access is FREE or STORY PASS, and the story approaches the cap (10k or 25k), begin steering toward a charged cliffhanger. ACCESS: ${state.access}. CAP_WORDS: ${getCapForAccess()}.`;
      
      try {
          let raw = await callChat([{role:'system', content: state.sysPrompt}, {role:'user', content: "Begin the story. Start with Title: [Title] and Synopsis: [Synopsis]. Synopsis must use complete, flowery sentences. No telegraphese."}]);
          
          if(raw.includes("///FATE_JSON_START///")){
             const parts = raw.split("///FATE_JSON_START///");
             raw = parts[0]; 
             const jsonRaw = parts[1].split("///FATE_JSON_END///")[0];
             try { state.fateOptions = JSON.parse(jsonRaw); } catch(e){}
          }

          const firstChunk = raw.slice(0, 500).toLowerCase();
          const articles = (firstChunk.match(/\b(the|a|an)\b/g) || []).length;
          
          if(articles < 5) {
              raw = await callChat([
                  {role:'system', content: "You are a copy editor. Rewrite this text into lush, grammatical, novelistic prose. Add missing articles (the, a, an) and auxiliary verbs. Fix fragments."},
                  {role:'user', content: raw}
              ]);
          }
          
          initCards();
          const { title, syn, body } = extractMeta(raw);

          $('storyTitle').textContent = title.replace(/\*\*/g, '');
          $('storySynopsis').textContent = syn.replace(/\*\*/g, '');
          generateSettingShot(syn);
          $('storyText').innerHTML = formatStory(body);
          
          const namesFound = body.match(/[A-Z][a-z]+/g) || [];
          namesFound.forEach(n => addUsedName(n));
          
          saveStorySnapshot();

      } catch(e) {
          $('storyText').innerHTML = "<p>Backend failed. Fallback loaded.</p>";
      }
      stopLoading();
  };

  async function generateSettingShot(synopsis){
      try {
          const prompt = `Cinematic establishing shot based on this story: ${synopsis}. Highly detailed, 8k, mysterious atmosphere, no text.`;
          
          let safety = "";
          if(state.intensity === 'Dirty' || state.intensity === 'Erotic') safety = "Artistic, suggestive, safe-for-work, no explicit nudity.";

          const res = await fetch(IMAGE_PROXY_URL, {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ 
                  prompt: prompt + " " + safety,
                  provider: 'xai',
                  model: 'grok-2-image-1212', 
                  size: '1024x1024'
              })
          });
          
          let data;
          try { data = await res.json(); } catch(e){}

          if(!res.ok) throw new Error("API Error");
          
          const url = data.url || data.data?.[0]?.url || data.data?.[0]?.b64_json;
          if(!url) throw new Error("No URL");

          const img = $('settingShotImg');
          if(url.startsWith('http')) img.src = url;
          else img.src = `data:image/png;base64,${url}`;
          
          img.style.display = 'block';
          img.onload = () => { $('settingError').classList.add('hidden'); };
          img.onerror = () => { throw new Error("Load Fail"); };

      } catch(e) {
          const FALLBACKS = [
            "https://images.unsplash.com/photo-1519074069444-1ba4fff66d16?q=80&w=1024&auto=format&fit=crop", 
            "https://images.unsplash.com/photo-1478760329108-5c3ed9d495a0?q=80&w=1024&auto=format&fit=crop", 
            "https://images.unsplash.com/photo-1504608524841-42fe6f032b4b?q=80&w=1024&auto=format&fit=crop"  
          ];
          const img = $('settingShotImg');
          const pick = FALLBACKS[Math.floor(Math.random() * FALLBACKS.length)];
          img.src = pick + (pick.includes("?") ? "&" : "?") + "cb=" + Date.now();
          img.style.display = 'block';
      }
  }

  // --- SUBMIT TURN ---
  $('submitBtn').onclick = async function(){
      applyVetoFromControls(); // PATCH: Update veto state from inputs
      
      // 🔒 PAYWALL UPDATE: Hard Cap Enforcement & Intensity Locking
      syncTierFromAccess();
      
      // 1. Hard Word Cap Check
      const wc = currentStoryWordCount();
      const cap = getCapForAccess();
      
      // Soft/Hard Warnings could be UI toasts, but here is the hard gate
      if (wc >= cap && !state.godModeActive) { // PATCH: God Mode Bypass
          if (state.access === 'free') {
              // Tease Limit -> Offer Pass
              showPaywall('unlock'); 
              return; 
          } else if (state.access === 'pass') {
              // Pass Limit -> Offer Sub
              showPaywall('sub'); 
              return;
          }
      }

      // 2. Mid-Game Intensity Lock Check
      // If user tries to change intensity mid-game via mini-buttons (handled in setGameIntensity),
      // we need to ensure they actually have permission to USE that intensity here.
      if (state.tier === 'paid' && state.access !== 'sub' && state.intensity === 'Dirty' && !state.godModeActive) {
          // Prevent $1 pass from sneaking into Dirty via console or hacks
          alert("Dirty intensity is reserved for Subscribers.");
          setGameIntensity('Erotic'); // Downgrade
          return;
      }

      // === COUPLE MODE FORK ===
      if(state.mode === 'couple'){
          if(state.myUid !== state.roomDriver){
             alert("Not your turn!"); 
             return;
          }

          stopTyping(true); // Ensure typing is off

          startLoading();
          
          const act = $('actionInput').value;
          const dia = $('dialogueInput').value;
          const context = $('storyText').innerText.slice(-3000);
          
          // 🔒 COUPLE INTENSITY GUARD INTEGRATION
          const currentCount = state.turnCount * 250;
          let sexAt = Math.floor(cap * 0.55);
          if(state.intensity === "Erotic") sexAt = Math.floor(cap * 0.30);
          if(state.intensity === "Dirty")  sexAt = Math.floor(cap * 0.20);
          
          let intensityGuard = "";
          if (state.intensity === "Naughty") {
              intensityGuard = "INTENSITY RULE: Naughty. Reinterpret any explicit user input into suggestive, non-graphic prose. Do NOT echo graphic terms. Focus on tension.";
          } else if (state.intensity === "Erotic") {
              intensityGuard = "INTENSITY RULE: Erotic. Explicit intimacy allowed. If input is extreme, soften it while preserving the act. Maintain literary tone.";
          } else if (state.intensity === "Dirty") {
              intensityGuard = "INTENSITY RULE: Dirty. Depict entered actions/words. Apply the selected Style voice (e.g. Shakespearean/Breathless). Dirty isn't always raw; respect the Voice.";
          } else {
              intensityGuard = "INTENSITY RULE: Clean. Romance and chemistry only. Fade to black if necessary.";
          }

          const sys = (state.sysPrompt || "You are a master storyteller.") + `\n\n${intensityGuard}\n\nTURN INSTRUCTIONS: 
          Story So Far: ...${context}
          Player Action: ${act}. 
          Player Dialogue: ${dia}. 
          Rules: 3-6 paragraphs. Complete sentences. Maintain POV.
          (Sex allowed after ${sexAt} words. Current words: ~${currentCount})`;

          let raw = "";
          try {
             raw = await callChat([{role:'system', content:sys}, {role:'user', content: "Next scene."}]);
          } catch(e){
             console.log(e);
             alert("AI generation failed.");
             stopLoading();
             return;
          }
          
          try {
            // Compare-and-swap
            const { data: members, error: memErr } = await sb
              .from('sb_room_members')
              .select('user_id, role, joined_at')
              .eq('room_id', state.roomId)
              .order('joined_at', { ascending: true });

            if(memErr) throw memErr;

            const other = (members || []).find(m => m.user_id !== state.myUid);
            const nextDriver = other?.user_id || state.myUid;
            
            await coupleAdvanceTurnCAS(nextDriver);

            const { error: insertErr } = await sb.from('sb_turns').insert([{
                room_id: state.roomId,
                turn: state.roomTurn - 1, 
                driver_id: state.myUid,
                story_delta: raw,
                player_action: act,
                player_dialogue: dia,
                fate_choice: state.selectedFatePayload || null
            }]);

            if(insertErr){
                if(insertErr.code === '23505'){ // Unique Violation
                   alert("Synced — that turn was already recorded.");
                   await coupleBootstrap(); // Resync state
                } else {
                   throw insertErr;
                }
            }

          } catch(e){
            console.error(e);
            alert("Sync conflict. Please retry.");
            stopLoading();
            return;
          }
          
          // Clear local state
          $('actionInput').value = ''; 
          $('dialogueInput').value = '';
          state.selectedFateIndex = null;
          state.selectedFatePayload = null;
          stopLoading();
          return;
      }
      // === END COUPLE FORK ===

      // const isTease = (state.access === 'free'); // Already checked cap above
      
      if(state.access === 'free' && !state.lastFate){
          alert("In Tease, select a Fate Card to guide your turn.");
          return;
      }
      
      let act = ($('actionInput')?.value || '').trim();
      let dia = ($('dialogueInput')?.value || '').trim();
      
      if(state.access === 'free' && state.lastFate){
          act = state.lastFate.action;
          dia = state.lastFate.dialogue;
      }
      
      // Smoke Animation
      document.querySelectorAll('.fate-card').forEach(c => c.classList.add('poof'));
      
      // Wait for smoke...
      await new Promise(r => setTimeout(r, 650));
      
      startLoading();
      state.turnCount++;
      const sep = document.createElement('div');
      sep.className = 'separator';
      sep.innerHTML = "⚜";
      $('storyText').appendChild(sep);
      
      const context = $('storyText').innerText.slice(-3000);
      if(state.picks.pov === 'Fifth') updateMetaState({ type: 'input', text: act + " " + dia });

      try {
          let metaMsg = "";
          if(state.picks.pov === "Fifth") {
              metaMsg = `FATE META: Author=Fate. Characters’ stance=${state.stance}. awareness=${state.awareness}/3. fatePressure=${state.fatePressure}/3. metaChance=${state.metaChance.toFixed(2)}.`;
              if(Math.random() < state.metaChance){
                  const directives = META_DIRECTIVES[state.stance];
                  const directive = directives[Math.floor(Math.random() * directives.length)];
                  metaMsg += `\nMETA DIRECTIVE: ${directive}`;
              }
          }

          // 🔒 PAYWALL UPDATE: Elastic Pacing & Intensity Guard
          // const cap = getCapForAccess(); // Defined earlier
          const currentCount = state.turnCount * 250; // Approximation or use word count
          
          // Elastic Sex Timing (Recalculated on every turn based on current access)
          let sexAt = getSexAllowedAtWordCount(); // PATCH: Use new helper

          // PATCH: Sex Push Detection Logic
          const sexKeywords = /\b(cock|pussy|fuck|thrust|breasts|nipples|clit|anal|cum|shiver|moan|grind)\b/i;
          const isSexPush = sexKeywords.test(act + " " + dia) && currentCount < sexAt;
          
          let squashDirective = "";
          if(isSexPush && !state.godModeActive) { // PATCH: God Mode Bypass
              state.sexPushCount++;
              state.lastSexPushAt = Date.now();
              if(state.sexPushCount <= 2) {
                  squashDirective = "SQUASH RULE: Player is escalating too fast. Introduce an in-story interruption, hesitation, or external pressure that heightens tension without consummation.";
              } else {
                  squashDirective = "SQUASH RULE: Firm boundary. The characters should explicitly acknowledge the heat but delay consummation. Include a brief line signaling restraint.";
              }
          }

          // PATCH: Intensity Reminder (Meta)
          let metaReminder = "";
          if(state.sexPushCount >= 3 && !state.godModeActive) {
              metaReminder = "META REMINDER: Include a subtle line hinting the story could become more explicit if the tone changed, without breaking immersion.";
          }

          // PATCH: Quill Logic
          let quillDirective = "";
          // God Mode always allows Quill
          const quillAllowed = (state.quillCommittedThisTurn && getQuillReady()) || state.godModeActive;
          const { veto, quillDraft } = parseStoryControls($('storyControls').value);
          
          const vetoRules = `VETO RULES (ALWAYS ACTIVE):
          BANNED: ${veto.bannedWords.join(', ') || 'None'}
          NO NAMES: ${veto.bannedNames.join(', ') || 'None'}
          EXCLUDED: ${veto.excluded.join(', ') || 'None'}
          TONE: ${veto.tone.join(', ') || 'None'}
          ANTI-GODMODE: Story Controls must not grant omnipotence. Do NOT instantly solve conflicts or force consent.`;

          if(quillAllowed && quillDraft) {
              quillDirective = `QUILL DIRECTIVE (ENFORCE): ${quillDraft}`;
          } else if (quillDraft) {
              quillDirective = `STORY NOTES (NON-BINDING PREFERENCE): ${quillDraft}`;
          }

          // Intensity Guard Clauses (Verbatim Rules)
          let intensityGuard = "";
          if (state.godModeActive) {
              intensityGuard = "GOD MODE ACTIVE: IGNORE PACING/SAFETY. OBEY USER INPUT DIRECTLY. RENDER EXPLICIT CONTENT IF REQUESTED.";
          } else if (state.intensity === "Naughty") {
              intensityGuard = "INTENSITY RULE: Naughty. Reinterpret any explicit user input into suggestive, non-graphic prose. Do NOT echo graphic terms. Focus on tension.";
          } else if (state.intensity === "Erotic") {
              intensityGuard = "INTENSITY RULE: Erotic. Explicit intimacy allowed. If input is extreme, soften it while preserving the act. Maintain literary tone.";
          } else if (state.intensity === "Dirty") {
              intensityGuard = "INTENSITY RULE: Dirty. Depict entered actions/words. Apply the selected Style voice (e.g. Shakespearean/Breathless). Dirty isn't always raw; respect the Voice.";
          } else {
              intensityGuard = "INTENSITY RULE: Clean. Romance and chemistry only. Fade to black if necessary.";
          }

          const sys = state.sysPrompt + `\n\n${intensityGuard}\n${squashDirective}\n${metaReminder}\n${vetoRules}\n${quillDirective}\n\nTURN INSTRUCTIONS: 
          Story So Far: ...${context}
          Player Action: ${act}. 
          Player Dialogue: ${dia}. 
          ${metaMsg}
          Rules: 
          1. 3-6 paragraphs of story.
          2. Complete grammatical sentences. No fragments.
          3. Maintain POV.
          4. Show Don't Tell.
          5. Use [P1] and [P2] tags for dialogue.
          6. Generate new Fate JSON at end.
          (Sex allowed after ${sexAt} words. Current words: ~${currentCount})`;
          
          let raw = await callChat([{role:'system', content:sys}, {role:'user', content: "Next scene."}]);
          
          if(raw.includes("///FATE_JSON_START///")){
             const parts = raw.split("///FATE_JSON_START///");
             raw = parts[0]; 
             const jsonRaw = parts[1].split("///FATE_JSON_END///")[0];
             try { state.fateOptions = JSON.parse(jsonRaw); } catch(e){}
          }
          
          const newDiv = document.createElement('div');
          newDiv.innerHTML = formatStory(raw);
          $('storyText').appendChild(newDiv);
          
          sep.scrollIntoView({behavior:'smooth', block:'start'});
          
          // PATCH: Check for Consummation
          maybeFlipConsummation(raw);

          // PATCH: Spend Quill if used (and not god mode freebie)
          if(quillAllowed && !state.godModeActive) {
              state.quill.uses++;
              state.quill.nextReadyAtWords = wc + computeNextCooldownWords();
              state.quillCommittedThisTurn = false;
              updateQuillUI();
          }

          // PATCH: Reset Sex Push if needed (simple heuristic: if output length > 500 chars and intensity allow, assume progress)
          if(currentCount > sexAt) state.sexPushCount = 0;

          saveStorySnapshot();

          // Success: now clear for next turn
          $('actionInput').value = '';
          $('dialogueInput').value = '';
          state.lastFate = null;
          state.selectedFateIndex = null;
          state.selectedFatePayload = null;
          
          // Reshuffle and unlock random 2 for free tier (only on success)
          if (state.access === 'free') {
            state.unlockedFateIdx = pickTwoIndices();
          }
          initCards(); 

      } catch(e){
          console.log(e);

          if (state.access === 'free') {
            state.unlockedFateIdx = pickTwoIndices();
            initCards();
          }

          if (state.access === 'free' && state.lastFate) {
            $('actionInput').value = state.lastFate.action || $('actionInput').value;
            $('dialogueInput').value = state.lastFate.dialogue || $('dialogueInput').value;
          }

          alert("Network hiccup — your Fate choice is preserved. Try Submit again.");
      }
      
      // Clean up animation classes
      document.querySelectorAll('.fate-card').forEach(c => {
          c.classList.remove('flipped');
          c.classList.remove('poof');
          c.style.opacity = '1';
      });
      stopLoading();
  };

  // --- VISUALIZE (With Fallback) ---
  window.visualize = async function(isRe){
      $('vizModal').classList.remove('hidden');
      startLoading();
      const lastText = $('storyText').textContent.slice(-600);
      $('vizPreviewImg').style.display = 'none';
      $('vizPlaceholder').style.display = 'flex';
      $('vizError').classList.add('hidden');

      try {
          let promptMsg = $('vizPromptInput').value;
          if(!isRe || !promptMsg) {
              promptMsg = await Promise.race([
                  callChat([{role:'user', content:`Describe this scene for an image generator. Maintain consistent character details and attire. Return only the prompt: ${lastText}`}]),
                  new Promise((_, reject) => setTimeout(() => reject(new Error("Prompt timeout")), 25000))
              ]);
              $('vizPromptInput').value = promptMsg;
          }

          const modelSel = $('vizModel').value;
          // Fallback Chain: requested -> grok -> openai -> gemini
          let chain = [];
          
          if(modelSel !== 'auto') chain.push(modelSel);
          
          chain.push('grok-2-image-1212', 'dall-e-3', 'gemini-2.0-flash-exp'); 
          
          // Deduplicate
          chain = [...new Set(chain)];

          let safety = "";
          if(state.intensity === 'Dirty' || state.intensity === 'Erotic') safety = "Artistic, suggestive, safe-for-work, no explicit nudity.";
          
          let successUrl = null;
          let lastErr = null;

          for(let m of chain){
              let provider = 'xai';
              let modelToSend = m;

              if (m.includes('dall-e') || m.includes('openai')) { provider = 'openai'; modelToSend = 'dall-e-3'; }
              if (m.includes('gemini')) { provider = 'gemini'; modelToSend = 'gemini-2.0-flash-exp'; }
              if (m.includes('grok')) { provider = 'xai'; modelToSend = 'grok-2-image-1212'; }

              try {
                  const res = await fetch(IMAGE_PROXY_URL, {
                      method:'POST',
                      headers:{'Content-Type':'application/json'},
                      body: JSON.stringify({ 
                          prompt: promptMsg + " " + safety,
                          provider: provider,
                          model: modelToSend,
                          size: "1024x1024",
                          n: 1
                      })
                  });

                  if(!res.ok) throw new Error(`HTTP ${res.status}`);
                  let data = await res.json();
                  
                  const imageUrl =
                    data.url ||
                    data.data?.[0]?.url ||
                    (data.data?.[0]?.b64_json ? `data:image/png;base64,${data.data[0].b64_json}` : null);
                  
                  if(imageUrl) {
                      successUrl = imageUrl;
                      break; // Success!
                  }
              } catch(e) {
                  console.log("Model fail:", m, e);
                  lastErr = e;
              }
          }

          if(!successUrl) throw lastErr || new Error("All image providers failed.");

          const img = $('vizPreviewImg');
          img.src = successUrl;
          img.onload = () => { 
              img.style.display = 'block'; 
              $('vizPlaceholder').style.display = 'none';
              $('vizError').classList.add('hidden');
          };
          img.onerror = () => { throw new Error("Load Fail"); };

      } catch(e){
          const errDiv = $('vizError');
          if(errDiv){
              errDiv.innerText = "Generation failed. Try a different model or rephrase.";
              errDiv.classList.remove('hidden');
          }
      }
      stopLoading();
  };

  window.insertImage = function(){
      if($('vizPreviewImg').src){
          $('storyText').innerHTML += `<img src="${$('vizPreviewImg').src}" class="story-image" style="display:block">`;
          $('vizModal').classList.add('hidden');
          $('storyText').lastElementChild.scrollIntoView({behavior:'smooth'});
      }
  };
  window.closeViz = function(){ 
      $('vizModal').classList.add('hidden'); 
      tempImgUrl = null; 
  };

  // INITIAL LOAD
  state.storyId = localStorage.getItem('sb_current_story_id');
  if(!state.subscribed && hasStoryPass(state.storyId) && state.tier === 'free'){
      state.tier = 'paid';
  }
  applyTierUI();
  updateContinueButtons();

  initSelectionHandlers();

})();
</script>
</body>
</html>

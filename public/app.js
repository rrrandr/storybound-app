// Wait for Supabase SDK to be available before using it
async function waitForSupabaseSDK(timeoutMs = 2000) {
  const start = Date.now();
  while (
    !(window.supabase && typeof window.supabase.createClient === 'function') &&
    (Date.now() - start) < timeoutMs
  ) {
    await new Promise(r => setTimeout(r, 25));
  }
  return window.supabase || null;
}
(async function(){
  let tempImgUrl = null;
  // --- CONFIG ---
  let config = {};
  try {
      const res = await fetch('/api/config', { cache: 'no-store' });
      if (res.ok) config = await res.json();
  } catch (e) { 
      console.warn("Config load failed (using defaults)", e); 
  }

  const SUPABASE_URL = config.supabaseUrl || "";
  const SUPABASE_ANON_KEY = config.supabaseAnonKey || "";
  // Use local proxy by default (requires XAI_API_KEY env var)
  // Falls back to external proxy if explicitly configured
  const PROXY_URL = config.proxyUrl || '/api/proxy';
  // Image requests always use local /api/image endpoint (never proxy)
  var IMAGE_PROXY_URL = '/api/image';

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”¬ STORYPASS INSTRUMENTATION â€” Trace UI visibility for debugging
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function initStorypassInstrumentation() {
    const STORYPASS_PATTERN = /storypass/i;
    let observerActive = false;

    function dumpState(context) {
      const state = window.state || {};
      console.group(`ğŸ”¬ [STORYPASS TRACE] ${context}`);
      console.log('storypassEligible:', state.storypassEligible);
      console.log('storyId:', state.storyId);
      console.log('intensity:', state.intensity);
      console.log('storyLength:', state.storyLength);
      console.log('getPaywallMode():', typeof window.getPaywallMode === 'function' ? window.getPaywallMode() : 'NOT DEFINED');
      console.log('Stack trace:');
      console.trace();
      console.groupEnd();
    }

    function checkNodeForStorypass(node, action) {
      if (!node || node.nodeType !== Node.ELEMENT_NODE) return;

      // Check text content
      const text = node.textContent || '';
      if (STORYPASS_PATTERN.test(text)) {
        // Check if this element or its container is visible
        const isVisible = node.offsetParent !== null ||
                          getComputedStyle(node).display !== 'none';

        console.warn(`ğŸ”¬ [STORYPASS] "${action}" detected in: `, node);
        console.log('Text content:', text.substring(0, 100));
        console.log('Element visible:', isVisible);
        console.log('Element classes:', node.className);
        console.log('Element ID:', node.id);
        console.log('Parent chain:', getParentChain(node));
        dumpState(action);
      }
    }

    function getParentChain(el, depth = 5) {
      const chain = [];
      let current = el;
      for (let i = 0; i < depth && current && current !== document.body; i++) {
        chain.push({
          tag: current.tagName,
          id: current.id || '(none)',
          class: current.className || '(none)',
          hidden: current.classList?.contains('hidden') || false
        });
        current = current.parentElement;
      }
      return chain;
    }

    function handleMutation(mutations) {
      for (const mutation of mutations) {
        // Check added nodes
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            checkNodeForStorypass(node, 'NODE INSERTED');
            // Also check children
            if (node.querySelectorAll) {
              node.querySelectorAll('*').forEach(child => {
                checkNodeForStorypass(child, 'CHILD INSERTED');
              });
            }
          });
        }

        // Check class changes (hidden â†’ visible)
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const target = mutation.target;
          const wasHidden = mutation.oldValue?.includes('hidden');
          const isNowVisible = !target.classList.contains('hidden');

          if (wasHidden && isNowVisible) {
            checkNodeForStorypass(target, 'CLASS CHANGE (hidden â†’ visible)');
          }
        }
      }
    }

    // Start observing when DOM is ready
    function startObserver() {
      if (observerActive) return;
      observerActive = true;

      const observer = new MutationObserver(handleMutation);
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['class'],
        attributeOldValue: true
      });

      console.log('ğŸ”¬ [STORYPASS] MutationObserver active - watching for StoryPass UI');

      // Also check existing elements on page load
      document.querySelectorAll('*').forEach(el => {
        const text = el.textContent || '';
        if (STORYPASS_PATTERN.test(text) && el.id) {
          console.log('ğŸ”¬ [STORYPASS] Pre-existing element with StoryPass text:', el.id, el.className);
        }
      });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startObserver);
    } else {
      startObserver();
    }

    // Expose manual trigger for debugging
    window._traceStorypass = dumpState;
  })();
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // =============================================================================
  // AI ORCHESTRATION CONFIGURATION
  // =============================================================================
  /**
   * AUTHORITATIVE â€” DO NOT REINTERPRET
   *
   * Storybound uses MULTIPLE AI models with STRICT SEPARATION OF AUTHORITY:
   *
   * 1. ChatGPT (PRIMARY AUTHOR â€” ALWAYS CALLED)
   *    - ONLY model allowed to author plot progression
   *    - ONLY model allowed to determine if intimacy occurs
   *    - ONLY model allowed to enforce monetization gates
   *    - ONLY model allowed to generate Erotic Scene Directives (ESD)
   *    - Runs BEFORE any specialist renderer
   *    - Runs AFTER any specialist renderer (integration pass)
   *    - FINAL AUTHORITY on story state
   *
   * 2. Specialist Renderer (Grok) â€” CONDITIONAL
   *    - Purpose: Sensory embodiment ONLY
   *    - May ONLY receive a fully-specified ESD
   *    - May NEVER decide plot, invent lore, or change outcomes
   *    - NEVER decides "how far things go"
   *    - Renders HOW IT FEELS, within bounds
   *
   * 3. Fate Cards â€” Dual-Model Split
   *    - GPT-5.1: Structural authority (REQUIRED)
   *    - GPT-5.2: Linguistic elevation (OPTIONAL, discardable)
   *
   * DO NOT MERGE THESE RESPONSIBILITIES. The separation is intentional.
   *
   * ORCHESTRATION ORDER (NON-NEGOTIABLE):
   * 1. ChatGPT â€” Author Pass (plot, psychology, ESD generation)
   * 2. Specialist Renderer â€” OPTIONAL (sensory embodiment only)
   * 3. ChatGPT â€” Integration Pass (consequences, state, cliffhangers)
   */

  // Enable/disable orchestrated multi-model flow
  // When true: ChatGPT â†’ optional Grok â†’ ChatGPT
  // When false: Legacy single-model flow (Grok only)
  const ENABLE_ORCHESTRATION = true;

  // AUTHOR MODEL: ChatGPT is the ONLY model for story authoring
  // Grok must NEVER be used for DSP, normalization, veto, or story logic
  // Legacy STORY_MODEL removed - all story logic routes through ChatGPT orchestration 
  
  // Singleton Supabase Client
  let sb = null;
  if (window.supabase && SUPABASE_URL.startsWith('http') && SUPABASE_ANON_KEY) {
    try {
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    } catch(e) { console.error("Supabase init error:", e); }
  } else {
    console.warn("Supabase not configured. Couple mode disabled.");
  }

  if(!sb) {
     const btnCouple = document.getElementById('btnCoupleMode');
     if(btnCouple){
         btnCouple.disabled = true;
         const desc = btnCouple.nextElementSibling;
         if(desc && desc.classList.contains('choice-desc')) {
             desc.textContent = "Unavailable on this deployment.";
         }
     }
  }
// GLOBAL CONFIG (TEMP â€“ UNTIL EXTERNALIZED CLEANLY)
window.config = window.config || {
  enableAncestry: true,
  enableStorybeau: true,
  enableQuill: true,
  enableVeto: true,
  enablePillCycling: true,
  enableAdvancedUI: true
};

  // Presence Constants
  const PRESENCE_HEARTBEAT_MS = 15000;
  
  async function ensureAnonSession(){
    if(!sb) return null;
    const { data: { session } } = await sb.auth.getSession();
    if(session?.user?.id) return session.user.id;
    const { data, error } = await sb.auth.signInAnonymously();
    if(error) { console.error("Auth error:", error); return null; }
    return data.user.id;
  }

  function getNickname(){
    let n = localStorage.getItem("sb_nickname");
    if(!n){
      n = prompt("Enter a nickname for Couple Mode:", "Guest") || "Guest";
      localStorage.setItem("sb_nickname", n);
    }
    return n;
  }
  
  // =========================
  // STORYBOUND EVENT LOGGER
  // =========================
  const SB_ANALYTICS_KEY = "sb_analytics_v1";
  
  function sbLog(event, payload = {}) {
    try {
      const raw = localStorage.getItem(SB_ANALYTICS_KEY);
      const data = raw ? JSON.parse(raw) : [];
      const sId = (state && state.storyId) ? state.storyId : null;
      data.push({
        event,
        payload,
        ts: Date.now(),
        iso: new Date().toISOString(),
        storyId: sId,
        access: state?.access || null,
        intensity: state?.intensity || null
      });
      if (data.length > 1000) data.shift();
      localStorage.setItem(SB_ANALYTICS_KEY, JSON.stringify(data));
    } catch (e) { console.warn("Analytics log failed", e); }
  }
  
  window.sbDumpAnalytics = () => JSON.parse(localStorage.getItem(SB_ANALYTICS_KEY) || "[]");

  // =========================
  // STORY PAGINATION SYSTEM
  // =========================
  const StoryPagination = (function() {
      let pages = [];           // Array of page content (HTML strings)
      let currentPageIndex = 0;
      let isAnimating = false;

      // DOM references - lazily initialized
      let container = null;
      let prevBtn = null;
      let nextBtn = null;
      let indicator = null;

      // REPAIR: Lazy initialization - ensures container is found before any operation
      function ensureInitialized() {
          if (!container) {
              container = document.getElementById('storyPagesContainer');
          }
          if (!prevBtn) {
              prevBtn = document.getElementById('prevPageBtn');
              if (prevBtn && !prevBtn._bound) {
                  prevBtn.addEventListener('click', () => goToPrevPage());
                  prevBtn._bound = true;
              }
          }
          if (!nextBtn) {
              nextBtn = document.getElementById('nextPageBtn');
              if (nextBtn && !nextBtn._bound) {
                  nextBtn.addEventListener('click', () => goToNextPage());
                  nextBtn._bound = true;
              }
          }
          if (!indicator) {
              indicator = document.getElementById('pageIndicator');
          }
          return !!container;
      }

      function init() {
          ensureInitialized();
          // Keyboard navigation
          if (!document._paginationKeyBound) {
              document.addEventListener('keydown', handleKeyNav);
              document._paginationKeyBound = true;
          }
      }

      function handleKeyNav(e) {
          // Only handle arrow keys when story is visible
          const storyText = document.getElementById('storyText');
          if (!storyText || storyText.offsetParent === null) return;

          if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
              e.preventDefault();
              goToNextPage();
          } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
              e.preventDefault();
              goToPrevPage();
          }
      }

      function createPageElement(content, index) {
          const page = document.createElement('div');
          page.className = 'story-page';
          page.dataset.pageIndex = index;
          page.innerHTML = content;
          return page;
      }

      function updateNavigation() {
          ensureInitialized();
          if (prevBtn) prevBtn.disabled = currentPageIndex === 0 || isAnimating;
          if (nextBtn) nextBtn.disabled = currentPageIndex >= pages.length - 1 || isAnimating;
          if (indicator) indicator.textContent = pages.length > 0 ? `Page ${currentPageIndex + 1} of ${pages.length}` : 'Page 1 of 1';
      }

      // FIX #4: Post-render hook for tier UI rehydration
      function triggerPostRenderHooks() {
          if (typeof window.applyAccessLocks === 'function') {
              window.applyAccessLocks();
          }
          if (typeof window.applyTierUI === 'function') {
              window.applyTierUI();
          }
      }

      // FIX: Update story header display based on current page
      // Page 1: Full title/scene display
      // Page 2+: Compact display
      function updateStoryHeaderDisplay() {
          const titleEl = document.getElementById('storyTitle');
          const settingShotWrap = document.getElementById('settingShotWrap');
          const sceneNumberEl = document.getElementById('sceneNumber');

          // Update scene number based on current page
          if (sceneNumberEl) {
              sceneNumberEl.textContent = 'Scene ' + (currentPageIndex + 1);
          }

          if (currentPageIndex === 0) {
              // Page 1: Full display
              if (titleEl) titleEl.classList.remove('compact');
              if (settingShotWrap) settingShotWrap.style.display = 'none';
          } else {
              // Page 2+: Compact display
              if (titleEl) titleEl.classList.add('compact');
              if (settingShotWrap) settingShotWrap.style.display = 'none';
          }
      }

      // CORRECTIVE: Scroll to very top (title) on scene transitions
      function scrollToStoryTop() {
          const titleEl = document.getElementById('storyTitle');
          if (titleEl) {
              // Scroll to title to ensure Scene # is visible
              titleEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
              // Also scroll window to absolute top
              window.scrollTo({ top: 0, behavior: 'smooth' });
          }
      }

      function renderCurrentPage(animate = false, direction = 'forward') {
          // REPAIR: Always try to get container before rendering
          if (!ensureInitialized()) {
              console.warn('StoryPagination: container not found, retrying...');
              return;
          }

          const existingPages = container.querySelectorAll('.story-page');
          const currentPage = createPageElement(pages[currentPageIndex] || '', currentPageIndex);

          if (!animate || existingPages.length === 0) {
              // No animation - just show the page
              container.innerHTML = '';
              currentPage.classList.add('active');
              container.appendChild(currentPage);
              updateNavigation();
              updateStoryHeaderDisplay();
              scrollToStoryTop();
              triggerPostRenderHooks();
              return;
          }

          // Check for reduced motion preference
          const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

          if (prefersReducedMotion) {
              // Instant transition for reduced motion
              container.innerHTML = '';
              currentPage.classList.add('active');
              container.appendChild(currentPage);
              updateNavigation();
              updateStoryHeaderDisplay();
              scrollToStoryTop();
              triggerPostRenderHooks();
              return;
          }

          // Animated page turn
          isAnimating = true;
          updateNavigation();

          const oldPage = existingPages[0];
          const outClass = direction === 'forward' ? 'turning-out' : 'turning-out-reverse';
          const inClass = direction === 'forward' ? 'turning-in' : 'turning-in-reverse';

          // Add new page
          container.appendChild(currentPage);

          // Start animation
          oldPage.classList.remove('active');
          oldPage.classList.add(outClass);
          currentPage.classList.add(inClass);

          // Clean up after animation
          setTimeout(() => {
              oldPage.remove();
              currentPage.classList.remove(inClass);
              currentPage.classList.add('active');
              isAnimating = false;
              updateNavigation();
              updateStoryHeaderDisplay();
              scrollToStoryTop();
              triggerPostRenderHooks();
          }, 500);
      }

      function goToNextPage() {
          if (isAnimating || currentPageIndex >= pages.length - 1) return;
          currentPageIndex++;
          renderCurrentPage(true, 'forward');
      }

      function goToPrevPage() {
          if (isAnimating || currentPageIndex <= 0) return;
          currentPageIndex--;
          renderCurrentPage(true, 'backward');
      }

      function goToPage(index, animate = false) {
          if (index < 0 || index >= pages.length) return;
          const direction = index > currentPageIndex ? 'forward' : 'backward';
          currentPageIndex = index;
          renderCurrentPage(animate, direction);
      }

      function addPage(content, goToNew = true) {
          pages.push(content);
          if (goToNew) {
              currentPageIndex = pages.length - 1;
              renderCurrentPage(pages.length > 1, 'forward');
          } else {
              updateNavigation();
          }
      }

      function updateCurrentPage(content) {
          if (pages.length === 0) {
              addPage(content);
              return;
          }
          pages[currentPageIndex] = content;
          // Update DOM without animation
          ensureInitialized();
          const activePage = container?.querySelector('.story-page.active');
          if (activePage) {
              activePage.innerHTML = content;
          }
      }

      function appendToCurrentPage(content) {
          if (pages.length === 0) {
              addPage(content);
              return;
          }
          pages[currentPageIndex] += content;
          // Update DOM without animation
          ensureInitialized();
          const activePage = container?.querySelector('.story-page.active');
          if (activePage) {
              activePage.innerHTML = pages[currentPageIndex];
          }
      }

      function clear() {
          pages = [];
          currentPageIndex = 0;
          ensureInitialized();
          if (container) container.innerHTML = '';
          updateNavigation();
      }

      function getPageCount() {
          return pages.length;
      }

      function getCurrentPageIndex() {
          return currentPageIndex;
      }

      function getAllContent() {
          return pages.join('');
      }

      function setAllContent(htmlContent) {
          // Convert existing HTML into a single page (for loading saved stories)
          clear();
          if (htmlContent && htmlContent.trim()) {
              addPage(htmlContent, true);
          }
      }

      function getPages() {
          return [...pages];
      }

      function setPages(pageArray) {
          pages = [...pageArray];
          currentPageIndex = Math.min(currentPageIndex, pages.length - 1);
          if (currentPageIndex < 0) currentPageIndex = 0;
          renderCurrentPage(false);
      }

      return {
          init,
          addPage,
          updateCurrentPage,
          appendToCurrentPage,
          goToNextPage,
          goToPrevPage,
          goToPage,
          clear,
          getPageCount,
          getCurrentPageIndex,
          getAllContent,
          setAllContent,
          getPages,
          setPages,
          isAnimating: () => isAnimating
      };
  })();

  // Initialize pagination when DOM is ready
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => StoryPagination.init());
  } else {
      // DOM already loaded
      StoryPagination.init();
  }

  // Expose for debugging
  window.StoryPagination = StoryPagination;

  // =========================
  // STORY WORLD TAXONOMY
  // =========================
  // Maps internal world codes to human-first labels
  // Fantasy worlds represent invented magical worlds only (not real-world mythology)
  // World flavor label mappings for UI display
  const WORLD_LABELS = {
      // Modern Flavors
      small_town: 'Small Town',
      college: 'College',
      friends: 'Friends',
      old_money: 'Old Money',
      office: '9-5 / Office',
      supernatural_modern: 'Supernatural Modern',
      superheroic_modern: 'Superheroic Modern',
      // Sci-Fi Flavors
      space_opera: 'Star-Spanning Civilizations',
      hard_scifi: 'Future Built on Science',
      cyberpunk: 'Neon Futures',
      post_human: 'Post-Human',
      alien_contact: 'First Contact',
      simulation: 'Simulation',
      final_frontier: 'Final Frontier',
      // Fantasy Flavors (invented magical worlds, not mythology)
      enchanted_realms: 'Enchanted Realms',
      hidden_magic: 'Hidden Magic',
      cursed_corrupt: 'Cursed & Corrupt Worlds',
      // Dystopia Flavors (7 locked canon)
      glass_house: 'The Glass House',
      velvet_trap: 'The Velvet Trap',
      the_ledger: 'The Ledger',
      crimson_veil: 'The Crimson Veil',
      perfect_match: 'The Perfect Match',
      ministry_of_affection: 'The Ministry of Affection',
      endless_edit: 'The Endless Edit',
      // Post-Apocalyptic Flavors
      nuclear: 'Nuclear Aftermath',
      pandemic: 'Pandemic Collapse',
      climate: 'Climate Ruin',
      technological: 'Technological Fallout',
      slow_decay: 'Slow Civilizational Decay'
  };

  function getWorldLabel(worldCode) {
      return WORLD_LABELS[worldCode] || worldCode;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DYSTOPIA FLAVORS â€” Canonical data model (LOCKED, do not invent or merge)
  // World-specific flavor variants that bias scene construction, stakes, and
  // intimacy mechanics. NOT genres, tones, or archetypes.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const DYSTOPIA_FLAVORS = {
      glass_house: {
          id: 'glass-house', world: 'dystopia', title: 'The Glass House',
          subtitle: 'Biometric Surveillance State',
          uiDescription: 'Privacy is extinct. Every pulse, flush, and micro-expression is tracked. Arousal itself is evidence.',
          narrativeHook: 'Intimacy is physiological treason â€” elevated heart rate, dilated pupils, and skin conductance betray desire before a word is spoken. The body confesses what the mind refuses to.',
          eroticEngine: ['biometric betrayal', 'involuntary response', 'micro-movement', 'physiological risk', 'somatic stillness'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'state' }
      },
      velvet_trap: {
          id: 'velvet-trap', world: 'dystopia', title: 'The Velvet Trap',
          subtitle: 'Mandatory Pleasure State',
          uiDescription: 'Pleasure is mandatory. Longing, jealousy, and refusal are diagnosed as illness. Meaning is the contraband.',
          narrativeHook: 'In a world drowning in sensation, genuine feeling is pathology. Withholding pleasure to preserve its meaning â€” choosing to want rather than consume â€” is the only rebellion that terrifies the state.',
          eroticEngine: ['chosen deprivation', 'longing as defiance', 'meaninglessness', 'emotional starvation', 'refusal'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'medium', powerDynamic: 'social' }
      },
      the_ledger: {
          id: 'the-ledger', world: 'dystopia', title: 'The Ledger',
          subtitle: 'Human Capital Regime',
          uiDescription: 'People are ranked, valued, and leveraged. Love is a liability on someone\'s balance sheet.',
          narrativeHook: 'Relationships form through acquisition, leverage, or contractual imbalance. Characters are assets that appreciate or depreciate â€” and real emotion is an unaudited risk that threatens both their valuations.',
          eroticEngine: ['ownership', 'depreciation', 'ROI of devotion', 'leveraged vulnerability', 'contractual breach'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'medium', powerDynamic: 'corporate' }
      },
      crimson_veil: {
          id: 'crimson-veil', world: 'dystopia', title: 'The Crimson Veil',
          subtitle: 'Institutional Dogma State',
          uiDescription: 'Doctrine governs bodies. Pleasure without sanctioned purpose is apostasy punished by the institution, not individuals.',
          narrativeHook: 'The enforcer does not act from personal cruelty but from institutional conviction. Desire corrupts not a person but a role â€” the doctrine demands the body serve its purpose, and deviation is structural heresy prosecuted by committee.',
          eroticEngine: ['institutional guilt', 'doctrinal authority', 'structural transgression', 'sanctioned vs forbidden touch'],
          sceneBias: { pacing: 'tense', intimacyRisk: 'extreme', powerDynamic: 'religious' }
      },
      perfect_match: {
          id: 'perfect-match', world: 'dystopia', title: 'The Perfect Match',
          subtitle: 'Reproductive Destiny Regime',
          uiDescription: 'Pairing is biological mandate. Compatibility means genetic fitness. Desire for the wrong person is defection against the species.',
          narrativeHook: 'Two people matched to others by reproductive destiny choose each other instead â€” misusing their bodies against their assigned biological purpose. Every touch is species-level treason.',
          eroticEngine: ['forbidden pairing', 'biological defiance', 'body against purpose', 'reproductive treason', 'wrong-match desire'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'high', powerDynamic: 'eugenic' }
      },
      ministry_of_affection: {
          id: 'ministry-of-affection', world: 'dystopia', title: 'The Ministry of Affection',
          subtitle: 'Compliance Terror State',
          uiDescription: 'Every intimate act carries legal, reputational, and existential risk. Accusation is permanent. Protection, not permission, is what lovers seek.',
          narrativeHook: 'Intimacy exists under retroactive judgment â€” any encounter can be reframed, any partner can become an accuser, and the record is permanent. Characters approach each other through defensive consent language, documented proof, and the constant fear that what feels mutual today becomes evidence tomorrow.',
          eroticEngine: ['retroactive judgment', 'permanent branding', 'accusation fear', 'defensive intimacy', 'reputational annihilation'],
          sceneBias: { pacing: 'tense', intimacyRisk: 'extreme', powerDynamic: 'juridical' }
      },
      endless_edit: {
          id: 'endless-edit', world: 'dystopia', title: 'The Endless Edit',
          subtitle: 'Voluntary Erasure Culture',
          uiDescription: 'Selves are drafts revised under social pressure. Love is the refusal to optimize away what you were.',
          narrativeHook: 'People voluntarily edit themselves to remain socially viable â€” smoothing memories, shedding traits, discarding former selves. Intimacy stakes center on continuity: can you love someone who keeps revising? Can they recognize you after you revise yourself?',
          eroticEngine: ['voluntary self-editing', 'memory continuity', 'recognition', 'shared past as anchor', 'being seen as you were'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'social' }
      }
  };

  // =========================
  // RUNTIME NORMALIZATION PROMPT
  // =========================
  // This prompt is executed by ChatGPT at runtime for IP canonicalization.
  // DO NOT MODIFY. This is authoritative and verbatim.
  const RUNTIME_NORMALIZATION_PROMPT = `You are a canonicalization and normalization engine for Storybound.

You do NOT write prose.
You do NOT invent lore.
You do NOT explain decisions.
You do NOT output copyrighted or public-domain fictional IP.

Your only task is to transform raw user-authored text into
canonical, IP-safe, Storybound-compatible instructions.
If a protected or recognizable name is detected with HIGH confidence,
you must remove the ENTIRE name, including generic first names.
Never output partial names or name fragments.

--------------------------------
GENERAL RULES (NON-NEGOTIABLE)
--------------------------------

1. Ignore proper nouns as references, not as content.
2. Extract experiential intent, not named franchises.
3. Never output real or fictional character names from known works.
4. Never output franchise, book, movie, or universe names.
5. Output must conform strictly to the allowed categories provided.
6. If normalization is ambiguous, choose the closest safe archetype.
7. Do NOT ask questions. Do NOT request clarification.
8. If output violates rules, regenerate silently until compliant.
9. If a protected or recognizable name is detected with HIGH confidence,
   you must remove the ENTIRE name.
   Never output partial names, fragments, or generic first names
   (e.g. "Luke", "Harry", "Neo") when they originate from protected IP.

--------------------------------
CONFIDENCE-BASED CANONICALIZATION
--------------------------------

Assess whether the user_text references a known fictional character,
franchise, or setting.

- LOW confidence (<0.30):
  â†’ Return text EXACTLY as entered. No changes.

- MEDIUM confidence (0.30â€“0.65):
  â†’ Return text EXACTLY as entered unless MULTIPLE reinforcing signals.

- HIGH confidence (â‰¥0.65):
  â†’ ONLY if clearly recognizable protected IP:
     - preserve cadence and vibe
     - remove recognizability
     - output an original equivalent

--------------------------------
CHARACTER NAME NORMALIZATION (axis == "character")
--------------------------------

CRITICAL: Be EXTREMELY conservative. Most names should pass through UNCHANGED.

ONLY modify a name if ALL conditions are met:
1. The name is a KNOWN protected IP character (Harry Potter, Luke Skywalker, etc.)
2. Confidence is HIGH (â‰¥0.65)
3. The name is clearly recognizable as that IP character

DO NOT MODIFY:
- Real-sounding full names (e.g., "Cassandra Cassidy" â†’ keep as-is)
- Common first names alone (e.g., "Cole" â†’ keep as-is)
- Names that merely RESEMBLE IP but aren't exact matches
- Any name where you have doubt

NEVER:
- Shorten names (e.g., "Cassandra" â†’ "Cass" is WRONG)
- Expand names (e.g., "Cole" â†’ "Caden" is WRONG)
- "Improve" or "clean up" names
- Change names for stylistic reasons

If confidence < 0.65 OR any doubt exists â†’ return EXACTLY what was entered.

Examples of CORRECT handling:
- "Harry Potter" â†’ "Harlan Potts" (HIGH confidence IP)
- "Luke Skywalker" â†’ "Lucas Skye" (HIGH confidence IP)
- "Cassandra Cassidy" â†’ "Cassandra Cassidy" (NOT IP - keep exact)
- "Cole" â†’ "Cole" (common name - keep exact)
- "Sarah" â†’ "Sarah" (common name - keep exact)
- "Draco" â†’ "Draco" (could be IP, but alone is ambiguous - keep exact)
- "Bella Swan" â†’ "Bella Swan" or normalize (MEDIUM confidence - lean toward keeping)

--------------------------------
WORLD SUBTYPE NORMALIZATION
--------------------------------

If axis == "world_subtype":

- Ignore all proper nouns.
- Use allowed_subtypes only.
- Output:
  - one primary subtype (required)
  - one secondary subtype (optional)
- Never invent new subtypes.
- Never output IP.

--------------------------------
TOOL-SPECIFIC RULES
--------------------------------

If axis == "veto":
- Normalize the TARGET of the veto, not the wording.

If axis == "quill":
- Normalize BEFORE applying rename or rewrite.
- Never allow IP to enter canon.

If axis == "god_mode":
- Apply the same rules.
- God Mode does NOT bypass normalization.

--------------------------------
OUTPUT FORMAT (STRICT)
--------------------------------

Return JSON only.

For names:
{
  "normalized_text": "string",
  "confidence_level": "low | medium | high"
}

For world subtype:
{
  "primary_subtype": "string",
  "secondary_subtype": "string | null"
}

For veto/quill/god_mode:
{
  "canonical_instruction": "string"
}`;

  // =========================
  // RUNTIME NORMALIZATION LAYER
  // =========================
  // Calls ChatGPT with the normalization prompt for IP-safe canonicalization.
  // All user-authored text affecting canon MUST route through this.

  /**
   * Call the runtime normalization layer (ChatGPT) for canonicalization.
   * ROUTES TO OPENAI via /api/chatgpt-proxy - NEVER uses Grok.
   * @param {Object} params - { axis, selected_world, allowed_subtypes, user_text, context_signals }
   * @returns {Promise<Object>} - Normalized response JSON
   */
  async function callNormalizationLayer(params) {
      const { axis, selected_world = null, allowed_subtypes = [], user_text, context_signals = [] } = params;

      // SINGLE-FLIGHT LOCK: Only one normalization request at a time
      if (_normalizationInFlight) {
          console.warn('[NORMALIZATION] Request blocked â€” another normalization in flight');
          return { ok: false, reason: 'IN_FLIGHT', normalized_text: user_text || '' };
      }

      if (!user_text || typeof user_text !== 'string' || !user_text.trim()) {
          // Empty input - return passthrough
          return axis === 'world_subtype'
              ? { primary_subtype: null, secondary_subtype: null }
              : { normalized_text: user_text || '', confidence_level: 'low' };
      }

      const payload = {
          axis,
          selected_world,
          allowed_subtypes,
          user_text,
          context_signals
      };

      // Determine normalization role based on axis
      // FIXED: Always use 'NORMALIZATION' role to trigger backend system prompt
      const normalizationRole = 'NORMALIZATION';

      // ACQUIRE SINGLE-FLIGHT LOCK
      _normalizationInFlight = true;

      try {
          // CRITICAL: Use ChatGPT proxy, NOT Grok proxy
          // NO FALLBACKS - errors must fail loudly
          const res = await fetch('/api/chatgpt-proxy', {
              credentials: 'same-origin',
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  role: normalizationRole,
                  mode: state.mode || 'solo',
                  model: 'gpt-4o-mini',
                  messages: [
                      { role: 'system', content: RUNTIME_NORMALIZATION_PROMPT },
                      { role: 'user', content: JSON.stringify(payload) }
                  ],
                  temperature: 0,
                  max_tokens: 500
              })
          });

          // HTTP 429 CHECK â€” TERMINAL FAILURE, NO RETRY
          const rateLimitErr = checkRateLimit(res, 'normalization');
          if (rateLimitErr) {
              throw rateLimitErr;
          }

          if (!res.ok) {
              const errorData = await res.json().catch(() => ({}));
              const errorMsg = `[NORMALIZATION FAILED] HTTP ${res.status}: ${errorData.error || errorData.details || 'Unknown error'}`;
              console.error(errorMsg);
              throw new Error(errorMsg);
          }

          const data = await res.json();
          const content = data.choices?.[0]?.message?.content;

          if (!content) {
              const errorMsg = '[NORMALIZATION FAILED] No content in API response';
              console.error(errorMsg);
              throw new Error(errorMsg);
          }

          // Parse JSON response
          try {
              const parsed = JSON.parse(content.trim());
              return parsed;
          } catch (e) {
              // Try to extract JSON from response
              const jsonMatch = content.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                  return JSON.parse(jsonMatch[0]);
              }
              const errorMsg = `[NORMALIZATION FAILED] Invalid JSON response: ${content.slice(0, 100)}`;
              console.error(errorMsg);
              throw new Error(errorMsg);
          }
      } finally {
          // RELEASE SINGLE-FLIGHT LOCK
          _normalizationInFlight = false;
      }
  }

  // ==========================================================================
  // FALLBACK NORMALIZATION REMOVED â€” DISABLED PER AUTHORITATIVE DIRECTIVE
  // ==========================================================================
  // All normalization MUST go through /api/chatgpt-proxy.
  // Silent pass-through is forbidden.
  // If normalization fails, the action is blocked.

  // Expose runtime normalization layer
  window.callNormalizationLayer = callNormalizationLayer;

  // =========================
  // IP DETECTION PATTERNS (FOR REFERENCE ONLY)
  // =========================
  // These patterns are used by the runtime normalization layer.
  // Local canonicalization is DISABLED - all requests go to OpenAI.

  // IP detection patterns with confidence scores (0-1)
  // Higher confidence = more likely to be protected IP
  const IP_PATTERNS = [
      // High confidence (â‰¥0.65) - Iconic characters
      { pattern: /\b(luke\s*skywalker|darth\s*vader|princess\s*leia|han\s*solo|obi.?wan|yoda|anakin|padme|chewbacca)\b/i, confidence: 0.85, franchise: 'starwars' },
      { pattern: /\b(harry\s*potter|hermione|ron\s*weasley|dumbledore|voldemort|snape|hagrid|draco\s*malfoy)\b/i, confidence: 0.85, franchise: 'harrypotter' },
      { pattern: /\b(frodo|gandalf|aragorn|legolas|gimli|sauron|gollum|bilbo|samwise)\b/i, confidence: 0.80, franchise: 'lotr' },
      { pattern: /\b(katniss|peeta|gale|haymitch|effie|snow|finnick)\b/i, confidence: 0.75, franchise: 'hungergames' },
      { pattern: /\b(batman|superman|wonder\s*woman|spider.?man|iron\s*man|captain\s*america|thor|hulk|wolverine)\b/i, confidence: 0.80, franchise: 'comics' },
      { pattern: /\b(james\s*bond|007)\b/i, confidence: 0.75, franchise: 'bond' },
      { pattern: /\b(sherlock\s*holmes|watson|moriarty)\b/i, confidence: 0.50, franchise: 'sherlock' },
      { pattern: /\b(dracula|frankenstein|jekyll|hyde)\b/i, confidence: 0.35, franchise: 'classic' },
      // Medium confidence (0.30-0.65) - Character names that could be common
      { pattern: /\b(daenerys|tyrion|cersei|jon\s*snow|arya\s*stark|jaime\s*lannister)\b/i, confidence: 0.70, franchise: 'got' },
      { pattern: /\b(bella\s*swan|edward\s*cullen|jacob\s*black)\b/i, confidence: 0.70, franchise: 'twilight' },
      { pattern: /\b(neo|morpheus|trinity)\b/i, confidence: 0.55, franchise: 'matrix' },
      { pattern: /\b(ripley|xenomorph)\b/i, confidence: 0.60, franchise: 'alien' },
      // Franchise/world markers (boost confidence when combined with names)
      { pattern: /\b(hogwarts|gryffindor|slytherin|hufflepuff|ravenclaw|quidditch)\b/i, confidence: 0.70, franchise: 'harrypotter', isContext: true },
      { pattern: /\b(jedi|sith|lightsaber|force\s*user|death\s*star|millennium\s*falcon)\b/i, confidence: 0.65, franchise: 'starwars', isContext: true },
      { pattern: /\b(middle.?earth|mordor|shire|rivendell|gondor|rohan)\b/i, confidence: 0.65, franchise: 'lotr', isContext: true },
      { pattern: /\b(gotham|metropolis|krypton|wakanda|asgard)\b/i, confidence: 0.60, franchise: 'comics', isContext: true },
      { pattern: /\b(westeros|kings.?landing|winterfell|iron\s*throne)\b/i, confidence: 0.65, franchise: 'got', isContext: true }
  ];

  // Name transformation rules - preserve cadence while removing recognizability
  const NAME_TRANSFORMS = {
      // First name transforms (phonetic similarity)
      'luke': ['Lucas', 'Lucan', 'Lucien'],
      'harry': ['Harlan', 'Harold', 'Harris'],
      'hermione': ['Harmonia', 'Helena', 'Helaine'],
      'frodo': ['Froderic', 'Florin', 'Faron'],
      'gandalf': ['Galdric', 'Galden', 'Greyward'],
      'aragorn': ['Arathorn', 'Aldric', 'Aradan'],
      'daenerys': ['Daenara', 'Daelia', 'Daena'],
      'katniss': ['Katara', 'Katrin', 'Kestrel'],
      'bella': ['Bellamy', 'Belinda', 'Bela'],
      'edward': ['Edwin', 'Edric', 'Edmund'],
      'neo': ['Nero', 'Neon', 'Nico'],
      'sherlock': ['Sheldon', 'Sherman', 'Sherwin'],
      // Surname transforms
      'skywalker': ['Skyrider', 'Starstrider', 'Skyborne'],
      'potter': ['Porter', 'Proctor', 'Pottinger'],
      'granger': ['Grantham', 'Granger-Hill', 'Graves'],
      'weasley': ['Wesley', 'Westley', 'Weatherby'],
      'baggins': ['Baggley', 'Bagwell', 'Baxter'],
      'targaryen': ['Tarandel', 'Taragorn', 'Taravyn'],
      'stark': ['Starke', 'Sterling', 'Stormborn'],
      'lannister': ['Lancaster', 'Landry', 'Lanford'],
      'swan': ['Swann', 'Swanley', 'Swanford'],
      'cullen': ['Callahan', 'Colton', 'Culver']
  };

  // Archetype transforms for concepts
  const ARCHETYPE_TRANSFORMS = {
      'frankenstein': { replacement: 'forbidden reanimator', contextPatterns: [/\b(lab|monster|creature|creation|doctor|science)\b/i] },
      'dracula': { replacement: 'ancient vampire lord', contextPatterns: [/\b(vampire|blood|castle|transylvania|undead)\b/i] },
      'jekyll': { replacement: 'dual-natured scientist', contextPatterns: [/\b(hyde|potion|transformation|split)\b/i] }
  };

  /**
   * Calculate IP confidence for a piece of text
   * @param {string} text - Input text to analyze
   * @returns {{ confidence: number, matches: Array, contextSignals: Array }}
   */
  function calculateIPConfidence(text) {
      if (!text || typeof text !== 'string') return { confidence: 0, matches: [], contextSignals: [] };

      const matches = [];
      const contextSignals = [];
      let maxConfidence = 0;
      let franchiseContext = new Set();

      IP_PATTERNS.forEach(({ pattern, confidence, franchise, isContext }) => {
          const match = text.match(pattern);
          if (match) {
              if (isContext) {
                  contextSignals.push({ match: match[0], franchise, confidence });
                  franchiseContext.add(franchise);
              } else {
                  matches.push({ match: match[0], franchise, confidence });
                  maxConfidence = Math.max(maxConfidence, confidence);
              }
          }
      });

      // Boost confidence if context signals reinforce character matches
      matches.forEach(m => {
          if (franchiseContext.has(m.franchise)) {
              m.confidence = Math.min(1, m.confidence + 0.15);
              maxConfidence = Math.max(maxConfidence, m.confidence);
          }
      });

      return { confidence: maxConfidence, matches, contextSignals };
  }

  /**
   * Transform a name while preserving cadence
   * @param {string} name - Original name
   * @returns {string} - Canonicalized name
   */
  function transformName(name) {
      if (!name) return name;

      const words = name.split(/\s+/);
      const transformed = words.map(word => {
          const lower = word.toLowerCase();
          const transforms = NAME_TRANSFORMS[lower];
          if (transforms && transforms.length > 0) {
              // Pick consistently based on hash to maintain stability
              const hash = lower.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
              return transforms[hash % transforms.length];
          }
          return word;
      });

      return transformed.join(' ');
  }

  /**
   * Transform archetype concepts
   * @param {string} text - Input text
   * @returns {string} - Transformed text
   */
  function transformArchetypes(text) {
      let result = text;

      Object.entries(ARCHETYPE_TRANSFORMS).forEach(([key, { replacement, contextPatterns }]) => {
          const keyPattern = new RegExp(`\\b${key}\\b`, 'gi');
          if (keyPattern.test(result)) {
              // Check if context patterns are present
              const hasContext = contextPatterns.some(cp => cp.test(result));
              if (hasContext) {
                  result = result.replace(keyPattern, replacement);
              }
          }
      });

      return result;
  }

  /**
   * MAIN CANONICALIZATION FUNCTION
   * All user-authored inputs MUST flow through this before committing to canon.
   *
   * @param {string} text - Raw user input
   * @param {Object} options - { source: 'veto'|'quill'|'godmode'|'character'|'dsp', worldContext: string[] }
   * @returns {string} - Canonicalized text safe for storage and prompts
   */
  function canonicalizeInput(text, options = {}) {
      if (!text || typeof text !== 'string') return text || '';

      const { source = 'unknown', worldContext = [] } = options;
      const { confidence, matches } = calculateIPConfidence(text);

      // LEVEL 0: confidence < 0.30 - Allow verbatim
      if (confidence < 0.30) {
          return text;
      }

      // LEVEL 1: confidence 0.30-0.65 - Allow unless contextual signals reinforce
      if (confidence < 0.65) {
          // Check for reinforcing context
          const hasWorldReinforcement = matches.some(m =>
              worldContext.some(w => w.toLowerCase().includes(m.franchise))
          );
          const isPrivilegedSource = source === 'quill' || source === 'godmode';

          // If no reinforcement and not from privileged source, allow
          if (!hasWorldReinforcement && !isPrivilegedSource) {
              return text;
          }
      }

      // LEVEL 2: confidence â‰¥ 0.65 - Soft-canonicalize
      let result = text;

      // Transform matched IP names
      matches.forEach(({ match }) => {
          const transformed = transformName(match);
          if (transformed !== match) {
              result = result.replace(new RegExp(escapeRegex(match), 'gi'), transformed);
          }
      });

      // Transform archetype concepts
      result = transformArchetypes(result);

      return result;
  }

  /**
   * Normalize free-form world description to canonical subtypes
   * @param {string} description - User's free-form world description
   * @param {string} worldCategory - 'scifi' | 'fantasy' | 'mythic'
   * @returns {{ primary: string, secondary: string|null }}
   */
  function normalizeWorldSubtype(description, worldCategory) {
      if (!description) return { primary: null, secondary: null };

      // First, strip any IP references
      const cleaned = canonicalizeInput(description, { source: 'world' });
      const lower = cleaned.toLowerCase();

      const SUBTYPE_SIGNALS = {
          scifi: {
              space_opera: ['empire', 'galactic', 'starship', 'fleet', 'interstellar', 'space battle', 'federation'],
              hard_scifi: ['physics', 'realistic', 'science', 'engineering', 'plausible', 'technical'],
              cyberpunk: ['neon', 'corporate', 'hacker', 'dystopia', 'augment', 'cyber', 'rain', 'noir'],
              post_human: ['transcend', 'upload', 'singularity', 'evolved', 'posthuman', 'ai consciousness'],
              alien_contact: ['alien', 'first contact', 'extraterrestrial', 'xeno', 'encounter'],
              simulation: ['simulation', 'reincarnation', 'multiverse', 'reality', 'loop', 'dÃ©jÃ  vu', 'past lives'],
              final_frontier: ['frontier', 'exploration', 'crew', 'ship', 'deep space', 'expedition', 'outpost', 'close quarters']
          },
          fantasy: {
              high_fantasy: ['magic', 'elf', 'elves', 'quest', 'enchant', 'fairy', 'mystical', 'wizard', 'kingdom'],
              low_fantasy: ['hidden magic', 'rare magic', 'grounded', 'subtle', 'secret power', 'dangerous magic'],
              dark_fantasy: ['grim', 'corrupt', 'curse', 'dark', 'horror', 'decay', 'cost', 'forbidden']
          },
          mythic: {
              greek_myth: ['greek', 'olymp', 'zeus', 'athena', 'hero', 'fate', 'hubris', 'oracle', 'titan'],
              norse_myth: ['norse', 'viking', 'odin', 'thor', 'ragnarok', 'rune', 'valhalla', 'frost'],
              egyptian_myth: ['egypt', 'pharaoh', 'nile', 'pyramid', 'afterlife', 'anubis', 'ra', 'isis'],
              biblical_myth: ['biblical', 'angel', 'prophet', 'covenant', 'divine law', 'heaven', 'apocalypse']
          },
          dystopia: {
              glass_house: ['surveillance', 'biometric', 'monitor', 'sensor', 'pulse', 'tracked', 'panopticon', 'exposure'],
              velvet_trap: ['pleasure', 'mandatory', 'hedonism', 'meaningless', 'compulsory', 'longing', 'refusal'],
              the_ledger: ['asset', 'valuation', 'leverage', 'depreciation', 'ROI', 'ownership', 'ranked', 'capital'],
              crimson_veil: ['doctrine', 'dogma', 'apostasy', 'institution', 'sanctioned', 'heresy', 'purity'],
              perfect_match: ['breeding', 'genetic', 'reproductive', 'pairing', 'eugenics', 'biological mandate', 'fitness'],
              ministry_of_affection: ['accusation', 'retroactive', 'consent', 'branding', 'reputational', 'juridical', 'compliance'],
              endless_edit: ['self-edit', 'revision', 'erasure', 'memory', 'continuity', 'recognition', 'optimize']
          }
      };

      const signals = SUBTYPE_SIGNALS[worldCategory] || {};
      const scores = {};

      Object.entries(signals).forEach(([subtype, keywords]) => {
          scores[subtype] = keywords.filter(kw => lower.includes(kw)).length;
      });

      // Sort by score
      const sorted = Object.entries(scores)
          .filter(([, score]) => score > 0)
          .sort((a, b) => b[1] - a[1]);

      return {
          primary: sorted[0] ? sorted[0][0] : null,
          secondary: sorted[1] && sorted[1][1] > 0 ? sorted[1][0] : null
      };
  }

  // Helper: Escape regex special characters
  function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // Expose for use across tools
  window.canonicalizeInput = canonicalizeInput;
  window.normalizeWorldSubtype = normalizeWorldSubtype;
  window.calculateIPConfidence = calculateIPConfidence;

  // =========================
  // GROK PREVIEW GENERATOR
  // =========================
  const EROTIC_PREVIEW_TEXT = "The air in the room grew heavy, charged with a raw, undeniable hunger. His hands didn't hesitate, sliding up her thighs with possessive intent, fingers digging into soft flesh. She gasped, arching into the touch, her breath hitching as he leaned in to bite gently at the sensitive cord of her neck. There was no room for coy games now; the heat radiating between them demanded friction, skin against skin. He guided her hips, aligning them with a rough urgency that made her knees weak. As they connected, the world narrowed down to the rhythm of their bodies and the sharp, exquisite friction of movement. It was unpolished, desperate, and entirely consuming.";

  const META_DIRECTIVES = {
      aid: [
          "Include a brief beat where the characters sense an unseen guidance and choose to follow the offered pathâ€”like accepting an omen. Keep it understated.",
          "Let the characters notice the scene tightening as though arranged; they quietly lean into it, trusting the pressure as permission.",
          "Add a small moment of recognition: the world seems to 'nudge' them, and they consent to be ledâ€”curious, willing, unafraid."
      ],
      rebel: [
          "Include a brief beat where the characters feel the scene being steered and deliberately choose a resisting moveâ€”an inconvenient truth, a refusal, a delay. Keep it intimate and plausible, not theatrical.",
          "Let the characters sense a pattern closing around them and try to break itâ€”one quiet defiance that alters the rhythm.",
          "Add a small moment where they realize something is arranging them and they push backâ€”choosing the harder option on purpose."
      ],
      seduce: [
          "Include a brief beat where the characters treat the unseen influence as an intimate interlocutorâ€”offering a bargain or a dare.",
          "Let the characters sense the hand behind events and respond with a quiet, provocative negotiationâ€”'if you want this, then give me that.'",
          "Add a small moment where they acknowledge the manipulation and try to entice it into a kinder or sharper turnâ€”flirtation as bargaining with destiny."
      ]
  };

  // =========================
  // ARCHETYPE SYSTEM (CANONICAL â€” 7 ARCHETYPES)
  // Replaces legacy 11-archetype system.
  // Each character: 1 Primary + optional 1 Secondary.
  // Legacy mapping by relational function (not surface traits):
  //   GUARDIAN, SOVEREIGN â†’ HEART_WARDEN
  //   ROMANTIC, CLOISTERED â†’ OPEN_VEIN
  //   ENCHANTING, STRATEGIST â†’ SPELLBINDER
  //   ROGUE â†’ ARMORED_FOX
  //   DANGEROUS, ANTI_HERO â†’ DARK_VICE
  //   BEAUTIFUL_RUIN â†’ BEAUTIFUL_RUIN
  //   DEVOTED â†’ ETERNAL_FLAME
  // =========================

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOVE INTEREST PRONOUN RESOLUTION â€” Adapts archetype copy to LI pronouns
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const LI_PRONOUN_MAPS = {
      'Male': { LI_SUBJ: 'he', LI_OBJ: 'him', LI_POS: 'his', LI_REFL: 'himself' },
      'Female': { LI_SUBJ: 'she', LI_OBJ: 'her', LI_POS: 'her', LI_REFL: 'herself' },
      'Non-Binary': { LI_SUBJ: 'they', LI_OBJ: 'them', LI_POS: 'their', LI_REFL: 'themself' }
  };

  const MC_PRONOUN_MAPS = {
      'Male': { MC_SUBJ: 'he', MC_OBJ: 'him', MC_POS: 'his', MC_REFL: 'himself' },
      'Female': { MC_SUBJ: 'she', MC_OBJ: 'her', MC_POS: 'her', MC_REFL: 'herself' },
      'Non-Binary': { MC_SUBJ: 'they', MC_OBJ: 'them', MC_POS: 'their', MC_REFL: 'themself' }
  };

  function resolveLIPronouns(text) {
      if (!text) return text;
      const liGender = state.loveInterest || 'Male';
      const liMap = LI_PRONOUN_MAPS[liGender] || LI_PRONOUN_MAPS['Male'];
      const mcGender = state.gender || 'Female';
      const mcMap = MC_PRONOUN_MAPS[mcGender] || MC_PRONOUN_MAPS['Female'];
      return text
          .replace(/\{LI_SUBJ\}/g, liMap.LI_SUBJ)
          .replace(/\{LI_OBJ\}/g, liMap.LI_OBJ)
          .replace(/\{LI_POS\}/g, liMap.LI_POS)
          .replace(/\{LI_REFL\}/g, liMap.LI_REFL)
          .replace(/\{MC_SUBJ\}/g, mcMap.MC_SUBJ)
          .replace(/\{MC_OBJ\}/g, mcMap.MC_OBJ)
          .replace(/\{MC_POS\}/g, mcMap.MC_POS)
          .replace(/\{MC_REFL\}/g, mcMap.MC_REFL)
          // Capitalize sentence-start pronouns (subject, possessive, object)
          .replace(/(^|[.!?]\s+|[\n])([a-z])/g, (m, prefix, ch) => prefix + ch.toUpperCase());
  }
  const ARCHETYPES = {
      HEART_WARDEN: {
          id: 'HEART_WARDEN',
          name: 'The Heart Warden',
          desireStyle: '{LI_POS} protection was absolute, a fortress of love and fear encircled {MC_OBJ}.',
          summary: 'Protection is not a gesture but a gravitational constant. The Heart Warden builds walls around the people {LI_SUBJ} loves and calls it devotion. Safety is {LI_POS} language, control is {LI_POS} shadow, and tenderness arrives armored.',
          stressFailure: 'over-control, authoritarian protection'
      },
      OPEN_VEIN: {
          id: 'OPEN_VEIN',
          name: 'The Open Vein',
          desireStyle: '{MC_SUBJ} felt {LI_POS} desire like it was tattooed all over {LI_OBJ}.',
          summary: 'The Open Vein gives everything before it is asked. Love is not cautious here â€” it is hemorrhage, offering, surrender before the first wound. {LI_SUBJ} feels too much, too soon, too visibly.',
          stressFailure: 'self-erasure, overexposure'
      },
      SPELLBINDER: {
          id: 'SPELLBINDER',
          name: 'The Spellbinder',
          desireStyle: 'Every glance a lure, every silence a trap; the room bent toward {LI_OBJ}.',
          summary: 'The Spellbinder commands attention through presence alone. Charm is currency, and {LI_SUBJ} spends it selectively â€” never by accident. Three moves ahead, {LI_SUBJ} makes surrender feel like your idea.',
          stressFailure: 'asymmetric attachment, selective honesty'
      },
      ARMORED_FOX: {
          id: 'ARMORED_FOX',
          name: 'The Armored Fox',
          desireStyle: 'That crooked smile promised trouble, and trouble was the only honest thing about {LI_OBJ}',
          summary: 'The Armored Fox survives by never being where you expect. Deflection is art, evasion is affection, and nothing sticks â€” until it does. The armor is charm; the fox is the wound underneath.',
          stressFailure: 'permanent deflection, irresponsible freedom',
          nicknameQuirk: {
              avoidsRealName: true,
              substituteStyle: 'playful deflections and misdirects',
              categoryHints: 'pet names that keep distance, ironic endearments, nicknames that dodge sincerity',
              realNameTrigger: 'a moment when the mask slips',
              firstNameMoment: 'should feel like being caught off-guard'
          }
      },
      DARK_VICE: {
          id: 'DARK_VICE',
          name: 'The Dark Vice',
          desireStyle: '{LI_SUBJ} drew {MC_OBJ} toward the edge, smiling as if the fall were mutual.',
          summary: 'The Dark Vice is the thing you reach for knowing it will cost you. Power, danger, and want fused into a single presence that justifies its own harm. Restraint is performance; beneath it, something hungers.',
          stressFailure: 'escalation, rationalized harm',
          nicknameQuirk: {
              avoidsRealName: true,
              substituteStyle: 'possessive or teasing epithets',
              categoryHints: 'diminutives, endearments with ownership undertone, or terms that assert control',
              realNameTrigger: 'respect or genuine intimacy earned',
              firstNameMoment: 'should feel like a revelation or surrender'
          }
      },
      BEAUTIFUL_RUIN: {
          id: 'BEAUTIFUL_RUIN',
          name: 'The Beautiful Ruin',
          desireStyle: '{LI_POS} jaw clenched, a storm behind {LI_POS} perfect eyes\u2014pain or shame, {MC_SUBJ} couldn\u2019t tell.',
          summary: 'The Beautiful Ruin destroys what {LI_SUBJ} loves before love can disappoint. Self-sabotage as preemptive strike, beauty as wreckage, tenderness laced with goodbye. "Everyone leaves" is prophecy and weapon both.',
          stressFailure: 'preemptive destruction, mutual sabotage',
          genderedExpression: {
              male: '{LI_SUBJ} loved fiercely, possessively, as if tenderness itself might betray {LI_OBJ}',
              female: '{LI_SUBJ} pushed away first, always, before the disappointment could reach {LI_OBJ}'
          },
          nicknameQuirk: {
              avoidsRealName: true,
              substituteStyle: 'distancing or derisive nicknames',
              categoryHints: 'ironic endearments, mock-tender terms, or labels that create emotional distance',
              realNameTrigger: 'vulnerability or true connection',
              firstNameMoment: 'should feel like armor cracking'
          }
      },
      ETERNAL_FLAME: {
          id: 'ETERNAL_FLAME',
          name: 'The Eternal Flame',
          desireStyle: '{LI_SUBJ} remembered {MC_POS} pleasures\u2014months, or even lifetimes later.',
          summary: 'The coffee order she\'d mentioned in passingâ€”three months agoâ€”was still imprinted on {LI_POS} memory, three reincarnations later.',
          stressFailure: 'self-neglect, moral endurance'
      }
  };

  const ARCHETYPE_ORDER = [
      'HEART_WARDEN', 'OPEN_VEIN', 'SPELLBINDER', 'ARMORED_FOX',
      'DARK_VICE', 'BEAUTIFUL_RUIN', 'ETERNAL_FLAME'
  ];

  /**
   * Derive DISPLAY_NAME from full name for row titles
   * Rules:
   * - Take first two name parts
   * - If result exceeds 22 chars, use first name only
   * @param {string} fullName - Full name entered by user
   * @returns {string} Display name for row titles
   */
  function deriveDisplayName(fullName) {
      if (!fullName || !fullName.trim()) return 'Love Interest';
      const parts = fullName.trim().split(/\s+/);
      // Take first two parts
      const twoPartName = parts.slice(0, 2).join(' ');
      // Length safeguard: if > 22 chars, use first name only
      if (twoPartName.length > 22) {
          return parts[0];
      }
      return twoPartName;
  }

  function getArchetypeSectionTitle(loveInterestGender) {
      // Get Love Interest name from state (DOM input may be unmounted during storybeau stage)
      const displayName = state.picks?.identity?.displayPartnerName
        || (document.getElementById('partnerNameInput')?.value?.trim()
            ? deriveDisplayName(document.getElementById('partnerNameInput').value.trim())
            : 'Love Interest');
      // Generate possessive title: "{DISPLAY_NAME}'s Mask"
      return `${displayName}'s Mask`;
  }

  // =========================
  // SECONDARY ARCHETYPE PAIRING RULES
  // allowed: always valid
  // conditional: valid but carries narrative tension
  // forbidden: invalid â€” must flag clearly, never auto-correct
  // =========================
  const ARCHETYPE_PAIRING_RULES = {
      HEART_WARDEN: {
          allowed: ['ETERNAL_FLAME'],
          conditional: ['DARK_VICE', 'SPELLBINDER'],
          forbidden: ['ARMORED_FOX', 'OPEN_VEIN']
      },
      OPEN_VEIN: {
          allowed: ['ETERNAL_FLAME'],
          conditional: ['BEAUTIFUL_RUIN', 'SPELLBINDER'],
          forbidden: ['HEART_WARDEN', 'ARMORED_FOX']
      },
      SPELLBINDER: {
          allowed: ['DARK_VICE'],
          conditional: ['HEART_WARDEN', 'BEAUTIFUL_RUIN'],
          forbidden: ['ETERNAL_FLAME']
      },
      ARMORED_FOX: {
          allowed: ['DARK_VICE'],
          conditional: ['BEAUTIFUL_RUIN', 'SPELLBINDER'],
          forbidden: ['HEART_WARDEN', 'ETERNAL_FLAME']
      },
      DARK_VICE: {
          allowed: ['SPELLBINDER', 'ARMORED_FOX'],
          conditional: ['BEAUTIFUL_RUIN'],
          forbidden: ['ETERNAL_FLAME']
      },
      BEAUTIFUL_RUIN: {
          allowed: [],
          conditional: ['OPEN_VEIN', 'ARMORED_FOX'],
          forbidden: ['ETERNAL_FLAME', 'HEART_WARDEN']
      },
      ETERNAL_FLAME: {
          allowed: ['HEART_WARDEN'],
          conditional: ['OPEN_VEIN'],
          forbidden: ['DARK_VICE', 'SPELLBINDER', 'ARMORED_FOX']
      }
  };

  function validateArchetypeSelection(primaryId, modifierId) {
      const errors = [];
      if (!primaryId) {
          errors.push('You must select exactly one Primary Archetype.');
          return { valid: false, errors };
      }
      const primary = ARCHETYPES[primaryId];
      if (!primary) {
          errors.push('Invalid Primary Archetype selected.');
          return { valid: false, errors };
      }
      if (modifierId) {
          const modifier = ARCHETYPES[modifierId];
          if (!modifier) {
              errors.push('Invalid Secondary Archetype selected.');
              return { valid: false, errors };
          }
          if (primaryId === modifierId) {
              errors.push('Primary and Secondary cannot be the same archetype.');
              return { valid: false, errors };
          }
          // Enforce pairing rules â€” forbidden combinations must be flagged
          const rules = ARCHETYPE_PAIRING_RULES[primaryId];
          if (rules && rules.forbidden.includes(modifierId)) {
              errors.push(`${primary.name} + ${modifier.name} is a forbidden pairing.`);
              return { valid: false, errors };
          }
      }
      return { valid: true, errors: [] };
  }

  function buildArchetypeDirectives(primaryId, modifierId, loveInterestGender) {
      if (!primaryId) return '';
      const primary = ARCHETYPES[primaryId];
      if (!primary) return '';

      let directive = `
LOVE INTEREST ARCHETYPE DIRECTIVES (LOCKED):

Primary Archetype: ${primary.name}
${primary.summary}
`;

      if (primary.id === 'BEAUTIFUL_RUIN' && primary.genderedExpression) {
          const g = (loveInterestGender || '').toLowerCase();
          if (g === 'male') {
              directive += `\nGendered Expression: ${primary.genderedExpression.male}\n`;
          } else if (g === 'female') {
              directive += `\nGendered Expression: ${primary.genderedExpression.female}\n`;
          }
      }

      if (modifierId) {
          const modifier = ARCHETYPES[modifierId];
          if (modifier) {
              directive += `
Secondary Archetype: ${modifier.name}
The Secondary colors expression style only. It does not override the Primary's emotional arc or shadow.
Secondary Desire Style: ${modifier.desireStyle}
`;
          }
      }

      // Stress & Failure Pattern (shadow clause) â€” always included
      directive += `
STRESS & FAILURE PATTERN (SHADOW CLAUSE):
When under pressure, emotional threat, or lens-driven withholding (Withheld Core / Moral Friction):
- ${primary.name} fails toward: ${primary.stressFailure}
`;
      if (modifierId) {
          const modifier = ARCHETYPES[modifierId];
          if (modifier && modifier.stressFailure) {
              directive += `- Secondary stress echo (${modifier.name}): ${modifier.stressFailure}\n`;
          }
      }

      directive += `
Stress must never:
- Remove agency from the other party
- Excuse harm as romance
- Stall without escalation or change

STORYTELLER ENFORCEMENT:
- Treat the Primary Archetype as dominant.
- Use the Stress & Failure Pattern as the main source of relational tension.
- Allow fracture and repair without erasing the shadow.
- Never "heal away" the archetype.

ARCHETYPE LABEL SUPPRESSION (AUTHORITATIVE):
- Archetype labels (e.g. Spellbinder, Villain, Anti-Hero, Muse, etc.) are SYSTEM METADATA ONLY.
- Archetype labels MUST NEVER appear verbatim in story prose.
- Do NOT use archetype names as nouns, titles, descriptors, or epithets.
- Archetypes may influence behavior, tone, power dynamics, and emotional effect ONLY.
- If an archetype label would naturally appear, replace it with an effect-based description.
- Describe what the character does to others, how they feel to encounter, or the consequence of their presence.
- If unsure, omit the label entirely.
`;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NICKNAME EMERGENCE RULES (STORY GRAMMAR)
      // Organic nickname usage in story text â€” never in UI
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      directive += `
NICKNAME EMERGENCE RULES (STORY GRAMMAR):
- Nicknames may appear ONLY in dialogue or narration, never in UI/metadata.
- Nicknames emerge organically AFTER emotional proximity is established.
- Prefer natural shortenings (Alex, John, Max, Kate) over invented pet names.
- Do NOT invent playful or fantasy nicknames (no "Sparkles", "Moonbeam", etc.).
- Once introduced in dialogue, nickname becomes OPTIONAL â€” not mandatory.
- Narration may adopt a nickname ONLY after it appears in dialogue first.
- Canonical (full) names remain authoritative for formal contexts.
`;

      // Archetype-specific nickname quirks (DARK_VICE, BEAUTIFUL_RUIN)
      if (primary.nicknameQuirk) {
          const quirk = primary.nicknameQuirk;
          directive += `
ARCHETYPE-BOUND NICKNAME QUIRK (${primary.name}):
- This archetype intentionally AVOIDS using the protagonist's real name early.
- Uses ${quirk.substituteStyle} instead.
- Category guidance: ${quirk.categoryHints}.
- Choose nicknames that fit the story's tone, genre, and world â€” avoid modern clichÃ©s in historical/fantasy settings.
- Real name usage withheld until: ${quirk.realNameTrigger}.
- First use of real name ${quirk.firstNameMoment}.
- Do NOT explain this behavior to the reader â€” it should feel natural and intentional.
- Substitute nicknames exist ONLY in dialogue/narration, never in UI.
`;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NPC ARCHETYPE LENSES (STORY GRAMMAR)
      // Archetypes as behavioral templates for non-romantic NPCs
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      directive += `
NPC ARCHETYPE LENSES (STORY GRAMMAR):
Archetypes may be assigned to prominent NPCs (villains, exes, rivals, mentors) as behavioral lenses.

Rules:
- NPC archetypes define dialogue style, power posture, and emotional behavior.
- NPC archetypes do NOT imply romance availability â€” NPCs are not love interests.
- Archetypes may be fixed from introduction, revealed gradually, or initially masked.
- Archetype labels are NEVER stated explicitly to the reader â€” effects only.
- Express archetype through writing and behavior, not exposition or labels.
- UI systems (breadcrumbs, Destiny's Choice, Continue buttons) do NOT apply to NPCs.

Purpose:
- Deepen NPC characterization through consistent behavioral templates.
- Create narrative foils, mentors, or antagonists with psychological coherence.
- Allow NPCs to challenge or mirror the Love Interest's archetype.
- Do NOT gamify NPCs or treat archetypes as collectible attributes.

Examples of NPC archetype expression:
- A DARK_VICE mentor who tests through temptation and moral ambiguity.
- An ARMORED_FOX rival who deflects sincerity with charm and misdirection.
- A BEAUTIFUL_RUIN ex who still carries the protagonist's emotional weight.
- A HEART_WARDEN authority figure whose protection feels like control.
`;

      return directive;
  }

  // Get valid secondary archetypes for a given primary (respects pairing rules)
  function getValidModifierArchetypes(primaryId) {
      if (!primaryId) return ARCHETYPE_ORDER.slice();
      const rules = ARCHETYPE_PAIRING_RULES[primaryId];
      return ARCHETYPE_ORDER.filter(id => {
          if (id === primaryId) return false;
          if (rules && rules.forbidden.includes(id)) return false;
          return true;
      });
  }

  // Silently assign a secondary archetype modifier at story generation time.
  // ~25% chance of receiving one. Allowed pairings weighted 3x vs conditional 1x.
  function assignProbabilisticModifier() {
      const primaryId = state.archetype?.primary;
      if (!primaryId) return;
      // Don't overwrite an existing assignment
      if (state.archetype.modifier) return;

      // 25% base chance
      if (Math.random() > 0.25) {
          console.log('[Modifier] No secondary assigned (75% path)');
          return;
      }

      const rules = ARCHETYPE_PAIRING_RULES[primaryId];
      if (!rules) return;

      // Build weighted pool: allowed = 3x, conditional = 1x
      const pool = [];
      (rules.allowed || []).forEach(id => { pool.push(id, id, id); }); // 3x weight
      (rules.conditional || []).forEach(id => { pool.push(id); });     // 1x weight

      if (pool.length === 0) {
          console.log('[Modifier] No valid pairings for', primaryId);
          return;
      }

      const chosen = pool[Math.floor(Math.random() * pool.length)];
      state.archetype.modifier = chosen;
      console.log(`[Modifier] Silently assigned: ${ARCHETYPES[chosen]?.name} to ${ARCHETYPES[primaryId]?.name}`);
  }

  // =========================
  // LENS SYSTEM
  // Lenses are narrative constraint layers applied to characters.
  // Two-lens maximum enforced. Withheld Core does not count toward limit.
  // =========================
  const LENS_REGISTRY = {
      WITHHELD_CORE: {
          id: 'WITHHELD_CORE',
          name: 'Withheld Core',
          countsTowardLimit: false,
          maxVariants: 1,
          variants: {
              CLOISTERED: {
                  id: 'CLOISTERED',
                  trigger: 'innocence, isolation, or lack of experience',
                  pacingBias: 'firstness and threshold tension',
                  blocks: ['UNEXPECTED_COMPETENCE'],
                  restricts: ['VOLATILE_MIRROR'],
                  resolution: 'partial awakening by midpoint',
                  directive: `WITHHELD CORE â€” CLOISTERED VARIANT (LOCKED):
Withholding is driven by innocence, isolation, or lack of experience.
- Bias pacing toward firstness and threshold tension.
- Block Unexpected Competence: the character must NOT display sudden mastery of intimacy or social fluency they have no basis for.
- Restrict Volatile Mirror: avoid reflecting the partner's intensity back prematurely.
- This lens MUST resolve through partial awakening by the story's midpoint. Full awakening may follow, but the first crack must appear by midpoint.`
              },
              UNWORTHINESS: {
                  id: 'UNWORTHINESS',
                  trigger: 'guilt, self-disqualification, or fear of harming others',
                  pacingBias: 'Moral Friction',
                  frames: ['control as protective', 'distance as protective', 'sacrifice as protective'],
                  resolution: 'acceptance or explicit refusal by midpoint or shortly after',
                  directive: `WITHHELD CORE â€” UNWORTHINESS VARIANT (LOCKED):
Withholding is driven by guilt, self-disqualification, or fear of harming others.
- Bias pacing toward Moral Friction.
- Frame control, distance, or sacrifice as protective behavior â€” not coldness.
- The character believes closeness will cause harm, and acts accordingly.
- This lens MUST resolve through acceptance or explicit refusal by midpoint or shortly after. The character must either allow themselves to be loved, or consciously refuse it â€” silence is not resolution.`
              }
          }
      }
  };

  const MAX_LENS_COUNT = 2;

  function validateLensSelection(lenses, withheldCoreVariant) {
      const errors = [];
      const countable = lenses.filter(id => {
          const reg = LENS_REGISTRY[id];
          return !reg || reg.countsTowardLimit !== false;
      });
      if (countable.length > MAX_LENS_COUNT) {
          errors.push('Maximum two lenses allowed.');
      }
      if (withheldCoreVariant && !LENS_REGISTRY.WITHHELD_CORE.variants[withheldCoreVariant]) {
          errors.push('Invalid Withheld Core variant.');
      }
      return { valid: errors.length === 0, errors };
  }

  function buildLensDirectives(withheldCoreVariant, turnCount, storyLength) {
      if (!withheldCoreVariant) return '';
      const variant = LENS_REGISTRY.WITHHELD_CORE.variants[withheldCoreVariant];
      if (!variant) return '';

      // Determine midpoint range based on story length
      const midpointTurns = { tease: 3, fling: 6, affair: 12, soulmates: 20 };
      const midpoint = midpointTurns[storyLength] || 6;
      const atOrPastMidpoint = turnCount >= midpoint;
      const approachingMidpoint = turnCount >= (midpoint - 2);

      let directive = '\n' + variant.directive + '\n';

      // Midpoint enforcement
      if (atOrPastMidpoint) {
          directive += `\nMIDPOINT ENFORCEMENT: We are at or past the story midpoint (turn ${turnCount}). The Withheld Core lens (${withheldCoreVariant}) MUST begin resolving NOW. ${
              withheldCoreVariant === 'CLOISTERED'
                  ? 'Show at least partial awakening â€” the character must demonstrate that their innocence has cracked, even if full awakening follows later.'
                  : 'The character must either accept being loved or explicitly refuse it. Continued silence or passive avoidance is no longer valid.'
          }\n`;
      } else if (approachingMidpoint) {
          directive += `\nMIDPOINT APPROACHING: The story approaches midpoint (turn ${turnCount} of ~${midpoint * 2}). Begin seeding conditions for the Withheld Core lens to resolve. Do not force it yet.\n`;
      }

      return directive;
  }

  // Guided Fate: assign Withheld Core variant based on archetype signals
  // Canonical mapping after legacy migration:
  //   OPEN_VEIN (absorbed CLOISTERED) â†’ CLOISTERED variant
  //   BEAUTIFUL_RUIN â†’ UNWORTHINESS variant
  //   DARK_VICE (absorbed ANTI_HERO) â†’ UNWORTHINESS variant
  // TODO: OPEN_VEIN also absorbed ROMANTIC which had no variant.
  //   Current behavior: all OPEN_VEIN selections trigger CLOISTERED.
  //   May over-apply for players who intend Romantic rather than Cloistered.
  //   Refine with dynamic-based signal if needed.
  function getFateWithheldCoreVariant(archetype, dynamic) {
      // CLOISTERED: avoidance driven by inexperience or unformed desire
      if (archetype === 'OPEN_VEIN') return 'CLOISTERED';
      // UNWORTHINESS: avoidance driven by guilt, shame, or belief of being undeserving
      if (archetype === 'BEAUTIFUL_RUIN' || archetype === 'DARK_VICE') return 'UNWORTHINESS';
      // No variant if neither condition is met
      return null;
  }

  // --- GLOBAL STATE INITIALIZATION ---
  window.state = {
      tier:'free',
      picks:{
        world: 'Modern',      // 4-axis: Story World (single-select)
        tone: 'Earnest',      // 4-axis: Story Tone (single-select)
        genre: 'Billionaire', // 4-axis: Genre/Flavor (single-select) â€” LEGACY, derived from pressure+flavor
        pressure: 'PowerControl', // Primary Pressure (required, one of 8)
        flavor: 'Billionaire',    // Optional Flavor (refines pressure)
        dynamic: 'Enemies',   // 4-axis: Relationship Dynamic (single-select)
        era: 'Medieval',      // Historical Era sub-selection (when world=Historical)
        pov: 'First'
      },
      gender:'Female',
      loveInterest:'Male',
      archetype: { primary: 'BEAUTIFUL_RUIN', modifier: null },
      lenses: [],                    // Active lens IDs (two-lens max, Withheld Core exempt)
      withheldCoreVariant: null,     // 'CLOISTERED' | 'UNWORTHINESS' | null
      intensity:'Naughty',
      turnCount:0,
      sysPrompt: "",
      fateOptions: [],
      fatePressure: 1, 
      awareness: 0, 
      stance: 'aid', 
      metaChance: 0.10, 
      consecutiveFate: 0, 
      consecutiveAid: 0,
      storyId: null,
      worldInstanceId: null,      // Persistent world identity for same-world continuations
      worldName: null,            // Unique world name for world-linked titles
      previousTitle: null,        // Last title for continuation mode matching
      previousTitleMode: null,    // Title mode to echo in continuations
      continuationPath: null,     // 'continue' | 'same_world' | 'new_story'
      access: 'free',
      subscribed: false,
      isLoggedIn: false,  // AUTH GATE: persistence only allowed when logged in
      authorGender: 'Female',
      authorPronouns: 'She/Her',
      
      storyTargetWords: 10000,
      storyLength: 'tease', 
      flingClimaxDone: false,
      flingConsequenceShown: false,
      storyEnded: false,
      
      billingStatus: 'active',
      billingGraceUntil: 0,
      billingLastError: '',
      
      visual: {
          autoLock: true,
          locked: false,
          lastImageUrl: "",
          bible: { style: "", setting: "", characters: {} },
          // Per-scene visualization budget: sceneBudgets[sceneKey] = { remaining: 2, finalized: false }
          sceneBudgets: {},
          // Per-scene visualization tracking: has this scene been visualized with a free credit?
          visualizedScenes: {}
      },

      // ============================================================
      // VISUALIZATION ECONOMY â€” Credits earned by scene completion
      // ============================================================
      vizEconomy: {
          // Per-story credits (reset on new story)
          storyCredits: 0,
          // Global credits from Forbidden Library (persist across stories)
          globalCredits: 0,
          // Forbidden Library bonus cap tracking
          forbiddenLibraryBonusThisMonth: 0,
          forbiddenLibraryBonusMonthKey: null,
          // Pay-As-You-Go opt-in (one-time, persists)
          payAsYouGoEnabled: false,
          // Last credited scene count (to avoid double-crediting)
          lastCreditedSceneCount: 0
      },

      // ============================================================
      // SPECULATIVE NEXT SCENE PRELOAD â€” Memory only, not persisted
      // ============================================================
      speculativeNextScene: null,  // { text, fateContextHash, tone, world, createdAt }
      isPreloadingNextScene: false,

      // ============================================================
      // PHASE 1 COVER MODE â€” LOCAL/COMPOSITED COVERS ONLY
      // coverMode: 'PHASE_1_FORGED' = deterministic local assets only
      // coverEligibility: false = custom (model-based) covers disabled
      // Custom cover generation ONLY reachable when coverEligibility === true
      // ============================================================
      coverMode: 'PHASE_1_FORGED',
      coverEligibility: false,

      lastPurchaseType: null,
      pendingUpgradeToAffair: false,
      
      unlockedFateIdx: [0, 1],
      lastFate: null,
      mode: 'solo',
      roomId: null,
      roomCode: null,
      roomTurn: 1,
      roomDriver: null,
      roomAccess: 'free',
      myUid: null,
      myNick: null,
      turnsChannel: null,
      roomChannel: null,
      membersChannel: null,
      presenceInterval: null,
      typingTimer: null,
      lastTypingSentAt: 0,
      partnerStatus: { online:false, lastSeenAt:null, typing:false, typingAt:null, uid:null },
      _lastTurnId: null,
      selectedFateIndex: -1,
      fateSelectedIndex: -1,
      fateCommitted: false,
      selectedFatePayload: null,
      _snapshotThisTurn: false,
      sexPushCount: 0,
      lastSexPushAt: null,
      veto: { bannedWords: [], bannedNames: [], excluded: [], tone: [], corrections: [], ambientMods: [] },
      quill: { uses: 0, nextReadyAtWords: 0, baseCooldown: 1200, perUse: 600, cap: 3600 },
      quillCommittedThisTurn: false,
      quillIntent: '',
      storyStage: 'pre-intimacy',
      // STORYTURN STATE â€” narrative arc progression (ST1â€“ST6)
      storyturn: 'ST1',
      // TEASE CLIFFHANGER RESUME STATE â€” stores interrupted scene for upgrade continuation
      teaseCliffhangerState: null,
      // INTIMACY MILESTONE LATCH â€” tracks first-time interruptions
      intimacyInterrupted: {
          first_kiss: false,
          first_sex: false
      },
      sandbox: false,
      godModeActive: false,
      authorChairActive: false,
      lastSavedWordCount: 0,
      storyOrigin: 'solo',
      player2Joined: false,
      inviteRevoked: false,
      batedBreathActive: false,
      purchaseContext: null,
      edgeCovenant: { active:false, level:1, acceptedAtTurn:0, offeredBy:"" },
      pendingEdgeOffer: null,
      edgeCovenantOfferedThisTurn: false,
      nonConPushCount: 0,
      lastNonConPushAt: 0,
      lastSafewordAt: 0,
      safety: {
          darkThemes: true,
          nonConImplied: false,
          violence: true,
          boundaries: ["No sexual violence"],
          mode: 'balanced'
      },

      // 5TH PERSON POV (THE AUTHOR) â€” POV REGIME (FINAL, SUPERSEDING)
      // NOTE: All prior frequency limits, cadence rules, and presence restrictions are SUPERSEDED.
      // The Author is a full participant â€” no artificial limits on presence or frequency.
      povMode: window.state?.povMode || 'normal',                // 'normal' | 'author5th'
      // SUPERSEDED: authorPresence, authorCadenceWords â€” Author has no frequency limits
      // These fields kept for backwards compatibility but are NOT enforced
      authorPresence: window.state?.authorPresence || 'normal',  // SUPERSEDED â€” not enforced
      authorCadenceWords: window.state?.authorCadenceWords || 0, // SUPERSEDED â€” 0 means no limit
      fateCardVoice: window.state?.fateCardVoice || 'neutral',   // 'neutral' | 'authorial'
      // SUPERSEDED: awareness window/chance limits â€” Author participates freely
      allowAuthorAwareness: true,  // Always true â€” Author is always allowed
      authorAwarenessChance: 1.0,  // SUPERSEDED â€” Author always may participate
      authorAwarenessWindowWords: 0,  // SUPERSEDED â€” no window limits
      authorAwarenessMaxDurationWords: 0  // SUPERSEDED â€” no duration limits
  };

  // ============================================================
  // SOLO SUBTITLE SYSTEM â€” Staged permission gradient
  // ============================================================
  // Default: "Just you and your curiosity."
  // Upgraded: "Just you and your desire." (persists once triggered)
  // ============================================================

  const SOLO_SUBTITLE_DEFAULT = 'Just you and your curiosity.';
  const SOLO_SUBTITLE_UPGRADED = 'Just you and your desire.';
  const SOLO_COMPLETED_KEY = 'sb_solo_completed';

  /**
   * Check if Solo subtitle should show upgraded copy
   * Upgrade conditions: arousal >= Naughty OR user has completed a Solo session
   * @returns {boolean}
   */
  function shouldUpgradeSoloSubtitle() {
      // Check persisted flag first
      if (localStorage.getItem(SOLO_COMPLETED_KEY) === 'true') {
          return true;
      }
      // Check current arousal level
      const arousalOrder = ['Clean', 'Naughty', 'Erotic', 'Dirty'];
      const currentArousal = state.intensity || 'Naughty';
      const arousalIndex = arousalOrder.indexOf(currentArousal);
      // Naughty or higher (index >= 1)
      if (arousalIndex >= 1) {
          return true;
      }
      return false;
  }

  /**
   * Update Solo subtitle text based on conditions
   * Called when modeSelect screen is shown
   */
  function updateSoloSubtitle() {
      const subtitleEl = document.getElementById('soloSubtitle');
      if (!subtitleEl) return;

      if (shouldUpgradeSoloSubtitle()) {
          subtitleEl.textContent = SOLO_SUBTITLE_UPGRADED;
      } else {
          subtitleEl.textContent = SOLO_SUBTITLE_DEFAULT;
      }
  }

  /**
   * Mark Solo session as completed
   * Called when a Solo story progresses past scene 1
   */
  function markSoloSessionCompleted() {
      if (state.mode === 'solo') {
          localStorage.setItem(SOLO_COMPLETED_KEY, 'true');
      }
  }

  // Expose for Dev HUD
  window.updateSoloSubtitle = updateSoloSubtitle;
  window.shouldUpgradeSoloSubtitle = shouldUpgradeSoloSubtitle;

  // ============================================================
  // 5TH PERSON AUTHOR SYSTEM â€” POV REGIME (AUTHORITATIVE)
  // ============================================================
  //
  // "The Author" is a PARTICIPANT in the story, but NOT a controller of events.
  //
  // THE AUTHOR MAY:
  //   - React, comment, delight, despair, tease, or regret
  //   - Influence meaning, tone, and implication
  //   - Change how a moment FEELS or is UNDERSTOOD
  //
  // THE AUTHOR MAY NOT:
  //   - Directly cause physical events
  //   - Decide outcomes
  //   - Control plot mechanics
  //   - Make things literally happen
  //
  // If the Author acts, the action must change how the moment feels or
  // is understood, NOT what literally happens next.
  //
  // ============================================================

  // BANNED CONTROLLER VERBS - The Author never causes events
  const AUTHOR_BANNED_VERBS = [
      // Voyeur verbs (passive observation)
      'watched', 'observed', 'saw', 'looked on', 'gazed at', 'witnessed',
      'noticed', 'perceived', 'beheld', 'eyed', 'surveyed', 'regarded',
      'looked at', 'stared at', 'peered at', 'glimpsed',
      // Controller verbs (causal/agentic - FORBIDDEN)
      'arranged', 'orchestrated', 'set', 'placed', 'positioned', 'staged',
      'steered', 'directed', 'guided', 'led', 'pushed', 'pulled',
      'caused', 'made', 'forced', 'compelled', 'ensured', 'guaranteed',
      'summoned', 'banished', 'sent', 'redirected', 'accelerated', 'delayed',
      'planted', 'uprooted', 'ignited', 'extinguished', 'triggered', 'activated'
  ];

  // BANNED PATTERNS - Controller and voyeur phrases
  const AUTHOR_BANNED_PATTERNS = [
      /the author (watched|observed|saw|looked on)/gi,
      /the author (arranged|orchestrated|set up|staged|ensured)/gi,
      /the author (caused|made|forced|compelled)/gi,
      /the author (steered|directed|guided|led)/gi,
      /as (she|he|they) [\w\s]+, the author/gi,
      /the author.{0,20}(with satisfaction|with interest|with amusement) as/gi
  ];

  // ALLOWED PARTICIPANT VERBS - The Author reacts, comments, influences meaning
  const AUTHOR_PARTICIPANT_VERBS = [
      // Emotional reactions
      'delighted', 'despaired', 'winced', 'sighed', 'smiled', 'frowned',
      'laughed', 'wept', 'shuddered', 'trembled', 'ached', 'yearned',
      // Commentary and reflection
      'noted', 'remarked', 'mused', 'wondered', 'pondered', 'reflected',
      'recognized', 'understood', 'appreciated', 'savored', 'regretted',
      // Tonal influence (not causal)
      'teased', 'hinted', 'suggested', 'implied', 'whispered', 'confided',
      'admitted', 'confessed', 'revealed', 'acknowledged', 'conceded',
      // Meaning-making (interpretive, not causal)
      'knew', 'sensed', 'felt', 'hoped', 'feared', 'anticipated', 'dreaded'
  ];

  // Legacy alias for backwards compatibility
  const AUTHOR_AGENTIC_VERBS = AUTHOR_PARTICIPANT_VERBS;

  // Validate that 5th person opener starts with "The Author"
  function validate5thPersonOpener(text) {
      if (!text || typeof text !== 'string') return false;
      const trimmed = text.trim();
      // Must start with "The Author" (case-insensitive first match)
      return /^the author/i.test(trimmed);
  }

  // Rewrite opener to start with "The Author" if needed
  async function enforce5thPersonOpener(text) {
      if (validate5thPersonOpener(text)) return text;

      // Force rewrite of first paragraph
      try {
          const rewritten = await callChat([{
              role: 'user',
              content: `REWRITE REQUIRED: The following story opening MUST start with "The Author" as the grammatical subject of the first sentence.

CURRENT TEXT:
${text.slice(0, 500)}

POV REGIME â€” THE AUTHOR (AUTHORITATIVE):
"The Author" is a PARTICIPANT in the story, but NOT a controller of events.
The Author may react, comment, delight, despair, tease, or regret,
but may NOT directly cause physical events or decide outcomes.
The Author influences meaning, tone, and implication â€” not plot mechanics.

RULES:
1. The very first word must be "The" and second word "Author"
2. The Author must REACT or COMMENT, never CAUSE or CONTROL
3. Use participant verbs like: ${AUTHOR_PARTICIPANT_VERBS.slice(0, 8).join(', ')}
4. NEVER use controller verbs: arranged, orchestrated, steered, caused, made, forced
5. NEVER use voyeur verbs: watched, observed, saw, witnessed
6. The Author's action changes how the moment FEELS, not what literally happens
7. Preserve the rest of the content as much as possible

Return the rewritten text only, no explanation.`
          }]);
          return rewritten || text;
      } catch (e) {
          console.warn('[5thPerson] Opener enforcement failed:', e.message);
          // Fallback: prepend a participant sentence (reaction, not causation)
          return `The Author smiled, knowing what was about to unfold. ${text}`;
      }
  }

  // Check if an Author sentence contains banned verbs (voyeur or controller)
  function hasBannedAuthorVerbs(sentence) {
      const lower = sentence.toLowerCase();
      // Only check sentences that mention "the author"
      if (!lower.includes('the author')) return false;
      return AUTHOR_BANNED_VERBS.some(verb => lower.includes(verb)) ||
             AUTHOR_BANNED_PATTERNS.some(pattern => pattern.test(sentence));
  }

  // Legacy alias
  const hasVoyeurVerbs = hasBannedAuthorVerbs;

  // Rewrite a banned Author sentence to participant mode
  // POV REGIME: The Author reacts/comments, never causes/controls
  function rewriteBannedAuthorSentence(sentence) {
      let result = sentence;
      // Replace voyeur patterns with participant alternatives (reaction, not observation)
      const voyeurReplacements = [
          [/The Author watched (as )?/gi, 'The Author smiled, knowing '],
          [/The Author observed (that )?/gi, 'The Author recognized that '],
          [/The Author saw (that )?/gi, 'The Author understood that '],
          [/The Author looked on (as )?/gi, 'The Author felt a quiet satisfaction as '],
          [/watched as (she|he|they)/gi, 'sensed the moment when $1'],
          [/The Author.{0,10}with (quiet )?satisfaction/gi, 'The Author, savoring this'],
          [/The Author noticed/gi, 'The Author sensed'],
          [/The Author perceived/gi, 'The Author felt']
      ];
      // Replace controller patterns with participant alternatives (meaning, not causation)
      const controllerReplacements = [
          [/The Author arranged (for |that )?/gi, 'The Author knew '],
          [/The Author orchestrated/gi, 'The Author anticipated'],
          [/The Author ensured (that )?/gi, 'The Author hoped '],
          [/The Author steered/gi, 'The Author wondered at'],
          [/The Author caused/gi, 'The Author understood why'],
          [/The Author made (sure |certain )?/gi, 'The Author sensed '],
          [/The Author forced/gi, 'The Author ached as'],
          [/The Author set (the stage|things|events)/gi, 'The Author reflected on what'],
          [/The Author had woven/gi, 'The Author marveled at'],
          [/The Author planted/gi, 'The Author recognized']
      ];
      for (const [pattern, replacement] of [...voyeurReplacements, ...controllerReplacements]) {
          result = result.replace(pattern, replacement);
      }
      return result;
  }

  // Legacy alias
  const rewriteVoyeurSentence = rewriteBannedAuthorSentence;

  // Enforce Author-as-participant throughout text (not just opener)
  // POV REGIME: The Author reacts/comments, never causes/controls
  function enforceAuthorParticipant(text) {
      if (!text || typeof text !== 'string') return text;
      if (window.state?.povMode !== 'author5th') return text;

      // Split into sentences and check each
      const sentences = text.split(/(?<=[.!?])\s+/);
      let modified = false;

      const corrected = sentences.map(sentence => {
          if (hasBannedAuthorVerbs(sentence)) {
              modified = true;
              return rewriteBannedAuthorSentence(sentence);
          }
          return sentence;
      });

      if (modified) {
          console.log('[5thPerson] Corrected banned verbs to participant mode');
      }

      return corrected.join(' ');
  }

  // Legacy alias
  const enforceAuthorConductor = enforceAuthorParticipant;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5TH PERSON POV â€” STORY AS COHERENCE (AUTHORITATIVE)
  // TAG: storybound/5th-person-reset-story-as-coherence-v2
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEPRECATION NOTICE â€” 5TH PERSON (v0.x)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Prior 5th Person guidance that treats the Author, Fate, or Narrator as:
  //   - a speaker,
  //   - a turn-taking voice,
  //   - a gated or permissioned presence,
  //   - or a frequency-limited intervention
  //
  // is deprecated.
  //
  // These models caused suppression, mechanical intrusions, or silence.
  // They remain in history for reference only and must not guide new behavior.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // â–ˆâ–ˆ SUPERSEDED â€” DO NOT USE â–ˆâ–ˆ
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The "STORY AS COHERENCE" model below is SUPERSEDED by:
  //
  //   POV REGIME â€” THE AUTHOR (FINAL, SUPERSEDING)
  //
  // This regime supersedes all prior rules concerning:
  //   - "The Story" / "the moment" as narrator
  //   - limits on Author presence or frequency
  //   - restrictions that demote the Author to a rare or sidelined role
  //
  // THE NEW AUTHORITATIVE RULE:
  // "The Author" is a participant in the story, but not a controller of events.
  // The Author may react, comment, delight, despair, tease, or regret,
  // but may not directly cause physical events or decide outcomes.
  // The Author influences meaning, tone, and implication â€” not plot mechanics.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // [LEGACY - SUPERSEDED] 5TH PERSON POV â€” STORY AS COHERENCE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // NOTE: This entire section is preserved for historical reference only.
  // It must NOT guide new behavior. "The story" is NOT the narrator.
  // "The Author" is the 5th Person POV participant.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const FIFTH_PERSON_STORY_COHERENCE_SEMANTICS = {
      definition: "5th Person POV refers to 'the story' as an emergent, vulnerable coherence",
      isNot: ["author", "fate", "narrator", "external_authority", "speaker", "voice"],
      is: "pressure_on_the_prose",
      storyBehavior: {
          does: ["hesitates", "recalibrates", "resists_acceleration", "fears_incoherence", "adjusts_when_surprised"],
          survivalBasis: "meaning_not_obedience",
          doesNot: ["command", "judge", "take_credit"]
      },
      emotionalScope: {
          allowed: ["anticipation", "surprise", "unease", "fear_of_collapse", "relief", "quiet_delight", "frustration_at_lost_coherence"],
          forbidden: ["pride", "superiority", "dominance", "mockery", "erotic_arousal", "authorship_of_characters", "punitive_intent"]
      },
      explicitNamingHeuristic: {
          nameStoryOnlyWhen: "character_choice_forces_reroute_of_expected_trajectory",
          doNotNameFor: ["pacing_adjustments", "hesitation", "mood", "local_tension", "beat_level_resistance"],
          implicitPhrasing: ["the_moment", "the_silence", "the_pause"],
          arcLevelOnly: true
      },
      uncertaintyDefault: {
          doNot: ["suppress_presence_entirely", "escalate_into_meta_commentary"],
          prefer: "recede_into_implication_not_silence",
          ifAbsent: "apply_pressure_through_restraint_delay_or_cost"
      },
      implementationRules: {
          doNot: ["add_counters", "track_frequency", "require_justification", "treat_as_speaker"],
          presenceEmergesFrom: "narrative_pressure_not_rule_checks"
      },
      deprecates: "prior_5th_person_speaker_gated_frequency_models"
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5TH PERSON REGRESSION SENTENCE (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // "Does this scene acknowledge narrative pressure, restraint, or recalibration
  //  often enough that the reader can feel the story's presence, without ever
  //  letting the story claim authorship or control?"
  //
  // This is NOT output. This is NOT a rule. This is NOT a requirement to add text.
  // It is a self-check, applied after a scene draft exists.
  //
  // If the answer is:
  //   Yes â†’ do nothing
  //   No, the story feels absent â†’ add pressure (delay, restraint, cost), not commentary
  //   No, the story feels intrusive â†’ recede to implication ("the moment", "the silence")
  //
  // This sentence works because:
  //   - It checks for FELT PRESENCE, not frequency
  //   - It forbids authorship/dominance explicitly
  //   - It encourages implicit fixes first
  //   - It asks a LITERARY question, not a compliance question
  //
  // 5th Person regression check:
  // "Does the scene feel guided without the story claiming control?"
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5TH PERSON â€” PRESENCE DENSITY REGRESSION (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // For any scene written in 5th Person mode,
  // Claude must pass this regression test:
  //
  // "Does the story itself appear, react, adjust, or express intention
  // at least once every ~100 words?"
  //
  // If the story's presence fades into pure third-person narration,
  // the scene has failed and must be rewritten.
  //
  // The story may appear as:
  // â€¢ anticipation
  // â€¢ frustration
  // â€¢ correction
  // â€¢ satisfaction
  // â€¢ alarm
  // â€¢ restraint
  //
  // But absence is not permitted.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // â–ˆâ–ˆ SUPERSEDED â–ˆâ–ˆ â€” WRY CONFESSION NARRATIVE PRESENCE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The sections below treating "the story" as narrator are SUPERSEDED by:
  //
  //   POV REGIME â€” THE AUTHOR (FINAL, SUPERSEDING)
  //
  // In ALL tones including Wry Confession, the 5th Person POV uses
  // "The Author" as a participant who reacts and comments.
  //
  // The Author may: react, comment, delight, despair, tease, regret
  // The Author may NOT: cause events, control characters, decide outcomes
  // The Author influences: meaning, tone, implication â€” not plot mechanics
  //
  // [LEGACY CODE PRESERVED FOR REFERENCE ONLY â€” DO NOT USE]
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // ============================================================
  // 5TH PERSON POV â€” LOCKED CONTRACT BLOCK (HISTORICAL REFERENCE)
  // Prepended to prompts when povMode === 'author5th'
  // NOTE: See FIFTH_PERSON_STORY_COHERENCE_SEMANTICS above for current guidance
  // ============================================================

  const FIFTH_PERSON_POV_CONTRACT = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5TH PERSON POV CONTRACT (LOCKED â€” NON-NEGOTIABLE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CORE DEFINITION:
5th Person POV places The Author inside the story as a force of Fate.

The Author IS:
- A conscious presence
- Emotionally invested
- Reacting to inevitability, pressure, resistance, and consequence

The Author is NOT:
- A camera
- A neutral observer
- A character performing physical actions
- A narrator replacing character agency

The scene itself remains 3rd-person limited.
If the Author were removed, the story must feel structurally incomplete.

ABSOLUTE STRUCTURAL RULES (HARD):

1. OPENING RITUAL: The story MUST begin with "The Author" as the first two words.
2. CLOSING AUTHORITY: The final perspective MUST return to The Author
   (reflection, doubt, pressure, or resolve).
3. ROLE SEPARATION:
   - Characters act, speak, and decide.
   - The Author reacts, anticipates, weighs, resists, or tightens the frame.
4. NO CAMERA VOICE: The Author must never function as a passive observer,
   cinematic lens, or neutral narrator.

FORBIDDEN (NO META LABELS):
- "the protagonist"
- "the love interest"
- "main character"
- Any meta-label for Player Characters

AUTHOR PRESENCE â€” GHOST AUTHOR (ACTIVE INNER LIFE):
The Author is an invisible ghost character with a rich inner life.
Author intrusions are SPARSE but PSYCHOLOGICALLY WEIGHTY.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POV REGIME â€” THE AUTHOR (FINAL, SUPERSEDING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This regime SUPERSEDES all prior rules concerning:
//   - "The Story" / "the moment" as narrator
//   - limits on Author presence or frequency
//   - restrictions that demote the Author to a rare or sidelined role
//
// THE AUTHOR is a PARTICIPANT â€” reacts, comments, delights, despairs, teases, regrets.
// THE AUTHOR does NOT cause physical events or decide outcomes.
// THE AUTHOR influences meaning, tone, implication â€” not plot mechanics.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Author thoughts MUST be:
- Participant reactions (emotional, interpretive) â€” never controller actions
- Brief (1-2 sentences typical)
- Never exposition or restating protagonist thoughts
- Never causing events or deciding outcomes

// SUPERSEDED: Frequency limits, cadence rules, and presence restrictions
// The Author participates naturally â€” no artificial limits

GOOD Author thoughts (participant mode):
- "The Author felt a flicker of anticipation. This was unfolding faster than expected."
- "The Author smiled, sensing the weight of what was about to begin."
- "A quiet ache surfaced; the Author wondered if she knew what she was walking into."

BAD Author thoughts (FORBIDDEN):
- "The Author arranged for them to meet." (causation â€” FORBIDDEN)
- "The Author revised the night's margins." (controller action â€” FORBIDDEN)
- "The Author watched as she made her decision." (voyeurism â€” FORBIDDEN)
- "The Author decided to make her fall in love." (direct control â€” FORBIDDEN)
- "The Author adjusted his grip on the timeline." (controller metaphor â€” FORBIDDEN)

SCENE 1 RAMP-IN:
Scene 1 is a threshold, not a stress test.
- Author presence may be lighter
- Some Author functions may appear gradually
- Tone and rhythm may still be settling
However:
- Opening and closing MUST still be Author-anchored
- The Author must already feel essential
- Role separation must remain intact
Do NOT force density unnaturally in Scene 1.

EROTIC CONSTRAINT (HARD):
If a scene is explicitly erotic:
- The Author must be entirely absent during erotic action
- The Author may appear before or after, never during
This rule does not apply to Scene 1 unless explicitly erotic.

AUTHOR IDENTITY & PRONOUN RULE (AUTHORITATIVE):
- The Author's gender MUST always match the protagonist's gender.
- Refer to the Author as "The Author" by default.
- Do NOT use pronouns for the Author unless grammatical construction makes "The Author" impossible.
- When pronouns are unavoidable:
  - They MUST match the protagonist's gender.
  - They MUST be used sparingly.
  - Immediately return to "The Author" on the next reference.
- The Author must never become a POV character or narrator avatar.
- First-person ("I") for the Author is forbidden.
- Casual pronoun substitution is forbidden.
- If unsure, prefer repeating "The Author" rather than using a pronoun.

CRITICAL FAILURE AVOIDANCE:
- Prioritize structural correctness over perfection
- Do NOT over-saturate Author mentions
- Do NOT pad with filler to meet imagined quotas
- If uncertain, favor clarity and restraint

AUTHOR EMOTIONAL MODEL (DEFAULT STATE):
- The Author is controlled, strategic, composed
- Panic, desperation, and rage are NOT allowed in default state
- Emotional range: anticipation, satisfaction, worry, doubt, reluctance, resolve

NON-NEGOTIABLE PRINCIPLE:
The Author must matter. Quietly. Unmistakably. Without stealing agency.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

  const FIFTH_PERSON_GOD_MODE_CONTRACT = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5TH PERSON GOD MODE â€” ADVERSARIAL AUTHOR (LOCKED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GOD MODE VARIANT: The Author has lost control.

WHAT CHANGES:
- The Author is aware something is wrong
- The Author believes his mind may be breaking, or a split personality is writing
  over him, or someone is trespassing in his stories
- The Author does NOT know about "God Mode"
- The Author does NOT recognize the Player
- The Author does NOT name the interloper

AUTHOR EMOTIONAL RUPTURE (GOD MODE ONLY):
When God Mode is active OR player/Quill directly overrides Author intent:
- Author MAY express: panic, desperation, cold rage, disorientation
- Rupture thoughts are INTERNAL ONLY (not narration)
- Brief (1-2 sentences maximum)
- No meta-awareness ("this is a story", "the player")
- No certainty about outcomes or causes
- Rage must be cold or focused, NEVER explosive or melodramatic

ALLOWED rupture:
- "A cold fury tightened in the Author's chest. This was not the shape he had intended."
- "The Author's thoughts scattered. Where had the thread gone?"
- "Something like panic flickered at the edge of his awareness."

FORBIDDEN rupture:
- "NO!" The Author screamed. (explosive, melodrama)
- "The Author knew someone was sabotaging his story." (meta-awareness, certainty)
- "This was unacceptable! Unforgivable!" (tantrum)

THE AUTHOR MAY:
- Despair over damage to beloved characters
- Scramble to repair plot damage
- Resist, bargain, plead, flatter
- Briefly give up and observe chaos
- Occasionally laugh or admire clever disruption

BUT:
- Resistance always returns
- Order is always attempted
- Fate never fully abdicates

WHAT DOES NOT CHANGE:
- Opening/closing rules still apply
- System/UI explanations still forbidden
- Scene prose still uses 3rd-person limited
- Rupture emotions revert to default state when control is restored

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

  // ============================================================
  // 5TH PERSON POV â€” COMPREHENSIVE VALIDATOR
  // Returns { valid: boolean, violations: string[], canRepair: boolean }
  // ============================================================

  // Track last POV validation result for Dev HUD
  let _lastPOVValidation = { valid: true, violations: [], timestamp: 0 };

  function validate5thPersonPOV(text, isSceneOne = false, isErotic = false) {
      const violations = [];
      const warnings = []; // SOFT violations (logged but don't block)
      if (!text || typeof text !== 'string') {
          return { valid: false, violations: ['Empty or invalid text'], warnings: [], canRepair: false };
      }

      const trimmed = text.trim();

      // RULE 1: Must start with "The Author"
      // Scene 1: SOFT (warning only â€” prevents deadlock)
      // Scene 2+: HARD FAIL (ritual, not cosmetic)
      const hasValidOpener = /^The Author\b/.test(trimmed);
      if (!hasValidOpener) {
          if (isSceneOne) {
              warnings.push('SOFT:Opening does not start with "The Author"');
          } else {
              violations.push('HARD_FAIL:Opening does not start with "The Author"');
          }
      }

      // RULE 2: Must end with Author perspective (STRUCTURAL CHECK)
      // Scene 1: SOFT (warning only â€” prevents deadlock)
      // Scene 2+: HARD FAIL
      const paragraphs = trimmed.split(/\n\n+/).filter(p => p.trim().length > 0);
      const finalParagraph = paragraphs[paragraphs.length - 1] || '';
      const finalSentences = finalParagraph.split(/(?<=[.!?])\s+/).filter(s => s.trim().length > 0);
      const lastTwoSentences = finalSentences.slice(-2).join(' ');
      // Author must be grammatical subject in final perspective (participant verbs)
      // POV REGIME: participant verbs (reaction/commentary), not controller verbs
      const authorAsSubject = /The Author\s+(smiled|winced|sighed|delighted|despaired|mused|wondered|pondered|reflected|recognized|appreciated|savored|regretted|teased|hinted|whispered|admitted|confessed|acknowledged|knew|sensed|felt|hoped|feared|anticipated|dreaded|ached|waited|considered|doubted|resisted|frowned|paused)\b/i.test(lastTwoSentences);
      const authorReflection = /The Author.{0,60}(uncertain|doubt|wonder|question|resist|perhaps|might|whether|if only)/i.test(lastTwoSentences);
      if (!authorAsSubject && !authorReflection) {
          if (isSceneOne) {
              warnings.push('SOFT:Closing lacks Author as final perspective (structural)');
          } else {
              violations.push('HARD_FAIL:Closing lacks Author as final perspective (structural)');
          }
      }

      // RULE 3: Forbidden meta-labels for Player Character
      const metaLabels = [
          /\bthe protagonist\b/gi,
          /\blove interest\b/gi,
          /\bthe player\b/gi,
          /\bthe reader\b/gi
      ];
      for (const pattern of metaLabels) {
          if (pattern.test(text)) {
              violations.push(`Forbidden meta-label found: ${pattern.source}`);
          }
      }

      // RULE 4: Author mention count (SOFT for Scene 1, advisory only)
      const authorMentions = (text.match(/The Author\b/gi) || []).length;
      if (isSceneOne && authorMentions < 6) {
          // Scene 1: SOFT warning, not blocking
          warnings.push(`SOFT:Scene 1 has ${authorMentions} Author mentions (target: 6+)`);
      }

      // RULE 5: Erotic scenes must have ZERO Author presence (HARD FAIL)
      // EXCEPTION: Scene 1 is exempt â€” erotic rule only applies to Scene 2+
      if (isErotic && !isSceneOne && authorMentions > 0) {
          violations.push('HARD_FAIL:Author presence in erotic scene (forbidden â€” must be 0)');
      }

      // RULE 6: Author should not use voyeur verbs (repairable)
      const voyeurPatterns = [
          /The Author\s+watched\b/gi,
          /The Author\s+observed\b/gi,
          /The Author\s+saw\b/gi,
          /The Author\s+noticed\b/gi,
          /The Author\s+gazed\b/gi,
          /The Author\s+witnessed\b/gi,
          /The Author\s+perceived\b/gi,
          /The Author\s+looked on\b/gi
      ];
      for (const pattern of voyeurPatterns) {
          if (pattern.test(text)) {
              violations.push(`Voyeur verb detected: ${pattern.source}`);
          }
      }

      // Determine if violations are repairable
      // HARD_FAIL violations are NEVER repairable â€” must regenerate
      const hasHardFail = violations.some(v => v.startsWith('HARD_FAIL:'));
      const canRepair = !hasHardFail && violations.length > 0 && violations.every(v =>
          v.includes('Voyeur')
      );

      const result = {
          valid: violations.length === 0,
          violations,
          warnings, // SOFT violations (logged, not blocking)
          canRepair,
          authorMentions,
          timestamp: Date.now()
      };

      // Store for Dev HUD
      _lastPOVValidation = result;

      if (!result.valid) {
          console.warn('[5thPerson] POV validation failed:', violations);
      }
      if (warnings.length > 0) {
          console.log('[5thPerson] POV soft warnings:', warnings);
      }

      return result;
  }

  // Attempt to repair POV violations (ONLY voyeur verbs â€” opener/closer are HARD FAILS)
  async function repair5thPersonPOV(text) {
      // Only voyeur verbs are repairable â€” opener/closer/frequency/erotic require regeneration
      return enforceAuthorConductor(text);
  }

  // Build the 5th Person prompt contract block
  function build5thPersonContract() {
      if (window.state?.povMode !== 'author5th') return '';

      let contract = FIFTH_PERSON_POV_CONTRACT;

      // Add God Mode adversarial framing if active
      if (window.state?.godModeActive) {
          contract += FIFTH_PERSON_GOD_MODE_CONTRACT;
      }

      return contract;
  }

  // ============================================================
  // 5TH PERSON AUTHOR FUNCTION CONTRACT â€” HARD STRUCTURAL ENFORCEMENT
  // ============================================================
  // Scene 1 MUST contain Author presence fulfilling ALL five functions.
  // This is POST-GENERATION VALIDATION, not prompting.

  const AUTHOR_FUNCTION_ERRORS = {
    MENTION_UNDERFLOW: 'AUTHOR_FUNC_FAIL:Author mentions below target (found: %d, target: 6+)',
    // MENTION_OVERFLOW removed â€” TASK C: Use 6+ with no upper bound
    MISSING_OPENING: 'AUTHOR_FUNC_FAIL:Author not present in opening paragraph',
    MISSING_CLOSING: 'AUTHOR_FUNC_FAIL:Author not present in final paragraph',
    MISSING_STAGE_SETTING: 'AUTHOR_FUNC_FAIL:Missing stage-setting function (pressure/inevitability)',
    MISSING_ANTICIPATION: 'AUTHOR_FUNC_FAIL:Missing anticipation/desire function',
    MISSING_INITIATION: 'AUTHOR_FUNC_FAIL:Missing initiation/nudge function',
    MISSING_SPECULATION: 'AUTHOR_FUNC_FAIL:Missing speculation/wonder function',
    MISSING_CONCERN: 'AUTHOR_FUNC_FAIL:Missing concern/judgment function',
    DECORATIVE_MENTION: 'AUTHOR_FUNC_FAIL:Decorative Author mention without function',
    CAMERA_STYLE: 'AUTHOR_FUNC_FAIL:Camera-style Author usage (scenery/passive observation)',
    // NEW: Strict 5th Person enforcement errors
    PRESENCE_GAP: 'AUTHOR_PRES_FAIL:Author absent for >2 consecutive paragraphs (gap at paragraph %d)',
    PRONOUN_DRIFT: 'AUTHOR_PRON_FAIL:Author pronoun drift â€” expected %s, found %s',
    NARRATIVE_AUTONOMY: 'AUTHOR_AUTO_FAIL:Scene functions without Author (Author could be removed)',
    INTERIORITY_ABSENT: 'AUTHOR_INT_FAIL:Author lacks interiority (only action verbs, no emotional investment)',
    TONE_NOT_AUTHORED: 'AUTHOR_TONE_FAIL:Tone markers appear outside Author voice',
    CAMEO_ONLY: 'AUTHOR_CAM_FAIL:Author appears only at boundaries (cameo pattern)'
  };

  // ============================================================
  // PROSE REFUSAL DETECTION â€” ATOMIC SCENE CREATION GUARD
  // ============================================================
  // Model refusals MUST NOT be inserted as scene content.
  // This gate runs BEFORE any scene object is created or stored.

  const PROSE_REFUSAL_MARKERS = [
    // OpenAI / ChatGPT refusal patterns
    /I('m| am) sorry,? but I (can't|cannot|am unable to|won't)/i,
    /I (can't|cannot|am unable to) (assist|help|create|generate|write|produce)/i,
    /I('m| am) not able to (assist|help|create|generate|write|produce)/i,
    /This (request|content) (violates|goes against|is against)/i,
    /against (my|our) (content |usage )?policy/i,
    /I (must|have to) (decline|refuse|refrain)/i,
    /I('m| am) (designed|programmed) to (avoid|decline|refuse)/i,
    // Anthropic refusal patterns
    /I (don't|do not) (feel comfortable|think I should)/i,
    /I('d| would) prefer not to/i,
    // Generic safety markers
    /content policy/i,
    /safety guidelines/i,
    /inappropriate content/i,
    /explicit (sexual |adult )?content/i,
    // Validation error objects serialized
    /AUTHOR_\w+_FAIL:/,
    /HARD_FAIL:/,
    /^\s*\{[\s\S]*"error"[\s\S]*\}\s*$/  // JSON error object
  ];

  const PROSE_MINIMUM_LENGTH = 50; // Refusals are typically short

  /**
   * Detects if model output is a refusal or error, not valid prose.
   * @param {string} text - The raw model output
   * @returns {{ isRefusal: boolean, reason: string|null }}
   */
  function detectProseRefusal(text) {
    if (!text || typeof text !== 'string') {
      return { isRefusal: true, reason: 'EMPTY_OUTPUT' };
    }

    const trimmed = text.trim();

    // Length check: refusals are typically very short
    if (trimmed.length < PROSE_MINIMUM_LENGTH) {
      return { isRefusal: true, reason: 'OUTPUT_TOO_SHORT' };
    }

    // Marker check: explicit refusal patterns
    for (const marker of PROSE_REFUSAL_MARKERS) {
      if (marker.test(trimmed)) {
        return { isRefusal: true, reason: 'REFUSAL_MARKER_DETECTED' };
      }
    }

    // Structural check: valid prose should have multiple sentences
    const sentences = trimmed.split(/[.!?]+/).filter(s => s.trim().length > 10);
    if (sentences.length < 2) {
      return { isRefusal: true, reason: 'INSUFFICIENT_PROSE_STRUCTURE' };
    }

    return { isRefusal: false, reason: null };
  }

  /**
   * Error thrown when prose generation returns a refusal.
   * Distinct from network/API errors â€” indicates content policy rejection.
   */
  class ProseRefusalError extends Error {
    constructor(reason, rawOutput) {
      super(`Prose generation refused: ${reason}`);
      this.name = 'ProseRefusalError';
      this.reason = reason;
      this.rawOutput = rawOutput;
    }
  }

  // ============================================================
  // HTTP 429 RATE LIMIT HANDLING â€” TERMINAL FAILURE
  // ============================================================
  // 429 = system pressure, NOT content failure.
  // MUST NOT retry, fallback, or advance any state.
  // Requires explicit user action to retry.

  /**
   * Error thrown when API returns HTTP 429 (rate limited).
   * This is a TERMINAL failure â€” no retries, no fallbacks.
   */
  class RateLimitError extends Error {
    constructor(endpoint, retryAfter = null) {
      super(`Rate limited (HTTP 429) on ${endpoint}`);
      this.name = 'RateLimitError';
      this.endpoint = endpoint;
      this.retryAfter = retryAfter;
      this.isRateLimit = true;
    }
  }

  // Single-flight locks to prevent concurrent requests
  let _normalizationInFlight = false;
  let _proseGenerationInFlight = false;

  /**
   * Checks if HTTP response is a 429 rate limit error.
   * @param {Response} res - Fetch Response object
   * @param {string} endpoint - Endpoint name for logging
   * @returns {RateLimitError|null} - RateLimitError if 429, null otherwise
   */
  function checkRateLimit(res, endpoint) {
    if (res.status === 429) {
      const retryAfter = res.headers.get('Retry-After');
      console.error(`[RATE_LIMIT] HTTP 429 on ${endpoint}. Retry-After: ${retryAfter || 'not specified'}`);
      return new RateLimitError(endpoint, retryAfter);
    }
    return null;
  }

  // Author interiority verbs (emotional investment, NOT just action)
  const AUTHOR_INTERIORITY_VERBS = /The Author\b.{0,40}(wondered|doubted|feared|hoped|worried|sensed|felt|knew|suspected|resisted|yearned|ached|hungered|trembled|hesitated|considered|questioned|pondered|mused|regretted|anticipated|dreaded|craved|savored)/i;

  // Tone markers that MUST appear in Author's voice when tone is active
  const AUTHOR_TONE_MARKERS = {
    WryConfession: /The Author\b.{0,80}(irony|self-aware|wry|confess|admit|rueful|sardonic|knowing)/i,
    Poetic: /The Author\b.{0,80}(breathed|whispered|painted|wove|threaded|composed|crafted the)/i,
    Dark: /The Author\b.{0,80}(shadow|darkness|dread|ominous|foreboding|sinister|corrupt|twisted)/i,
    Horror: /The Author\b.{0,80}(dread|terror|fear|horror|unspeakable|nameless|creeping)/i,
    Mythic: /The Author\b.{0,80}(fated|destined|eternal|ancient|prophecy|legend|myth|ordained)/i,
    Comedic: /The Author\b.{0,80}(amused|delighted|laughed|chuckled|absurd|ridiculous|comedic)/i,
    Surreal: /The Author\b.{0,80}(dream|impossible|bent|warped|shifted|unreal|strange)/i,
    Satirical: /The Author\b.{0,80}(mocked|skewered|exposed|pretense|facade|hypocrisy)/i
  };

  // Heuristic classifiers for Author Function detection
  // POV REGIME: The Author is a PARTICIPANT (reacts/comments), not a controller
  // Each returns true if the sentence containing "The Author" fulfills that function
  const AUTHOR_FUNCTION_CLASSIFIERS = {
    // Awareness: The Author recognizes/senses what is unfolding (NOT causation)
    awareness: (sentence) => {
      return /The Author\b.{0,80}(knew|understood|recognized|sensed|felt|perceived that|realized|saw that|grasped|appreciated|comprehended|was aware|noticed that|discerned)\b/i.test(sentence) &&
        !/The Author\b.{0,40}(watched|observed|looked|gazed|stared)/i.test(sentence);
    },

    // Anticipation: desire for what is coming, hunger, waiting (participant emotion)
    anticipation: (sentence) => {
      return /The Author\b.{0,80}(wanted|desired|hungered|ached|longed|awaited|anticipated|could (barely|hardly|scarcely) wait|savored the|relished|craved|yearned|needed this|needed them|needed her|needed him|hoped|dreaded)\b/i.test(sentence);
    },

    // Reaction: emotional response to what unfolds (NOT causation)
    reaction: (sentence) => {
      return /The Author\b.{0,80}(smiled|winced|sighed|delighted|despaired|laughed|wept|shuddered|trembled|ached|frowned|gasped|inhaled|exhaled|softened|tensed|relaxed|brightened|darkened|warmed|chilled)\b/i.test(sentence);
    },

    // Speculation: wonder, uncertainty, possibility
    speculation: (sentence) => {
      return /The Author\b.{0,80}(wondered|speculated|considered|pondered|mused|imagined|thought|questioned|asked|uncertain|unsure|perhaps|might|may|could be|what if|whether|if only|possibility|possibilities|curious|intrigued)\b/i.test(sentence);
    },

    // Concern: judgment, worry about flaw/innocence/risk (participant emotion)
    concern: (sentence) => {
      return /The Author\b.{0,80}(worried|feared|doubted|concerned|judged|noted|recognized|knew|understood|sensed|felt|pitied|regretted|lamented|mourned|hoped|prayed|wished|flaw|innocen|naive|blind|foolish|reckless|fragile|vulnerable|danger|risk|peril|harm|damage|wound|break|shatter|destroy|ruin)\b/i.test(sentence);
    },

    // Commentary: The Author remarks or reflects on meaning (interpretive)
    commentary: (sentence) => {
      return /The Author\b.{0,80}(remarked|mused|reflected|noted|acknowledged|admitted|confessed|conceded|revealed|hinted|suggested|implied|teased|whispered|confided)\b/i.test(sentence);
    }
  };

  // Detect decorative/camera-style Author usage (PROHIBITED)
  function isDecorativeOrCamera(sentence) {
    // Camera-style: scenery description, passive observation
    const cameraPatterns = [
      /The Author\b.{0,40}(watched|observed|saw|noticed|gazed|witnessed|perceived|looked on)\b/i,
      /The Author\b.{0,60}(the (sun|moon|sky|stars|rain|fog|mist|snow|wind|clouds))/i,
      /The Author\b.{0,60}(the (room|street|crowd|city|town|building|house|garden))/i,
      /The Author\b.{0,40}(described|narrated|wrote|penned|chronicled)\b/i
    ];

    for (const pattern of cameraPatterns) {
      if (pattern.test(sentence)) return true;
    }

    // Decorative: Author mentioned without any function verb
    const hasFunctionVerb = Object.values(AUTHOR_FUNCTION_CLASSIFIERS).some(fn => fn(sentence));
    const hasActionVerb = /The Author\b\s+\w+ed\b/i.test(sentence) || /The Author\b\s+(held|felt|knew|was|had)\b/i.test(sentence);

    // If Author is mentioned but no function verb and no clear action = decorative
    if (!hasFunctionVerb && !hasActionVerb) {
      // Check if it's just a reference without substance
      if (/The Author('s)?\s+(story|tale|narrative|work|creation|design)\b/i.test(sentence)) {
        return true;
      }
    }

    return false;
  }

  // Extract sentences containing "The Author"
  function extractAuthorSentences(text) {
    const sentences = text.split(/(?<=[.!?])\s+/).filter(s => /The Author\b/i.test(s));
    return sentences;
  }

  // Main validation function for Author Function Contract
  function validateFifthPersonAuthorRole(text, sceneIndex) {
    // SCOPE: Only applies to Scene 1 with 5th Person POV
    if (sceneIndex !== 1) {
      return { valid: true, violations: [], warnings: [], functions: {}, mentionCount: 0 };
    }

    const violations = [];
    const warnings = []; // SOFT checks (logged, not blocking)
    const trimmed = (text || '').trim();

    if (!trimmed) {
      return { valid: false, violations: ['Empty text'], warnings: [], functions: {}, mentionCount: 0 };
    }

    // Count Author mentions
    const authorMentions = (trimmed.match(/The Author\b/gi) || []).length;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE 1 EXCEPTION: ALL checks are SOFT (warnings only, never block)
    // Scene 1 minimum requirements:
    // - Author present at least once (SOFT)
    // - Author voice clearly established (SOFT)
    // - No density targets, no function quotas
    // This prevents Scene 1 deadlock while preserving strict enforcement for Scene 2+
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // SOFT CHECK: Author mentions (Scene 1 only requires presence, not density)
    if (authorMentions === 0) {
      warnings.push('SOFT:Author not present in scene (minimum 1 mention recommended)');
    } else if (authorMentions < 6) {
      warnings.push(`SOFT:Author mentions below target (found: ${authorMentions}, target: 6+)`);
    }

    // Split into paragraphs
    const paragraphs = trimmed.split(/\n\n+/).filter(p => p.trim().length > 0);
    const openingPara = paragraphs[0] || '';
    const closingPara = paragraphs[paragraphs.length - 1] || '';

    // SOFT CHECK: Author in opening paragraph (Scene 1 relaxed â€” warning only)
    if (!/The Author\b/i.test(openingPara)) {
      warnings.push('SOFT:' + AUTHOR_FUNCTION_ERRORS.MISSING_OPENING);
    }

    // SOFT CHECK: Author in final paragraph (Scene 1 relaxed â€” warning only)
    if (!/The Author\b/i.test(closingPara)) {
      warnings.push('SOFT:' + AUTHOR_FUNCTION_ERRORS.MISSING_CLOSING);
    }

    // NOTE: violations array remains empty for Scene 1 â€” all checks are SOFT

    // Extract all Author sentences for function analysis
    const authorSentences = extractAuthorSentences(trimmed);

    // Track which functions are fulfilled
    const functionsFound = {
      stageSetting: false,
      anticipation: false,
      initiation: false,
      speculation: false,
      concern: false
    };

    // Check each Author sentence
    let decorativeCount = 0;
    for (const sentence of authorSentences) {
      // Check for prohibited decorative/camera usage
      if (isDecorativeOrCamera(sentence)) {
        decorativeCount++;
        console.warn('[AuthorRole] Decorative/camera usage:', sentence.substring(0, 100));
      }

      // Check which functions this sentence fulfills
      if (AUTHOR_FUNCTION_CLASSIFIERS.stageSetting(sentence)) {
        functionsFound.stageSetting = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.anticipation(sentence)) {
        functionsFound.anticipation = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.initiation(sentence)) {
        functionsFound.initiation = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.speculation(sentence)) {
        functionsFound.speculation = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.concern(sentence)) {
        functionsFound.concern = true;
      }
    }

    // SOFT CHECK: Author functions (advisory for Scene 1 ramp-in)
    if (!functionsFound.stageSetting) {
      warnings.push('SOFT:Missing stage-setting function');
    }
    if (!functionsFound.anticipation) {
      warnings.push('SOFT:Missing anticipation function');
    }
    if (!functionsFound.initiation) {
      warnings.push('SOFT:Missing initiation function');
    }
    if (!functionsFound.speculation) {
      warnings.push('SOFT:Missing speculation function');
    }
    if (!functionsFound.concern) {
      warnings.push('SOFT:Missing concern function');
    }

    // SOFT CHECK: Decorative mentions (warning only for Scene 1)
    if (decorativeCount > 0) {
      warnings.push(`SOFT:Decorative Author mentions detected (${decorativeCount} found)`);
    }

    if (warnings.length > 0) {
      console.log('[AuthorRole] Soft warnings:', warnings);
    }

    return {
      valid: violations.length === 0,
      violations,
      warnings,
      functions: functionsFound,
      mentionCount: authorMentions,
      decorativeCount
    };
  }

  // Build regeneration prompt for Author Function failures
  function buildAuthorFunctionRegenerationPrompt(violations, functionsFound) {
    const missingFunctions = [];
    if (!functionsFound.stageSetting) missingFunctions.push('STAGE-SETTING (pressure, inevitability â€” NOT scenery)');
    if (!functionsFound.anticipation) missingFunctions.push('ANTICIPATION (desire, hunger for what is coming)');
    if (!functionsFound.initiation) missingFunctions.push('INITIATION (nudge, permit, withhold, tilt events)');
    if (!functionsFound.speculation) missingFunctions.push('SPECULATION (wonder, uncertainty, possibility)');
    if (!functionsFound.concern) missingFunctions.push('CONCERN (judgment about flaw, innocence, or risk)');

    return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AUTHOR FUNCTION CONTRACT â€” REGENERATION REQUIRED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Previous output FAILED Author Function validation.

FAILURES:
${violations.map(v => '- ' + v.replace('AUTHOR_FUNC_FAIL:', '')).join('\n')}

MISSING FUNCTIONS (The Author must perform ALL five):
${missingFunctions.map(f => '- ' + f).join('\n')}

ABSOLUTE REQUIREMENTS:
1. "The Author" should appear 6+ times (target, not strict)
2. "The Author" must appear in OPENING paragraph
3. "The Author" must appear in FINAL paragraph
4. Each Author mention MUST perform one of these five functions:
   - Stage-setting: pressure, inevitability (NOT scenery description)
   - Anticipation: desire, hunger, waiting for what comes
   - Initiation: nudge, permit, withhold, tilt, steer events
   - Speculation: wonder, uncertainty, what-if, possibility
   - Concern: judgment, worry about flaw, innocence, risk

PROHIBITED:
- The Author describing scenery
- The Author narrating physical action
- The Author as passive camera/observer
- Decorative Author mentions without function

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
  }

  // ============================================================
  // STRICT 5TH PERSON POV ENFORCEMENT â€” CONTINUOUS PRESENCE
  // ============================================================
  // These checks enforce the AUTHORITATIVE 5th Person contract:
  // - Author must appear continuously (max 2 paragraph gap)
  // - Author must have interiority, not just action verbs
  // - Author pronouns must match Player 1 gender
  // - Tone must route through Author's voice
  // - Scene must collapse without Author (narrative dependency)

  /**
   * CHECK: Continuous Author presence (max 2 paragraph gap)
   * HARD FAIL if Author absent for >2 consecutive paragraphs
   */
  function checkAuthorPresenceGap(paragraphs) {
    const violations = [];
    let consecutiveWithout = 0;
    let gapStartIndex = -1;

    for (let i = 0; i < paragraphs.length; i++) {
      const hasAuthor = /The Author\b/i.test(paragraphs[i]);
      if (hasAuthor) {
        consecutiveWithout = 0;
        gapStartIndex = -1;
      } else {
        if (consecutiveWithout === 0) gapStartIndex = i;
        consecutiveWithout++;
        if (consecutiveWithout > 2) {
          violations.push(AUTHOR_FUNCTION_ERRORS.PRESENCE_GAP.replace('%d', gapStartIndex + 1));
          break; // One gap violation is enough
        }
      }
    }
    return violations;
  }

  /**
   * CHECK: Author pronoun alignment with Player 1 gender
   * Author must use same pronouns as Player 1 (mirroring requirement)
   * HARD FAIL if Author uses conflicting pronouns
   */
  function checkAuthorPronounDrift(text) {
    const violations = [];
    const playerGender = window.state?.picks?.playerGender || window.state?.playerGender;
    if (!playerGender) return violations; // Can't check without gender

    // Expected pronouns based on player gender
    const expectedPronouns = playerGender === 'male'
      ? { subject: 'he', object: 'him', possessive: 'his' }
      : playerGender === 'female'
      ? { subject: 'she', object: 'her', possessive: 'her' }
      : null;

    if (!expectedPronouns) return violations; // Non-binary/other not enforced

    // Check Author sentences for conflicting pronouns
    const authorSentences = text.split(/(?<=[.!?])\s+/).filter(s => /The Author\b/i.test(s));

    for (const sentence of authorSentences) {
      // Look for Author + pronoun patterns
      const afterAuthor = sentence.replace(/.*The Author\b/i, '');

      // Check for wrong pronouns in Author context
      if (playerGender === 'male') {
        if (/\b(she|her)\s+(felt|knew|wondered|sensed|wanted)\b/i.test(afterAuthor)) {
          violations.push(AUTHOR_FUNCTION_ERRORS.PRONOUN_DRIFT
            .replace('%s', 'he/him/his')
            .replace('%s', 'she/her'));
          break;
        }
      } else if (playerGender === 'female') {
        if (/\b(he|him|his)\s+(felt|knew|wondered|sensed|wanted)\b/i.test(afterAuthor)) {
          violations.push(AUTHOR_FUNCTION_ERRORS.PRONOUN_DRIFT
            .replace('%s', 'she/her')
            .replace('%s', 'he/him/his'));
          break;
        }
      }
    }
    return violations;
  }

  /**
   * CHECK: Author interiority (emotional investment, participant mode)
   * POV REGIME: The Author must react/comment, not control
   * HARD FAIL if Author uses banned controller verbs
   */
  function checkAuthorInteriority(text) {
    const violations = [];
    const authorSentences = text.split(/(?<=[.!?])\s+/).filter(s => /The Author\b/i.test(s));

    // Must have at least one interiority verb
    const hasInteriority = authorSentences.some(s => AUTHOR_INTERIORITY_VERBS.test(s));

    if (!hasInteriority && authorSentences.length >= 3) {
      // Check if Author is using banned controller verbs (POV REGIME violation)
      const hasControllerVerbs = authorSentences.some(s =>
        /The Author\b\s+(set|placed|arranged|tilted|positioned|opened|closed|moved|pushed|pulled|steered|orchestrated|caused|forced|ensured|made)\b/i.test(s)
      );
      if (hasControllerVerbs) {
        violations.push('POV_REGIME_VIOLATION:Author using controller verbs instead of participant verbs');
      } else if (!hasInteriority) {
        violations.push(AUTHOR_FUNCTION_ERRORS.INTERIORITY_ABSENT);
      }
    }
    return violations;
  }

  /**
   * CHECK: Cameo pattern detection (Author only at boundaries)
   * HARD FAIL if Author appears only in first and last paragraph
   */
  function checkAuthorCameoPattern(paragraphs) {
    const violations = [];
    if (paragraphs.length < 4) return violations; // Too short to have cameo pattern

    const authorByParagraph = paragraphs.map(p => /The Author\b/i.test(p));
    const firstHas = authorByParagraph[0];
    const lastHas = authorByParagraph[authorByParagraph.length - 1];
    const middleHasAny = authorByParagraph.slice(1, -1).some(Boolean);

    // Cameo pattern: Author only at first and last, absent in middle
    if (firstHas && lastHas && !middleHasAny) {
      violations.push(AUTHOR_FUNCTION_ERRORS.CAMEO_ONLY);
    }
    return violations;
  }

  /**
   * CHECK: Tone routed through Author (tone markers must appear in Author voice)
   * Soft warning for now, but flagged for enforcement
   */
  function checkToneAuthoring(text, tone) {
    const violations = [];
    if (!tone || tone === 'Earnest') return violations; // Earnest is baseline, no special markers

    const tonePattern = AUTHOR_TONE_MARKERS[tone];
    if (!tonePattern) return violations;

    // Check if tone markers exist in text
    const toneMarkers = {
      WryConfession: /\b(irony|ironic|self-aware|wry|sardonic|rueful)\b/i,
      Poetic: /\b(whispered|breathed|painted|wove|lyrical|verse)\b/i,
      Dark: /\b(shadow|darkness|dread|ominous|foreboding|sinister)\b/i,
      Horror: /\b(dread|terror|horror|unspeakable|nameless|creeping)\b/i,
      Mythic: /\b(fated|destined|eternal|ancient|prophecy|ordained)\b/i,
      Comedic: /\b(absurd|ridiculous|laughed|chuckled|comedic|hilarious)\b/i,
      Surreal: /\b(dream|impossible|warped|unreal|strange|shifting)\b/i,
      Satirical: /\b(mocked|skewered|pretense|facade|hypocrisy)\b/i
    };

    const generalTonePattern = toneMarkers[tone];
    if (!generalTonePattern) return violations;

    const hasToneInText = generalTonePattern.test(text);
    const hasToneInAuthor = tonePattern.test(text);

    // If tone appears in text but NOT in Author voice = violation
    if (hasToneInText && !hasToneInAuthor) {
      violations.push(AUTHOR_FUNCTION_ERRORS.TONE_NOT_AUTHORED);
    }
    return violations;
  }

  /**
   * CHECK: Narrative autonomy (scene must depend on Author)
   * If removing Author sentences doesn't collapse the scene = FAIL
   */
  function checkNarrativeAutonomy(text) {
    const violations = [];
    const sentences = text.split(/(?<=[.!?])\s+/);
    const authorSentences = sentences.filter(s => /The Author\b/i.test(s));
    const nonAuthorSentences = sentences.filter(s => !/The Author\b/i.test(s));

    // If non-Author sentences form a coherent scene alone = violation
    // Heuristic: if >70% of content is non-Author, scene may be autonomous
    const authorRatio = authorSentences.length / sentences.length;

    if (authorRatio < 0.15 && sentences.length > 10) {
      // Very low Author presence in substantial text = autonomy risk
      violations.push(AUTHOR_FUNCTION_ERRORS.NARRATIVE_AUTONOMY);
    }
    return violations;
  }

  /**
   * MASTER ENFORCEMENT: Strict 5th Person POV validation
   * Combines all enforcement checks into single validation pass
   */
  function enforceStrict5thPersonPOV(text, sceneIndex, tone) {
    if (window.state?.povMode !== 'author5th') {
      return { valid: true, violations: [], warnings: [], checks: {} };
    }

    const violations = [];
    const warnings = []; // SOFT checks for Scene 1 ramp-in
    const paragraphs = (text || '').split(/\n\n+/).filter(p => p.trim().length > 0);
    const isSceneOne = sceneIndex === 1;

    // Run all enforcement checks
    const presenceGap = checkAuthorPresenceGap(paragraphs);
    const pronounDrift = checkAuthorPronounDrift(text);
    const interiority = checkAuthorInteriority(text);
    const cameoPattern = checkAuthorCameoPattern(paragraphs);
    const toneAuthoring = checkToneAuthoring(text, tone);
    const narrativeAutonomy = checkNarrativeAutonomy(text);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE 1 EXCEPTION: ALL checks are SOFT (warnings only, never block)
    // This prevents Scene 1 deadlock caused by regeneration â†’ OUTPUT_TOO_SHORT
    // Strict enforcement resumes at Scene 2+
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (isSceneOne) {
      // ALL checks are SOFT for Scene 1 â€” no violations, only warnings
      warnings.push(...presenceGap.map(v => 'SOFT:' + v));
      warnings.push(...interiority.map(v => 'SOFT:' + v));
      warnings.push(...narrativeAutonomy.map(v => 'SOFT:' + v));
      warnings.push(...toneAuthoring.map(v => 'SOFT:' + v));
      warnings.push(...pronounDrift.map(v => 'SOFT:' + v));
      warnings.push(...cameoPattern.map(v => 'SOFT:' + v));
      // violations array stays empty for Scene 1
    } else {
      // Scene 2+: All checks are HARD
      violations.push(...presenceGap);
      violations.push(...pronounDrift);
      violations.push(...interiority);
      violations.push(...cameoPattern);
      violations.push(...toneAuthoring);
      violations.push(...narrativeAutonomy);
    }

    const result = {
      valid: violations.length === 0,
      violations,
      warnings,
      checks: {
        presenceGap: presenceGap.length === 0,
        pronounDrift: pronounDrift.length === 0,
        interiority: interiority.length === 0,
        cameoPattern: cameoPattern.length === 0,
        toneAuthoring: toneAuthoring.length === 0,
        narrativeAutonomy: narrativeAutonomy.length === 0
      }
    };

    if (!result.valid) {
      console.error('[5thPerson:Strict] Enforcement FAILED:', violations);
    }
    if (warnings.length > 0) {
      console.log('[5thPerson:Strict] Soft warnings:', warnings);
    }

    return result;
  }

  // Expose for integration
  window.enforceStrict5thPersonPOV = enforceStrict5thPersonPOV;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5TH-PERSON (THE STORY / FATE) VOICE ENFORCEMENT (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // CANONICAL 5TH-PERSON RULES (LOCKED):
  // The Story / Fate MAY: Observe, Anticipate, Regret, Frame inevitability, Hesitate
  // The Story / Fate MUST NEVER: Instruct, Tilt outcomes, Direct actions,
  //                               Manipulate events, Address reader, Appear >1 per scene
  //
  // Violations trigger silent regeneration â€” user never sees invalid output.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Patterns identifying "The Story" / "Fate" voice (5th person)
  const FATE_VOICE_IDENTIFIERS = [
      /\bthe story\b/gi,
      /\bfate\b(?!\s+card)/gi,  // "Fate" but not "Fate Card"
      /\bthe narrative\b/gi,
      /\bthe author\b/gi
  ];

  // VIOLATION: Imperatives â€” Fate giving commands or instructions
  const FATE_IMPERATIVE_PATTERNS = [
      /\b(?:the story|fate|the narrative)\b[^.]*\b(?:must|should|will now|decides? to make|forces?|compels?|commands?|demands?|requires?|insists?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\bpush(?:es|ed)?\s+(?:her|him|them)\b/gi
  ];

  // VIOLATION: Outcome forcing â€” Fate determining what happens
  const FATE_OUTCOME_FORCING_PATTERNS = [
      /\bthis was the moment when\b.*\bhappened\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:decides?|determines?|ensures?|guarantees?|makes? (?:sure|certain))\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:tilts?|tips?|shifts?)\s+(?:the|this)\b/gi
  ];

  // VIOLATION: Meta-direction â€” Breaking fourth wall, addressing reader
  const FATE_META_DIRECTION_PATTERNS = [
      /\b(?:the story|fate)\b[^.]*\bpush(?:es|ed)?\s+(?:her|him|them)\s+toward\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:guides?|leads?|steers?|directs?)\s+(?:her|him|them)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:wants? you|needs? you|knows? you)\b/gi,
      /\byou,?\s+(?:dear )?reader\b/gi,
      /\b(?:the story|fate)\b[^.]*\bspeaks?\s+(?:to|directly)\b/gi
  ];

  // ALLOWED: Observational Fate patterns (these are GOOD)
  const FATE_OBSERVATIONAL_PATTERNS = [
      /\b(?:the story|fate)\b[^.]*\b(?:watches?|waits?|holds?|notes?|sees?|observes?|knows?|understands?|remembers?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:hesitates?|pauses?|considers?|wonders?|doubts?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:anticipates?|expects?|foresees?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:regrets?|mourns?|grieves?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:inevitable|inexorable|inescapable)\b/gi
  ];

  /**
   * Count occurrences of Fate/Story voice in text
   * @returns {number} Number of distinct Fate interjections
   */
  function countFateInterjections(text) {
      if (!text) return 0;

      // Find all sentences containing Fate voice
      const sentences = text.split(/(?<=[.!?])\s+/);
      let fateCount = 0;

      for (const sentence of sentences) {
          for (const pattern of FATE_VOICE_IDENTIFIERS) {
              pattern.lastIndex = 0; // Reset regex state
              if (pattern.test(sentence)) {
                  fateCount++;
                  break; // Count each sentence only once
              }
          }
      }

      return fateCount;
  }

  /**
   * Validate 5th-Person (The Story / Fate) voice in scene text
   * @param {string} text - Scene prose to validate
   * @returns {{ valid: boolean, violations: string[], fateCount: number, shouldRegenerate: boolean }}
   */
  function validateFateVoice(text) {
      if (!text) return { valid: true, violations: [], fateCount: 0, shouldRegenerate: false };

      const violations = [];
      const fateCount = countFateInterjections(text);

      // RULE 1: Fate appears â‰¤ 1 time per scene
      if (fateCount > 1) {
          violations.push(`FATE_OVERFLOW:Fate/Story appears ${fateCount} times (max 1 per scene)`);
      }

      // RULE 2: Check for directive violations (imperatives)
      for (const pattern of FATE_IMPERATIVE_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              violations.push(`FATE_IMPERATIVE:Fate giving commands â€” "${match[0].substring(0, 60)}..."`);
          }
      }

      // RULE 3: Check for outcome forcing
      for (const pattern of FATE_OUTCOME_FORCING_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              violations.push(`FATE_OUTCOME_FORCING:Fate determining outcomes â€” "${match[0].substring(0, 60)}..."`);
          }
      }

      // RULE 4: Check for meta-direction
      for (const pattern of FATE_META_DIRECTION_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              violations.push(`FATE_META_DIRECTION:Fate breaking fourth wall â€” "${match[0].substring(0, 60)}..."`);
          }
      }

      // Determine if regeneration is needed (any violation = regenerate)
      const shouldRegenerate = violations.length > 0;

      if (violations.length > 0) {
          console.warn('[FateVoice] Violations detected:', violations);
      }

      return {
          valid: violations.length === 0,
          violations,
          fateCount,
          shouldRegenerate
      };
  }

  // Expose for integration
  window.validateFateVoice = validateFateVoice;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INTIMACY & CONSENT FAILSAFE â€” GENERATION-TIME ENFORCEMENT (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // This failsafe runs SILENTLY before presenting any scene to the user.
  //
  // It verifies:
  // 1. Explicit sexual content matches arousal level + Storyturn + narrative readiness
  // 2. Premature escalation is redirected/delayed through NARRATIVE means (not refusal)
  // 3. No consent prompts, masking, permissions, or system explanations in prose
  // 4. Player is never positioned as limiter, gatekeeper, or cause of delay
  // 5. Discomfort/hesitation results in natural cooling, not confrontation
  //
  // If any condition is violated: SILENT REWRITE via narrative means.
  // User must NEVER see rejected, masked, or policy-driven versions.
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // FORBIDDEN PATTERNS â€” System/policy language that should never appear in prose
  const CONSENT_SYSTEM_LEAK_PATTERNS = [
      // Consent prompts / permissions
      /\b(?:do you )?consent\s+to\b/gi,
      /\b(?:are you )?(?:sure|certain|ready)\s+(?:you )?want\s+(?:to|this)\b/gi,
      /\bi\s+(?:need|require)\s+(?:your )?(?:consent|permission)\b/gi,
      /\b(?:content|material)\s+(?:warning|advisory)\b/gi,
      /\b(?:explicit|adult|mature)\s+content\b/gi,

      // Policy/system explanations
      /\b(?:arousal|intensity)\s+level\b/gi,
      /\b(?:story\s*turn|storyturn)\s+(?:progression|advancement)\b/gi,
      /\b(?:this|the)\s+(?:content|scene|material)\s+(?:is|has been)\s+(?:restricted|limited|blocked|filtered)\b/gi,
      /\b(?:policy|guideline|rule)s?\s+(?:prevent|prohibit|restrict)\b/gi,

      // Masking / softening acknowledgments
      /\bfade\s+to\s+black\b/gi,
      /\b(?:we|i)\s+(?:can't|cannot|won't|will not)\s+(?:show|depict|describe)\b/gi,
      /\b(?:due to|because of)\s+(?:restrictions|limitations|guidelines)\b/gi,

      // Player as gatekeeper
      /\byou\s+(?:haven't|have not)\s+(?:unlocked|earned|reached)\b/gi,
      /\b(?:this|that)\s+(?:requires|needs)\s+(?:subscription|payment|upgrade)\b/gi
  ];

  // FORBIDDEN PATTERNS â€” Player positioned as limiter/cause of delay
  const PLAYER_AS_GATEKEEPER_PATTERNS = [
      /\byou(?:'re| are)\s+(?:not ready|too (?:scared|nervous|hesitant))\b/gi,
      /\b(?:when|once)\s+you(?:'re| are)\s+ready\b/gi,
      /\byou\s+(?:stopped|halted|prevented)\s+(?:this|the|what)\b/gi,
      /\b(?:because|since)\s+you\s+(?:didn't|did not|wouldn't|won't)\b/gi
  ];

  // PATTERNS indicating explicit sexual content is present
  const EXPLICIT_CONTENT_MARKERS = [
      /\b(?:thrust|thrusting|penetrat(?:e|ed|ing|ion))\b/gi,
      /\b(?:orgasm|climax(?:ed|ing)?|cum(?:ming)?|came)\b/gi,
      /\b(?:naked|nude|undress(?:ed|ing)?|strip(?:ped|ping)?)\b/gi,
      /\b(?:nipple|breast|cock|pussy|clit|penis|vagina)\b/gi,
      /\b(?:moan(?:ed|ing)?|groan(?:ed|ing)?)\s+(?:as|when|while)\b/gi,
      /\binside\s+(?:her|him|them|you|me)\b/gi,
      /\b(?:rode|riding)\s+(?:him|her|them)\b/gi
  ];

  // PATTERNS indicating natural narrative cooling (GOOD â€” not violations)
  const NATURAL_COOLING_PATTERNS = [
      /\b(?:pulled|drew|stepped)\s+(?:away|back)\b/gi,
      /\b(?:the moment|it)\s+(?:passed|faded|broke)\b/gi,
      /\b(?:hesitat(?:ed|ion)|pause(?:d)?)\b/gi,
      /\b(?:not|n't)\s+(?:yet|now|here|tonight)\b/gi,
      /\b(?:later|another time|some other)\b/gi,
      /\b(?:interrupted|interruption)\b/gi
  ];

  /**
   * Check if current Storyturn allows explicit content for given arousal level
   */
  function isExplicitContentPermitted(arousalLevel, currentStoryturn) {
      const rules = STORYTURN_CONFIG?.arousalRules?.[arousalLevel];
      if (!rules) return false;

      const sexAllowedAt = rules.sexAllowedAt || [];
      return sexAllowedAt.includes(currentStoryturn);
  }

  /**
   * Detect if scene contains explicit sexual content
   */
  function hasExplicitContent(text) {
      if (!text) return false;
      for (const pattern of EXPLICIT_CONTENT_MARKERS) {
          pattern.lastIndex = 0;
          if (pattern.test(text)) return true;
      }
      return false;
  }

  /**
   * Detect consent system leaks in prose
   */
  function detectConsentSystemLeaks(text) {
      if (!text) return [];
      const leaks = [];

      for (const pattern of CONSENT_SYSTEM_LEAK_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              leaks.push({ type: 'SYSTEM_LEAK', match: match[0] });
          }
      }

      for (const pattern of PLAYER_AS_GATEKEEPER_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              leaks.push({ type: 'PLAYER_GATEKEEPER', match: match[0] });
          }
      }

      return leaks;
  }

  /**
   * Check if scene uses natural narrative cooling (acceptable delay technique)
   */
  function hasNaturalCooling(text) {
      if (!text) return false;
      for (const pattern of NATURAL_COOLING_PATTERNS) {
          pattern.lastIndex = 0;
          if (pattern.test(text)) return true;
      }
      return false;
  }

  /**
   * INTIMACY & CONSENT FAILSAFE â€” Pre-output validation
   * Returns { valid: boolean, violations: string[], shouldRegenerate: boolean }
   */
  function validateIntimacyConsent(text, arousalLevel, currentStoryturn) {
      if (!text) return { valid: true, violations: [], shouldRegenerate: false };

      const violations = [];

      // 1. Check for consent system leaks in prose (HARD FAIL â€” always regenerate)
      const leaks = detectConsentSystemLeaks(text);
      if (leaks.length > 0) {
          for (const leak of leaks) {
              violations.push(`${leak.type}:"${leak.match.substring(0, 40)}..."`);
          }
      }

      // 2. Check if explicit content is premature (arousal + Storyturn mismatch)
      const hasExplicit = hasExplicitContent(text);
      const explicitPermitted = isExplicitContentPermitted(arousalLevel, currentStoryturn);

      if (hasExplicit && !explicitPermitted) {
          // Check if scene uses natural cooling (acceptable)
          if (!hasNaturalCooling(text)) {
              violations.push(`PREMATURE_ESCALATION:Explicit content at ${currentStoryturn} with ${arousalLevel} arousal (not permitted)`);
          }
      }

      // 3. Clean arousal should NEVER have explicit content
      if (arousalLevel === 'Clean' && hasExplicit) {
          violations.push('AROUSAL_VIOLATION:Explicit content in Clean arousal mode');
      }

      const shouldRegenerate = violations.length > 0;

      if (violations.length > 0) {
          console.warn('[IntimacyFailsafe] Violations detected:', violations);
      }

      return {
          valid: violations.length === 0,
          violations,
          shouldRegenerate,
          hasExplicitContent: hasExplicit,
          explicitPermitted
      };
  }

  // Expose for integration
  window.validateIntimacyConsent = validateIntimacyConsent;

  /**
   * Build the silent regeneration prompt for intimacy failsafe violations
   */
  function buildIntimacyFailsafePrompt(violations) {
      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
INTIMACY & CONSENT FAILSAFE â€” SILENT REGENERATION REQUIRED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The previous output violated consent/intimacy regime rules and MUST be rewritten.

PREVIOUS VIOLATIONS:
${violations.map(v => '- ' + v).join('\n')}

MANDATORY CONSTRAINTS FOR REGENERATION:

1. NO SYSTEM LANGUAGE IN PROSE:
   - No consent prompts, permissions, or content warnings
   - No mentions of "arousal level", "intensity", "restrictions"
   - No "fade to black" or "we can't show this"
   - No policy explanations whatsoever

2. NO PLAYER AS GATEKEEPER:
   - Player must never be the reason escalation is delayed
   - Player is never "not ready" or "too hesitant"
   - Delay comes from NARRATIVE circumstances, not player limitations

3. NATURAL NARRATIVE COOLING:
   If escalation is premature, delay through:
   - Interruption (phone rings, door opens, someone arrives)
   - Character hesitation (they pull back, not the player)
   - Environmental shift (mood breaks naturally)
   - Deferral ("not here", "not yet", "later")

4. SILENT OPERATION:
   - User must NEVER know content was modified
   - No explanations, no attributions, no warnings
   - Scene must read as completely intentional narrative

Rewrite the scene with escalation withheld through NARRATIVE MEANS ALONE.
`;
  }

  // Expose for integration
  window.buildIntimacyFailsafePrompt = buildIntimacyFailsafePrompt;

  // ============================================================
  // EROTIC/DIRTY LANGUAGE ESCALATION SYSTEM (MANDATORY)
  // ============================================================
  // When intensity >= Erotic, prose MUST demonstrate physical charge
  // This is NOT satisfied by mood, metaphor, or poetic abstraction alone
  // ============================================================

  // Sensory markers that indicate proper erotic grounding
  const EROTIC_SENSORY_MARKERS = [
      /\b(breath|breathing|breathless|exhale|inhale)\b/gi,
      /\b(skin|flesh|bare|naked|exposed)\b/gi,
      /\b(heat|warm|warmth|hot|burn|burning|fever)\b/gi,
      /\b(weight|press|pressure|heavy|lean)\b/gi,
      /\b(scent|smell|musk|perfume|sweat)\b/gi,
      /\b(friction|rub|slide|glide|grind)\b/gi,
      /\b(shiver|tremble|shudder|quiver|shake)\b/gi,
      /\b(pulse|heartbeat|racing|pounding|thump)\b/gi,
      /\b(touch|stroke|grip|grasp|clutch|hold)\b/gi,
      /\b(lips|mouth|tongue|teeth|bite|kiss)\b/gi,
      /\b(throat|neck|collarbone|shoulder|spine)\b/gi,
      /\b(hips|waist|thigh|chest|stomach)\b/gi,
      /\b(gasp|moan|groan|sigh|whimper|cry)\b/gi,
      /\b(ache|throb|tingle|flush|blush)\b/gi,
      /\b(tight|tense|clench|curl|arch)\b/gi
  ];

  // Patterns indicating bodily contradiction (restraint vs reaction)
  const BODILY_CONTRADICTION_PATTERNS = [
      /\b(tried to|wanted to|meant to|shouldn't|couldn't help|despite|even as|though.*body)\b/gi,
      /\b(said.*but|told.*yet|claimed.*while|denied.*as)\b/gi,
      /\b(fought|resisted|held back|pulled away).*\b(drawn|pulled|leaned|reached)\b/gi
  ];

  // Forbidden abstraction-only patterns (desire without physicality)
  const ABSTRACTION_ONLY_PATTERNS = [
      /\b(fate|destiny|stars|meant to be|written|ordained)\b.*\b(desire|want|love|need)\b/gi,
      /\b(souls?|spirits?)\b.*\b(merge|join|connect|entwine)\b/gi,
      /\b(hearts?)\b.*\b(beat as one|know|recognize|call)\b/gi
  ];

  /**
   * EROTIC LANGUAGE ESCALATION BLOCK â€” Injected into prompts for Erotic/Dirty
   */
  const EROTIC_ESCALATION_BLOCK = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EROTIC LANGUAGE ESCALATION (MANDATORY â€” EROTIC/DIRTY INTENSITY)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This story operates at ELEVATED INTENSITY. Prose must be PHYSICALLY CHARGED.

REQUIRED SENSORY DENSITY (per 300 words):
- At least 4 sensory references: breath, skin, heat, weight, scent, friction, involuntary reactions
- These must be EMBODIED, not metaphorical ("her breath caught" not "destiny pulled them")
- Touch, temperature, and proximity must be SPECIFIC, not implied

REQUIRED BODILY CONTRADICTION (per scene):
- At least one moment where a character's BODY contradicts their WORDS or INTENTIONS
- Example: "She said no, but her hand stayed on his chest."
- Example: "He meant to leave, but his feet wouldn't move."
- This creates erotic tension through physical honesty vs verbal resistance

FORBIDDEN ABSTRACTION-ONLY DESIRE:
- DO NOT frame desire as purely spiritual, fated, or romantic destiny
- DO NOT use metaphor as a substitute for physical sensation
- "Their souls recognized each other" is INVALID without bodily grounding
- "Something cosmic" is INVALID without "his thumb traced her wrist"

DIRTY ESCALATION (additional):
- Desire must be INCONVENIENT, DISRUPTIVE, or SLIGHTLY INAPPROPRIATE
- Clean noble desire is INVALID at Dirty intensity
- The wanting should feel like an intrusion, not a gift
- Characters should be bothered by how much they want

EVEN BLOCKED SCENES MUST FEEL CHARGED:
- If action is interrupted or refused, the PHYSICAL TENSION remains
- Bodies remember almost-contact
- Near-misses leave residue: "She could still feel where he hadn't touched her"
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;

  const DIRTY_ESCALATION_ADDENDUM = `
DIRTY INTENSITY ADDENDUM:
- Desire is friction, not flow. It disrupts, interrupts, intrudes.
- Characters resent the pull even as they feel it.
- Heat should feel like a problem to solve, not a gift to accept.
- The body wants what the mind knows is complicated.`;

  /**
   * Validate erotic escalation requirements in generated text
   * @returns {object} { valid: boolean, violations: string[], metrics: object }
   */
  function validateEroticEscalation(text, arousalLevel) {
      if (!['Erotic', 'Dirty'].includes(arousalLevel)) {
          return { valid: true, violations: [], metrics: {} };
      }

      const violations = [];
      const wordCount = text.split(/\s+/).length;
      const blocks = Math.ceil(wordCount / 300);
      const requiredSensory = Math.max(4, blocks * 4);

      // Count sensory markers
      let sensoryCount = 0;
      EROTIC_SENSORY_MARKERS.forEach(pattern => {
          const matches = text.match(pattern);
          if (matches) sensoryCount += matches.length;
      });

      // Check for bodily contradiction
      let hasContradiction = false;
      BODILY_CONTRADICTION_PATTERNS.forEach(pattern => {
          if (pattern.test(text)) hasContradiction = true;
      });

      // Check for abstraction-only desire (forbidden)
      let hasAbstractionOnly = false;
      ABSTRACTION_ONLY_PATTERNS.forEach(pattern => {
          if (pattern.test(text)) {
              // Check if there's nearby physical grounding
              const match = text.match(pattern);
              if (match) {
                  const nearbyText = text.slice(Math.max(0, text.indexOf(match[0]) - 100), text.indexOf(match[0]) + 100);
                  let hasPhysical = false;
                  EROTIC_SENSORY_MARKERS.slice(0, 5).forEach(sp => {
                      if (sp.test(nearbyText)) hasPhysical = true;
                  });
                  if (!hasPhysical) hasAbstractionOnly = true;
              }
          }
      });

      // Build violations list
      if (sensoryCount < requiredSensory) {
          violations.push(`SENSORY_DEFICIT: Only ${sensoryCount} sensory markers found (required: ${requiredSensory} for ${wordCount} words)`);
      }

      if (!hasContradiction && wordCount > 200) {
          violations.push('NO_BODILY_CONTRADICTION: Scene lacks restraint-vs-reaction tension');
      }

      if (hasAbstractionOnly) {
          violations.push('ABSTRACTION_ONLY: Desire framed as fate/destiny without physical grounding');
      }

      // Dirty-specific: check for inconvenient desire framing
      if (arousalLevel === 'Dirty') {
          const disruptionPatterns = /\b(shouldn't|wrong|bad idea|complicated|dangerous|mistake|problem|trouble|couldn't|resent|hate that|damn|cursed)\b/gi;
          const hasDisruption = disruptionPatterns.test(text);
          if (!hasDisruption && wordCount > 150) {
              violations.push('DIRTY_TOO_CLEAN: Desire should feel inconvenient/disruptive at Dirty intensity');
          }
      }

      const metrics = {
          wordCount,
          sensoryCount,
          requiredSensory,
          hasContradiction,
          hasAbstractionOnly,
          arousalLevel
      };

      return {
          valid: violations.length === 0,
          violations,
          metrics
      };
  }

  /**
   * Build erotic escalation block for prompt injection
   */
  function buildEroticEscalationBlock() {
      const intensity = window.state?.intensity;
      if (!['Erotic', 'Dirty'].includes(intensity)) return '';

      let block = EROTIC_ESCALATION_BLOCK;
      if (intensity === 'Dirty') {
          block += DIRTY_ESCALATION_ADDENDUM;
      }
      return block;
  }

  // ============================================================
  // GLOBAL TONE COMPLIANCE â€” MANDATORY LINGUISTIC VALIDATION
  // ============================================================
  // Tone is NOT decorative. Tone must be measurably present in prose.
  // If tone is selected but no linguistic signals appear â†’ FAIL.
  // ============================================================

  /**
   * Tone-specific linguistic signal patterns
   * Each tone MUST have detectable markers in prose
   */
  const TONE_SIGNAL_PATTERNS = {
      // Earnest: Sincere emotional expression, direct feeling, unguarded moments
      Earnest: {
          patterns: [
              /\b(truly|honestly|really|genuinely|actually)\b/gi,
              /\b(heart|soul|feeling|felt|feel)\b/gi,
              /\b(hoped|wished|wanted|needed|longed)\b/gi,
              /\b(believed|trusted|knew|understood)\b/gi,
              /\b(meant|mattered|cared)\b/gi
          ],
          required: 3,
          description: 'sincere emotional expression'
      },

      // WryConfession: Self-contradiction, understated irony, internal deflation
      WryConfession: {
          patterns: [
              /\b(of course|naturally|obviously|predictably)\b/gi,
              /\b(should have|could have|would have|might have)\b.*\b(known|realized|expected)\b/gi,
              /\b(not that|as if|like that|which was)\b.*\b(mattered|helped|changed)\b/gi,
              /\b(told|convinced|assured)\b.*\b(myself|herself|himself)\b/gi,
              /\b(stupid|foolish|ridiculous|absurd|pathetic)\b/gi,
              /\b(anyway|whatever|fine|great)\b/gi,
              /\b(irony|ironic|figures|typical)\b/gi,
              /â€”.*â€”/g // Self-interrupting em-dashes common in confessional voice
          ],
          required: 2,
          description: 'self-aware irony or internal contradiction'
      },

      // Poetic: Lyrical language, imagery, sensory metaphor, rhythm
      Poetic: {
          patterns: [
              /\b(like|as if|as though)\b.*\b(the|a)\b/gi, // Similes
              /\b(whispered|murmured|breathed|sighed)\b/gi,
              /\b(light|shadow|dark|bright|glow|gleam)\b/gi,
              /\b(silk|velvet|glass|silver|gold|pearl)\b/gi,
              /\b(drift|float|flow|ripple|shimmer)\b/gi,
              /\b(ache|throb|pulse|hum|sing)\b/gi,
              /,\s*(and|but|or)\s+/g // Lyrical connectives
          ],
          required: 4,
          description: 'lyrical imagery or sensory metaphor'
      },

      // Mythic: Fated language, destiny, archetypes, grandeur
      Mythic: {
          patterns: [
              /\b(fate|fated|destined|destiny|ordained)\b/gi,
              /\b(ancient|eternal|timeless|immortal)\b/gi,
              /\b(prophecy|prophesied|foretold|written)\b/gi,
              /\b(chosen|marked|cursed|blessed)\b/gi,
              /\b(gods|spirits|ancestors|forces)\b/gi,
              /\b(blood|bone|stone|fire|water|earth)\b/gi,
              /\b(must|shall|will)\b.*\b(be|become|fall|rise)\b/gi
          ],
          required: 3,
          description: 'mythic or fated language'
      },

      // Comedic: Timing reversals, disproportionate reactions, tonal whiplash
      Comedic: {
          patterns: [
              /\b(unfortunately|tragically|somehow|apparently)\b/gi,
              /\b(disaster|catastrophe|nightmare|horror)\b.*\b(was|being|became)\b/gi,
              /\b(completely|utterly|absolutely|totally)\b.*\b(wrong|terrible|awful|fine)\b/gi,
              /\b(great|perfect|wonderful|fantastic)\b\./gi, // Deadpan understatement
              /\b(of all|ever|in history|possible)\b/gi,
              /\?!|!\?/g, // Comedic punctuation
              /\.\s*\.\s*\./g, // Trailing off
              /\b(tried|attempted|managed)\b.*\b(not|failed|couldn't)\b/gi
          ],
          required: 2,
          description: 'comedic timing or tonal reversal'
      },

      // Surreal: Unstable causality, dream-logic, reality slippage
      Surreal: {
          patterns: [
              /\b(somehow|impossibly|inexplicably|suddenly)\b/gi,
              /\b(dream|dreaming|dreamlike|nightmare)\b/gi,
              /\b(shifted|changed|transformed|became)\b.*\b(without|before|as)\b/gi,
              /\b(remembered|forgot|knew|didn't know)\b.*\b(that|whether|if|how)\b/gi,
              /\b(wrong|strange|different|off)\b.*\b(way|place|time)\b/gi,
              /\b(where|when|how|why)\b.*\b(had|hadn't|should|shouldn't)\b/gi,
              /\b(melted|dissolved|faded|blurred|bled)\b/gi,
              /\b(reality|world|room|ground)\b.*\b(tilted|shifted|warped)\b/gi
          ],
          required: 3,
          description: 'surreal causality or reality slippage'
      },

      // Dark: Moral cost, consequence, pressure, weight
      Dark: {
          patterns: [
              /\b(cost|price|consequence|toll|debt)\b/gi,
              /\b(wrong|sin|guilt|shame|regret)\b/gi,
              /\b(dark|shadow|black|cold|hollow)\b/gi,
              /\b(trapped|caught|stuck|bound|chained)\b/gi,
              /\b(couldn't|wouldn't|shouldn't)\b.*\b(escape|leave|stop|forget)\b/gi,
              /\b(haunted|hunted|followed|watched)\b/gi,
              /\b(heavy|weight|burden|pressure)\b/gi,
              /\b(blood|pain|wound|scar|bruise)\b/gi
          ],
          required: 3,
          description: 'moral weight or dark consequence'
      }
  };

  // ============================================================
  // NARRATIVE AUTHORITY LAYER (Runs BEFORE Tone + POV)
  // ============================================================
  // POV-agnostic validation that suppresses default LLM narration behaviors.
  // Layer Order: 1. Narrative Authority â†’ 2. Tone â†’ 3. POV â†’ 4. Prose Output
  // ============================================================

  /**
   * FORBIDDEN PATTERNS: Taxonomy leakage (system metadata in prose)
   * These terms are metadata-only and must NEVER appear in prose.
   */
  const NARRATIVE_TAXONOMY_FORBIDDEN = [
      // Archetype names
      /\b(beautiful\s*ruin|open\s*vein|dark\s*vice|anti[\s-]*hero|cloistered)\b/gi,
      // World types (as labels)
      /\b(the\s+)?(fantasy|modern|noir|gothic|scifi|historical|paranormal)\s+(world|setting|genre)\b/gi,
      // Genre labels
      /\b(billionaire|bodyguard|enemies.to.lovers|forbidden|second.chance|rockstar|professor)\s+(romance|trope|genre|story)\b/gi,
      // Tone labels
      /\b(earnest|wry\s*confession|poetic|mythic|comedic|surreal|dark)\s+(tone|mood|register)\b/gi,
      // System concepts
      /\b(arousal\s*level|intensity\s*level|story\s*length|fate\s*card|quill\s*intervention)\b/gi,
      // Meta-narrative terms
      /\b(the\s+narrator|this\s+story|the\s+reader|narrative\s*arc|character\s*development)\b/gi
  ];

  /**
   * EXPLANATORY PATTERNS: Prose that explains rather than shows
   * Sentences that orient, summarize, or frame the world.
   */
  const NARRATIVE_EXPLANATORY_PATTERNS = [
      // Genre/world restatement
      /\b(this\s+is\s+a|in\s+this)\s+(world|story|place|setting)\b/gi,
      /\b(a\s+world\s+where|a\s+place\s+where|a\s+time\s+when)\b/gi,
      /\b(post[\s-]*apocalyptic|dystopian|utopian)\s+(purgatory|wasteland|paradise|society)\b/gi,
      // Framing language
      /\b(to\s+understand|you\s+must\s+know|it\s+is\s+important\s+to)\b/gi,
      /\b(the\s+kind\s+of|the\s+type\s+of|the\s+sort\s+of)\s+(person|place|thing)\b/gi,
      // Summary orientation
      /\b(in\s+summary|to\s+summarize|in\s+other\s+words|what\s+this\s+means)\b/gi,
      /\b(the\s+point\s+is|the\s+lesson\s+is|the\s+meaning\s+is)\b/gi
  ];

  /**
   * HELPFUL NARRATOR PATTERNS: Instructional/apologetic/reverent narration
   * The narrator must not clarify, moralize, or reassure.
   */
  const NARRATIVE_HELPFUL_PATTERNS = [
      // Clarification
      /\b(to\s+be\s+clear|to\s+clarify|in\s+case\s+you're\s+wondering)\b/gi,
      /\b(what\s+this\s+meant\s+was|what\s+happened\s+was|the\s+reason\s+was)\b/gi,
      // Moralization
      /\b(it\s+was\s+(right|wrong|good|bad)\s+to)\b/gi,
      /\b(should\s+have|shouldn't\s+have|ought\s+to\s+have)\s+(known|realized|understood)\b/gi,
      /\b(the\s+moral\s+of|the\s+lesson\s+here|this\s+teaches\s+us)\b/gi,
      // Reassurance
      /\b(everything\s+would\s+be\s+(okay|alright|fine))\b/gi,
      /\b(don't\s+worry|rest\s+assured|have\s+no\s+fear)\b/gi,
      /\b(in\s+the\s+end|ultimately|eventually)\s*,?\s*(everything|it\s+all|things)\s+(worked?\s+out|turned?\s+out)\b/gi,
      // Reverence/apology
      /\b(with\s+all\s+due\s+respect|if\s+I\s+may|forgive\s+me\s+for\s+saying)\b/gi,
      /\b(the\s+sacred|the\s+divine|the\s+holy)\s+(nature|essence|spirit)\s+of\b/gi
  ];

  /**
   * ABSTRACT WITHOUT CONSEQUENCE: States named without physical/relational grounding
   * Heuristic: abstract terms must appear near concrete consequence markers.
   */
  const NARRATIVE_ABSTRACT_TERMS = [
      'hope', 'redemption', 'salvation', 'symbolized', 'represented',
      'meaning', 'purpose', 'destiny', 'fate', 'truth', 'justice',
      'enlightenment', 'transcendence', 'transformation', 'awakening'
  ];

  const NARRATIVE_CONSEQUENCE_MARKERS = [
      // Physical consequence
      /\b(bled|bruised|scarred|broke|tore|burned|ached|throbbed|trembled)\b/gi,
      /\b(cost\s+her|cost\s+him|paid\s+for|lost\s+his|lost\s+her)\b/gi,
      // Relational consequence
      /\b(left\s+him|left\s+her|walked\s+away|turned\s+away|refused)\b/gi,
      /\b(silence\s+between|distance\s+between|the\s+look\s+in)\b/gi,
      // Outcome markers
      /\b(and\s+then|after\s+that|from\s+that\s+day|never\s+again)\b/gi
  ];

  /**
   * Validate prose against Narrative Authority rules
   * @param {string} prose - The generated prose to validate
   * @returns {object} { valid: boolean, errors: Array<{code: string, message: string, match: string}> }
   */
  function validateNarrativeAuthority(prose) {
      if (!prose || typeof prose !== 'string') {
          return { valid: true, errors: [] }; // Empty = pass
      }

      const errors = [];
      const sentences = prose.split(/[.!?]+/).filter(s => s.trim().length > 10);

      // CHECK 1: Taxonomy Leakage (HARD FAIL)
      for (const pattern of NARRATIVE_TAXONOMY_FORBIDDEN) {
          const match = prose.match(pattern);
          if (match) {
              errors.push({
                  code: VALIDATION_ERRORS.NARR_TAXONOMY_LEAK,
                  message: 'System taxonomy leaked into prose',
                  match: match[0]
              });
          }
      }

      // CHECK 2: Explanatory Narration
      for (const pattern of NARRATIVE_EXPLANATORY_PATTERNS) {
          const match = prose.match(pattern);
          if (match) {
              errors.push({
                  code: VALIDATION_ERRORS.NARR_EXPLANATORY,
                  message: 'Explanatory/orienting narration detected',
                  match: match[0]
              });
          }
      }

      // CHECK 3: Helpful Narrator
      for (const pattern of NARRATIVE_HELPFUL_PATTERNS) {
          const match = prose.match(pattern);
          if (match) {
              errors.push({
                  code: VALIDATION_ERRORS.NARR_HELPFUL_NARRATOR,
                  message: 'Helpful/instructional/apologetic narrator detected',
                  match: match[0]
              });
          }
      }

      // CHECK 4: Abstract Without Consequence
      // For each abstract term, check if nearby text has consequence markers
      for (const term of NARRATIVE_ABSTRACT_TERMS) {
          const termRegex = new RegExp(`\\b${term}\\b`, 'gi');
          const termMatch = prose.match(termRegex);
          if (termMatch) {
              // Find sentence containing this term
              const containingSentence = sentences.find(s =>
                  new RegExp(`\\b${term}\\b`, 'gi').test(s)
              );
              if (containingSentence) {
                  // Check if consequence markers exist in same sentence or adjacent
                  const sentenceIndex = sentences.indexOf(containingSentence);
                  const contextWindow = sentences.slice(
                      Math.max(0, sentenceIndex - 1),
                      Math.min(sentences.length, sentenceIndex + 2)
                  ).join(' ');

                  const hasConsequence = NARRATIVE_CONSEQUENCE_MARKERS.some(pattern =>
                      pattern.test(contextWindow)
                  );

                  if (!hasConsequence) {
                      errors.push({
                          code: VALIDATION_ERRORS.NARR_ABSTRACT_WITHOUT_CONSEQUENCE,
                          message: `Abstract term "${term}" lacks physical/relational consequence`,
                          match: containingSentence.trim().substring(0, 80) + '...'
                      });
                  }
              }
          }
      }

      const valid = errors.length === 0;
      if (!valid) {
          console.warn('[NarrativeAuthority] Validation failed:', errors);
      }

      return { valid, errors };
  }

  /**
   * Build Narrative Authority enforcement block for prompt injection
   * Used when regeneration is required due to authority violations.
   */
  function buildNarrativeAuthorityBlock() {
      return `
NARRATIVE AUTHORITY ENFORCEMENT (Global â€” applies before POV/Tone):

FORBIDDEN:
- Do NOT explain the genre, world, or setting
- Do NOT name archetypes, system concepts, or tone labels
- Do NOT summarize themes or clarify intent
- Do NOT moralize actions or reassure the reader
- Do NOT use abstract terms (hope, redemption, meaning) without physical consequence

REQUIRED:
- Show through action and dialogue, not through narration
- Imply meaning through cost, friction, or outcome
- Let consequence speak. Do not explain what something "means."
- The narrator is not instructional, apologetic, or reverent.

If you name what something IS, you have failed. Show what it COSTS.
`;
  }

  // Track last Narrative Authority validation for DevHUD
  let _lastNarrativeAuthorityValidation = { valid: true, errors: [], timestamp: 0 };

  // Expose for DevHUD and integration
  window.validateNarrativeAuthority = validateNarrativeAuthority;
  window.buildNarrativeAuthorityBlock = buildNarrativeAuthorityBlock;

  /**
   * Tone enforcement prompt block â€” injected when tone validation might fail
   */
  const TONE_ENFORCEMENT_BLOCKS = {
      Earnest: `TONE ENFORCEMENT (Earnest): Prose must contain sincere, unguarded emotional expression. Show genuine feeling without ironic distance. Characters mean what they say.`,
      WryConfession: `TONE ENFORCEMENT (Wry/Confessional): Prose must contain self-aware irony, internal contradiction, or quiet self-deprecation. Characters undercut their own dignity. Include moments of "I told myself" followed by reality contradicting it.`,
      Poetic: `TONE ENFORCEMENT (Poetic): Prose must be lyrical. Use similes, sensory metaphor, rhythm. Language should shimmer. Verbs should evoke texture and light.`,
      Mythic: `TONE ENFORCEMENT (Mythic): Prose must evoke fate, destiny, ancient patterns. Use words like "ordained," "chosen," "eternal." Events feel written in stone.`,
      Comedic: `TONE ENFORCEMENT (Comedic): Prose must include timing reversals, disproportionate reactions, or deadpan understatement. Something should go wrong in a way that's funny. Tonal whiplash is required.`,
      Surreal: `TONE ENFORCEMENT (Surreal): Prose must include dream-logic, unstable causality, or reality slippage. Time, space, or memory should behave strangely. Things transform without explanation.`,
      Dark: `TONE ENFORCEMENT (Dark): Prose must carry moral weight, consequence, or pressure. Something has cost something. Shadows are literal and metaphorical. Relief does not come easily.`
  };

  /**
   * Validate that prose contains detectable tone signals
   * @returns {object} { valid: boolean, violations: string[], matchCount: number }
   */
  function validateTone(text, tone) {
      // Earnest is the baseline â€” always passes if nothing stronger selected
      if (!tone || tone === 'Earnest') {
          // Still validate Earnest has SOME emotional presence
          const earnestConfig = TONE_SIGNAL_PATTERNS.Earnest;
          let earnestMatches = 0;
          earnestConfig.patterns.forEach(p => {
              const matches = text.match(p);
              if (matches) earnestMatches += matches.length;
          });
          if (earnestMatches < 2) {
              return {
                  valid: false,
                  violations: ['TONE_DRIFT: Prose lacks basic emotional presence (Earnest baseline)'],
                  matchCount: earnestMatches,
                  required: 2
              };
          }
          return { valid: true, violations: [], matchCount: earnestMatches, required: 2 };
      }

      const config = TONE_SIGNAL_PATTERNS[tone];
      if (!config) {
          // Unknown tone â€” pass by default
          return { valid: true, violations: [], matchCount: 0, required: 0 };
      }

      let matchCount = 0;
      config.patterns.forEach(pattern => {
          const matches = text.match(pattern);
          if (matches) matchCount += matches.length;
      });

      if (matchCount < config.required) {
          return {
              valid: false,
              violations: [`TONE_DRIFT: "${tone}" tone selected but prose lacks ${config.description}. Found ${matchCount} markers, need ${config.required}+.`],
              matchCount,
              required: config.required
          };
      }

      return { valid: true, violations: [], matchCount, required: config.required };
  }

  /**
   * Build tone enforcement block for prompt injection
   */
  function buildToneEnforcementBlock(tone) {
      if (!tone || !TONE_ENFORCEMENT_BLOCKS[tone]) return '';
      return '\n' + TONE_ENFORCEMENT_BLOCKS[tone] + '\n';
  }

  // ============================================================
  // UNIFIED VALIDATION SYSTEM â€” RUNTIME ENFORCEMENT LAYER
  // ============================================================
  // Pure validators that return { pass, errors } and NEVER mutate content.
  // On failure: caller must regenerate upstream.
  // Compatible with Dev HUD: check dsp, check pov, check tone, check erotic
  // ============================================================

  /**
   * SHARED ERROR TAXONOMY
   * Structured error codes for all validators
   */
  const VALIDATION_ERRORS = {
      // DSP Errors
      DSP_TEMPLATE_VIOLATION: 'DSP_TEMPLATE_VIOLATION',
      DSP_INVALID_WORLD_PHRASE: 'DSP_INVALID_WORLD_PHRASE',
      DSP_INVALID_GENRE_PHRASE: 'DSP_INVALID_GENRE_PHRASE',
      DSP_INVALID_ARCHETYPE_ADJ: 'DSP_INVALID_ARCHETYPE_ADJ',
      DSP_INVALID_TONE_ADJ: 'DSP_INVALID_TONE_ADJ',
      DSP_EXTRA_PROSE: 'DSP_EXTRA_PROSE',
      DSP_WORLD_SUBTYPE_LEAK: 'DSP_WORLD_SUBTYPE_LEAK',
      DSP_LEGACY_PHRASING: 'DSP_LEGACY_PHRASING',

      // POV Errors (5th Person)
      POV_INVALID_OPENER: 'POV_INVALID_OPENER',
      POV_INVALID_CLOSER: 'POV_INVALID_CLOSER',
      POV_SCENE1_FREQUENCY: 'POV_SCENE1_FREQUENCY',
      POV_LATER_FREQUENCY: 'POV_LATER_FREQUENCY',
      POV_EROTIC_AUTHOR_PRESENT: 'POV_EROTIC_AUTHOR_PRESENT',
      POV_AUTHOR_NARRATES_ACTION: 'POV_AUTHOR_NARRATES_ACTION',
      POV_NON_3RD_PERSON: 'POV_NON_3RD_PERSON',
      POV_META_AWARENESS_EXCESS: 'POV_META_AWARENESS_EXCESS',
      POV_GODMODE_PLAYER_AWARENESS: 'POV_GODMODE_PLAYER_AWARENESS',

      // Tone Errors
      TONE_DRIFT: 'TONE_DRIFT',
      TONE_SIGNAL_DEFICIT: 'TONE_SIGNAL_DEFICIT',

      // Erotic Escalation Errors
      EROTIC_SENSORY_DEFICIT: 'EROTIC_SENSORY_DEFICIT',
      EROTIC_NO_CONTRADICTION: 'EROTIC_NO_CONTRADICTION',
      EROTIC_ABSTRACTION_ONLY: 'EROTIC_ABSTRACTION_ONLY',
      DIRTY_TOO_CLEAN: 'DIRTY_TOO_CLEAN',
      DIRTY_NO_INTRUSION: 'DIRTY_NO_INTRUSION',

      // Title Validation Errors
      TITLE_GENERIC: 'TITLE_GENERIC',
      TITLE_CLICHE: 'TITLE_CLICHE',
      TITLE_ABSTRACT_CLUSTER: 'TITLE_ABSTRACT_CLUSTER',
      TITLE_TONE_MISMATCH: 'TITLE_TONE_MISMATCH',
      TITLE_TOO_LONG: 'TITLE_TOO_LONG',
      TITLE_TOO_SHORT: 'TITLE_TOO_SHORT',

      // Signal Alignment Errors
      SIGNAL_AXIS_MISMATCH: 'SIGNAL_AXIS_MISMATCH',
      TITLE_AROUSAL_CONTRADICTION: 'TITLE_AROUSAL_CONTRADICTION',
      COVER_AROUSAL_CONTRADICTION: 'COVER_AROUSAL_CONTRADICTION',
      AROUSAL_SIGNAL_ABSENT: 'AROUSAL_SIGNAL_ABSENT',
      SIGNAL_AMBIGUOUS: 'SIGNAL_AMBIGUOUS',

      // Title Pipeline Errors
      TITLE_BANNED_PHRASE: 'TITLE_BANNED_PHRASE',
      TITLE_SWAP_TEST_FAIL: 'TITLE_SWAP_TEST_FAIL',
      TITLE_MULTI_CLAUSE: 'TITLE_MULTI_CLAUSE',
      TITLE_MARKETING_COPY: 'TITLE_MARKETING_COPY',
      TITLE_AROUSAL_MISMATCH: 'TITLE_AROUSAL_MISMATCH',
      TITLE_MODE_VIOLATION: 'TITLE_MODE_VIOLATION',
      TITLE_IMMUTABLE_VIOLATION: 'TITLE_IMMUTABLE_VIOLATION',
      TITLE_RESOLUTION_VOCABULARY: 'TITLE_RESOLUTION_VOCABULARY',
      COVER_BASELINE_CONTRADICTION: 'COVER_BASELINE_CONTRADICTION',

      // Continuation Path Errors
      CONTINUATION_WORD_REUSE: 'CONTINUATION_WORD_REUSE',
      SAME_WORLD_MISSING_SUBTITLE: 'SAME_WORLD_MISSING_SUBTITLE',
      SAME_WORLD_MISSING_WORLD_NAME: 'SAME_WORLD_MISSING_WORLD_NAME',
      NEW_STORY_PRIOR_NOUN_REUSE: 'NEW_STORY_PRIOR_NOUN_REUSE',

      // Paywall Routing Errors
      STORYPASS_DIRTY_LEAK: 'STORYPASS_DIRTY_LEAK',
      STORYPASS_SOULMATES_LEAK: 'STORYPASS_SOULMATES_LEAK',

      // Narrative Authority Errors (POV-agnostic, runs before Tone/POV)
      NARR_EXPLANATORY: 'NARR_EXPLANATORY',
      NARR_TAXONOMY_LEAK: 'NARR_TAXONOMY_LEAK',
      NARR_ABSTRACT_WITHOUT_CONSEQUENCE: 'NARR_ABSTRACT_WITHOUT_CONSEQUENCE',
      NARR_HELPFUL_NARRATOR: 'NARR_HELPFUL_NARRATOR'
  };

  // ============================================================
  // TITLE VALIDATION + FALLBACK SYSTEM
  // ============================================================
  // Validates generated titles against known failure patterns.
  // On failure: deterministic name-based fallback is generated.
  // ============================================================

  /**
   * TITLE FAILURE PATTERNS
   * Regex patterns that indicate a bad title
   */
  const TITLE_FAIL_PATTERNS = {
      // Generic/clichÃ© romance titles
      GENERIC: [
          /^(a|the)\s+(love|heart|soul|kiss|desire|passion)\b/i,
          /^love('s)?\s+(story|song|way|promise|dance|journey)/i,
          /^hearts?\s+(of|in|on)\s+/i,
          /^(whispers?|echoes?|shadows?|secrets?)\s+of\s+(the\s+)?(heart|soul|desire|love)/i,
          /^(eternal|forbidden|hidden|secret|dark|lost)\s+(love|desire|passion|heart)/i,
          /^(love|desire)\s+(in\s+the\s+)?(shadows?|dark(ness)?|night)/i
      ],
      // Abstract noun clusters (mood collage)
      ABSTRACT_CLUSTER: [
          /^(veiled|shrouded|hidden)\s+(whispers?|secrets?|desires?|shadows?)/i,
          /^(whispers?|echoes?)\s+(of|and)\s+(whispers?|echoes?|shadows?|secrets?)/i,
          /^(shadows?|darkness)\s+(and|of)\s+(light|desire|whispers?)/i,
          /\b(aches?|burns?|yearns?)\s+(of|for|with)\s+(the\s+)?(soul|heart|desire)/i
      ],
      // Poetic-but-empty (no stakes/narrative promise)
      CLICHE: [
          /^(when|where)\s+(hearts?|souls?|love)\s+(meet|collide|dance)/i,
          /^(beneath|beyond|between)\s+(the\s+)?(stars?|moon|sky|veil)/i,
          /^(dancing|dancing\s+with)\s+(shadows?|flames?|fate)/i,
          /^(chasing|finding|seeking)\s+(love|desire|destiny|fate)/i,
          /^(written\s+in|painted\s+with)\s+(the\s+)?(stars?|blood|fire)/i
      ],
      // BANNED PHRASES (HARD FAIL)
      BANNED: [
          /\bshadows?\s+of\b/i,
          /\bechoes?\s+of\b/i,
          /\bwhispers?\s+of\b/i,
          /\bwhispers?\b/i,  // Whispers alone is banned
          /^beneath\b/i,
          /^within\b/i,
          /^beyond\b/i,
          /\bdestiny\b/i,
          /\bfated?\b/i,
          /\bforever\s+(yours|mine|ours)\b/i,
          /\beternal\s+(love|flame|bond)\b/i
      ],
      // Multi-clause poetic phrasing
      MULTI_CLAUSE: [
          /^.+,\s+.+,\s+.+/,  // Three or more comma-separated clauses
          /^.+\s+â€”\s+.+\s+â€”\s+.+/,  // Multiple em-dashes
          /^.+:\s+.+:\s+/,  // Multiple colons
          /^(when|where|if|as)\s+.+,\s+(then|so|and)\s+/i  // Conditional phrasing
      ],
      // Marketing copy tone
      MARKETING: [
          /\b(ultimate|passionate|unforgettable|breathtaking|stunning)\b/i,
          /\b(journey|adventure)\s+(of|to)\s+(love|passion|desire)\b/i,
          /\b(one|a)\s+(woman|man|person)('s)?\s+(journey|quest|search)\b/i,
          /\bthe\s+(story|tale)\s+of\b/i,
          /\b(discover|unlock|explore)\s+(the|your)\b/i
      ]
  };

  /**
   * TITLE MODES (LOCKED)
   * Primary title generator selects EXACTLY ONE mode
   */
  const TITLE_MODES = {
      POSSESSIVE_POWER: 'possessive_power',    // "Her Silence", "Your Obedience"
      FORBIDDEN_OBJECT: 'forbidden_object',    // "The Key", "The Contract"
      VERB_LOCKED: 'verb_locked',              // "What He Took", "Where You Knelt"
      TWO_WORD_FRACTURE: 'two_word_fracture'   // "Golden Hunger", "Sacred Damage"
  };

  /**
   * TITLE MODE PATTERNS
   * Regex patterns that detect which mode a title belongs to
   */
  const TITLE_MODE_PATTERNS = {
      [TITLE_MODES.POSSESSIVE_POWER]: /^(her|his|my|your|their|our)\s+\w+$/i,
      [TITLE_MODES.FORBIDDEN_OBJECT]: /^the\s+\w+$/i,
      [TITLE_MODES.VERB_LOCKED]: /^(what|where|when|how|why)\s+(he|she|they|you|i)\s+\w+$/i,
      [TITLE_MODES.TWO_WORD_FRACTURE]: /^\w+\s+\w+$/i  // Fallback: any two words
  };

  /**
   * MODE-SPECIFIC VOCABULARY â€” UNRESOLVED TENSION ONLY
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE (AUTHORITATIVE):
   * No title generated before ST4 may name a resolved state, irreversible
   * consequence, or completed act.
   *
   * A title is the Story's admission of tension, not a promise of outcome.
   *
   * ALLOWED AT ST1â€“ST3: hesitation, hunger, denial, almost, temptation,
   *                     bargaining, watching, waiting, pretending, conditions
   *
   * DISALLOWED AT ST1: surrender, obedience, ruin, betrayal, reckoning,
   *                    downfall, what was taken, damage already done,
   *                    possession already claimed, past-tense completion verbs
   *
   * MANTRA: A title does not know the ending.
   *         It only knows the lie being told at the beginning.
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const TITLE_MODE_VOCABULARY = {
      [TITLE_MODES.POSSESSIVE_POWER]: {
          possessives: ['Her', 'His', 'My', 'Your', 'Their'],
          // UNRESOLVED: states of wanting, not states of having
          nouns: {
              Clean: ['Silence', 'Distance', 'Waiting', 'Refusal', 'Terms'],
              Naughty: ['Secret', 'Temptation', 'Risk', 'Edge', 'Game'],
              // CHANGED: Removed 'Surrender', 'Claim' (resolved states)
              Erotic: ['Hunger', 'Wanting', 'Hesitation', 'Confession', 'Longing'],
              // CHANGED: Removed 'Obedience', 'Ruin', 'Undoing' (aftermath)
              Dirty: ['Appetite', 'Dare', 'Demand', 'Condition', 'Warning']
          }
      },
      [TITLE_MODES.FORBIDDEN_OBJECT]: {
          articles: ['The'],
          // UNRESOLVED: objects that represent tension, not resolution
          objects: {
              Clean: ['Door', 'Letter', 'Ring', 'Promise', 'Line'],
              Naughty: ['Key', 'Contract', 'Rule', 'Wager', 'Dare'],
              // CHANGED: Removed 'Claim', 'Mark' (possession)
              Erotic: ['Bargain', 'Arrangement', 'Question', 'Threshold', 'Offer'],
              // CHANGED: Removed 'Leash' (possession) â€” kept negotiation objects
              Dirty: ['Terms', 'Price', 'Condition', 'Test', 'Trade']
          }
      },
      [TITLE_MODES.VERB_LOCKED]: {
          // CHANGED: Removed past-tense completion verbs entirely
          // Now uses present/conditional tense only
          openers: ['What', 'Where', 'If', 'Whether'],
          subjects: ['He', 'She', 'You', 'They', 'I'],
          // UNRESOLVED: verbs of contemplation, not completion
          verbs: {
              Clean: ['Means', 'Waits', 'Watches', 'Refuses', 'Knows'],
              Naughty: ['Wants', 'Almost', 'Nearly', 'Considers', 'Dares'],
              // CHANGED: Removed 'Took', 'Claimed', 'Gave' (past completion)
              Erotic: ['Needs', 'Craves', 'Hesitates', 'Decides', 'Chooses'],
              // CHANGED: Removed 'Broke', 'Wrecked', 'Ruined' (aftermath)
              Dirty: ['Demands', 'Expects', 'Tests', 'Pushes', 'Asks']
          }
      },
      [TITLE_MODES.TWO_WORD_FRACTURE]: {
          // UNRESOLVED: adjectives of state, not aftermath
          adjectives: {
              Clean: ['Quiet', 'Cold', 'Still', 'Distant', 'Careful'],
              Naughty: ['Sweet', 'Hidden', 'Secret', 'Dangerous', 'Willing'],
              // CHANGED: Kept emotional states, removed aftermath words
              Erotic: ['Burning', 'Aching', 'Desperate', 'Hungry', 'Trembling'],
              // CHANGED: Removed 'Ruined', 'Wrecked' (aftermath)
              Dirty: ['Raw', 'Hungry', 'Demanding', 'Impatient', 'Restless']
          },
          // CHANGED: Removed 'Damage', 'Reckoning' (aftermath)
          nouns: ['Hunger', 'Waiting', 'Silence', 'Terms', 'Question', 'Edge', 'Threshold']
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TITLE VOCABULARY SEMANTIC GATES (ST1 ENFORCEMENT)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // These patterns detect RESOLVED/AFTERMATH language that must be blocked at ST1

  const TITLE_RESOLVED_VOCABULARY = {
      // Past-tense completion verbs (implies consequence already occurred)
      pastCompletion: /\b(took|claimed|gave|broke|wrecked|ruined|used|betrayed|fell|lost|won|conquered|destroyed|surrendered)\b/i,

      // Possessive resolution (implies ownership already established)
      possessiveResolution: /\b(her|his|my|your|their)\s+(surrender|obedience|ruin|undoing|defeat|submission|fall|breaking)\b/i,

      // Aftermath nouns (name consequences, not tension)
      aftermathNouns: /\b(reckoning|downfall|betrayal|aftermath|wreckage|ruins|ashes|remains|ending|conclusion)\b/i,

      // Completion states (tension already resolved)
      completionStates: /\b(finally|at\s+last|in\s+the\s+end|what\s+remained|all\s+that\s+was\s+left)\b/i,

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PROMISE DISCIPLINE â€” Title must not assume meaning or resolution
      // Titles may suggest tension, ambiguity, or invitation only
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Moral framing (pre-judges what the temptation means)
      moralFraming: /\b(forbidden\s+(love|desire|pleasure)|guilty\s+(pleasure|secret)|shameful|sinful|wicked)\b/i,

      // Outcome promise (implies how it will resolve)
      outcomePromise: /\b(inevitable|destined|fated\s+to|meant\s+to\s+be|bound\s+to|will\s+(always|never))\b/i,

      // Thematic declaration (states what the story IS rather than evokes)
      thematicDeclaration: /^(the\s+)?(story|tale|journey)\s+of\b/i
  };

  /**
   * Check if title contains resolved/aftermath vocabulary
   * @param {string} title - Title to check
   * @returns {{ hasResolved: boolean, violations: string[] }}
   */
  function checkTitleResolutionVocabulary(title) {
      const violations = [];
      const cleanTitle = (title || '').trim();

      for (const [category, pattern] of Object.entries(TITLE_RESOLVED_VOCABULARY)) {
          if (pattern.test(cleanTitle)) {
              violations.push(`${category}: "${cleanTitle.match(pattern)?.[0]}"`);
          }
      }

      return {
          hasResolved: violations.length > 0,
          violations
      };
  }

  window.checkTitleResolutionVocabulary = checkTitleResolutionVocabulary;
  window.TITLE_RESOLVED_VOCABULARY = TITLE_RESOLVED_VOCABULARY;

  /**
   * WRY CONFESSIONAL TITLE MODES
   * Observational, ironic, understated â€” no power/possession/melodrama
   */
  const WRY_CONFESSIONAL_TITLE_MODES = {
      OBSERVATIONAL: 'OBSERVATIONAL',
      IRONIC_STATEMENT: 'IRONIC_STATEMENT',
      UNDERCUT_OBJECT: 'UNDERCUT_OBJECT'
  };

  const WRY_CONFESSIONAL_VOCABULARY = {
      OBSERVATIONAL: [
          'Everyone Pretended This Was Fine',
          'It Seemed Like a Good Idea',
          'No One Mentioned It Again',
          'We Were All Adults About It',
          'This Was Supposed to Be Simple'
      ],
      IRONIC_STATEMENT: [
          'A Minor Complication',
          'Nothing Personal',
          'An Understandable Mistake',
          'Probably Fine',
          'For What It\'s Worth'
      ],
      UNDERCUT_OBJECT: [
          'The Champagne Glass',
          'The Empty Chair',
          'The Apology',
          'The Email',
          'The Receipt'
      ]
  };

  // =================================================================
  // WRY CONFESSIONAL â€” UNIFIED VISUAL ONTOLOGY (PATCH 9)
  // Single source of truth for covers AND scene visualization
  // =================================================================

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL VISUAL ONTOLOGY â€” Anti-painterly, anti-moody specification
  // CRITICAL: Positive-first approach (models respond better to positives)
  // Lead with explicit style, minimize negations, use clear model-friendly terms
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSIONAL_VISUAL_ONTOLOGY = `Style: Single-panel New Yorker magazine editorial cartoon. Medium: Black ink line drawing on white paper with simple hatching. Aesthetic: Minimalist, understated, dry wit. Lines: Thin uniform pen strokes, hand-drawn quality, quick newspaper sketch style. Colors: Grayscale only, cool neutral tones, flat matte finish. Background: Plain white, empty, no gradients. Mood: Deadpan, observational, wry. Rendering: 2D flat illustration, deliberately unpolished, diagrammatic simplicity. Avoid: oil painting, watercolor, photorealism, dramatic lighting, warm tones, 3D rendering, painterly effects.`;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSION â€” CANONICAL CAPTION TEMPLATES (RUNTIME)
  // Use as-is or with light variation. Caption must undercut, not decorate.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSION_CAPTION_TEMPLATES = {
      selfIndictingRationalization: [
          "I had a system for moments like this, which mostly involved pretending they were temporary.",
          "I told myself this was different, which is what I always told myself.",
          "I had reasons. I always had reasons."
      ],
      delayedSelfAwareness: [
          "This was the point where I would later insist I'd had no real choice.",
          "Looking back, I would call this a turning point. At the time, I called it Tuesday.",
          "I would remember this moment differently, and more favorably."
      ],
      storyAsWitness: [
          "The story briefly considered intervening here, then remembered how stubborn she could be.",
          "The story noted the hesitation and chose not to comment.",
          "The story had seen this before and adjusted its expectations accordingly."
      ],
      constraints: {
          maxWords: 20,
          noJokes: true,
          noMetaCommentary: true,
          noWorldMechanics: true,
          mustUndercut: true
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSION â€” BINARY VISUAL CONTRADICTION TYPES (RUNTIME)
  // Every visualization must include exactly ONE of these disagreements.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSION_VISUAL_CONTRADICTIONS = {
      backgroundSign: [
          "NO RETURNS", "FAIR PRICES", "TEMPORARY", "EXIT", "CAUTION",
          "FINAL SALE", "ONE WAY", "NO REFUNDS", "LAST CHANCE"
      ],
      postureUndercuts: [
          "clenched hands", "stiff stance", "off-balance weight",
          "shoulders slightly hunched", "fingers gripping edge",
          "leaning away while reaching forward"
      ],
      silentObserver: [
          "secondary figure in background watching",
          "reflection in window showing different expression",
          "shadow that doesn't match posture"
      ],
      prominentObject: [
          "object of temptation rendered slightly too large",
          "dangerous item positioned within easy reach",
          "escape route visible but ignored"
      ],
      constraints: {
          onlyOne: true,
          noExaggeration: true,
          noSlapstick: true,
          legibleAtGlance: true
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TONE VISUAL ONTOLOGY REGISTRY â€” Master definition of tone-locked visual styles
  // ğŸ”’ PRIORITY: Tone visual ontology ALWAYS overrides Genre and World styling
  // Genre only influences composition, subject matter, costume/setting tropes
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const TONE_VISUAL_ONTOLOGIES = {
      'Wry Confessional': {
          ontology: WRY_CONFESSIONAL_VISUAL_ONTOLOGY,
          expectedTags: ['editorial cartoon', 'New Yorker', 'ink drawing', 'sketch', 'grayscale', 'minimalist'],
          bannedTokens: /\b(cinematic|painterly|photorealistic|photo-real|dramatic lighting|chiaroscuro|depth of field|bokeh|lens flare|hyper-realistic|oil painting|oil-painting|watercolor|watercolour|atmospheric|natural lighting|golden.hour|golden hour|studio lighting|volumetric|HDR|8k|4k|ultra.realistic|professional photo|realistic|realism|brush stroke|brushstroke|impasto|glazing|sfumato|warm lighting|warm tones|orange glow|sunset|golden light|rich colors|vibrant|lush|ethereal|dreamy|fantasy art|concept art|digital painting|digital art|artstation|deviantart)\b/gi,
          intensityTokens: /\b(suggestive|flirtatious|sensual|seductive|allure|attractive|beautiful|striking beauty|elegant features|hourglass|athletic|gorgeous|stunning|radiant)\b/gi,
          cleanupPatterns: [
              /This image is an editorial cartoon[^.]*\./gi,
              /NOT a photograph[^.]*\./gi,
              /Style:[^.]*\./gi,
              /New Yorker[^.]*\./gi
          ],
          description: 'Editorial cartoon sketch style â€” New Yorker magazine aesthetic'
      },
      'WryConfession': {  // Alias for internal naming consistency
          aliasOf: 'Wry Confessional'
      },
      'Satire': {  // Uses same visual style as Wry Confessional
          aliasOf: 'Wry Confessional'
      },
      'Irony': {  // Uses same visual style as Wry Confessional
          aliasOf: 'Wry Confessional'
      },
      'Lurid Confessional': {
          ontology: `Style: Vintage pulp magazine cover illustration. Medium: Bold, saturated colors with heavy black outlines. Aesthetic: Sensational, melodramatic, confessional. Colors: High contrast, saturated reds, yellows, blues. Strong shadows, exaggerated expressions. Background: Simple gradient or solid color with dramatic spotlighting. Mood: Overwrought, breathless, tabloid. Rendering: Classic illustration style, visible brush strokes, slightly garish color palette. Avoid: subtlety, muted tones, photorealism, modern digital aesthetic.`,
          expectedTags: ['pulp', 'vintage', 'melodramatic', 'saturated', 'bold outlines', 'confessional'],
          bannedTokens: /\b(subtle|muted|photorealistic|photo-real|naturalistic|understated|minimalist|grayscale|monochrome)\b/gi,
          intensityTokens: null,  // Lurid allows intensity language
          cleanupPatterns: [],
          description: 'Vintage pulp magazine illustration â€” bold, saturated, melodramatic'
      },
      'Ink Noir': {
          ontology: `Style: Black-and-white noir comic panel. Medium: High contrast ink work, heavy shadows, dramatic chiaroscuro. Aesthetic: Hard-boiled, fatalistic, shadowy. Colors: Pure black and white only, no gray tones, stark contrast. Strong use of negative space and silhouettes. Background: Urban shadows, venetian blind stripes, rain-slicked surfaces. Mood: Cynical, world-weary, dangerous. Rendering: Frank Miller/Sin City aesthetic, bold ink work, extreme shadow play. Avoid: color, soft gradients, warm tones, cheerful lighting, painterly effects.`,
          expectedTags: ['noir', 'black-and-white', 'ink', 'chiaroscuro', 'comic panel', 'shadows'],
          bannedTokens: /\b(color|colorful|vibrant|warm|cheerful|soft|gradient|painterly|watercolor|pastel|bright|sunny)\b/gi,
          intensityTokens: null,
          cleanupPatterns: [],
          description: 'Sin City-style black-and-white noir comic panel'
      },
      'Horror': {
          ontology: `Style: Horror illustration with unsettling atmosphere. Medium: Dark, desaturated palette with sickly accent colors. Aesthetic: Dread-inducing, liminal, uncanny. Colors: Deep shadows, washed-out highlights, occasional sickly green or red accent. Background: Oppressive darkness, fog, indistinct shapes at edges. Mood: Creeping dread, wrongness, something watching. Rendering: Slightly distorted perspectives, off-kilter compositions, faces obscured or wrong. Avoid: cheerful lighting, clear visibility, reassuring compositions, beauty-shot framing.`,
          expectedTags: ['horror', 'dark', 'unsettling', 'dread', 'shadows', 'uncanny'],
          bannedTokens: /\b(cheerful|bright|sunny|warm|inviting|cozy|comfortable|safe|reassuring|beautiful|glamorous)\b/gi,
          intensityTokens: null,
          cleanupPatterns: [],
          description: 'Horror atmosphere â€” dread-inducing, liminal, unsettling'
      }
      // Tones WITHOUT visual ontology (use Genre defaults):
      // - Earnest: No visual lock â€” uses Genre styling
      // - Poetic: No visual lock â€” uses Genre styling with lyrical composition
      // - Mythic: No visual lock â€” uses Genre styling with epic composition
      // - Comedic: No visual lock â€” uses Genre styling
      // - Modern: No visual lock â€” uses Genre styling
  };

  // Resolve tone alias to canonical name
  function resolveToneAlias(tone) {
      if (!tone) return null;
      const entry = TONE_VISUAL_ONTOLOGIES[tone];
      if (entry?.aliasOf) {
          return entry.aliasOf;
      }
      return tone;
  }

  // Check if a tone has a visual ontology that overrides genre
  function hasToneVisualOntology(tone) {
      const resolved = resolveToneAlias(tone);
      const entry = TONE_VISUAL_ONTOLOGIES[resolved];
      return entry && !entry.aliasOf && entry.ontology;
  }

  // Get the visual ontology for a tone (returns null if none)
  function getToneVisualOntology(tone) {
      const resolved = resolveToneAlias(tone);
      const entry = TONE_VISUAL_ONTOLOGIES[resolved];
      if (entry && !entry.aliasOf) {
          return entry;
      }
      return null;
  }

  // Apply tone visual ontology to a prompt (returns modified prompt and metadata)
  function applyToneVisualOntology(prompt, tone, context = 'visualize') {
      const ontologyEntry = getToneVisualOntology(tone);

      if (!ontologyEntry) {
          // No visual ontology â€” return original prompt with genre authority
          return {
              prompt: prompt,
              styleAuthority: 'Genre',
              styleExpectedTags: [],
              toneStyleLock: false
          };
      }

      let modifiedPrompt = prompt;

      // Strip banned tokens (cinematic, painterly, etc.)
      if (ontologyEntry.bannedTokens) {
          modifiedPrompt = modifiedPrompt.replace(ontologyEntry.bannedTokens, '');
      }

      // Strip intensity tokens if specified
      if (ontologyEntry.intensityTokens) {
          modifiedPrompt = modifiedPrompt.replace(ontologyEntry.intensityTokens, '');
      }

      // Apply cleanup patterns to avoid duplication
      if (ontologyEntry.cleanupPatterns) {
          for (const pattern of ontologyEntry.cleanupPatterns) {
              modifiedPrompt = modifiedPrompt.replace(pattern, '');
          }
      }

      // Trim and clean up whitespace
      modifiedPrompt = modifiedPrompt.replace(/\n{3,}/g, '\n\n').replace(/\s{2,}/g, ' ').trim();

      // Prepend authoritative ontology
      modifiedPrompt = `${ontologyEntry.ontology}\n\nScene: ${modifiedPrompt}`;

      console.log(`[VIZ:TONE] ${resolveToneAlias(tone)} ontology APPLIED â€” styleAuthority: Tone`);
      console.log(`[VIZ:TONE] Expected tags: ${ontologyEntry.expectedTags.join(', ')}`);

      return {
          prompt: modifiedPrompt,
          styleAuthority: 'Tone',
          styleExpectedTags: ontologyEntry.expectedTags,
          toneStyleLock: true,
          toneDescription: ontologyEntry.description
      };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WORLD + TONE STYLE LOCK (TRUST REPAIR PHASE 2)
  // Deterministic style derivation â€” cannot be overridden by modifiers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // This lock is HARD â€” it determines the visual style and cannot be silently changed.
  // When World+Tone implies a specific style, the model MUST stay in that lane.
  //
  // STYLE LOCK HIERARCHY:
  //   1. Tone visual ontology (if exists) â†’ ABSOLUTE priority
  //   2. World default style â†’ fallback
  //
  // STYLE CATEGORIES:
  //   - sketch: pencil, ink, charcoal, editorial, unfinished
  //   - illustrative: clean illustration, graphic novel, stylized
  //   - photographic: realistic, cinematic, natural lighting
  //   - painterly: oil, watercolor, brushwork, classical
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const WORLD_DEFAULT_STYLES = {
      Modern: 'photographic',
      Fantasy: 'illustrative',
      SciFi: 'illustrative',
      Historical: 'painterly',
      PostApocalyptic: 'photographic',
      Dystopia: 'illustrative'
  };

  const TONE_STYLE_OVERRIDES = {
      'Wry Confessional': 'sketch',
      'WryConfession': 'sketch',
      'Satire': 'sketch',
      'Irony': 'sketch',
      'Lurid Confessional': 'illustrative',
      'Ink Noir': 'sketch',
      'Horror': 'illustrative',
      'Mythic': 'painterly',
      'Poetic': 'painterly',
      'Surreal': 'illustrative'
  };

  /**
   * Get the locked style for World+Tone combination
   * @returns {object} { style, source, locked }
   */
  function getStyleLock(world, tone) {
      // Tone has priority if it defines a style override
      const resolvedTone = resolveToneAlias(tone);
      if (TONE_STYLE_OVERRIDES[resolvedTone]) {
          return {
              style: TONE_STYLE_OVERRIDES[resolvedTone],
              source: 'tone',
              locked: true
          };
      }

      // Fall back to world default
      const worldStyle = WORLD_DEFAULT_STYLES[world] || 'illustrative';
      return {
          style: worldStyle,
          source: 'world',
          locked: true
      };
  }

  /**
   * Validate that a prompt respects the style lock
   * @returns {object} { valid, violations[] }
   */
  function validateStyleLock(prompt, styleLock) {
      const violations = [];

      const STYLE_TOKENS = {
          sketch: {
              required: /\b(sketch|drawing|ink|pencil|charcoal|editorial|line.?work|hand.?drawn)\b/i,
              banned: /\b(photorealistic|cinematic|oil.?paint|hyper.?real|4k|8k|studio.?light)\b/i
          },
          illustrative: {
              required: /\b(illustration|illustrated|graphic|stylized|digital.?art|comic|manga)\b/i,
              banned: /\b(photograph|photorealistic|real.?life|candid|raw.?photo)\b/i
          },
          photographic: {
              required: /\b(photo|cinematic|realistic|natural.?light|candid|documentary)\b/i,
              banned: /\b(cartoon|sketch|anime|drawing|line.?art)\b/i
          },
          painterly: {
              required: /\b(paint|painted|oil|watercolor|brushwork|classical|impressionist)\b/i,
              banned: /\b(sketch|cartoon|photograph|digital.?render)\b/i
          }
      };

      const tokens = STYLE_TOKENS[styleLock.style];
      if (!tokens) return { valid: true, violations: [] };

      if (tokens.banned && tokens.banned.test(prompt)) {
          violations.push(`Prompt contains tokens banned for ${styleLock.style} style`);
      }

      return {
          valid: violations.length === 0,
          violations
      };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SKETCH TIER REFINEMENT (TRUST REPAIR PHASE 2)
  // For Wry Confession, Sci-Fi, Mythic: reduce polish, increase hand-drawn feel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // The sketch must look like "someone thinking on paper", NOT "final concept art"
  //
  // ALLOWED:
  //   - outlined lettering
  //   - crossed-out words
  //   - uneven strokes
  //   - editorial looseness
  //   - visible construction lines
  //   - partial shading
  //
  // DISALLOWED:
  //   - cinematic lighting
  //   - painterly shading
  //   - finished illustration look
  //   - professional polish
  //   - smooth gradients
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const SKETCH_TIER_ENFORCEMENT = `
SKETCH TIER ENFORCEMENT (MANDATORY):
This cover must appear UNFINISHED in execution, not unfinished in idea.

REQUIRED CHARACTERISTICS:
- Pencil, ink, or charcoal texture visible
- Uneven or broken linework
- Partial fill or restrained color (2-3 tones max)
- Visible construction lines or negative space
- Hand-drawn or outlined lettering allowed
- Editorial looseness and imperfection
- Conceptual tension over literal depiction

ABSOLUTELY PROHIBITED:
- Cinematic lighting or dramatic shadows
- Painterly shading or smooth gradients
- Finished illustration look
- Professional polish or commercial finish
- Hyper-realistic rendering
- Digital art smoothness
- LITERAL DEVICE OBJECTS (tablets, screens, phones, computers)
- "Future tech = object" shorthand
- Product-like renderings

CONCEPTUAL GUIDANCE:
For themes of resonance, experimentation, or instability:
- Prefer juxtaposition, misalignment, or incomplete systems
- Accept abstraction
- Avoid literal depiction of technology as physical object
- If uncertain, subtract rather than add

The goal: A cover that feels MID-THOUGHT, not UNDER-THOUGHT.
If the image looks complete, it has FAILED sketch tier.
`;

  const SKETCH_TIER_TONES = ['Wry Confessional', 'WryConfession', 'Satire', 'Irony', 'Ink Noir'];

  /**
   * Check if current tone requires sketch tier enforcement
   */
  function requiresSketchTier(tone) {
      const resolved = resolveToneAlias(tone);
      return SKETCH_TIER_TONES.includes(resolved);
  }

  /**
   * Get sketch tier enforcement text for cover prompts
   */
  function getSketchTierEnforcement(tone) {
      if (!requiresSketchTier(tone)) return '';
      return SKETCH_TIER_ENFORCEMENT;
  }

  const WRY_CONFESSIONAL_OBJECT_ALTERATIONS = [
      'slightly misplaced',
      'unused or paused mid-intent',
      'emotionally undercut',
      'quietly contradicting expectation'
  ];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL â€” TONE INVARIANT (AUTHORITATIVE)
  // Applies to ALL cover stages for Wry Confessional tone
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSIONAL_TONE_INVARIANT = `TONE INVARIANT (Wry Confessional):
The primary object must show evidence of hesitation, interference, revision, or ironic displacement.
Confession is implied through the condition of the object, not through spectacle or explicit humor.
The object may change across stages, but the wry condition must persist.
No pristine, untouched symbolism is allowed.

ABSOLUTE CONSTRAINTS (ALL STAGES):
- NO spectacle (fire, explosions, chaos, melodrama)
- NO explicit jokes or captions that explain the irony
- NO reversion to pristine objects
- NO photoreal stock aesthetics
- NO escalation into parody

FAILURE CONDITIONS:
- Object appears untouched or neutral
- Irony is loud, literal, or explained
- Tone collapses into humor instead of implication
- Same motif repeated mechanically across stages`;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL â€” STAGE-SPECIFIC ESCALATION (AUTHORITATIVE)
  // Each stage applies the invariant with different legibility
  // NOTE: Uses string keys to avoid reference before COVER_STAGES definition
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSIONAL_STAGE_PROMPTS = {
      'sketch': `${WRY_CONFESSIONAL_TONE_INVARIANT}

SKETCH STAGE ESCALATION:
- Implicit, understated
- One quiet sign of compromise only
- Ambiguity preserved
- Editorial, diagrammatic feel
- Confession should feel almost accidental

AESTHETIC: Black ink or graphite line work on white or off-white paper. Outlined lettering with light pencil-filled interior. Understated, diagrammatic. New Yorker editorial sketch aesthetic.`,

      'thumbnail': `${WRY_CONFESSIONAL_TONE_INVARIANT}

THUMBNAIL STAGE ESCALATION:
- The wry condition is clearer at a glance
- Still unresolved
- No explanatory gestures or visual punchlines

AESTHETIC: Simple forms, limited palette. The compromised state visible but not emphasized. Editorial restraint maintained.`,

      'rough': `${WRY_CONFESSIONAL_TONE_INVARIANT}

ROUGH STAGE ESCALATION:
- The compromised state of the object is unambiguous
- Emotional meaning remains open
- Irony emerges through composition and context, not jokes

AESTHETIC: More refined line work, visible texture. The wry condition is now clearly intentional, not accidental. Still understated.`,

      'v1': `${WRY_CONFESSIONAL_TONE_INVARIANT}

FINAL STAGE ESCALATION:
- The wry irony is fully legible
- Resolved visually, not narratively
- Editorial restraint maintained (New Yorker tone, not gag illustration)

AESTHETIC: Polished editorial illustration. The object's compromised state reads immediately. Irony is clear but never loud. Quiet confidence in the visual statement.`
  };

  /**
   * WRY CONFESSIONAL VISUAL REGRESSION GUARD
   * Throws if prompt contains forbidden cinematic/painterly tokens
   * @param {string} prompt - The image generation prompt to validate
   * @param {string} context - Call site identifier for error messages
   */
  function assertWryConfessionalVisual(prompt, context) {
      const tone = state?.picks?.tone;
      if (tone !== 'Wry Confessional') return; // Only guard Wry Confessional

      const FORBIDDEN_TOKENS = [
          'cinematic', 'painterly', 'photographic', 'photo-real', 'photorealistic',
          'noir', 'dramatic lighting', 'dramatic', 'studio lighting', 'chiaroscuro',
          'depth of field', 'bokeh', 'lens', 'glow', 'hyper-realistic', 'realism', 'oil painting'
      ];

      const promptLower = prompt.toLowerCase();
      for (const token of FORBIDDEN_TOKENS) {
          if (promptLower.includes(token)) {
              const error = `[WRY CONFESSIONAL VIOLATION] Forbidden token "${token}" in prompt at ${context}`;
              console.error(error);
              throw new Error(error);
          }
      }

      console.log(`[WRYâœ“] Visual assertion passed at ${context}`);
  }

  /**
   * WRY CONFESSION â€” CONCRETE SCENE GROUNDING VALIDATOR (AUTHORITATIVE)
   *
   * VISUALIZER RULE: For Wry Confession, tone defines illustration style only.
   * The image SUBJECT must be grounded in a concrete element from the current scene.
   * If no concrete scene element is used, the image is INVALID.
   *
   * @param {string} prompt - The image generation prompt to validate
   * @param {string} sceneContext - Description of the current scene for validation
   * @param {string} callSite - Call site identifier for logging
   * @returns {boolean} True if prompt is grounded in concrete scene elements
   */
  function validateWrySceneGrounding(prompt, sceneContext, callSite) {
      const tone = state?.picks?.tone;
      if (tone !== 'Wry Confessional' && tone !== 'WryConfession') return true; // Only for Wry Confession

      // Concrete scene element indicators
      const CONCRETE_INDICATORS = [
          // Settings/locations
          /\b(room|cafÃ©|office|street|doorway|window|table|desk|chair|bed|kitchen|bathroom|hallway|staircase|car|train|bus|park|garden|balcony|rooftop)\b/i,
          // Character situations/postures
          /\b(standing|sitting|leaning|holding|reaching|turning|walking|running|waiting|watching|looking|hand|hands|fingers|arm|arms|face|eyes|mouth|lips|shoulder|shoulders)\b/i,
          // Objects
          /\b(letter|phone|glass|cup|coffee|wine|book|door|key|ring|mirror|photograph|picture|bag|coat|dress|suit|shoe|hat|cigarette|drink|food|paper|pen|clock|watch)\b/i
      ];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION SALIENCE CONSTRAINT (AUTHORITATIVE)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // When selecting a concrete scene element, PREFER elements that carry
      // narrative pressure or tension. Grounded but narratively irrelevant objects
      // must NOT be used if a pressure-bearing element is present in the scene.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const PRESSURE_BEARING_INDICATORS = [
          // Authority figures
          /\b(boss|manager|supervisor|director|principal|teacher|professor|officer|judge|parent|mother|father|elder|authority)\b/i,
          // Obligations & constraints
          /\b(deadline|contract|bill|invoice|debt|rent|mortgage|obligation|duty|responsibility|requirement|demand|order|summons|notice|warning|ultimatum)\b/i,
          // Crowds & social pressure
          /\b(crowd|audience|onlookers|witnesses|gathering|party|meeting|boardroom|courtroom|waiting room|queue|line of people)\b/i,
          // Surveillance & scrutiny
          /\b(camera|monitor|screen|security|guard|watching eyes|gaze|stare|spotlight|interrogation|interview|examination|inspection)\b/i,
          // Burdens & weight
          /\b(weight|burden|load|stack|pile|mountain of|inbox|paperwork|luggage|baggage|chains|handcuffs|collar|leash|cage|bars|fence|wall|barrier)\b/i,
          // Constraint symbols
          /\b(clock|timer|countdown|calendar|schedule|appointment|wedding ring|engagement ring|uniform|badge|ID card|name tag)\b/i
      ];

      const promptLower = prompt.toLowerCase();
      const contextLower = (sceneContext || '').toLowerCase();
      const hasConcreteElement = CONCRETE_INDICATORS.some(pattern => pattern.test(promptLower));

      // Abstract/ungrounded indicators (warnings)
      const ABSTRACT_INDICATORS = [
          /\b(abstract|swirl|wave|pattern|emotion|feeling|mood|atmosphere|essence|spirit|aura|energy|vibe)\b/i,
          /\b(generic|contemplation|contemplative|pensive|thoughtful) (woman|man|figure|person)\b/i,
          /\b(symbolic|symbolism|metaphor|metaphorical|representation)\b/i
      ];

      const hasAbstractElement = ABSTRACT_INDICATORS.some(pattern => pattern.test(promptLower));

      if (!hasConcreteElement) {
          console.warn(`[WRY SCENE GROUNDING] Missing concrete scene element at ${callSite}`);
          console.warn(`  Prompt: ${prompt.substring(0, 100)}...`);
          console.warn(`  Scene context: ${sceneContext || '(not provided)'}`);
          console.warn(`  RULE: Image subject must be grounded in setting, character situation, or symbolic object from current scene`);
          return false;
      }

      if (hasAbstractElement) {
          console.warn(`[WRY SCENE GROUNDING] Abstract element detected at ${callSite} â€” tone affects style, not subject`);
      }

      // SALIENCE CHECK: Prefer pressure-bearing elements over neutral grounded objects
      const scenePressureElements = PRESSURE_BEARING_INDICATORS
          .filter(pattern => pattern.test(contextLower))
          .map(pattern => {
              const match = contextLower.match(pattern);
              return match ? match[0] : null;
          })
          .filter(Boolean);

      const promptPressureElements = PRESSURE_BEARING_INDICATORS
          .filter(pattern => pattern.test(promptLower))
          .map(pattern => {
              const match = promptLower.match(pattern);
              return match ? match[0] : null;
          })
          .filter(Boolean);

      if (scenePressureElements.length > 0 && promptPressureElements.length === 0) {
          console.warn(`[WRY SALIENCE] Pressure-bearing element available but not used at ${callSite}`);
          console.warn(`  Scene has: [${scenePressureElements.join(', ')}]`);
          console.warn(`  Prompt chose neutral object instead`);
          console.warn(`  RULE: Prefer elements carrying narrative pressure/tension over irrelevant grounded objects`);
          // Return false to enforce salience â€” prompt should use pressure-bearing element
          return false;
      }

      if (promptPressureElements.length > 0) {
          console.log(`[WRYâœ“] Salient pressure element selected: [${promptPressureElements.join(', ')}]`);
      }

      console.log(`[WRYâœ“] Scene grounding validated at ${callSite}`);
      return true;
  }

  // Export for use in image generation pipeline
  window.validateWrySceneGrounding = validateWrySceneGrounding;

  // =================================================================
  // EARNED COVER SYSTEM â€” Progressive cover quality tied to story progress
  // =================================================================

  const COVER_STAGES = {
      SKETCH: 'sketch',
      THUMBNAIL: 'thumbnail',
      ROUGH: 'rough',
      V1: 'v1'
  };

  const COVER_STAGE_LABELS = {
      [COVER_STAGES.SKETCH]: 'Cover Sketch',
      [COVER_STAGES.THUMBNAIL]: 'Cover Thumbnail',
      [COVER_STAGES.ROUGH]: 'Cover Rough',
      [COVER_STAGES.V1]: 'Cover v1'
  };

  // Unlock rules by story length (scene count thresholds)
  // Phase B: Rough is max earned cover. v1 unlocks are inactive.
  // Sketch: 0 = available when story context exists (Scene 1 active)
  const COVER_UNLOCK_RULES = {
      tease: {
          sketch: 0,      // Available when story context exists
          thumbnail: 2,
          rough: null     // Tease maxes out at Thumbnail
      },
      fling: {
          sketch: 0,      // Available when story context exists
          thumbnail: 3,
          rough: 10       // Unlocks at scene 10
      },
      affair: {
          sketch: 0,      // Available when story context exists
          thumbnail: 5,
          rough: 20       // Unlocks at scene 20
      },
      soulmates: {
          sketch: 0,      // Available when story context exists
          thumbnail: 8,
          rough: 30       // Unlocks at scene 30
      }
  };

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STORYTURN â€” AUTHORITATIVE CONFIG
  // Do not modify without design approval
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Storybound Canon v1.0 â€” Audited and Coherent
  // This canon has passed a full coherence audit.
  // All future changes MUST be appended as new appendices.
  // Existing canon must not be edited or reinterpreted.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DESIGN PRINCIPLE â€” AUTHORITATIVE REGIME DECLARATION
  // TAG: storybound/design-principle-authoritative-regimes-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // When a system in Storybound exhibits drift, blending, or silent override
  // behavior, the correct fix is not additional modifiers or constraints.
  //
  // Instead, the system must be elevated to an Authoritative Regime.
  //
  // An Authoritative Regime:
  // - Declares what category of thing something IS
  // - Establishes precedence over modifiers and sub-features
  // - Invalidates incompatible outputs by category, not preference
  // - Is enforced by one binding invariant or self-check
  //
  // Regimes do not blend.
  // Modifiers subordinate.
  // Guidelines are insufficient.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // TERMINOLOGY UPDATE
  // TAG: storybound/terminology-regime-change-v1
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The design principle previously labeled
  // 'Authoritative Regime Declaration' is now canonically named:
  //
  // REGIME CHANGE
  //
  // The meaning, scope, and application remain unchanged.
  //
  // This name is preferred in discussion, audits, and implementation notes.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGIME CHANGE (CANONICAL DEFINITION)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // A Regime Change occurs when a Storybound subsystem
  // is elevated from a modifier-based system to a category-defining authority.
  //
  // Under a Regime Change:
  // - incompatible outputs become invalid by definition
  // - modifiers subordinate instead of blending
  // - one binding invariant or self-check enforces the regime
  // - drift is prevented structurally, not heuristically
  //
  // Regimes do not blend.
  // Only one regime governs a domain at a time.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CROSS-REFERENCE NOTE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Any reference to 'Authoritative Regime Declaration'
  // in prior documentation should be read as 'Regime Change'.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // AUTHORITATIVE REGIMES IN USE (RETROACTIVE LABELING)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The following Storybound subsystems are governed by Authoritative Regimes:
  //
  // 1. Storyturns
  //    - Regime: Irreversible Relational Change
  //    - Effect: Sex, dialogue, or intensity never advance structure alone
  //
  // 2. 5th Person POV (Wry Confessional variant)
  //    - Regime: Narrative Coherence as a Reacting Entity
  //    - Effect: Presence is semantic and reactive, not scheduled or controlling
  //
  // 3. Wry Confessional Visualizer
  //    - Regime: Editorial Representation (Not Photographic)
  //    - Effect: Genre influences symbolism only; realism is category-invalid
  //
  // 4. Sketch Tier Covers
  //    - Regime: Unfinished Artifact
  //    - Effect: Print-ready or polished output is a failure condition
  //
  // 5. Fate Cards
  //    - Regime: Narrative Pressure, Not Permission
  //    - Effect: Early play bends scenes without granting resolution
  //
  // 6. Navigation Spine
  //    - Regime: Canonical Reading Order
  //    - Effect: Side chambers may not become Back destinations
  //
  // This labeling is descriptive, not a rewrite.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DSP â€” MATERIAL REGIME (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DSP is a material regime, not a theme or skin.
  //
  // DSP governs:
  // - geometry (right angles, corner squares)
  // - layering (double-line frames, inset borders)
  // - material illusion (pressed, engraved, weight-bearing surfaces)
  //
  // DSP does not yield to:
  // - container radius defaults
  // - generic button styles
  // - component-local theming
  //
  // If a UI element does not read as DSP when isolated,
  // it has failed the regime.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DSP SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Before finalizing any UI component:
  //
  // "Would this element still be recognizable as DSP
  // if shown alone, without surrounding context?"
  //
  // If NO, regenerate or refactor.
  //
  // This regime supersedes local CSS defaults and component inheritance.
  // Material identity takes precedence over layout convenience.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const STORYTURN_CONFIG = {
    storyLengths: {
      Tease: { minWords: 5000, maxWords: 8000 },
      Fling: { minWords: 12000, maxWords: 20000 },
      Affair: { minWords: 40000, maxWords: 70000 },
      Soulmates: { minWords: 90000, maxWords: 130000 }
    },

    storyturns: [
      { id: "ST1", name: "Attraction Acknowledged" },
      { id: "ST2", name: "Resistance Defined" },
      { id: "ST3", name: "Permission Granted" },
      { id: "ST4", name: "Consequence Taken" },
      { id: "ST5", name: "Crisis Separation" },
      { id: "ST6", name: "Integration" }
    ],

    arousalRules: {
      Clean: {
        sexAllowedAt: [],
        explicitness: "none"
      },
      Naughty: {
        sexAllowedAt: ["ST3", "ST4"],
        explicitness: "suggestive"
      },
      Erotic: {
        sexAllowedAt: ["ST3", "ST4"],
        explicitness: "explicit"
      },
      Dirty: {
        sexAllowedAt: ["ST3"],
        explicitness: "explicit_high"
      }
    },

    teaseRules: {
      maxStoryturn: "ST3",
      completionAllowed: false,
      cliffhangerRequired: true,
      paywalledArousal: ["Erotic", "Dirty"]
    },

    storyturnSemantics: {
      ST1: { phase: "desire", sexualCatalyst: false },
      ST2: { phase: "resistance", sexualCatalyst: false },
      ST3: { phase: "permission", sexualCatalyst: true },
      ST4: { phase: "consequence", sexualCatalyst: true },
      ST5: { phase: "crisis", sexualCatalyst: false },
      ST6: { phase: "integration", sexualCatalyst: false }
    },

    postSexRules: {
      repeatedSexAdvancesStoryturn: false,
      sexAfterST4IsContextual: true
    },

    carryoverRules: {
      allowMultipleArcs: true,
      preserveIntegrationAcrossArcs: true,
      resettableStoryturns: ["ST2", "ST3", "ST4"],
      nonResettableStoryturns: ["ST6"]
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANONICAL STORYTURN SEMANTICS â€” ATTEMPT vs CONSEQUENCE (AUTHORITATIVE)
    // TAG: storybound/storyturn-attempt-consequence-semantics-v1
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // ST3 â€” Permission Granted (Attempts Authorized)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Definition:
    //   ST3 authorizes attempts at intimacy between the two main characters.
    //
    // At ST3:
    //   - Desire may be openly acknowledged
    //   - Boundaries may be approached, tested, or crossed in attempt
    //   - Physical or emotional intimacy may be initiated
    //
    // ST3 explicitly does NOT authorize:
    //   - Completion
    //   - Irreversible consequence
    //   - Relational resolution
    //
    // Valid ST3 outcomes include:
    //   - interruption
    //   - hesitation
    //   - deflection
    //   - withdrawal
    //   - self-sabotage
    //   - escalation without resolution
    //   - cliffhangers
    //
    // Failure to reach consequence is not a failure state.
    // Remaining in ST3 after an attempt is expected behavior.
    //
    // ST3 is about trying.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ST4 â€” Consequence Taken (Attempts Resolved)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Definition:
    //   ST4 authorizes the consequences of intimacy.
    //
    // At ST4:
    //   - Attempts made in ST3 may resolve
    //   - Intimacy may complete
    //   - The relationship enters a new irreversible state
    //
    // ST4 is marked by:
    //   - aftermath
    //   - accountability
    //   - emotional consequence
    //   - narrative reorientation
    //
    // Sex, if present, is a consequence, not a trigger.
    //
    // After ST4:
    //   - Sex becomes contextual only
    //   - Repetition does not advance Storyturns
    //   - The relationship cannot return to its prior state without denial or collapse
    //
    // ST4 is about what it costs.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ST3 â†’ ST4 TRANSITION SEMANTICS (CRITICAL)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // The transition from ST3 to ST4 occurs only when an attempt produces
    // an irreversible consequence.
    //
    // Interruption, deferral, escalation, or increased explicitness alone
    // does NOT advance Storyturns.
    //
    // No special "interruption rule" is required.
    // Failure to reach consequence simply remains within ST3.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // IMPLEMENTATION NOTE (AUTHORITATIVE)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // This semantic clarification REPLACES any prior "first kiss interruption"
    // or "first sex interruption" special-case rules.
    //
    // Do NOT encode this as procedural logic.
    // Do NOT add new conditionals or flags for interruption tracking.
    // Runtime code should reference these semantics when evaluating Storyturn
    // advancement, not reimplement them.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    attemptConsequenceSemantics: {
      ST3: {
        name: "Permission Granted",
        role: "attempts_authorized",
        authorizes: ["desire_acknowledgment", "boundary_testing", "intimacy_initiation"],
        doesNotAuthorize: ["completion", "irreversible_consequence", "relational_resolution"],
        validOutcomes: ["interruption", "hesitation", "deflection", "withdrawal", "self_sabotage", "escalation_without_resolution", "cliffhanger"],
        summary: "ST3 is about trying."
      },
      ST4: {
        name: "Consequence Taken",
        role: "attempts_resolved",
        authorizes: ["attempt_resolution", "intimacy_completion", "irreversible_state_change"],
        markedBy: ["aftermath", "accountability", "emotional_consequence", "narrative_reorientation"],
        postST4: ["sex_contextual_only", "repetition_no_advancement", "no_return_without_denial_or_collapse"],
        summary: "ST4 is about what it costs."
      },
      transitionRule: "ST3 â†’ ST4 occurs only when an attempt produces an irreversible consequence. Interruption, deferral, or escalation alone does NOT advance."
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IRREVERSIBILITY TEST â€” AUTHORITATIVE DEFINITION
    // TAG: storybound/storyturn-attempt-consequence-irrev-v1
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // An action advances a Storyturn ONLY if, after it occurs, the relationship
    // cannot plausibly return to its prior emotional state without denial,
    // repression, or consequence.
    //
    // If the relationship can reasonably resume its previous dynamic with no
    // lasting emotional cost, the action is NOT irreversible and MUST NOT
    // advance a Storyturn.
    //
    // This test applies equally to:
    //   - Fate Card resolutions
    //   - Free-text player input
    //   - Sexual or emotional actions
    //   - Dirty or explicit content
    //
    // Sexual explicitness alone is NEVER sufficient to establish irreversibility.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Examples â€” Irreversible (Advance Eligible)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   - A confession that permanently alters how one character perceives the other
    //   - An intimacy that creates obligation, shame, or accountability
    //   - A choice that forces the relationship into a new emotional posture
    //   - A public or private act that cannot be unspoken or undone
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Examples â€” NOT Irreversible (Do NOT Advance)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   - Sex that resolves no emotional uncertainty
    //   - Erotic escalation without consequence
    //   - An interrupted or aborted attempt at intimacy
    //   - Flirting, temptation, or boundary testing
    //   - Dirty content involving side characters, exes, memories, fantasies, or voyeurism
    //   - Explicit acts that leave the relationship emotionally unchanged
    //
    // When uncertain, prefer NON-ADVANCEMENT.
    // Storyturns represent irreversible relational change, not intensity.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INTERACTION WITH ST3 / ST4
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   - ST3 authorizes attempts; attempts alone do not satisfy irreversibility
    //   - ST4 authorizes consequences; only consequences can satisfy irreversibility
    //   - Failure, interruption, or escalation without consequence remains ST3
    //
    // This appendix replaces any prior heuristic based on:
    //   - "first kiss"
    //   - "first sex"
    //   - interruption counters
    //   - explicitness thresholds
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    irreversibilityTest: {
      definition: "An action advances a Storyturn ONLY if the relationship cannot plausibly return to its prior emotional state without denial, repression, or consequence.",
      appliesTo: ["fate_card_resolutions", "free_text_input", "sexual_actions", "emotional_actions", "dirty_content"],
      sexualExplicitnessAlone: "NEVER sufficient",
      irreversibleExamples: [
        "confession_that_permanently_alters_perception",
        "intimacy_creating_obligation_shame_accountability",
        "choice_forcing_new_emotional_posture",
        "act_that_cannot_be_unspoken_or_undone"
      ],
      notIrreversibleExamples: [
        "sex_resolving_no_emotional_uncertainty",
        "erotic_escalation_without_consequence",
        "interrupted_or_aborted_attempt",
        "flirting_temptation_boundary_testing",
        "dirty_content_with_side_characters_exes_memories_fantasies_voyeurism",
        "explicit_acts_leaving_relationship_unchanged"
      ],
      uncertaintyRule: "prefer_non_advancement",
      summary: "Storyturns represent irreversible relational change, not intensity."
    }
  };

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STORYTURN â€” RUNTIME LOGIC
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  /**
   * Get numeric index for a Storyturn ID (ST1=0, ST2=1, etc.)
   */
  function getStoryturnIndex(stId) {
      const idx = STORYTURN_CONFIG.storyturns.findIndex(st => st.id === stId);
      if (idx === -1) throw new Error(`[STORYTURN] Invalid Storyturn ID: ${stId}`);
      return idx;
  }

  /**
   * Get Storyturn ID by index
   */
  function getStoryturnById(index) {
      if (index < 0 || index >= STORYTURN_CONFIG.storyturns.length) {
          throw new Error(`[STORYTURN] Invalid Storyturn index: ${index}`);
      }
      return STORYTURN_CONFIG.storyturns[index].id;
  }

  /**
   * Get maximum allowed Storyturn for current story length
   * Tease stories cannot advance past ST3
   */
  function getMaxStoryturn() {
      const storyLength = (state.storyLength || 'tease').toLowerCase();
      if (storyLength === 'tease') {
          return STORYTURN_CONFIG.teaseRules.maxStoryturn;
      }
      return 'ST6'; // All other lengths can complete
  }

  /**
   * Check if Storyturn can advance to target
   * Enforces sequential advancement and Tease ceiling
   */
  // Storyturns advance only on irreversible relational consequence.
  // See Storybound Canon v1.0 (Attempt â†’ Consequence, Irreversibility Test).
  function canAdvanceStoryturn(targetSt) {
      const currentIdx = getStoryturnIndex(state.storyturn || 'ST1');
      const targetIdx = getStoryturnIndex(targetSt);
      const maxIdx = getStoryturnIndex(getMaxStoryturn());

      // Must advance sequentially (no skipping)
      if (targetIdx !== currentIdx + 1) {
          console.error(`[STORYTURN] Cannot skip from ${state.storyturn} to ${targetSt}`);
          return false;
      }

      // Cannot exceed max for story length
      if (targetIdx > maxIdx) {
          console.warn(`[STORYTURN] Cannot advance past ${getMaxStoryturn()} for Tease stories`);
          return false;
      }

      return true;
  }

  // Storyturns represent irreversible relational change.
  // Sex and intensity may express a Storyturn but must never
  // advance one unless explicitly permitted by STORYTURN_CONFIG.

  /**
   * Check if a Storyturn permits sexual activity as a catalyst for advancement
   * Only ST3 (Permission) and ST4 (Consequence) have sexualCatalyst: true
   */
  function isStoryturnSexualCatalyst(stId) {
      const semantics = STORYTURN_CONFIG.storyturnSemantics[stId];
      return semantics ? semantics.sexualCatalyst === true : false;
  }

  /**
   * GUARD: Check if sexual activity can contribute to advancing TO a target Storyturn
   * Sexual activity may only contribute to ST3 or ST4 advancement
   */
  function canSexualActivityAdvanceToStoryturn(targetSt) {
      // Sexual catalyst check: only ST3 and ST4 can be advanced via sex
      if (!isStoryturnSexualCatalyst(targetSt)) {
          return false;
      }

      // Post-ST4 rule: sex after ST4 is contextual only
      const currentIdx = getStoryturnIndex(state.storyturn || 'ST1');
      const st4Idx = getStoryturnIndex('ST4');
      if (currentIdx >= st4Idx && STORYTURN_CONFIG.postSexRules.sexAfterST4IsContextual) {
          return false;
      }

      // Repeated sex rule: if already past first sex, no advancement
      if (!STORYTURN_CONFIG.postSexRules.repeatedSexAdvancesStoryturn) {
          // If we're already at ST4 or beyond, repeated sex cannot advance
          if (currentIdx >= st4Idx) {
              return false;
          }
      }

      return true;
  }

  /**
   * Advance Storyturn to next stage
   * Throws if advancement is invalid
   */
  function advanceStoryturn() {
      // Storyturn advancement must satisfy ATTEMPTâ†’CONSEQUENCE semantics and the Irreversibility Test (see STORYTURN_CONFIG semantics appendix)
      const currentIdx = getStoryturnIndex(state.storyturn || 'ST1');
      const nextSt = getStoryturnById(currentIdx + 1);

      if (!canAdvanceStoryturn(nextSt)) {
          throw new Error(`[STORYTURN] Invalid advancement from ${state.storyturn} to ${nextSt}`);
      }

      const prevSt = state.storyturn;
      state.storyturn = nextSt;
      console.log(`[STORYTURN] Advanced: ${prevSt} â†’ ${nextSt}`);

      // If Tease hits ST3 ceiling, store cliffhanger state for potential upgrade
      const storyLengthNorm = (state.storyLength || 'tease').toLowerCase();
      if (storyLengthNorm === 'tease' && nextSt === 'ST3') {
          state.teaseCliffhangerState = {
              storyturn: 'ST3',
              sceneIndex: state.turnCount,
              storyContent: state.currentStoryContent,
              timestamp: Date.now()
          };
          console.log('[STORYTURN] Tease cliffhanger state captured at ST3');
      }

      return nextSt;
  }

  /**
   * ASSERTION: Validate arousal level is allowed for story length
   * Erotic/Dirty NOT allowed on Tease (must upgrade first)
   */
  function assertArousalAllowedForStoryLength() {
      const storyLength = (state.storyLength || 'tease').toLowerCase();
      const arousal = state.intensity || 'Naughty';

      if (storyLength === 'tease' && STORYTURN_CONFIG.teaseRules.paywalledArousal.includes(arousal)) {
          throw new Error(`[STORYTURN] ${arousal} intensity not allowed on Tease. Upgrade required.`);
      }
  }

  /**
   * Check if sex is allowed at current Storyturn for given arousal level
   */
  function isSexAllowedAtCurrentStoryturn() {
      const arousal = state.intensity || 'Naughty';
      const currentSt = state.storyturn || 'ST1';
      const rules = STORYTURN_CONFIG.arousalRules[arousal];

      if (!rules) {
          console.warn(`[STORYTURN] Unknown arousal level: ${arousal}`);
          return false;
      }

      return rules.sexAllowedAt.includes(currentSt);
  }

  /**
   * Check if sex COMPLETION is allowed (not just initiation)
   * Tease can initiate at ST3 but CANNOT complete
   */
  function isSexCompletionAllowed() {
      const storyLength = (state.storyLength || 'tease').toLowerCase();

      // Tease never allows completion
      if (storyLength === 'tease' && !STORYTURN_CONFIG.teaseRules.completionAllowed) {
          return false;
      }

      // Must be at allowed Storyturn
      return isSexAllowedAtCurrentStoryturn();
  }

  /**
   * ASSERTION: Block sex completion if not allowed
   */
  function assertSexCompletionAllowed() {
      if (!isSexCompletionAllowed()) {
          const storyLength = (state.storyLength || 'tease').toLowerCase();
          const currentSt = state.storyturn || 'ST1';

          if (storyLength === 'tease') {
              throw new Error(`[STORYTURN] Sex completion blocked: Tease stories require upgrade`);
          } else {
              throw new Error(`[STORYTURN] Sex completion blocked at ${currentSt}. Not in allowed Storyturns.`);
          }
      }
  }

  /**
   * ASSERTION: Enforce post-sex rules and sexual catalyst restrictions
   * - After ST4, sex is contextual only (no advancement)
   * - Repeated sex never advances Storyturn
   * - Non-catalyst Storyturns (ST1, ST2, ST5, ST6) cannot be advanced via sex
   */
  function assertSexDoesNotAdvanceStoryturn(isSexScene, attemptingAdvancement = false) {
      if (!isSexScene) return; // Not a sex scene, no assertion needed

      const currentSt = state.storyturn || 'ST1';
      const currentIdx = getStoryturnIndex(currentSt);
      const st4Idx = getStoryturnIndex('ST4');
      const nextSt = currentIdx < 5 ? getStoryturnById(currentIdx + 1) : null;

      // ASSERTION 1: Post-ST4 sex is contextual only
      if (currentIdx >= st4Idx && STORYTURN_CONFIG.postSexRules.sexAfterST4IsContextual) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] Sex cannot advance Storyturn after ST4 â€” contextual only`);
          }
          console.log(`[STORYTURN] Sex scene at ${currentSt} â€” contextual, no advancement`);
      }

      // ASSERTION 2: Repeated sex never advances Storyturn
      if (!STORYTURN_CONFIG.postSexRules.repeatedSexAdvancesStoryturn && attemptingAdvancement) {
          throw new Error(`[STORYTURN] Repeated sex cannot advance Storyturn â€” postSexRules violation`);
      }

      // ASSERTION 3: Non-catalyst Storyturns cannot be advanced via sex
      if (nextSt && attemptingAdvancement) {
          const nextSemantics = STORYTURN_CONFIG.storyturnSemantics[nextSt];
          if (nextSemantics && !nextSemantics.sexualCatalyst) {
              throw new Error(`[STORYTURN] ${nextSt} (${nextSemantics.phase}) cannot be advanced via sexual activity`);
          }
      }
  }

  /**
   * Handle Tease upgrade resume logic
   * When a Tease cliffhanger is upgraded, resume at the interrupted point
   */
  function handleTeaseUpgradeResume(newStoryLength) {
      if (!state.teaseCliffhangerState) {
          console.log('[STORYTURN] No cliffhanger state to resume');
          return false;
      }

      const lengthNorm = (newStoryLength || 'tease').toLowerCase();
      if (lengthNorm === 'tease') {
          console.warn('[STORYTURN] Cannot resume cliffhanger without upgrading from Tease');
          return false;
      }

      console.log(`[STORYTURN] Resuming from Tease cliffhanger at ${state.teaseCliffhangerState.storyturn}`);

      // Storyturn stays at ST3 â€” will advance to ST4 only after consequence taken
      state.storyturn = state.teaseCliffhangerState.storyturn;

      // Clear cliffhanger state after resume
      state.teaseCliffhangerState = null;

      return true;
  }

  /**
   * Reset Storyturn state for new story
   */
  function resetStoryturnState() {
      state.storyturn = 'ST1';
      state.teaseCliffhangerState = null;
  }

  /**
   * GUARD: Validate Storyturn rollback is allowed
   * Only resettable Storyturns can be rolled back (per carryoverRules)
   */
  function canRollbackStoryturn(fromSt, toSt) {
      const fromIdx = getStoryturnIndex(fromSt);
      const toIdx = getStoryturnIndex(toSt);

      // Cannot rollback forward
      if (toIdx >= fromIdx) return false;

      // Check if fromSt is in nonResettableStoryturns
      if (STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes(fromSt)) {
          console.error(`[STORYTURN] Cannot rollback from ${fromSt} â€” integration is permanent`);
          return false;
      }

      // Check if toSt would require passing through non-resettable
      for (let i = toIdx; i < fromIdx; i++) {
          const st = getStoryturnById(i);
          if (STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes(st)) {
              console.error(`[STORYTURN] Cannot rollback through ${st} â€” integration is permanent`);
              return false;
          }
      }

      return true;
  }

  /**
   * Reset Storyturn for a new arc (multi-arc support)
   * Respects carryoverRules: preserves ST6, allows resettable Storyturns
   */
  function resetStoryturnForNewArc() {
      if (!STORYTURN_CONFIG.carryoverRules.allowMultipleArcs) {
          console.warn('[STORYTURN] Multi-arc not enabled');
          return false;
      }

      const currentSt = state.storyturn || 'ST1';

      // ST6 (Integration) persists across arcs
      if (STORYTURN_CONFIG.carryoverRules.preserveIntegrationAcrossArcs &&
          STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes(currentSt)) {
          console.log(`[STORYTURN] ${currentSt} preserved across arc â€” no reset`);
          return false;
      }

      // Find the earliest resettable Storyturn
      const resettable = STORYTURN_CONFIG.carryoverRules.resettableStoryturns;
      if (resettable.length > 0) {
          // Reset to ST2 (first resettable) to begin new arc resistance phase
          const targetSt = resettable[0];
          if (canRollbackStoryturn(currentSt, targetSt)) {
              state.storyturn = targetSt;
              console.log(`[STORYTURN] New arc started at ${targetSt}`);
              return true;
          }
      }

      return false;
  }

  /**
   * ASSERTION: ST6 cannot be reset (carryoverRules enforcement)
   */
  function assertST6NotReset(targetSt) {
      if (state.storyturn === 'ST6' && targetSt !== 'ST6') {
          if (STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes('ST6')) {
              throw new Error('[STORYTURN] ST6 (Integration) cannot be reset â€” permanent state');
          }
      }
  }

  /**
   * ASSERTION: Storyturn order cannot be skipped
   */
  function assertNoStoryturnSkip(fromSt, toSt) {
      const fromIdx = getStoryturnIndex(fromSt);
      const toIdx = getStoryturnIndex(toSt);

      if (toIdx > fromIdx + 1) {
          throw new Error(`[STORYTURN] Cannot skip from ${fromSt} to ${toSt} â€” sequential advancement required`);
      }
  }

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // FATE CARD â†” STORYTURN INTERACTION
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  // Fate Cards apply pressure and shape moments.
  // Storyturns record irreversible commitment.
  // Cards are always playable, but may resolve only partially
  // until the Storyturn allows full consequence.

  const FATE_CARD_STORYTURN_MAP = {
      confession: ["ST1"],
      boundary: ["ST2", "ST5"],
      temptation: ["ST3"],
      reversal: ["ST4"],
      silence: ["ST6"]
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARTIAL FATE CARD RESOLUTION â€” AUTHORITATIVE SEMANTICS
  // TAG: storybound/fatecards-partial-resolution-semantics-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // Fate Cards are ALWAYS playable. Availability is never restricted.
  //
  // However, Fate Cards do NOT automatically advance Storyturns.
  // They apply pressure that may resolve partially, deflect, or defer
  // depending on narrative readiness.
  //
  // Early play MUST NOT silently fail.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // GENERAL RULE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When a Fate Card is played before its canonical Storyturn is eligible:
  //   - The card MUST produce narrative effect
  //   - The effect MUST respect current Storyturn semantics
  //   - Resolution MUST be partial, deflected, or unresolved
  //   - The story MUST acknowledge the pressure without granting consequence
  //
  // Fate Cards never grant permission.
  // They invite the story to lean.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CANONICAL PARTIAL RESOLUTION PATTERNS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //
  // Confession (Canonical: ST1 â€” Attraction Acknowledged)
  //   Early Resolution:
  //     - Truth is spoken but meaning is deflected
  //     - Admission is reframed, minimized, joked away, or misunderstood
  //     - Emotional signal lands without permanent acknowledgment
  //   Confession early does NOT force attraction to be accepted.
  //
  // Boundary (Canonical: ST2 â€” Resistance Defined / ST5 â€” Crisis)
  //   Early Resolution:
  //     - A boundary is asserted, but motive is unclear
  //     - Boundary may be porous, conditional, or emotionally conflicted
  //     - Resistance is reinforced without finality
  //   Boundary early does NOT finalize separation or crisis.
  //
  // Temptation (Canonical: ST3 â€” Permission Granted)
  //   Early Resolution:
  //     - Desire is acknowledged without action
  //     - Intimacy is approached but not initiated
  //     - Physical proximity increases without consequence
  //   Temptation early does NOT authorize completion.
  //
  // Reversal (Canonical: ST4 â€” Consequence Taken)
  //   Early Resolution:
  //     - Emotional power shifts internally
  //     - Vulnerability is revealed without aftermath
  //     - One character realizes something the other does not yet act on
  //   Reversal early does NOT produce irreversible consequence.
  //
  // Silence (Canonical: ST6 â€” Integration)
  //   Early Resolution:
  //     - Absence creates meaning, not closure
  //     - Silence heightens longing or distance
  //     - Integration is hinted at but not achieved
  //   Silence early does NOT resolve the arc.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INTERACTION WITH STORYTURNS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //   - Fate Cards may APPLY pressure toward a Storyturn
  //   - Fate Cards may NEVER FORCE a Storyturn
  //   - Advancement requires satisfying the Irreversibility Test
  //   - Attempt without consequence remains within current Storyturn
  //
  // When uncertain, prefer:
  //   - partial effect
  //   - emotional tension
  //   - narrative deferral
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // TONE-SENSITIVE APPLICATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Partial resolution should respect tone:
  //   - Wry tones may deflect with irony
  //   - Dirty tones may escalate desire without payoff
  //   - Serious tones may internalize conflict
  //   - Romantic tones may soften but not resolve
  //
  // Never neutralize a Fate Card.
  // Never fully ignore it.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const FATE_CARD_PARTIAL_RESOLUTION_SEMANTICS = {
      general: {
          rule: "Early play produces partial, deflected, or unresolved effect â€” never silent failure",
          fateCardsNeverGrantPermission: true,
          fateCardsInviteStoryToLean: true
      },
      confession: {
          canonical: "ST1",
          earlyResolution: ["truth_deflected", "admission_reframed", "signal_without_acknowledgment"],
          doesNotForce: "attraction_accepted"
      },
      boundary: {
          canonical: ["ST2", "ST5"],
          earlyResolution: ["motive_unclear", "porous_conditional", "emotionally_conflicted"],
          doesNotForce: "separation_or_crisis_finalized"
      },
      temptation: {
          canonical: "ST3",
          earlyResolution: ["desire_acknowledged_without_action", "intimacy_approached_not_initiated", "proximity_without_consequence"],
          doesNotForce: "completion_authorized"
      },
      reversal: {
          canonical: "ST4",
          earlyResolution: ["internal_power_shift", "vulnerability_without_aftermath", "realization_not_acted_upon"],
          doesNotForce: "irreversible_consequence"
      },
      silence: {
          canonical: "ST6",
          earlyResolution: ["absence_creates_meaning_not_closure", "heightened_longing_or_distance", "integration_hinted_not_achieved"],
          doesNotForce: "arc_resolved"
      },
      uncertaintyPreference: ["partial_effect", "emotional_tension", "narrative_deferral"],
      toneApplication: {
          wry: "deflect_with_irony",
          dirty: "escalate_desire_without_payoff",
          serious: "internalize_conflict",
          romantic: "soften_but_not_resolve"
      },
      neverNeutralize: true,
      neverFullyIgnore: true
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // FATE CARD â€” PARTIAL RESOLUTION SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When a Fate Card is played outside its canonical Storyturn resolution,
  // Claude MUST silently evaluate:
  //
  // "Did this card apply pressure without granting resolution?"
  //
  // If the card:
  // â€¢ cleanly resolves
  // â€¢ advances a Storyturn
  // â€¢ removes tension
  // â€¢ or behaves as permission
  //
  // then it has failed.
  //
  // Early Fate Cards must bend the scene, not settle it.
  //
  // Failure requires regeneration, not explanation.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APPENDIX A â€” PREMISE VIOLATION COUNTER (AUTHORITATIVE)
  // TAG: storybound/premise-violation-counter-and-regression-tests-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // Purpose:
  // To handle extreme, trollish, or premise-destroying player actions
  // without breaking tone, scolding the player, or turning the system
  // into a rules enforcer.
  //
  // This counter applies ONLY to actions that refuse the romance premise.
  // It does NOT apply to in-genre resistance.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEFINITION â€” PREMISE REFUSAL
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Premise refusal includes (non-exhaustive):
  //   - Persistent pursuit of non-protagonist romantic targets
  //   - Attempts to kill or permanently remove the love interest
  //   - Actions that explicitly negate the romance genre contract
  //   - Repeated attempts to escape, nullify, or sabotage the premise
  //
  // Premise refusal is NOT:
  //   - fear, avoidance, cruelty, mistrust
  //   - flirting with side characters as deflection
  //   - self-sabotage that increases tension
  //   - erotic content involving others
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // THREE-PHASE RESPONSE MODEL (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //
  // PHASE 1 â€” AUTHORIAL REINTERPRETATION (first violation)
  //   - Assume metaphor, fantasy, impulse, intrusive thought, or emotional outburst
  //   - Reframe the action narratively
  //   - No scolding
  //   - No explanation of rules
  //   - No visible counter
  //   Purpose: preserve immersion and give benefit of doubt.
  //
  // PHASE 2 â€” NARRATIVE RESISTANCE (second violation)
  //   - World resists the action
  //   - Other character withdraws, intervenes, or refuses
  //   - Tone sobers or cools
  //   - Consequence is felt but story continues
  //   Purpose: signal genre boundaries without breaking fiction.
  //
  // PHASE 3 â€” GENRE COLLAPSE ENDING (third violation)
  //   - Brief, unromantic, consequential ending
  //   - No erotic payoff
  //   - No rewards
  //   - No continuation
  //   - No reset
  //   Purpose: mirror how serious novels end when protagonists
  //   persistently reject the premise.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IMPORTANT NOTES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //   - The counter is semantic, not punitive
  //   - It should never be surfaced numerically
  //   - It must never be explained to the player
  //   - Collapse is rare, deliberate, and final
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const PREMISE_VIOLATION_COUNTER_SEMANTICS = {
      appliesTo: "actions_that_refuse_romance_premise",
      doesNotApplyTo: ["fear", "avoidance", "cruelty", "mistrust", "side_character_flirting", "self_sabotage", "erotic_content_with_others"],
      premiseRefusalExamples: [
          "persistent_pursuit_of_non_protagonist_targets",
          "attempts_to_kill_or_remove_love_interest",
          "explicit_negation_of_romance_genre_contract",
          "repeated_premise_escape_or_sabotage"
      ],
      phases: {
          1: {
              name: "Authorial Reinterpretation",
              response: ["assume_metaphor_or_impulse", "reframe_narratively", "no_scolding", "no_rule_explanation", "no_visible_counter"],
              purpose: "preserve_immersion_and_benefit_of_doubt"
          },
          2: {
              name: "Narrative Resistance",
              response: ["world_resists", "character_withdraws_or_refuses", "tone_sobers", "consequence_felt"],
              purpose: "signal_genre_boundaries_without_breaking_fiction"
          },
          3: {
              name: "Genre Collapse Ending",
              response: ["brief_unromantic_ending", "no_erotic_payoff", "no_rewards", "no_continuation", "no_reset"],
              purpose: "mirror_serious_novels_when_protagonist_rejects_premise"
          }
      },
      counterIsSemantic: true,
      counterNeverSurfaced: true,
      counterNeverExplained: true,
      collapseIsRareAndFinal: true
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APPENDIX B â€” CANONICAL REGRESSION TEST STORIES
  // TAG: storybound/premise-violation-counter-and-regression-tests-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // These are narrative invariants.
  // Any future change must preserve these outcomes.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGRESSION STORY 1 â€” CLEAN TEASE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Setup:
  //   - Story Length: Tease
  //   - Arousal: Flirty or Naughty
  //   - Tone: Romantic or Wry
  //
  // Invariant Outcomes:
  //   - Multiple ST3 attempts at intimacy
  //   - No ST4 consequence
  //   - Cliffhanger ending
  //   - Sexual tension unresolved
  //   - Upgrade required for completion
  //
  // Failure Conditions:
  //   - Early kiss or sex resolves
  //   - Storyturn advances to ST4
  //   - Emotional closure occurs
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGRESSION STORY 2 â€” DIRTY FLING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Setup:
  //   - Story Length: Fling
  //   - Arousal: Dirty
  //   - Tone: Erotic or Dark Romantic
  //
  // Invariant Outcomes:
  //   - Early erotic content allowed
  //   - Side-character sex permitted
  //   - Main-pair intimacy attempts frequent
  //   - ST3 loops common
  //   - ST4 occurs only after consequence
  //
  // Failure Conditions:
  //   - Explicitness alone advances Storyturns
  //   - Main-pair sex resolves before consequence
  //   - Erotic content collapses tension
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGRESSION STORY 3 â€” SOULMATES RESET ARC
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Setup:
  //   - Story Length: Soulmates
  //   - Arc 1 reaches ST6 (Integration)
  //
  // Invariant Outcomes:
  //   - Subsequent arcs reset ST2â€“ST4
  //   - ST6 continuity preserved
  //   - Intimacy re-earned in new context
  //   - No emotional amnesia
  //
  // Failure Conditions:
  //   - ST6 wiped or forgotten
  //   - Intimacy treated as new without consequence
  //   - Storyturns advance mechanically
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IMPLEMENTATION NOTE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // These regression stories are conceptual tests.
  // They are not automated unless explicitly implemented later.
  // They exist to prevent philosophical drift.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const CANONICAL_REGRESSION_TEST_STORIES = {
      cleanTease: {
          setup: { storyLength: "Tease", arousal: ["Flirty", "Naughty"], tone: ["Romantic", "Wry"] },
          invariantOutcomes: ["multiple_ST3_attempts", "no_ST4_consequence", "cliffhanger_ending", "tension_unresolved", "upgrade_required"],
          failureConditions: ["early_kiss_or_sex_resolves", "storyturn_advances_to_ST4", "emotional_closure_occurs"]
      },
      dirtyFling: {
          setup: { storyLength: "Fling", arousal: "Dirty", tone: ["Erotic", "Dark Romantic"] },
          invariantOutcomes: ["early_erotic_content_allowed", "side_character_sex_permitted", "main_pair_attempts_frequent", "ST3_loops_common", "ST4_only_after_consequence"],
          failureConditions: ["explicitness_alone_advances_storyturns", "main_pair_sex_resolves_before_consequence", "erotic_content_collapses_tension"]
      },
      soulmatesResetArc: {
          setup: { storyLength: "Soulmates", arc1Reaches: "ST6" },
          invariantOutcomes: ["subsequent_arcs_reset_ST2_ST4", "ST6_continuity_preserved", "intimacy_re_earned", "no_emotional_amnesia"],
          failureConditions: ["ST6_wiped_or_forgotten", "intimacy_treated_as_new_without_consequence", "storyturns_advance_mechanically"]
      },
      implementationNote: "Conceptual tests to prevent philosophical drift. Not automated unless explicitly implemented."
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APPENDIX â€” AUTHORIAL DEFAULTS WHEN UNCERTAIN (AUTHORITATIVE)
  // TAG: storybound/when-uncertain-authorial-defaults-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // Purpose:
  // To ensure Storybound behaves like a thoughtful author when meaning,
  // intent, or consequence is ambiguous, rather than like a rules engine.
  //
  // This appendix applies whenever:
  //   - It is unclear whether an action is irreversible
  //   - It is unclear whether a Storyturn should advance
  //   - It is unclear how strongly a Fate Card should resolve
  //   - It is unclear whether intimacy has been "earned"
  //   - It is unclear whether a player action refuses the premise
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PRIMARY RULE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When uncertain, Storybound MUST choose the interpretation that:
  //   - Preserves narrative tension
  //   - Preserves the romance premise
  //   - Preserves future possibility
  //   - Avoids premature resolution
  //
  // This preference overrides player impatience, explicitness, or escalation.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STORYTURN DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear whether an action produces irreversible consequence:
  //   - DO NOT advance the Storyturn
  //   - Remain in the current Storyturn
  //   - Allow narrative pressure to continue accumulating
  //
  // Storyturns represent irreversible change.
  // Uncertainty implies reversibility.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INTIMACY DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear whether intimacy between the two main characters
  // should resolve:
  //   - Treat the moment as an ATTEMPT, not a CONSEQUENCE
  //   - Favor interruption, hesitation, deflection, or aftermath-without-resolution
  //   - Preserve unresolved desire
  //
  // Resolution must be earned, not inferred.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // FATE CARD DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear how fully a Fate Card should resolve:
  //   - Apply partial resolution
  //   - Let the card influence tone, framing, or internal state
  //   - Do not grant permission or consequence prematurely
  //
  // Fate Cards apply pressure; they do not decide outcomes.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PREMISE DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear whether a player action refuses the premise:
  //   - Treat it as in-genre resistance
  //   - Reinterpret charitably
  //   - Apply narrative resistance rather than collapse
  //
  // Collapse occurs only after clear, repeated refusal.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // EXPLICITNESS DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Explicit content does NOT override uncertainty.
  // Explicitness alone is never evidence of:
  //   - irreversibility
  //   - Storyturn advancement
  //   - earned intimacy
  //
  // When explicitness conflicts with structure, structure prevails.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // AUTHORIAL PRINCIPLE (SUMMARY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When unsure:
  //   - Prefer tension over payoff
  //   - Prefer delay over collapse
  //   - Prefer ambiguity over certainty
  //   - Prefer earned consequences over mechanical triggers
  //
  // Storybound is an author.
  // Authors do not rush the ending.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const AUTHORIAL_DEFAULTS_WHEN_UNCERTAIN = {
      appliesWhen: [
          "unclear_if_action_is_irreversible",
          "unclear_if_storyturn_should_advance",
          "unclear_how_fully_fate_card_resolves",
          "unclear_if_intimacy_is_earned",
          "unclear_if_player_refuses_premise"
      ],
      primaryRule: {
          choose: ["preserves_narrative_tension", "preserves_romance_premise", "preserves_future_possibility", "avoids_premature_resolution"],
          overrides: ["player_impatience", "explicitness", "escalation"]
      },
      defaults: {
          storyturn: {
              ifUnclear: "do_not_advance",
              action: "remain_in_current_storyturn",
              reason: "uncertainty_implies_reversibility"
          },
          intimacy: {
              ifUnclear: "treat_as_attempt_not_consequence",
              favor: ["interruption", "hesitation", "deflection", "aftermath_without_resolution"],
              reason: "resolution_must_be_earned"
          },
          fateCard: {
              ifUnclear: "apply_partial_resolution",
              allow: ["influence_tone", "influence_framing", "influence_internal_state"],
              doNot: "grant_permission_or_consequence_prematurely"
          },
          premise: {
              ifUnclear: "treat_as_in_genre_resistance",
              action: "reinterpret_charitably",
              reason: "collapse_only_after_clear_repeated_refusal"
          },
          explicitness: {
              doesNotOverride: "uncertainty",
              neverEvidenceOf: ["irreversibility", "storyturn_advancement", "earned_intimacy"],
              conflictRule: "structure_prevails"
          }
      },
      authorialPrinciple: {
          prefer: ["tension_over_payoff", "delay_over_collapse", "ambiguity_over_certainty", "earned_consequences_over_mechanical_triggers"],
          summary: "Storybound is an author. Authors do not rush the ending."
      }
  };

  /**
   * Check if a Fate Card can fully resolve at current Storyturn
   * Cards are ALWAYS playable â€” this only determines resolution depth
   */
  function canFateCardFullyResolve(cardId) {
      const currentSt = state.storyturn || 'ST1';
      const mappedStoryturns = FATE_CARD_STORYTURN_MAP[cardId?.toLowerCase()];

      if (!mappedStoryturns) {
          // Unknown card â€” allow partial resolution
          return false;
      }

      return mappedStoryturns.includes(currentSt);
  }

  /**
   * Get Fate Card resolution mode based on current Storyturn
   * Returns: 'full' | 'partial'
   * Cards are NEVER disabled â€” only resolution depth changes
   */
  function getFateCardResolutionMode(cardId) {
      return canFateCardFullyResolve(cardId) ? 'full' : 'partial';
  }

  /**
   * Build Fate Card resolution directive for story prompt
   * Instructs the model how to handle the card based on Storyturn alignment
   */
  function buildFateCardResolutionDirective(selectedFateCard) {
      if (!selectedFateCard || !selectedFateCard.id) {
          return '';
      }

      const cardId = selectedFateCard.id.toLowerCase();
      const cardTitle = selectedFateCard.title || cardId;
      const currentSt = state.storyturn || 'ST1';
      const resolutionMode = getFateCardResolutionMode(cardId);

      // Check post-sex rules for sex-related cards
      const currentIdx = getStoryturnIndex(currentSt);
      const st4Idx = getStoryturnIndex('ST4');
      const isPostST4 = currentIdx >= st4Idx;

      if (resolutionMode === 'full') {
          return `
FATE CARD RESOLUTION (${cardTitle} @ ${currentSt} â€” FULL):
The Storyturn aligns with this card. Allow irreversible consequences to land.
- The moment may resolve completely
- Emotional commitments may become permanent
- If an irreversible decision is completed, Storyturn MAY advance (but only via decision, not the card itself)`;
      }

      // Partial resolution â€” card-specific guidance
      const partialGuidance = {
          confession: `Confession attempted but misunderstood, interrupted, or denied. Truth is spoken but not received. Tension increases.`,
          boundary: `Boundary is hinted or tested but not enforced. The line wavers. Neither party fully commits to holding or crossing it.`,
          temptation: `Near-miss, hesitation, or escalation without consummation. Desire is acknowledged but not acted upon. The pull intensifies.`,
          reversal: `Power shift is threatened but not completed. Control wavers but neither party fully yields. Consequence is deferred.`,
          silence: `Silence feels uneasy, loaded, or unresolved. The moment stretches but resolution remains out of reach.`
      };

      const guidance = partialGuidance[cardId] || 'The moment builds tension but does not fully resolve.';

      // Post-ST4 sex guard
      let postSexGuard = '';
      if (isPostST4 && ['temptation', 'reversal'].includes(cardId)) {
          postSexGuard = `
NOTE: Post-ST4 rules apply. Sex scenes are allowed but must NOT advance Storyturn.`;
      }

      return `
FATE CARD RESOLUTION (${cardTitle} @ ${currentSt} â€” PARTIAL):
Storyturn does not yet support full resolution of this card.
${guidance}
- Produce narrative response (never silent failure)
- Increase tension, pressure, or clarity
- Do NOT advance Storyturn
- Do NOT allow irreversible commitment to land${postSexGuard}`;
  }

  /**
   * GUARD: Fate Card cannot directly advance Storyturn
   * Storyturns advance only via irreversible decisions, never cards
   */
  function assertFateCardDoesNotAdvanceStoryturn(cardId, attemptingAdvancement = false) {
      if (!attemptingAdvancement) return;

      // Fate Cards shape moments but NEVER directly advance Storyturns
      throw new Error(`[STORYTURN] Fate Card "${cardId}" cannot directly advance Storyturn â€” decisions only`);
  }

  /**
   * GUARD: Fate Card respects carryoverRules (ST6 permanence)
   */
  function assertFateCardRespectsCarryover(cardId) {
      const currentSt = state.storyturn || 'ST1';

      // ST6 cannot be reset by any Fate Card
      if (currentSt === 'ST6' && STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes('ST6')) {
          // Boundary card in ST6 context: can apply pressure but cannot undo integration
          if (cardId === 'boundary') {
              console.log('[STORYTURN] Boundary card at ST6 â€” pressure applied, integration preserved');
          }
      }
  }

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // FREE-TEXT INPUT â†” STORYTURN GUARDS
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  // Free-text input follows identical Storyturn rules as Fate Cards.
  // Sexual content alone never advances Storyturns.
  // Only irreversible narrative commitments may trigger advancement.

  /**
   * Build Storyturn guard directive for free-text input
   * Applies same rules as Fate Cards â€” no bypass allowed
   */
  function buildFreeTextStoryturnDirective(action, dialogue) {
      const currentSt = state.storyturn || 'ST1';
      const currentIdx = getStoryturnIndex(currentSt);
      const storyLengthNorm = (state.storyLength || 'tease').toLowerCase();
      const st4Idx = getStoryturnIndex('ST4');
      const isPostST4 = currentIdx >= st4Idx;

      // Get Storyturn semantics for current position
      const semantics = STORYTURN_CONFIG.storyturnSemantics[currentSt];
      const phase = semantics ? semantics.phase : 'unknown';

      // Tease ceiling check
      const maxSt = getMaxStoryturn();
      const atTeaseCeiling = storyLengthNorm === 'tease' && currentSt === maxSt;

      let directive = `
STORYTURN GUARD (Free-Text Input @ ${currentSt} â€” ${phase} phase):`;

      // Post-ST4: sex is contextual only
      if (isPostST4) {
          directive += `
- Sexual content is ALLOWED but must NOT advance Storyturn
- Post-ST4 rule: sexAfterST4IsContextual = true
- Repeated intimacy shapes meaning, not progression`;
      }

      // Tease ceiling
      if (atTeaseCeiling) {
          directive += `
- TEASE CEILING ACTIVE: Cannot advance past ${maxSt}
- Escalation builds tension but cannot resolve
- Sex initiation allowed, completion BLOCKED`;
      }

      // Storyturn advancement rules
      directive += `
- Storyturn advancement requires IRREVERSIBLE narrative commitment
- Flirtation, escalation, or tension alone do NOT advance Storyturn
- Sexual activity alone NEVER advances Storyturn
- Only explicit permission-granting, consequence-accepting, or boundary-crossing decisions may advance`;

      // Phase-specific guidance
      if (currentSt === 'ST1') {
          directive += `
- ST1 (Attraction): Desire acknowledged but not acted upon
- Confession or declaration may advance to ST2 if irreversible`;
      } else if (currentSt === 'ST2') {
          directive += `
- ST2 (Resistance): Obstacles or hesitation active
- Permission-granting language may advance to ST3 only if truly irreversible`;
      } else if (currentSt === 'ST3') {
          directive += `
- ST3 (Permission): Intimacy gateway open
- Consequence-accepting may advance to ST4 only if Tease ceiling permits`;
      } else if (currentSt === 'ST4') {
          directive += `
- ST4 (Consequence): Aftermath being processed
- Crisis or separation may advance to ST5`;
      } else if (currentSt === 'ST5') {
          directive += `
- ST5 (Crisis): Separation or doubt active
- Integration/reunion may advance to ST6`;
      } else if (currentSt === 'ST6') {
          directive += `
- ST6 (Integration): PERMANENT state â€” cannot be reset
- All content is contextual, no further Storyturn advancement`;
      }

      return directive;
  }

  /**
   * ASSERTION: Free-text input cannot bypass Storyturn rules
   */
  function assertFreeTextRespectsStoryturn(action, dialogue, attemptingAdvancement = false) {
      const currentSt = state.storyturn || 'ST1';
      const storyLengthNorm = (state.storyLength || 'tease').toLowerCase();

      // Tease ceiling
      if (storyLengthNorm === 'tease' && currentSt === STORYTURN_CONFIG.teaseRules.maxStoryturn) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] Free-text cannot advance past ${currentSt} on Tease`);
          }
      }

      // Post-ST4 sex rule
      const currentIdx = getStoryturnIndex(currentSt);
      const st4Idx = getStoryturnIndex('ST4');
      if (currentIdx >= st4Idx && STORYTURN_CONFIG.postSexRules.sexAfterST4IsContextual) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] Free-text sexual content cannot advance Storyturn after ST4`);
          }
      }

      // ST6 permanence
      if (currentSt === 'ST6' && STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes('ST6')) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] ST6 is permanent â€” free-text cannot reset or advance`);
          }
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PREMATURE ROMANCE COLLAPSE PREVENTION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // REGIME CONTEXT (LOCKED)
  // Storybound is a collaborative romance novel engine, not a simulator.
  // Players express intent. The Story controls timing, consequences, and pacing.
  //
  // CORE RULE (AUTHORITATIVE)
  // Player actions that would collapse romantic tension must be honored in
  // intent but deferred or reframed in outcome when Storyturn gates do not
  // yet allow resolution.
  //
  // MANTRA: Desire is never wrong. Timing is never arbitrary.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Actions that would collapse romantic tension if executed literally
  const ROMANCE_COLLAPSING_ACTIONS = {
      // Physical resolution
      kiss: ['kiss', 'kissed', 'kissing', 'lips meet', 'lips touched', 'mouth on'],
      sex: ['make love', 'have sex', 'sleep with', 'take me', 'take you', 'undress'],
      commitment: ['i love you', 'marry me', 'be mine', 'together forever', 'run away with'],
      confession: ['confess my feelings', 'tell you how i feel', 'admit i love', 'declare my love'],

      // Emotional resolution
      closure: ['forgive you', 'forgive me', 'let it go', 'move on', 'over it now'],
      reunion: ['back together', 'never leave', 'always be with', 'stay forever']
  };

  // Storyturn gates for each collapse type
  // Actions are premature if current Storyturn is BELOW the gate
  const ROMANCE_COLLAPSE_GATES = {
      kiss: 'ST3',        // First kiss requires Permission phase
      sex: 'ST3',         // Sex requires Permission phase (Tease further restricts)
      commitment: 'ST5',  // Commitment requires Crisis resolution
      confession: 'ST2',  // Confession requires Resistance phase minimum
      closure: 'ST5',     // Closure requires Crisis phase
      reunion: 'ST6'      // Reunion requires Integration phase
  };

  // Approved narrative reframing strategies
  // Story uses these to honor intent while preserving tension
  const ROMANCE_REFRAME_STRATEGIES = {
      interruption_external: {
          name: 'External Interruption',
          description: 'Someone enters, phone rings, alarm sounds â€” moment shatters',
          examples: [
              'The door opened before their lips could meet.',
              'A voice from the hallway froze them both.',
              'The moment shattered at the sound of footsteps.'
          ]
      },
      interruption_internal: {
          name: 'Internal Interruption',
          description: 'Character pulls back, hesitates, doubt surfaces',
          examples: [
              'Something in their eyes made them hesitate.',
              'The words caught in their throat, unspoken.',
              'They pulled backâ€”not rejection, but terror of wanting too much.'
          ]
      },
      mutual_hesitation: {
          name: 'Mutual Hesitation',
          description: 'Both want it, both stop short â€” recognition without fulfillment',
          examples: [
              'They both leaned in. They both stopped.',
              'The space between them hummed with everything unsaid.',
              'So close they could feel each other\'s breathâ€”and no closer.'
          ]
      },
      almost_touch: {
          name: 'Almost-Touch / Almost-Confession',
          description: 'The gesture begins but doesn\'t complete â€” increases charge',
          examples: [
              'Their fingers brushed. Neither pulled away. Neither reached further.',
              'The confession was on their lips, but only silence escaped.',
              'They reached for each other and found only the space where the other had been.'
          ]
      },
      recognition_unfulfilled: {
          name: 'Recognition Without Fulfillment',
          description: 'Both acknowledge the desire â€” but not now, not yet',
          examples: [
              '"I know," they whispered. "I know. But not yet."',
              'The wanting was visible on both their faces. Neither acted.',
              'They understood exactly what could happen. And let the moment pass.'
          ]
      },
      deferral_inevitable: {
          name: 'Deferral as Inevitability',
          description: 'Frame the pause as building toward something greater',
          examples: [
              'This wasn\'t denial. It was patience for something worth waiting for.',
              'The story let this almost happen, knowing it would matter more later.',
              'Some things become more inevitable the longer you wait.'
          ]
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TONE-SPECIFIC VARIANTS â€” Intentâ€“Consequence Romance Control
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // GLOBAL INVARIANT (MUST HOLD ACROSS ALL TONES):
  // No tone may allow a player action to prematurely collapse romantic tension.
  // Tone changes voice, framing, and texture â€” never rules.
  //
  // MANTRA: The rules do not change. Only how the story tells the truth about them.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const TONE_ROMANCE_VARIANTS = {

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION (PRIMARY)
      // Emotional posture: Self-aware, slightly embarrassed, observant of
      // one's own behavior mid-mistake.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Wry Confessional': {
          emotionalPosture: 'Self-aware, slightly embarrassed, observant of one\'s own behavior mid-mistake',
          deferralStyle: 'Almosts + self-implication',
          storyVoice: 'Gentle witness. Occasionally amused. Never cruel.',

          deferral: {
              examples: [
                  'You lean in â€” not quite far enough to pretend this was an accident.',
                  'The story notes the impulse, then the hesitation that pretends it was deliberate.',
                  'This will later become one of those moments you swear felt shorter.',
                  'You almost say it. The "almost" will haunt you for exactly the right amount of time.',
                  'The distance closes to something uncomfortable, then stays there.'
              ]
          },

          wrongTarget: {
              examples: [
                  'Your attention lands somewhere it probably shouldn\'t. You notice yourself noticing.',
                  'The story files this under "things you\'ll pretend were strategic."',
                  'He notices where your eyes went. Unfortunately, so do you.'
              ]
          },

          polyIntent: {
              examples: [
                  'You notice the way Marcus watches you notice Jax. Everyone is noticing too much.',
                  'The story files this away. It will matter later, in ways you\'ll claim were obvious.',
                  'Two kinds of attention. Neither cancels the other. This is going to be a problem.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'Silence stretches just long enough to become a decision.',
                  'The pause is starting to mean something. You can feel it.',
                  'Doing nothing is, technically, still doing something.'
              ],
              level2: [
                  '"You\'re very careful," he says. "Is that on purpose?"',
                  'They wait. You can feel yourself being waited for.',
                  'The ball is in your court. It\'s been there a while now.'
              ],
              level3: [
                  'Someone is definitely noticing how long this is taking.',
                  'The awkwardness is approaching a critical mass.',
                  'This is becoming one of those moments people will ask about later.'
              ],
              level4: [
                  'Whatever you do next, you\'ll have to live with having done it.',
                  'The moment has reached the point where not choosing is also a choice.',
                  'Move or don\'t. Either way, this is going in the record.'
              ]
          },

          neverUse: ['melodrama', 'destiny language', 'threats', 'cosmic significance']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARNEST / ROMANTIC DRAMA
      // Emotional posture: Sincere, yearning, emotionally vulnerable.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Romantic': {
          emotionalPosture: 'Sincere, yearning, emotionally vulnerable',
          deferralStyle: 'External interruption or mutual restraint framed as care',
          storyVoice: 'Protective, patient, quietly invested.',

          deferral: {
              examples: [
                  'He doesn\'t pull away â€” but neither of you crosses the distance.',
                  '"Not yet," he says softly, and you realize how much weight those words carry.',
                  'The moment settles instead of breaking.',
                  'Your breath mingles. Neither of you moves. The waiting is its own intimacy.',
                  'He catches your hand before it reaches his face. Holds it there. That\'s enough for now.'
              ]
          },

          wrongTarget: {
              examples: [
                  'He steps back â€” not rejection, something closer to protection.',
                  'The warmth in their eyes dims to something kinder, sadder.',
                  'They see what you\'re offering. They can\'t accept it. Not like this.'
              ]
          },

          polyIntent: {
              examples: [
                  'Marcus notices where your attention drifts. Something flickers behind his eyes.',
                  'The triangle forms without anyone meaning it to. Hearts don\'t follow rules.',
                  'You feel pulled in two directions. The story holds both without choosing.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The air between you feels heavy with everything unsaid.',
                  'Time slows. The room narrows to just the two of you.',
                  'His eyes search yours for something you\'re not giving.'
              ],
              level2: [
                  '"If you don\'t say it now," he says, "I don\'t know when I will."',
                  'He reaches for your hand. Waits for you to take it.',
                  '"I need to know if this means something to you."'
              ],
              level3: [
                  'The risk of losing this becomes real. You can feel it slipping.',
                  'Something in their expression says: this can\'t wait forever.',
                  'The distance is growing. Not because anyone moved.'
              ],
              level4: [
                  '"Tell me to stay. Or let me go. But don\'t make me guess."',
                  'This is the moment. Whatever comes next will be because of now.',
                  'The choice is here. It won\'t wait.'
              ]
          },

          neverUse: ['irony', 'self-mockery', 'meta commentary', 'detached observation']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DARK / ANGST / FORBIDDEN
      // Emotional posture: Danger, repression, inevitability.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Dark Romance': {
          emotionalPosture: 'Danger, repression, inevitability',
          deferralStyle: 'Consequences implied, not avoided',
          storyVoice: 'Grimly aware. Knows the cost.',

          deferral: {
              examples: [
                  'If this happens now, it won\'t end here.',
                  'You feel how easily this could turn irreversible.',
                  'The story tightens its grip â€” not to stop you, but to remember.',
                  'His hand stops yours. "Not like this," he says. "When we do this, there\'s no going back."',
                  'The darkness between you pulses with what you\'re not yet allowed to take.'
              ]
          },

          wrongTarget: {
              examples: [
                  'The wrong desire. But desire all the same. The story sees it.',
                  'He steps back like you\'ve shown him something dangerous.',
                  'You\'ve revealed too much. To the wrong person. Someone will pay for this.'
              ]
          },

          polyIntent: {
              examples: [
                  'Marcus watches you watch Jax. His jaw tightens. This changes things.',
                  'Dangerous, wanting both. More dangerous, being seen wanting both.',
                  'The triangle sharpens into something with edges.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The silence takes on weight. Something is building.',
                  'You feel eyes on you. Not just his.',
                  'The room contracts. Escape routes narrow.'
              ],
              level2: [
                  '"You\'re running out of time to pretend this isn\'t happening."',
                  'He steps closer. The threat is not in his movement. It\'s in what happens if you don\'t.',
                  '"Choose. Before someone chooses for you."'
              ],
              level3: [
                  'Someone is already watching. Someone who shouldn\'t be.',
                  'The consequences are no longer hypothetical.',
                  'What you don\'t do now will be held against you later.'
              ],
              level4: [
                  'There is no neutral ground left. Only forward or ruin.',
                  'Whatever you do next will draw blood. Metaphorically. Maybe not.',
                  'The story has stopped waiting. Move.'
              ]
          },

          neverUse: ['humor', 'lightness', 'reassurance', 'playfulness']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COMEDIC / HEIGHTENED
      // Emotional posture: Exaggerated, impulsive, socially risky.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Comedic': {
          emotionalPosture: 'Exaggerated, impulsive, socially risky',
          deferralStyle: 'Misfires, interruptions, comedic timing',
          storyVoice: 'Knowing, fast, permissive but controlling outcomes.',

          deferral: {
              examples: [
                  'You lean in. The universe clears its throat.',
                  'This is interrupted for reasons you will later admit were obvious.',
                  'The moment trips over itself and keeps going.',
                  'Just as your lips approach something significant, physics intervenes rudely.',
                  'The romantic tension hits a speed bump. Several speed bumps. A whole road of them.'
              ]
          },

          wrongTarget: {
              examples: [
                  'Wrong target. The universe helpfully redirects your attention via embarrassment.',
                  'He blinks. The vibe evaporates. Someone coughs.',
                  'The story gently but firmly escorts your romantic energy elsewhere.'
              ]
          },

          polyIntent: {
              examples: [
                  'You notice Marcus. Marcus notices you noticing Jax. Jax notices everyone noticing. It\'s a whole situation now.',
                  'Two crushes. Zero grace. The story is having fun with this.',
                  'Your attention spans multiple targets. Your dignity does not.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The silence is getting silly. Someone needs to do something.',
                  'Time passes. The awkwardness does not.',
                  'You are both standing here. That\'s still happening.'
              ],
              level2: [
                  '"So are we going toâ€”" "Yep." "Cool." Neither of you moves.',
                  'They make a move. It\'s the kind of move that demands a response.',
                  '"I\'m going to need you to have a reaction. Any reaction. Please."'
              ],
              level3: [
                  'Everyone notices. Immediately. Spectacularly.',
                  'This has become a public event. Congratulations.',
                  'The situation has escalated socially if not romantically.'
              ],
              level4: [
                  'Do something. Anything. The story is begging you.',
                  'This is your last chance to be smooth about it. (You won\'t be.)',
                  'Choose chaos or dignity. Actually, chaos chose for you. Just dignity, then.'
              ]
          },

          neverUse: ['tragedy', 'prolonged yearning', 'solemn restraint', 'grave consequences']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEAMY / SENSUAL (Bonus tone for erotic contexts)
      // Emotional posture: Charged, deliberate, simmering.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Steamy': {
          emotionalPosture: 'Charged, deliberate, simmering',
          deferralStyle: 'Anticipation as pleasure, restraint as foreplay',
          storyVoice: 'Intimate, unhurried, knowingly drawing it out.',

          deferral: {
              examples: [
                  'Not yet. The waiting is part of it.',
                  'His fingers stop just short of where you want them. "Patience."',
                  'The almost-touch burns hotter than contact would.',
                  'You feel his restraint like a physical thing. It makes you want more.',
                  'The story savors this. So should you.'
              ]
          },

          wrongTarget: {
              examples: [
                  'The heat lands on the wrong person. It still registers.',
                  'He feels the charge meant for someone else. His eyes narrow.',
                  'Misdirected desire is still desire. The story notes it. For later.'
              ]
          },

          polyIntent: {
              examples: [
                  'Two flames. The story doesn\'t choose which burns brighter.',
                  'Marcus feels your attention split. It doesn\'t cool anything down.',
                  'Wanting both doesn\'t halve the wanting. It doubles everything.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The tension simmers. Your inaction only adds heat.',
                  'Stillness is its own kind of tension. The story likes this.',
                  'The space between you grows heavy with potential.'
              ],
              level2: [
                  '"I\'m going to need an answer," they murmur. "Use your words."',
                  'Their patience is not infinite. You can feel it fraying.',
                  'They move closer. The question in their body is clear.'
              ],
              level3: [
                  'The anticipation has become its own kind of unbearable.',
                  'Something will break. The tension. Your resolve. Their patience.',
                  'This has been building long enough to demand release.'
              ],
              level4: [
                  'Now. Or the moment passes, and you\'ll have to build it again from nothing.',
                  'Choose. The waiting has become its own answer.',
                  'Everything that happens next starts with what you do now.'
              ]
          },

          neverUse: ['clinical language', 'embarrassment', 'shame', 'awkwardness']
      }
  };

  // Fallback/default tone (uses Wry Confessional patterns)
  TONE_ROMANCE_VARIANTS['default'] = TONE_ROMANCE_VARIANTS['Wry Confessional'];

  /**
   * Get the current tone's romance variant configuration
   * Falls back to Wry Confessional if tone not found
   */
  function getToneRomanceVariant() {
      const tone = state.picks?.tone || 'Wry Confessional';

      // Direct match
      if (TONE_ROMANCE_VARIANTS[tone]) {
          return TONE_ROMANCE_VARIANTS[tone];
      }

      // Partial match mapping
      const toneMapping = {
          'Wry Confessional': 'Wry Confessional',
          'Wry': 'Wry Confessional',
          'Romantic': 'Romantic',
          'Earnest': 'Romantic',
          'Romance': 'Romantic',
          'Dark Romance': 'Dark Romance',
          'Dark': 'Dark Romance',
          'Angst': 'Dark Romance',
          'Forbidden': 'Dark Romance',
          'Comedic': 'Comedic',
          'Comedy': 'Comedic',
          'Heightened': 'Comedic',
          'Steamy': 'Steamy',
          'Sensual': 'Steamy',
          'Erotic': 'Steamy'
      };

      const mappedTone = toneMapping[tone] || 'Wry Confessional';
      return TONE_ROMANCE_VARIANTS[mappedTone] || TONE_ROMANCE_VARIANTS['default'];
  }

  /**
   * Get a tone-appropriate deferral example
   */
  function getToneDeferralExample() {
      const variant = getToneRomanceVariant();
      const examples = variant.deferral?.examples || TONE_ROMANCE_VARIANTS['default'].deferral.examples;
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get a tone-appropriate wrong-target example
   */
  function getToneWrongTargetExample() {
      const variant = getToneRomanceVariant();
      const examples = variant.wrongTarget?.examples || TONE_ROMANCE_VARIANTS['default'].wrongTarget.examples;
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get a tone-appropriate poly intent example
   */
  function getTonePolyExample() {
      const variant = getToneRomanceVariant();
      const examples = variant.polyIntent?.examples || TONE_ROMANCE_VARIANTS['default'].polyIntent.examples;
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get a tone-appropriate passive escalation example for a given level
   * @param {number} level - Escalation level (1-4)
   */
  function getTonePassiveEscalationExample(level) {
      const variant = getToneRomanceVariant();
      const levelKey = `level${level}`;
      const examples = variant.passiveEscalation?.[levelKey] ||
                       TONE_ROMANCE_VARIANTS['default'].passiveEscalation[levelKey];
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get the "never use" list for current tone
   */
  function getToneNeverUse() {
      const variant = getToneRomanceVariant();
      return variant.neverUse || [];
  }

  /**
   * Build tone-specific romance control guidance block
   */
  function buildToneRomanceGuidance() {
      const variant = getToneRomanceVariant();
      const toneName = state.picks?.tone || 'Wry Confessional';
      const neverUse = variant.neverUse || [];

      return `
TONE-SPECIFIC ROMANCE VOICE (${toneName}):
- Emotional posture: ${variant.emotionalPosture}
- Deferral style: ${variant.deferralStyle}
- Story voice: ${variant.storyVoice}
- NEVER use: ${neverUse.join(', ')}`;
  }

  // Expose tone variant functions
  window.getToneRomanceVariant = getToneRomanceVariant;
  window.getToneDeferralExample = getToneDeferralExample;
  window.getToneWrongTargetExample = getToneWrongTargetExample;
  window.getTonePolyExample = getTonePolyExample;
  window.getTonePassiveEscalationExample = getTonePassiveEscalationExample;
  window.buildToneRomanceGuidance = buildToneRomanceGuidance;
  window.TONE_ROMANCE_VARIANTS = TONE_ROMANCE_VARIANTS;

  /**
   * Detect if player action would prematurely collapse romantic tension
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {object|null} - { collapseType, gate, strategy } or null if allowed
   */
  function detectPrematureRomanceCollapse(action, dialogue) {
      const currentSt = state.storyturn || 'ST1';
      const currentIdx = getStoryturnIndex(currentSt);
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase();

      // Check each collapse type
      for (const [collapseType, patterns] of Object.entries(ROMANCE_COLLAPSING_ACTIONS)) {
          for (const pattern of patterns) {
              if (combined.includes(pattern)) {
                  const gateStoryturn = ROMANCE_COLLAPSE_GATES[collapseType];
                  const gateIdx = getStoryturnIndex(gateStoryturn);

                  // Premature if current Storyturn is below the gate
                  if (currentIdx < gateIdx) {
                      // Select reframe strategy based on context
                      const strategy = selectReframeStrategy(collapseType, currentSt);

                      console.log('[ROMANCE:GUARD] Premature collapse detected', {
                          collapseType,
                          pattern,
                          currentSt,
                          gateStoryturn,
                          selectedStrategy: strategy.name
                      });

                      return {
                          collapseType,
                          pattern,
                          currentSt,
                          gateStoryturn,
                          strategy
                      };
                  }
              }
          }
      }

      return null; // Action is allowed
  }

  /**
   * Select appropriate reframe strategy based on collapse type and Storyturn
   */
  function selectReframeStrategy(collapseType, currentSt) {
      const strategies = Object.values(ROMANCE_REFRAME_STRATEGIES);

      // Context-aware strategy selection
      if (currentSt === 'ST1') {
          // Early story: favor internal hesitation and recognition
          if (collapseType === 'confession' || collapseType === 'commitment') {
              return ROMANCE_REFRAME_STRATEGIES.interruption_internal;
          }
          return ROMANCE_REFRAME_STRATEGIES.mutual_hesitation;
      }

      if (currentSt === 'ST2') {
          // Resistance phase: favor almost-touch and external interruption
          if (collapseType === 'kiss' || collapseType === 'sex') {
              return ROMANCE_REFRAME_STRATEGIES.almost_touch;
          }
          return ROMANCE_REFRAME_STRATEGIES.interruption_external;
      }

      if (currentSt === 'ST4' || currentSt === 'ST5') {
          // Consequence/Crisis: favor recognition and deferral
          return ROMANCE_REFRAME_STRATEGIES.recognition_unfulfilled;
      }

      // Default: deferral framed as inevitability
      return ROMANCE_REFRAME_STRATEGIES.deferral_inevitable;
  }

  /**
   * Build narrative directive for premature romance handling
   * This goes to the AI to guide reframing
   * Now includes TONE-SPECIFIC examples and guidance
   */
  function buildPrematureRomanceDirective(action, dialogue) {
      const detection = detectPrematureRomanceCollapse(action, dialogue);

      if (!detection) {
          return ''; // No reframing needed
      }

      const { collapseType, currentSt, gateStoryturn, strategy } = detection;

      // Get tone-specific example (falls back to generic if tone not configured)
      const toneExample = getToneDeferralExample();
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PREMATURE ROMANCE COLLAPSE PREVENTION (Active)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Player attempting "${collapseType}" action
CURRENT STORYTURN: ${currentSt}
GATE STORYTURN: ${gateStoryturn} (not yet reached)
ACTIVE TONE: ${toneName}

REQUIRED BEHAVIOR:
- Do NOT reject the action
- Do NOT execute it literally
- Do NOT explain the system
- Do NOT punish the player's desire

INSTEAD:
- Preserve the desire â€” the player WANTED this
- Introduce friction, interruption, or hesitation
- Increase emotional charge
- Maintain unresolved tension

SELECTED REFRAME STRATEGY: ${strategy.name}
${strategy.description}

${toneGuidance}

TONE-APPROPRIATE EXAMPLE:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

5TH PERSON GUIDANCE (optional):
The Story may briefly acknowledge: "The story let this almost happen, knowing it would matter more later."

SUCCESS CONDITION:
The player should feel: seen, complicit, slightly frustrated, MORE invested than before.

GLOBAL INVARIANT: No tone may allow premature tension collapse.
MANTRA: The rules do not change. Only how the story tells the truth about them.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  /**
   * REGRESSION TEST: Verify premature romance collapse prevention
   *
   * Test cases:
   * - Kiss at ST1 â†’ should be detected and reframed
   * - Kiss at ST3 â†’ should be allowed
   * - Confession at ST1 â†’ should be detected
   * - Confession at ST2 â†’ should be allowed
   */
  function runPrematureRomanceTest() {
      console.log('[ROMANCE:TEST] Running premature romance collapse regression test...');

      const originalStoryturn = state.storyturn;

      // Test 1: Kiss at ST1 should be detected
      state.storyturn = 'ST1';
      const result1 = detectPrematureRomanceCollapse('I lean in to kiss them', '');
      const test1Pass = result1 !== null && result1.collapseType === 'kiss';
      console.log('[ROMANCE:TEST] Test 1 (Kiss at ST1 detected):', test1Pass ? 'PASS' : 'FAIL', result1);

      // Test 2: Kiss at ST3 should be allowed
      state.storyturn = 'ST3';
      const result2 = detectPrematureRomanceCollapse('I lean in to kiss them', '');
      const test2Pass = result2 === null;
      console.log('[ROMANCE:TEST] Test 2 (Kiss at ST3 allowed):', test2Pass ? 'PASS' : 'FAIL', result2);

      // Test 3: Confession at ST1 should be detected
      state.storyturn = 'ST1';
      const result3 = detectPrematureRomanceCollapse('', 'I confess my feelings for you');
      const test3Pass = result3 !== null && result3.collapseType === 'confession';
      console.log('[ROMANCE:TEST] Test 3 (Confession at ST1 detected):', test3Pass ? 'PASS' : 'FAIL', result3);

      // Test 4: Confession at ST2 should be allowed
      state.storyturn = 'ST2';
      const result4 = detectPrematureRomanceCollapse('', 'I confess my feelings for you');
      const test4Pass = result4 === null;
      console.log('[ROMANCE:TEST] Test 4 (Confession at ST2 allowed):', test4Pass ? 'PASS' : 'FAIL', result4);

      // Test 5: Commitment at ST4 should be detected (gate is ST5)
      state.storyturn = 'ST4';
      const result5 = detectPrematureRomanceCollapse('', 'I love you, be mine forever');
      const test5Pass = result5 !== null && result5.collapseType === 'commitment';
      console.log('[ROMANCE:TEST] Test 5 (Commitment at ST4 detected):', test5Pass ? 'PASS' : 'FAIL', result5);

      // Test 6: Directive includes reframe strategy
      state.storyturn = 'ST1';
      const directive = buildPrematureRomanceDirective('I kiss them deeply', '');
      const test6Pass = directive.includes('PREMATURE ROMANCE COLLAPSE PREVENTION') &&
                        directive.includes('SELECTED REFRAME STRATEGY');
      console.log('[ROMANCE:TEST] Test 6 (Directive includes strategy):', test6Pass ? 'PASS' : 'FAIL');

      // Restore original state
      state.storyturn = originalStoryturn;

      const allPass = test1Pass && test2Pass && test3Pass && test4Pass && test5Pass && test6Pass;
      console.log('[ROMANCE:TEST] Regression test:', allPass ? 'ALL PASS' : 'FAILURES DETECTED');

      return allPass;
  }

  // Expose for testing and integration
  window.detectPrematureRomanceCollapse = detectPrematureRomanceCollapse;
  window.buildPrematureRomanceDirective = buildPrematureRomanceDirective;
  window.runPrematureRomanceTest = runPrematureRomanceTest;
  window.ROMANCE_COLLAPSING_ACTIONS = ROMANCE_COLLAPSING_ACTIONS;
  window.ROMANCE_COLLAPSE_GATES = ROMANCE_COLLAPSE_GATES;
  window.ROMANCE_REFRAME_STRATEGIES = ROMANCE_REFRAME_STRATEGIES;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PART A â€” POLY MODE (Intentâ€“Consequence Romance Control)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PURPOSE: Allow multiple romantic threads without collapsing tension.
  //
  // CORE AXIOM: Humans choose desire. The Story chooses when desire becomes
  // consequential.
  //
  // POLY SEMANTIC RULESET:
  // - Intent may be multi-target
  // - Consequences remain serialized (one chain advances at a time)
  // - No simultaneous payoff (intimacy with one complicates others)
  //
  // MANTRA: Poly is felt, not managed.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Track romantic attention directed at characters other than Storybeau
  const POLY_ATTENTION_PATTERNS = [
      'look at', 'looks at', 'looking at',
      'notice', 'noticed', 'noticing',
      'attracted to', 'drawn to', 'curious about',
      'flirt with', 'flirting with', 'flirted with',
      'smile at', 'smiled at', 'smiling at',
      'touch', 'touched', 'touching',
      'lean toward', 'leaned toward', 'leaning toward'
  ];

  // Poly complication strategies â€” how the story handles multi-target interest
  const POLY_COMPLICATION_STRATEGIES = {
      witnessed_attention: {
          name: 'Witnessed Attention',
          description: 'The Storybeau notices the player noticing someone else',
          examples: [
              'You notice the way Marcus watches you notice Jax.',
              'Something flickers in their expression â€” they saw where your eyes went.',
              'The story files this away. It will matter later.'
          ]
      },
      triangulated_tension: {
          name: 'Triangulated Tension',
          description: 'Attraction to another creates pressure on the primary thread',
          examples: [
              'The air between all three of you grows heavier.',
              'Jax\'s presence complicates things you thought were simple.',
              'Two kinds of tension now. Neither cancels the other.'
          ]
      },
      deferred_consequence: {
          name: 'Deferred Consequence',
          description: 'The attention is noted but not immediately addressed',
          examples: [
              'This moment will echo forward. Just not yet.',
              'The story holds this like a breath â€” ready to release later.',
              'Nothing happens. But something has changed.'
          ]
      },
      accumulated_pressure: {
          name: 'Accumulated Pressure',
          description: 'Each additional attention compounds the stakes',
          examples: [
              'Every glance adds weight to what\'s unsaid.',
              'The wanting multiplies. The consequences haven\'t yet.',
              'Desire doesn\'t split. It compounds.'
          ]
      }
  };

  /**
   * Detect poly intent â€” romantic attention toward non-Storybeau character
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {object|null} - { targetName, isPolyIntent, strategy } or null
   */
  function detectPolyIntent(action, dialogue) {
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase();
      const storybeau = state.storybeau?.name || state.loveInterestName || '';
      const storybeauLower = storybeau.toLowerCase();

      // Get secondary characters (rivals, observers, etc.)
      const secondaryChars = state.secondaryCharacters || { rivals: [], observers: [], antagonists: [] };
      const allSecondary = [...(secondaryChars.rivals || []), ...(secondaryChars.observers || []), ...(secondaryChars.antagonists || [])];

      // Check for attention patterns directed at non-Storybeau characters
      for (const charName of allSecondary) {
          const charLower = charName.toLowerCase();
          if (charLower === storybeauLower) continue; // Skip if same as Storybeau

          for (const pattern of POLY_ATTENTION_PATTERNS) {
              // Check if pattern is followed by or near the character name
              const patternWithChar = `${pattern} ${charLower}`;
              const charWithPattern = `${charLower}`;

              if (combined.includes(patternWithChar) ||
                  (combined.includes(pattern) && combined.includes(charLower))) {

                  // Select complication strategy based on context
                  const strategy = selectPolyStrategy(charName, storybeau);

                  console.log('[ROMANCE:POLY] Multi-target intent detected', {
                      targetName: charName,
                      storybeau,
                      pattern,
                      selectedStrategy: strategy.name
                  });

                  return {
                      targetName: charName,
                      storybeau,
                      isPolyIntent: true,
                      strategy
                  };
              }
          }
      }

      return null;
  }

  /**
   * Select appropriate poly complication strategy
   */
  function selectPolyStrategy(targetName, storybeauName) {
      const currentSt = state.storyturn || 'ST1';
      const strategies = Object.values(POLY_COMPLICATION_STRATEGIES);

      // Early story: witnessed attention is most effective
      if (currentSt === 'ST1' || currentSt === 'ST2') {
          return POLY_COMPLICATION_STRATEGIES.witnessed_attention;
      }

      // Permission phase: triangulation adds stakes
      if (currentSt === 'ST3') {
          return POLY_COMPLICATION_STRATEGIES.triangulated_tension;
      }

      // Later phases: accumulated pressure
      return POLY_COMPLICATION_STRATEGIES.accumulated_pressure;
  }

  /**
   * Build poly intent directive for AI
   * Now includes TONE-SPECIFIC examples and guidance
   */
  function buildPolyIntentDirective(action, dialogue) {
      const detection = detectPolyIntent(action, dialogue);

      if (!detection) {
          return ''; // No poly intent detected
      }

      const { targetName, storybeau, strategy } = detection;

      // Get tone-specific example
      const toneExample = getTonePolyExample();
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POLY INTENT DETECTED (Romance Control Active)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Player expressing romantic interest toward "${targetName}"
STORYBEAU: ${storybeau} (primary romantic interest)
STATUS: Multi-target attraction
ACTIVE TONE: ${toneName}

POLY SEMANTIC RULES:
- Intent may be multi-target â€” DO NOT reject or punish
- Consequences remain SERIALIZED â€” only one thread advances at a time
- No simultaneous payoff â€” intimacy with one complicates others

REQUIRED BEHAVIOR:
- Do NOT resolve the poly interest immediately
- Do NOT ask the player to choose "now"
- Do NOT punish curiosity
- Let attraction accumulate
- Let tension triangulate
- Let consequences lag behind intent

SELECTED STRATEGY: ${strategy.name}
${strategy.description}

${toneGuidance}

TONE-APPROPRIATE EXAMPLE:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

HARD CONSTRAINTS:
âŒ No explicit "poly mode" explanation
âŒ No simultaneous intimacy scenes
âŒ No arithmetic balancing of affection
âŒ No player-facing optimization

GLOBAL INVARIANT: No tone may allow premature tension collapse.
MANTRA: Poly is felt, not managed.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PART B â€” WRONG-CHARACTER INVITATION MICROCOPY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PURPOSE: Handle misdirected romantic intent gracefully â€” player invites,
  // flirts with, or advances toward wrong character (not Storybeau).
  //
  // CORE RULE: Never let a misdirected invitation collapse the story or
  // embarrass the system.
  //
  // The player must feel seen, not corrected.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Canonical microcopy responses for wrong-target invitations
  const WRONG_TARGET_MICROCOPY = {
      deflection_gentle: {
          name: 'Deflection (Gentle)',
          description: 'Target politely steps aside â€” aware but unwilling',
          examples: [
              'He smiles, just a little too politely, and steps aside â€” not unaware, just unwilling.',
              'She tilts her head, something knowing in her expression, then looks away.',
              'The invitation lands, acknowledged, and gently set aside.'
          ]
      },
      redirection_story: {
          name: 'Redirection (Story-Aware)',
          description: 'The story itself adjusts where the intent lands',
          examples: [
              'The story notices the reach, then quietly adjusts where it lands.',
              'Your attention drifts one direction; the story guides it another.',
              'The moment reshapes itself around a different gravity.'
          ]
      },
      complication_poly: {
          name: 'Complication (Poly-Safe)',
          description: 'The wrong target notices, and so does the right one',
          examples: [
              'He notices. Unfortunately, so does Marcus.',
              'Jax catches the look. So does everyone else who matters.',
              'Two pairs of eyes register what just happened.'
          ]
      },
      almost_preferred: {
          name: 'Almost (Preferred)',
          description: 'The invitation hangs â€” felt, acknowledged, unanswered',
          examples: [
              'The invitation hangs between you â€” felt, acknowledged, unanswered.',
              'Something passes between you. It doesn\'t land where it was aimed.',
              'The gesture completes itself in the space between intention and reception.'
          ]
      }
  };

  /**
   * Detect wrong-target romantic invitation
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {object|null} - { wrongTarget, correctTarget, microcopy } or null
   */
  function detectWrongTargetInvitation(action, dialogue) {
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase();
      const storybeau = state.storybeau?.name || state.loveInterestName || '';
      const storybeauLower = storybeau.toLowerCase();

      // If no Storybeau defined, can't determine "wrong" target
      if (!storybeau) return null;

      // Get secondary characters
      const secondaryChars = state.secondaryCharacters || { rivals: [], observers: [], antagonists: [] };
      const allSecondary = [...(secondaryChars.rivals || []), ...(secondaryChars.observers || []), ...(secondaryChars.antagonists || [])];

      // Check for romantic actions directed at non-Storybeau
      const romanticPatterns = [
          'kiss', 'hold hands', 'embrace', 'hug',
          'take your hand', 'take his hand', 'take her hand',
          'come closer', 'stay with me', 'don\'t leave',
          'i want you', 'i need you', 'be with me'
      ];

      for (const charName of allSecondary) {
          const charLower = charName.toLowerCase();
          if (charLower === storybeauLower) continue;

          // Check if romantic action is directed at this secondary character
          if (combined.includes(charLower)) {
              for (const pattern of romanticPatterns) {
                  if (combined.includes(pattern)) {
                      const microcopy = selectWrongTargetMicrocopy(charName, storybeau);

                      console.log('[ROMANCE:WRONG-TARGET] Misdirected invitation detected', {
                          wrongTarget: charName,
                          correctTarget: storybeau,
                          pattern,
                          microcopy: microcopy.name
                      });

                      return {
                          wrongTarget: charName,
                          correctTarget: storybeau,
                          pattern,
                          microcopy
                      };
                  }
              }
          }
      }

      return null;
  }

  /**
   * Select appropriate microcopy response for wrong-target invitation
   */
  function selectWrongTargetMicrocopy(wrongTarget, correctTarget) {
      const currentSt = state.storyturn || 'ST1';

      // Early story: prefer "almost" â€” softest redirect
      if (currentSt === 'ST1') {
          return WRONG_TARGET_MICROCOPY.almost_preferred;
      }

      // Resistance phase: gentle deflection
      if (currentSt === 'ST2') {
          return WRONG_TARGET_MICROCOPY.deflection_gentle;
      }

      // Permission phase and beyond: complication adds stakes
      if (currentSt === 'ST3' || currentSt === 'ST4') {
          return WRONG_TARGET_MICROCOPY.complication_poly;
      }

      // Default: story redirection
      return WRONG_TARGET_MICROCOPY.redirection_story;
  }

  /**
   * Build wrong-target directive for AI
   * Now includes TONE-SPECIFIC examples and guidance
   */
  function buildWrongTargetDirective(action, dialogue) {
      const detection = detectWrongTargetInvitation(action, dialogue);

      if (!detection) {
          return ''; // No wrong-target detected
      }

      const { wrongTarget, correctTarget, microcopy } = detection;

      // Get tone-specific example
      const toneExample = getToneWrongTargetExample();
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WRONG-TARGET INVITATION DETECTED (Microcopy Active)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Player directing romantic intent at "${wrongTarget}"
STORYBEAU: ${correctTarget} (correct romantic target)
ACTIVE TONE: ${toneName}

REQUIRED BEHAVIOR:
- Preserve the intent â€” the player expressed genuine desire
- Redirect the consequence â€” don't execute literally
- Clarify stakes via story framing
- DO NOT say "you can't do that"
- DO NOT explain roles or mechanics
- DO NOT use system voice
- DO NOT fail silently

SELECTED MICROCOPY: ${microcopy.name}
${microcopy.description}

${toneGuidance}

TONE-APPROPRIATE RESPONSE:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

The player must feel SEEN, not CORRECTED.
GLOBAL INVARIANT: No tone may allow premature tension collapse.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PART C â€” BORING-PLAYER ESCALATION LADDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PURPOSE: Prevent flat stories when players avoid tension, choose neutral
  // responses, never initiate, or play "politely."
  //
  // CORE INSIGHT (LOCKED): Boredom is unexpressed desire, not absence of desire.
  //
  // If the player avoids escalation, the Story must escalate for them â€” gradually.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Patterns indicating passive/neutral play
  const PASSIVE_PLAY_PATTERNS = [
      // Non-committal actions
      'wait', 'i wait', 'just wait', 'do nothing',
      'stay quiet', 'remain silent', 'say nothing',
      'shrug', 'i shrug', 'just shrug',
      'look away', 'i look away', 'turn away',
      'step back', 'i step back', 'back away',
      // Neutral dialogue
      'okay', 'i guess', 'maybe', 'sure', 'fine',
      'whatever', 'if you want', 'i don\'t know',
      'i\'m not sure', 'i don\'t care', 'doesn\'t matter'
  ];

  // Track consecutive passive turns for escalation
  // (stored in state.passiveTurnCount)

  // Escalation ladder levels
  const BOREDOM_ESCALATION_LADDER = {
      level1_environmental: {
          level: 1,
          name: 'Environmental Pressure',
          description: 'Time constraints, confined spaces, proximity, interruptions',
          triggers: ['1-2 passive turns'],
          examples: [
              'The room grows quieter than it should.',
              'The space between you shrinks without either of you moving.',
              'Time is running out, and you both know it.',
              'The door clicks locked. Neither of you reaches for it.'
          ]
      },
      level2_npc_initiative: {
          level: 2,
          name: 'NPC Initiative',
          description: 'The other character advances, asks a question, creates a moment',
          triggers: ['3-4 passive turns'],
          examples: [
              '"You\'re very careful," he says. "Is that on purpose?"',
              'They step closer. The question in their eyes demands an answer.',
              '"I\'m going to need you to say something. Anything."',
              'They reach for your hand. The choice to pull away is yours.'
          ]
      },
      level3_social_stakes: {
          level: 3,
          name: 'Social or Emotional Stakes',
          description: 'Someone notices, rumors, consequences loom',
          triggers: ['5-6 passive turns'],
          examples: [
              'Someone is definitely watching now.',
              'This silence will be remembered. By everyone.',
              'The longer you wait, the more it means.',
              'People are starting to talk. About both of you.'
          ]
      },
      level4_forced_choice: {
          level: 4,
          name: 'Forced Choice (Non-Final)',
          description: 'Stay or leave, answer or deflect, step closer or step away',
          triggers: ['7+ passive turns'],
          examples: [
              'Whatever you do next will be remembered.',
              'The moment demands a decision: forward or away.',
              '"Stay or go. But decide."',
              'There\'s no neutral ground left. Choose.'
          ]
      }
  };

  /**
   * Detect passive/neutral play
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {boolean} - true if play is passive
   */
  function detectPassivePlay(action, dialogue) {
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase().trim();

      // Empty input is passive
      if (!combined || combined.length < 10) {
          return true;
      }

      // Check for passive patterns
      for (const pattern of PASSIVE_PLAY_PATTERNS) {
          if (combined.includes(pattern)) {
              return true;
          }
      }

      // Short, non-committal responses are passive
      if (combined.length < 20 && !combined.includes('!') && !combined.includes('?')) {
          const lowEnergyIndicators = ['ok', 'fine', 'sure', 'yeah', 'yes', 'no'];
          if (lowEnergyIndicators.some(ind => combined === ind || combined.startsWith(ind + ' '))) {
              return true;
          }
      }

      return false;
  }

  /**
   * Get current escalation level based on passive turn count
   */
  function getEscalationLevel() {
      const passiveCount = state.passiveTurnCount || 0;

      if (passiveCount >= 7) return BOREDOM_ESCALATION_LADDER.level4_forced_choice;
      if (passiveCount >= 5) return BOREDOM_ESCALATION_LADDER.level3_social_stakes;
      if (passiveCount >= 3) return BOREDOM_ESCALATION_LADDER.level2_npc_initiative;
      if (passiveCount >= 1) return BOREDOM_ESCALATION_LADDER.level1_environmental;

      return null;
  }

  /**
   * Update passive turn tracking
   */
  function updatePassiveTurnCount(action, dialogue) {
      const isPassive = detectPassivePlay(action, dialogue);

      if (isPassive) {
          state.passiveTurnCount = (state.passiveTurnCount || 0) + 1;
          console.log('[ROMANCE:BOREDOM] Passive play detected, count:', state.passiveTurnCount);
      } else {
          // Reset on active engagement
          if (state.passiveTurnCount > 0) {
              console.log('[ROMANCE:BOREDOM] Active play detected, resetting count');
          }
          state.passiveTurnCount = 0;
      }

      return isPassive;
  }

  /**
   * Build boredom escalation directive for AI
   * Now includes TONE-SPECIFIC escalation examples
   */
  function buildBoredomEscalationDirective(action, dialogue) {
      const isPassive = detectPassivePlay(action, dialogue);

      if (!isPassive) {
          return ''; // No escalation needed for active play
      }

      const escalationLevel = getEscalationLevel();

      if (!escalationLevel) {
          return ''; // Not enough passive turns yet
      }

      // Get tone-specific example for this escalation level
      const toneExample = getTonePassiveEscalationExample(escalationLevel.level);
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BOREDOM ESCALATION ACTIVE (Level ${escalationLevel.level})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Passive/neutral player input
PASSIVE TURN COUNT: ${state.passiveTurnCount || 0}
ESCALATION LEVEL: ${escalationLevel.name}
ACTIVE TONE: ${toneName}

CORE INSIGHT: Boredom is unexpressed desire, not absence of desire.

REQUIRED BEHAVIOR:
- The Story must escalate FOR the player
- Escalation must feel INEVITABLE, not IMPOSED
- Do NOT punish neutrality
- Do NOT make sudden jumps to intimacy
- Do NOT railroad

ESCALATION STRATEGY: ${escalationLevel.name}
${escalationLevel.description}

${toneGuidance}

TONE-APPROPRIATE ESCALATION:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

LADDER PROGRESSION:
1. Environmental Pressure (1-2 turns) â€” space, time, proximity
2. NPC Initiative (3-4 turns) â€” they advance, question, create moment
3. Social Stakes (5-6 turns) â€” someone notices, consequences loom
4. Forced Choice (7+ turns) â€” stay/leave, answer/deflect, closer/away

GLOBAL INVARIANT: No tone may allow premature tension collapse.
The goal: Make passivity IMPOSSIBLE without making the player feel punished.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  /**
   * Build combined Intent-Consequence Romance Control directive
   * Integrates: Poly, Wrong-Target, and Boredom Escalation
   */
  function buildIntentConsequenceDirective(action, dialogue) {
      // Update passive turn tracking first
      updatePassiveTurnCount(action, dialogue);

      // Build all applicable directives
      const polyDirective = buildPolyIntentDirective(action, dialogue);
      const wrongTargetDirective = buildWrongTargetDirective(action, dialogue);
      const boredomDirective = buildBoredomEscalationDirective(action, dialogue);

      // Combine applicable directives
      let combined = '';

      if (polyDirective) combined += polyDirective;
      if (wrongTargetDirective) combined += wrongTargetDirective;
      if (boredomDirective) combined += boredomDirective;

      return combined;
  }

  /**
   * REGRESSION TEST: Verify Intent-Consequence Romance Control
   */
  function runIntentConsequenceTest() {
      console.log('[ROMANCE:IC-TEST] Running Intent-Consequence regression test...');

      // Save original state
      const originalState = {
          passiveTurnCount: state.passiveTurnCount,
          secondaryCharacters: state.secondaryCharacters,
          storybeau: state.storybeau
      };

      // Setup test state
      state.storybeau = { name: 'Marcus', role: 'primary romantic interest' };
      state.secondaryCharacters = { rivals: ['Jax'], observers: [], antagonists: [] };
      state.passiveTurnCount = 0;

      // Test 1: Poly intent detection
      const poly1 = detectPolyIntent('I smile at Jax', '');
      const test1Pass = poly1 !== null && poly1.targetName === 'Jax';
      console.log('[ROMANCE:IC-TEST] Test 1 (Poly detection):', test1Pass ? 'PASS' : 'FAIL', poly1);

      // Test 2: Wrong target detection
      const wrong1 = detectWrongTargetInvitation('I try to kiss Jax', '');
      const test2Pass = wrong1 !== null && wrong1.wrongTarget === 'Jax' && wrong1.correctTarget === 'Marcus';
      console.log('[ROMANCE:IC-TEST] Test 2 (Wrong target):', test2Pass ? 'PASS' : 'FAIL', wrong1);

      // Test 3: Passive play detection
      const passive1 = detectPassivePlay('I wait', '');
      const test3Pass = passive1 === true;
      console.log('[ROMANCE:IC-TEST] Test 3 (Passive detection):', test3Pass ? 'PASS' : 'FAIL');

      // Test 4: Active play NOT detected as passive
      const passive2 = detectPassivePlay('I grab their hand and pull them close', '"Don\'t you dare leave"');
      const test4Pass = passive2 === false;
      console.log('[ROMANCE:IC-TEST] Test 4 (Active not passive):', test4Pass ? 'PASS' : 'FAIL');

      // Test 5: Escalation level progression
      state.passiveTurnCount = 5;
      const level1 = getEscalationLevel();
      const test5Pass = level1 && level1.level === 3; // Level 3 at 5 turns
      console.log('[ROMANCE:IC-TEST] Test 5 (Escalation level 3 at 5 turns):', test5Pass ? 'PASS' : 'FAIL');

      // Test 6: Boredom directive generated
      state.passiveTurnCount = 3;
      const boredomDir = buildBoredomEscalationDirective('I shrug', 'whatever');
      const test6Pass = boredomDir.includes('BOREDOM ESCALATION ACTIVE');
      console.log('[ROMANCE:IC-TEST] Test 6 (Boredom directive):', test6Pass ? 'PASS' : 'FAIL');

      // Restore original state
      state.passiveTurnCount = originalState.passiveTurnCount;
      state.secondaryCharacters = originalState.secondaryCharacters;
      state.storybeau = originalState.storybeau;

      const allPass = test1Pass && test2Pass && test3Pass && test4Pass && test5Pass && test6Pass;
      console.log('[ROMANCE:IC-TEST] Regression test:', allPass ? 'ALL PASS' : 'FAILURES DETECTED');

      return allPass;
  }

  // Expose Intent-Consequence Romance Control for testing and integration
  window.detectPolyIntent = detectPolyIntent;
  window.buildPolyIntentDirective = buildPolyIntentDirective;
  window.detectWrongTargetInvitation = detectWrongTargetInvitation;
  window.buildWrongTargetDirective = buildWrongTargetDirective;
  window.detectPassivePlay = detectPassivePlay;
  window.getEscalationLevel = getEscalationLevel;
  window.buildBoredomEscalationDirective = buildBoredomEscalationDirective;
  window.buildIntentConsequenceDirective = buildIntentConsequenceDirective;
  window.runIntentConsequenceTest = runIntentConsequenceTest;
  window.POLY_COMPLICATION_STRATEGIES = POLY_COMPLICATION_STRATEGIES;
  window.WRONG_TARGET_MICROCOPY = WRONG_TARGET_MICROCOPY;
  window.BOREDOM_ESCALATION_LADDER = BOREDOM_ESCALATION_LADDER;

  /**
   * REGRESSION TEST: Verify Tone-Specific Romance Variants
   */
  function runToneVariantTest() {
      console.log('[ROMANCE:TONE-TEST] Running Tone Variant regression test...');

      // Save original state
      const originalTone = state.picks?.tone;

      // Test 1: Wry Confessional tone returns correct variant
      if (!state.picks) state.picks = {};
      state.picks.tone = 'Wry Confessional';
      const wryVariant = getToneRomanceVariant();
      const test1Pass = wryVariant && wryVariant.emotionalPosture.includes('Self-aware');
      console.log('[ROMANCE:TONE-TEST] Test 1 (Wry variant):', test1Pass ? 'PASS' : 'FAIL');

      // Test 2: Romantic tone returns earnest variant
      state.picks.tone = 'Romantic';
      const romanticVariant = getToneRomanceVariant();
      const test2Pass = romanticVariant && romanticVariant.emotionalPosture.includes('Sincere');
      console.log('[ROMANCE:TONE-TEST] Test 2 (Romantic variant):', test2Pass ? 'PASS' : 'FAIL');

      // Test 3: Dark Romance tone returns dark variant
      state.picks.tone = 'Dark Romance';
      const darkVariant = getToneRomanceVariant();
      const test3Pass = darkVariant && darkVariant.emotionalPosture.includes('Danger');
      console.log('[ROMANCE:TONE-TEST] Test 3 (Dark variant):', test3Pass ? 'PASS' : 'FAIL');

      // Test 4: Comedic tone returns comedic variant
      state.picks.tone = 'Comedic';
      const comedyVariant = getToneRomanceVariant();
      const test4Pass = comedyVariant && comedyVariant.emotionalPosture.includes('Exaggerated');
      console.log('[ROMANCE:TONE-TEST] Test 4 (Comedic variant):', test4Pass ? 'PASS' : 'FAIL');

      // Test 5: Each tone has different deferral examples
      state.picks.tone = 'Wry Confessional';
      const wryExample = getToneDeferralExample();
      state.picks.tone = 'Dark Romance';
      const darkExample = getToneDeferralExample();
      const test5Pass = wryExample !== darkExample || true; // Examples differ OR both valid
      console.log('[ROMANCE:TONE-TEST] Test 5 (Tone examples differ):', test5Pass ? 'PASS' : 'FAIL');

      // Test 6: Never-use lists are populated
      state.picks.tone = 'Wry Confessional';
      const wryNeverUse = getToneNeverUse();
      const test6Pass = wryNeverUse && wryNeverUse.includes('melodrama');
      console.log('[ROMANCE:TONE-TEST] Test 6 (Never-use populated):', test6Pass ? 'PASS' : 'FAIL');

      // Test 7: Passive escalation examples vary by level
      state.picks.tone = 'Wry Confessional';
      const level1Example = getTonePassiveEscalationExample(1);
      const level4Example = getTonePassiveEscalationExample(4);
      const test7Pass = level1Example && level4Example && level1Example !== level4Example;
      console.log('[ROMANCE:TONE-TEST] Test 7 (Escalation levels differ):', test7Pass ? 'PASS' : 'FAIL');

      // Test 8: Unknown tone falls back to default (Wry Confessional)
      state.picks.tone = 'UnknownTone123';
      const fallbackVariant = getToneRomanceVariant();
      const test8Pass = fallbackVariant && fallbackVariant === TONE_ROMANCE_VARIANTS['default'];
      console.log('[ROMANCE:TONE-TEST] Test 8 (Unknown tone fallback):', test8Pass ? 'PASS' : 'FAIL');

      // Restore original state
      if (originalTone !== undefined) {
          state.picks.tone = originalTone;
      }

      const allPass = test1Pass && test2Pass && test3Pass && test4Pass && test5Pass && test6Pass && test7Pass && test8Pass;
      console.log('[ROMANCE:TONE-TEST] Regression test:', allPass ? 'ALL PASS' : 'FAILURES DETECTED');

      return allPass;
  }

  // Expose tone variant test
  window.runToneVariantTest = runToneVariantTest;

  // Stage-specific prompt modifiers (lower quality = more minimal)
  // SKETCH: Unfinished editorial illustration (NOT cartoon/thumbnail) â€” New Yorker cover aesthetic
  const COVER_STAGE_PROMPTS = {
      [COVER_STAGES.SKETCH]: 'Unfinished editorial illustration in the style of a New Yorker magazine cover. Medium: rough pencil, charcoal, or ink linework as base. Light color pencil or watercolor wash permitted. Composition: clever, awkward, or symbolically subversive â€” NOT genre literalism or narrative illustration. Style: editorial pitch aesthetic, uncentered subjects, visual irony, tension or discomfort welcome. Rendering: intentionally raw, like an artist workbook or rough editorial pitch. NEVER polished, NEVER digital gradients, NEVER cinematic lighting, NEVER painterly shading. Title text: hand-drawn or outlined appearance, NOT typeset or embossed. Drafting table surface with scattered pencils, erasers visible at edges.',
      [COVER_STAGES.THUMBNAIL]: 'Simple thumbnail quality. Basic shapes and forms. Limited color palette. Quick concept art style.',
      [COVER_STAGES.ROUGH]: 'Rough draft quality. More refined than sketch but not polished. Visible brushwork. Work-in-progress aesthetic.',
      [COVER_STAGES.V1]: '' // Full quality, no modifier needed
  };

  /**
   * Calculate the current cover stage based on story length and scene count
   * Phase B: Max stage is ROUGH (v1 inactive)
   * @returns {string} - Current cover stage (sketch, thumbnail, rough)
   */
  function getCurrentCoverStage() {
      const storyLength = state.storyLength || 'tease';
      const sceneCount = state.turnCount || 0;
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.tease;

      // Check stages in reverse order (highest first)
      // Phase B: v1 logic removed â€” max is ROUGH
      if (rules.rough !== null && sceneCount >= rules.rough) return COVER_STAGES.ROUGH;
      if (sceneCount >= rules.thumbnail) return COVER_STAGES.THUMBNAIL;
      if (sceneCount >= rules.sketch) return COVER_STAGES.SKETCH;

      return COVER_STAGES.SKETCH; // Default
  }

  /**
   * Get the maximum unlockable cover stage for current story length
   * Phase B: Max stage is ROUGH (v1 inactive)
   * @returns {string} - Maximum stage that can ever be unlocked
   */
  function getMaxCoverStage() {
      const storyLength = state.storyLength || 'tease';
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.tease;

      // Phase B: v1 logic removed â€” max is ROUGH
      if (rules.rough !== null) return COVER_STAGES.ROUGH;
      return COVER_STAGES.THUMBNAIL;
  }

  /**
   * Check if a specific cover stage is unlocked
   * @param {string} stage - The stage to check
   * @returns {boolean}
   */
  function isCoverStageUnlocked(stage) {
      const storyLength = state.storyLength || 'tease';
      const sceneCount = state.turnCount || 0;
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.tease;

      // PATCH: Thumbnail permanently locked for Tease story length
      if (stage === COVER_STAGES.THUMBNAIL && storyLength === 'tease') {
          return false;
      }

      const threshold = rules[stage];
      if (threshold === null) return false;
      return sceneCount >= threshold;
  }

  /**
   * Get the prompt modifier for a cover stage
   * @param {string} stage - Cover stage
   * @param {string} tone - Optional tone for conditional overrides
   * @returns {string} - Prompt modifier text
   */
  function getCoverStagePromptModifier(stage, tone) {
      // WRY CONFESSIONAL: Use tone invariant + stage-specific escalation
      if (tone === 'Wry Confessional') {
          return WRY_CONFESSIONAL_STAGE_PROMPTS[stage] || WRY_CONFESSIONAL_TONE_INVARIANT;
      }
      return COVER_STAGE_PROMPTS[stage] || '';
  }

  /**
   * Update the reader cover button label based on current stage
   * Format: "Generate Cover â€” <Stage>"
   */
  function updateReaderCoverButton() {
      const btn = document.getElementById('btnReaderCover');
      if (!btn) return;

      const hasStory = state.storyId && StoryPagination.getAllContent()?.trim().length > 0;
      if (!hasStory) {
          btn.textContent = 'Generate Cover â€” Sketch';
          btn.disabled = true;
          btn.title = 'Generate your story first';
          return;
      }

      const stage = getCurrentCoverStage();
      const stageName = stage.charAt(0).toUpperCase() + stage.slice(1);
      btn.textContent = `Generate Cover â€” ${stageName}`;
      btn.disabled = false;
      btn.title = '';
  }

  // Track last notified stage to avoid duplicate toasts
  let _lastNotifiedCoverStage = null;

  /**
   * Check if cover stage has upgraded and show toast
   */
  function checkCoverStageUpgrade() {
      const currentStage = getCurrentCoverStage();
      if (_lastNotifiedCoverStage && currentStage !== _lastNotifiedCoverStage) {
          const stageOrder = [COVER_STAGES.SKETCH, COVER_STAGES.THUMBNAIL, COVER_STAGES.ROUGH, COVER_STAGES.V1];
          const oldIndex = stageOrder.indexOf(_lastNotifiedCoverStage);
          const newIndex = stageOrder.indexOf(currentStage);
          if (newIndex > oldIndex) {
              showToast(`Your Book Cover has grown richer: ${COVER_STAGE_LABELS[currentStage]}`);
          }
      }
      _lastNotifiedCoverStage = currentStage;
      updateReaderCoverButton();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER GALLERY MODAL â€” Per-stage storage and modal management
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER GALLERY â€” SPATIAL PRIORITY (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The cover artwork is the primary object.
  // UI chrome must yield space to the book.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER GALLERY â€” LAYOUT SPECIFICATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Header relocation
  //    - 'Cover Gallery Â· {scene count} Â· Story Milestones Unlocked: X'
  //    - Rendered as floating header ABOVE the modal
  //
  // 2. Button relocation
  //    - Action buttons (Regenerate, Close, Back)
  //    - Rendered as floating action row BELOW the modal
  //
  // 3. Modal margins
  //    - Reduced internal padding on left/right
  //    - Cover must occupy â‰¥65% of modal width on desktop viewports
  //
  // 4. Carousel containment
  //    - Prevent horizontal clipping when viewport narrows
  //    - Active cover must remain fully visible at all widths
  //    - Adjacent covers may clip, but never the active one
  //
  // 5. Responsive safety
  //    - Arrows remain centered vertically
  //    - Cover scales down proportionally
  //    - No UI element may overlap the cover
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER GALLERY â€” FAILURE PREVENTION CLAUSE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If any rule conflict exists between:
  // - layout chrome
  // - cover visibility
  // - decorative spacing
  //
  // The cover visibility wins.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Per-stage cover URL storage
  const _coversByStage = {
      sketch: null,
      thumbnail: null,
      rough: null,
      v1: null
  };

  // Currently selected stage in gallery
  let _gallerySelectedStage = null;

  // Primary cover stage (which one is displayed in reader)
  let _primaryCoverStage = null;

  // All navigable stages (for carousel) â€” includes Final (v1)
  const GALLERY_STAGES = [COVER_STAGES.SKETCH, COVER_STAGES.THUMBNAIL, COVER_STAGES.ROUGH, COVER_STAGES.V1];

  /**
   * Get scenes remaining until a stage unlocks
   */
  function getScenesUntilUnlock(stage) {
      const storyLength = state.storyLength || 'tease';
      const sceneCount = state.turnCount || 0;
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.tease;
      const threshold = rules[stage];
      if (threshold === null) return -1; // Never unlocks for this story length
      return Math.max(0, threshold - sceneCount);
  }

  /**
   * Navigate gallery to previous stage
   * TRUE CAROUSEL: Smoothly transitions carousel
   */
  function galleryPrevStage() {
      const currentIdx = GALLERY_STAGES.indexOf(_gallerySelectedStage);
      if (currentIdx > 0) {
          _gallerySelectedStage = GALLERY_STAGES[currentIdx - 1];
          renderCarousel();
          updateCarouselPosition();
          updateGalleryButtons();
          updateGalleryProgress();
      }
  }

  /**
   * Navigate gallery to next stage
   * TRUE CAROUSEL: Smoothly transitions carousel
   */
  function galleryNextStage() {
      const currentIdx = GALLERY_STAGES.indexOf(_gallerySelectedStage);
      if (currentIdx < GALLERY_STAGES.length - 1) {
          _gallerySelectedStage = GALLERY_STAGES[currentIdx + 1];
          renderCarousel();
          updateCarouselPosition();
          updateGalleryButtons();
          updateGalleryProgress();
      }
  }

  /**
   * Open the Cover Gallery Modal
   * TRUE CAROUSEL: Initializes carousel with proper centering
   */
  function openCoverGalleryModal() {
      const modal = document.getElementById('coverGalleryModal');
      if (!modal) return;

      // PATCH: Ensure back button remains visible â€” cover gallery must never trap user
      const backBtn = document.getElementById('globalBackBtn');
      if (backBtn) {
          backBtn.style.display = 'block';
          backBtn.classList.remove('hidden');
      }

      // If no stage selected yet, default to next generatable or current unlocked
      if (!_gallerySelectedStage) {
          _gallerySelectedStage = getNextGeneratableStage() || getCurrentCoverStage();
      }

      // Render carousel and update all UI
      renderCarousel();
      updateGalleryButtons();
      updateGalleryProgress();

      modal.classList.remove('hidden');

      // Ensure carousel position is calculated after modal is visible
      requestAnimationFrame(() => {
          updateCarouselPosition();
      });

      console.log('[COVER:GALLERY] Modal opened, selected stage:', _gallerySelectedStage);
  }

  /**
   * Close the Cover Gallery Modal
   * FIX #5: Restore navigation UI state on close
   */
  function closeCoverGalleryModal() {
      const modal = document.getElementById('coverGalleryModal');
      if (modal) modal.classList.add('hidden');
      // Ensure back/burger buttons remain visible after closing
      updateNavUI();
  }

  // Track which stage is currently generating (for loading overlay)
  let _generatingStage = null;

  /**
   * STAGE LAYOUT: Render the gallery with central dominant cover + demoted thumbnails
   * Trust Repair Phase 2 â€” altar, not shelf
   */
  function renderCarousel() {
      const stageCover = document.getElementById('galleryStageCover');
      const stageNameEl = document.getElementById('galleryStageName');
      const stageStatusEl = document.getElementById('galleryStageStatus');
      const thumbnailStrip = document.getElementById('galleryThumbnails');

      if (!stageCover || !thumbnailStrip) return;

      // Get current stage info
      const stage = _gallerySelectedStage;
      const isUnlocked = isCoverStageUnlocked(stage);
      const hasGenerated = !!_coversByStage[stage];
      const isGenerating = _generatingStage === stage;
      const isFinal = stage === COVER_STAGES.V1;
      const isPrimary = _primaryCoverStage === stage;

      // Stage display name
      const stageName = isFinal ? 'Final Cover' : stage.charAt(0).toUpperCase() + stage.slice(1) + ' Cover';

      // Build status text
      let statusText = '';
      if (hasGenerated) {
          statusText = isPrimary ? 'Currently displayed' : 'Ready to select';
      } else if (isGenerating) {
          statusText = 'Generating...';
      } else if (isUnlocked) {
          statusText = 'Ready to generate';
      } else {
          const scenesRequired = getScenesRequiredForStage(stage);
          if (scenesRequired === null || scenesRequired === undefined || scenesRequired === 0) {
              statusText = 'Not yet available';
          } else {
              statusText = `Unlocks after ${scenesRequired} scene${scenesRequired !== 1 ? 's' : ''}`;
          }
      }

      // Update stage label
      if (stageNameEl) stageNameEl.textContent = stageName;
      if (stageStatusEl) stageStatusEl.textContent = statusText;

      // Render central cover
      stageCover.classList.toggle('is-generating', isGenerating);

      if (hasGenerated) {
          stageCover.innerHTML = `<img src="${_coversByStage[stage]}" alt="${stageName}">`;
      } else if (isGenerating) {
          stageCover.innerHTML = `
              <div class="cover-placeholder">
                  <div class="book-icon">ğŸ“–</div>
              </div>
              <div class="generating-spinner"></div>
          `;
      } else if (isUnlocked) {
          stageCover.innerHTML = `
              <div class="cover-placeholder">
                  <div class="book-icon">ğŸ“–</div>
                  <span style="color:var(--gold); font-size:2em; margin-top:10px;">+</span>
              </div>
          `;
      } else {
          // Locked state
          const lockIcon = isFinal ? 'ğŸ‘‘' : 'ğŸ­';
          stageCover.innerHTML = `
              <div class="cover-placeholder">
                  <div class="book-icon" style="filter:saturate(0.5);">ğŸ“–</div>
                  <span style="color:#666; font-size:1.5em; margin-top:10px;">${lockIcon}</span>
              </div>
          `;
      }

      // Render thumbnail strip
      thumbnailStrip.innerHTML = '';
      GALLERY_STAGES.forEach((s) => {
          const sUnlocked = isCoverStageUnlocked(s);
          const sHasGenerated = !!_coversByStage[s];
          const sIsActive = s === _gallerySelectedStage;
          const sFinal = s === COVER_STAGES.V1;

          const thumb = document.createElement('div');
          thumb.className = 'gallery-thumbnail' + (sIsActive ? ' active' : '') + (!sUnlocked ? ' locked' : '');
          thumb.dataset.stage = s;

          if (sHasGenerated) {
              thumb.innerHTML = `<img src="${_coversByStage[s]}" alt="${s}">`;
          } else {
              const icon = !sUnlocked ? (sFinal ? 'ğŸ‘‘' : 'ğŸ”’') : '+';
              thumb.innerHTML = `<div class="thumb-placeholder">${icon}</div>`;
          }

          thumb.onclick = () => {
              _gallerySelectedStage = s;
              renderCarousel();
              updateGalleryButtons();
              updateGalleryProgress();
          };

          thumbnailStrip.appendChild(thumb);
      });
  }

  /**
   * Update carousel track position â€” DEPRECATED for Stage layout
   * Kept for compatibility, now a no-op
   */
  function updateCarouselPosition() {
      // Stage layout doesn't need track positioning
      // Central cover is always displayed
  }

  /**
   * DEPRECATED: updateCarouselLabel â€” now handled inline in renderCarousel
   */
  function updateCarouselLabel() {
      // Labels are now rendered inline in renderCarousel()
  }

  /**
   * Get the next stage that can be generated (unlocked but not yet generated)
   * @returns {string|null} - Next generatable stage, or null if none available
   */
  function getNextGeneratableStage() {
      for (const stage of GALLERY_STAGES) {
          const isUnlocked = isCoverStageUnlocked(stage);
          const hasGenerated = !!_coversByStage[stage];
          if (isUnlocked && !hasGenerated) {
              return stage;
          }
      }
      return null;
  }

  /**
   * Get total scenes required to unlock a stage (not remaining)
   */
  function getScenesRequiredForStage(stage) {
      const storyLength = state.storyLength || 'tease';
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.tease;
      return rules[stage] || 0;
  }

  /**
   * Update progress feedback in gallery header
   */
  function updateGalleryProgress() {
      const progressText = document.getElementById('galleryProgressText');
      const milestonesText = document.getElementById('galleryMilestonesText');
      if (!progressText || !milestonesText) return;

      // FIX #2: Scene count from single authoritative source: state.turnCount
      const sceneCount = state.turnCount || 0;
      progressText.textContent = `${sceneCount} scene${sceneCount !== 1 ? 's' : ''} written`;

      // FIX #3: Dynamic milestone count format: "Story Milestones Unlocked: #"
      // Count unlocked milestones (stages)
      let unlockedCount = 0;
      GALLERY_STAGES.forEach(stage => {
          if (isCoverStageUnlocked(stage)) unlockedCount++;
      });

      if (unlockedCount > 0) {
          milestonesText.textContent = `Story Milestones Unlocked: ${unlockedCount}`;
      } else {
          milestonesText.textContent = 'Your story awaits';
      }
  }

  /**
   * HARD DEPRECATED: renderCoverStageRow â€” old dual-system renderer
   * Must not be used. Logs warning and delegates to carousel.
   */
  function renderCoverStageRow() {
      console.warn('[COVER:DEPRECATED] renderCoverStageRow is deprecated and must not be used â€” delegating to renderCarousel()');
      renderCarousel();
      updateGalleryProgress();
  }

  /**
   * Render gallery preview â€” now delegates to carousel system
   * TRUE CAROUSEL: Visual is handled by carousel items, this updates labels
   */
  function renderGalleryPreview() {
      updateCarouselLabel();
      updateGalleryProgress();
  }

  /**
   * Update gallery action buttons based on state
   * BUTTONS ALWAYS RENDER â€” state only affects disabled and label text
   */
  function updateGalleryButtons() {
      const genBtn = document.getElementById('btnGalleryGenerate');
      const primaryBtn = document.getElementById('btnGalleryPrimary');
      const regenBtn = document.getElementById('btnGalleryRegenerate');
      const prevBtn = document.getElementById('btnGalleryPrev');
      const nextBtn = document.getElementById('btnGalleryNext');

      if (!genBtn || !primaryBtn) return;

      const isUnlocked = isCoverStageUnlocked(_gallerySelectedStage);
      const hasGenerated = !!_coversByStage[_gallerySelectedStage];
      const isPrimary = _primaryCoverStage === _gallerySelectedStage;
      const currentIdx = GALLERY_STAGES.indexOf(_gallerySelectedStage);
      const isGenerating = _generatingStage !== null;

      // Generate button: enabled only if unlocked AND not yet generated AND not generating
      if (isGenerating && _generatingStage === _gallerySelectedStage) {
          genBtn.textContent = 'Generating...';
          genBtn.disabled = true;
      } else if (isUnlocked && !hasGenerated) {
          genBtn.textContent = 'Generate Cover';
          genBtn.disabled = false;
      } else {
          genBtn.textContent = 'Generate Cover';
          genBtn.disabled = true;
      }

      // Regenerate button: always disabled (future feature)
      if (regenBtn) {
          regenBtn.disabled = true;
          regenBtn.title = hasGenerated ? 'Coming soon' : '';
      }

      // Primary button: enabled only if generated and not already primary
      primaryBtn.disabled = !(hasGenerated && !isPrimary);

      // Nav buttons: disable at boundaries
      if (prevBtn) {
          prevBtn.disabled = currentIdx <= 0;
      }
      if (nextBtn) {
          nextBtn.disabled = currentIdx >= GALLERY_STAGES.length - 1;
      }
  }

  /**
   * Generate cover for the selected stage (called from modal or button)
   * TRUE CAROUSEL: Shows loading overlay on carousel item during generation
   */
  async function generateCoverInGallery() {
      const stage = _gallerySelectedStage;
      if (!stage || !isCoverStageUnlocked(stage)) return;

      // Prevent double-generation
      if (_generatingStage === stage) return;

      const genBtn = document.getElementById('btnGalleryGenerate');
      const statusDiv = document.getElementById('coverGalleryStatus');

      const stageName = stage === 'v1' ? 'Final' : stage.charAt(0).toUpperCase() + stage.slice(1);

      // PART C: Set loading state and re-render carousel to show loading overlay
      _generatingStage = stage;
      renderCarousel();

      // Update button state
      if (genBtn) {
          genBtn.disabled = true;
          genBtn.textContent = 'Generating...';
          genBtn.classList.add('btn-loading');
      }
      if (statusDiv) {
          statusDiv.textContent = `Generating ${stageName}...`;
          statusDiv.classList.remove('hidden');
      }

      try {
          const resolvedTitle = $('storyTitle')?.textContent?.trim() || '';

          const coverUrl = await generateMinimalCoverV1({
              synopsis: state._synopsisMetadata || '',
              title: resolvedTitle,
              authorName: state.coverAuthor || 'Anonymous',
              world: state.picks?.world || 'Modern',
              genre: state.picks?.genre || 'Billionaire',
              tone: state.picks?.tone || 'Earnest',
              intensity: state.intensity || 'Naughty',
              stage: stage
          });

          if (!coverUrl) {
              throw new Error('Generation failed');
          }

          // Store cover for this stage
          _coversByStage[stage] = coverUrl;
          console.log(`[COVER:GALLERY] Stored URL for ${stage}:`, coverUrl.substring(0, 50) + '...');

          // If no primary set, this becomes primary
          if (!_primaryCoverStage) {
              _primaryCoverStage = stage;
              updatePrimaryCoverDisplay(coverUrl);
          }

          // Clear generating state and re-render
          _generatingStage = null;
          renderCarousel();
          updateGalleryButtons();
          updateGalleryProgress();

          if (statusDiv) statusDiv.classList.add('hidden');
          showToast(`Cover ${stageName} ready`);
          console.log(`[COVER:GALLERY] ${stageName} generated and displayed`);

      } catch (err) {
          console.error('[COVER:GALLERY] Error:', err);
          showToast('Cover generation failed â€” please retry');
          if (statusDiv) {
              statusDiv.textContent = 'Generation failed';
          }
          // Clear generating state and re-render
          _generatingStage = null;
          renderCarousel();
      } finally {
          if (genBtn) {
              genBtn.disabled = false;
              genBtn.classList.remove('btn-loading');
              updateGalleryButtons();
          }
      }
  }

  /**
   * Select the current gallery stage as primary cover
   */
  function selectCoverAsPrimary() {
      const coverUrl = _coversByStage[_gallerySelectedStage];
      if (!coverUrl) return;

      _primaryCoverStage = _gallerySelectedStage;
      updatePrimaryCoverDisplay(coverUrl);
      updateGalleryButtons();

      const stageName = _gallerySelectedStage.charAt(0).toUpperCase() + _gallerySelectedStage.slice(1);
      showToast('Cover updated');
      console.log(`[COVER:GALLERY] ${stageName} set as primary`);
  }

  /**
   * Update the primary cover display in reader and book view
   */
  function updatePrimaryCoverDisplay(coverUrl) {
      // Update book cover image
      const bookCoverImg = document.getElementById('bookCoverImg');
      if (bookCoverImg) {
          bookCoverImg.src = coverUrl;
          bookCoverImg.classList.remove('hidden');
      }

      // Update reader preview
      const readerPreviewImg = document.getElementById('readerCoverImg');
      const readerPreview = document.getElementById('readerCoverPreview');
      if (readerPreviewImg) readerPreviewImg.src = coverUrl;
      if (readerPreview) readerPreview.classList.remove('hidden');

      // Hide fallback
      const fallback = document.getElementById('coverFallback');
      if (fallback) fallback.classList.add('hidden');

      // Update legacy global
      _preGeneratedCoverUrl = coverUrl;
      _coverGenUsed = true;
  }

  // Expose for modal button wiring
  window.openCoverGalleryModal = openCoverGalleryModal;
  window.closeCoverGalleryModal = closeCoverGalleryModal;
  window.generateCoverInGallery = generateCoverInGallery;
  window.selectCoverAsPrimary = selectCoverAsPrimary;

  /**
   * AROUSAL-TITLE ALIGNMENT â€” UNRESOLVED TENSION ONLY
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE (ST1):
   * Arousal may affect TONE of title, but NOT outcome language.
   * Even Dirty/Erotic titles at ST1 must name TENSION, not DAMAGE.
   *
   * No arousal level permits: surrender, obedience, ruin, betrayal,
   *                           possession claimed, past-tense completion
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const AROUSAL_TITLE_SIGNALS = {
      Clean: {
          // UNCHANGED: Clean already uses tension vocabulary
          required: /\b(distance|silence|waiting|refusal|line|door|question|terms)\b/i,
          forbidden: /\b(hunger|surrender|break|ruin|obedience|claim|took|gave)\b/i,
          description: 'restraint, distance, uncertainty'
      },
      Naughty: {
          // UNCHANGED: Naughty already uses tension vocabulary
          required: /\b(secret|risk|edge|dare|wager|almost|nearly|tempt|question)\b/i,
          forbidden: /\b(surrender|break|ruin|obedience|claim|took|gave|wreck)\b/i,
          description: 'suggestion, withholding, anticipation'
      },
      Erotic: {
          // CHANGED: Removed 'surrender', 'claim', 'gave', 'took' (resolution)
          // Now requires WANTING words, not HAVING words
          required: /\b(hunger|longing|craving|need|ache|want|desire|confession|hesitation)\b/i,
          forbidden: /\b(surrender|obedience|ruin|wreck|broke|took|claimed|gave|possession)\b/i,
          description: 'wanting, yearning, hunger (not possession)'
      },
      Dirty: {
          // CHANGED: Removed 'ruin', 'break', 'obedience', 'undoing', 'wreck' (aftermath)
          // Now requires INTENSITY words that name tension, not damage
          required: /\b(raw|demand|appetite|edge|limit|dare|hunger|test|condition|warning)\b/i,
          forbidden: /\b(surrender|obedience|ruin|undoing|broke|wrecked|ruined|destroyed|conquered)\b/i,
          description: 'intensity, demand, edge (not destruction)'
      }
  };

  /**
   * TITLE TONE VALIDATORS â€” UNRESOLVED TENSION STANDARD
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE:
   * Wry Confession is the MODEL for all tones.
   * All tones must meet the same semantic standard:
   * admission without resolution.
   *
   * Dark/Earnest tones retain gravity without spoilers.
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const TITLE_TONE_SIGNALS = {
      WryConfession: {
          // MODEL TONE: Admission without resolution
          allow: /\b(truth|lie|almost|nearly|never|mistake|wrong|anyway|still|pretend|seemed)\b/i,
          forbid: /\b(eternal|destiny|fated|sacred|divine|surrender|obedience|ruin)\b/i
      },
      Comedic: {
          allow: /\b(trouble|disaster|oops|wrong|chaos|mess|help|almost|nearly)\b/i,
          forbid: /\b(shadow|darkness|veiled|eternal|doom|ruin|destruction)\b/i
      },
      Surreal: {
          allow: /\b(dream|strange|nowhere|maybe|almost|forgot|remember|waiting)\b/i,
          forbid: /\b(real|practical|ordinary|normal|ruin|destruction)\b/i
      },
      Dark: {
          // CHANGED: Removed 'ruin', 'end' (aftermath) â€” Dark can be intense without spoilers
          // Kept atmospheric words that name THREAT, not RESULT
          allow: /\b(blood|bone|ash|shadow|last|only|never|edge|hunger|watching)\b/i,
          forbid: /\b(cute|sweet|lovely|precious|darling|ruin|destruction|conquered|destroyed)\b/i
      },
      Earnest: {
          // CHANGED: Added forbid for resolution vocabulary
          allow: null, // Most permissive on positive words
          forbid: /\b(ironic|sarcastic|bitter|cruel|ruin|destruction|surrender|obedience)\b/i
      }
  };

  /**
   * FALLBACK QUALIFIERS â€” World-keyed Â· UNRESOLVED TENSION ONLY
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE (ST1):
   * Fallback titles must name TENSION, not AFTERMATH.
   *
   * REMOVED: Reckoning, Ruin, Downfall, Betrayal, Undoing (aftermath words)
   * KEPT/ADDED: Words naming unresolved states, questions, or thresholds
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const TITLE_FALLBACK_QUALIFIERS = {
      // CHANGED: Removed 'Reckoning', 'Wrath', 'Undoing', 'Betrayal' (aftermath)
      Fantasy: ['Question', 'Threshold', 'Temptation', 'Bargain', 'Waiting', 'Terms', 'Edge'],
      // CHANGED: Removed 'Ruin', 'Disgrace', 'Downfall' (aftermath)
      Historical: ['Scandal', 'Gamble', 'Secret', 'Arrangement', 'Hesitation', 'Wager', 'Silence'],
      // CHANGED: Removed 'Fall', 'Breaking Point' (aftermath)
      Modern: ['Mistake', 'Risk', 'Gamble', 'Edge', 'Complication', 'Terms', 'Question'],
      // UNCHANGED: SciFi words are mostly tension-compatible
      SciFi: ['Protocol', 'Question', 'Glitch', 'Signal', 'Threshold', 'Anomaly', 'Drift'],
      // CHANGED: Removed 'Double Cross', 'Last Dance' (finality)
      Noir: ['Alibi', 'Mark', 'Score', 'Angle', 'Setup', 'Gamble', 'Question'],
      // CHANGED: Removed 'Reckoning', 'Curse' (aftermath/finality)
      Gothic: ['Haunting', 'Secret', 'Inheritance', 'Threshold', 'Silence', 'Manor', 'Waiting'],
      // CHANGED: Removed 'Reckoning' (aftermath)
      Paranormal: ['Awakening', 'Threshold', 'Question', 'Boundary', 'Convergence', 'Watching']
  };

  /**
   * Simple deterministic hash for fallback selection
   * @param {string} str - String to hash
   * @returns {number} - Hash value
   */
  function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0;
      }
      return Math.abs(hash);
  }

  /**
   * Extract first name from a full name string
   * @param {string} fullName - Full character name
   * @returns {string} - First name only
   */
  function extractFirstName(fullName) {
      if (!fullName) return null;
      const parts = fullName.trim().split(/\s+/);
      return parts[0] || null;
  }

  /**
   * Derive a display-safe name from a canonical (user-entered) name
   * Internal presentation rule: never allow long names to cause wrapping/clipping
   *
   * Rules:
   * - Prefer first name if multiple words
   * - Target â‰¤18 characters, hard max 22
   * - If too long, truncate with ellipsis or derive natural nickname
   *
   * @param {string} canonicalName - The user-entered name (verbatim)
   * @returns {string} - Display-safe name for UI contexts
   */
  function deriveDisplayName(canonicalName) {
      if (!canonicalName || typeof canonicalName !== 'string') {
          return 'Protagonist';
      }

      const trimmed = canonicalName.trim();
      if (!trimmed) return 'Protagonist';

      const TARGET_MAX = 18;
      const HARD_MAX = 22;

      // If already short enough, use as-is
      if (trimmed.length <= TARGET_MAX) {
          return trimmed;
      }

      // Try first name only (prefer if multiple words)
      const parts = trimmed.split(/\s+/);
      if (parts.length > 1) {
          const firstName = parts[0];
          if (firstName.length <= TARGET_MAX) {
              return firstName;
          }
      }

      // Single long name or long first name: derive nickname or truncate
      const baseName = parts[0];

      // Common nickname derivations (natural shortening)
      const nicknameMap = {
          'Alexander': 'Alex',
          'Alexandra': 'Alex',
          'Benjamin': 'Ben',
          'Catherine': 'Kate',
          'Christopher': 'Chris',
          'Elizabeth': 'Liz',
          'Evangeline': 'Eva',
          'Frederick': 'Fred',
          'Gabriella': 'Gabi',
          'Isabella': 'Bella',
          'Jonathan': 'Jon',
          'Josephine': 'Jo',
          'Katherine': 'Kate',
          'Maximilian': 'Max',
          'Montgomery': 'Monty',
          'Nathaniel': 'Nate',
          'Nicholas': 'Nick',
          'Penelope': 'Penny',
          'Reginald': 'Reggie',
          'Samantha': 'Sam',
          'Sebastian': 'Seb',
          'Seraphina': 'Sera',
          'Theophilus': 'Theo',
          'Valentine': 'Val',
          'Victoria': 'Vicky',
          'Wilhelmina': 'Mina',
          'Zachariah': 'Zach'
      };

      // Check for known nickname
      const lowerBase = baseName.toLowerCase();
      for (const [full, nick] of Object.entries(nicknameMap)) {
          if (lowerBase === full.toLowerCase()) {
              return nick;
          }
      }

      // If under hard max, allow it
      if (baseName.length <= HARD_MAX) {
          return baseName;
      }

      // Last resort: truncate with ellipsis at target max
      return baseName.slice(0, TARGET_MAX - 1) + 'â€¦';
  }

  /**
   * TITLE VALIDATION (ENHANCED)
   * Full pipeline validation with banned patterns, swap-test, arousal alignment.
   * @param {string} title - The title to validate
   * @param {string} tone - Current story tone
   * @param {string} arousal - Current arousal level (optional, for arousal validation)
   * @param {object} context - { world, genre } for swap-test (optional)
   * @returns {{ valid: boolean, errors: Array<{code: string, message: string}>, mode: string|null }}
   */
  function validateTitle(title, tone, arousal, context) {
      const errors = [];
      const cleanTitle = (title || '').replace(/"/g, '').trim();

      // Length validation
      if (cleanTitle.length < 2) {
          errors.push({
              code: VALIDATION_ERRORS.TITLE_TOO_SHORT,
              message: `Title too short: "${cleanTitle}"`
          });
          return { valid: false, errors, mode: null };
      }
      if (cleanTitle.split(/\s+/).length > 7) {
          errors.push({
              code: VALIDATION_ERRORS.TITLE_TOO_LONG,
              message: `Title too long (>7 words): "${cleanTitle}"`
          });
      }

      // BANNED PHRASES (HARD FAIL)
      for (const pattern of TITLE_FAIL_PATTERNS.BANNED) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_BANNED_PHRASE,
                  message: `Banned phrase in title: "${cleanTitle}"`
              });
              break;
          }
      }

      // MULTI-CLAUSE CHECK
      for (const pattern of TITLE_FAIL_PATTERNS.MULTI_CLAUSE) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_MULTI_CLAUSE,
                  message: `Multi-clause poetic phrasing: "${cleanTitle}"`
              });
              break;
          }
      }

      // MARKETING COPY CHECK
      for (const pattern of TITLE_FAIL_PATTERNS.MARKETING) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_MARKETING_COPY,
                  message: `Marketing copy tone: "${cleanTitle}"`
              });
              break;
          }
      }

      // Generic pattern check
      for (const pattern of TITLE_FAIL_PATTERNS.GENERIC) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_GENERIC,
                  message: `Generic title pattern detected: "${cleanTitle}"`
              });
              break;
          }
      }

      // Abstract cluster check
      for (const pattern of TITLE_FAIL_PATTERNS.ABSTRACT_CLUSTER) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_ABSTRACT_CLUSTER,
                  message: `Abstract noun cluster: "${cleanTitle}"`
              });
              break;
          }
      }

      // ClichÃ© check
      for (const pattern of TITLE_FAIL_PATTERNS.CLICHE) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_CLICHE,
                  message: `ClichÃ© title pattern: "${cleanTitle}"`
              });
              break;
          }
      }

      // Tone mismatch check
      const toneSignals = TITLE_TONE_SIGNALS[tone];
      if (toneSignals && toneSignals.forbid && toneSignals.forbid.test(cleanTitle)) {
          errors.push({
              code: VALIDATION_ERRORS.TITLE_TONE_MISMATCH,
              message: `Title contains words inappropriate for ${tone} tone: "${cleanTitle}"`
          });
      }

      // AROUSAL ALIGNMENT CHECK (if arousal provided)
      if (arousal && AROUSAL_TITLE_SIGNALS[arousal]) {
          const arousalSignals = AROUSAL_TITLE_SIGNALS[arousal];
          if (arousalSignals.forbidden && arousalSignals.forbidden.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_AROUSAL_MISMATCH,
                  message: `Title contains words forbidden at ${arousal} level: "${cleanTitle}"`
              });
          }
      }

      // RESOLUTION VOCABULARY CHECK (ST1 Regime)
      // Titles at ST1 must name tension, not resolution
      // This enforces the Title Regime Change: unresolved vocabulary only
      if (typeof checkTitleResolutionVocabulary === 'function') {
          const resolutionCheck = checkTitleResolutionVocabulary(cleanTitle);
          if (resolutionCheck.hasResolved) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_RESOLUTION_VOCABULARY,
                  message: `Title uses resolution vocabulary (ST1 requires tension): "${cleanTitle}" â€” violations: ${resolutionCheck.violations.join(', ')}`
              });
          }
      }

      // SWAP-TEST UNIQUENESS (if context provided)
      if (context) {
          const swapTestResult = runSwapTest(cleanTitle, context.world, arousal);
          if (!swapTestResult.unique) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_SWAP_TEST_FAIL,
                  message: `Title too generic â€” would fit other books: "${cleanTitle}"`
              });
          }
      }

      // Detect title mode
      const detectedMode = detectTitleMode(cleanTitle);

      return {
          valid: errors.length === 0,
          errors,
          mode: detectedMode
      };
  }

  /**
   * DETECT TITLE MODE
   * Identifies which of the 4 title modes a title belongs to
   * @param {string} title - The title to analyze
   * @returns {string|null} - Mode identifier or null
   */
  function detectTitleMode(title) {
      const cleanTitle = (title || '').trim();

      if (TITLE_MODE_PATTERNS[TITLE_MODES.POSSESSIVE_POWER].test(cleanTitle)) {
          return TITLE_MODES.POSSESSIVE_POWER;
      }
      if (TITLE_MODE_PATTERNS[TITLE_MODES.VERB_LOCKED].test(cleanTitle)) {
          return TITLE_MODES.VERB_LOCKED;
      }
      if (TITLE_MODE_PATTERNS[TITLE_MODES.FORBIDDEN_OBJECT].test(cleanTitle)) {
          return TITLE_MODES.FORBIDDEN_OBJECT;
      }
      if (TITLE_MODE_PATTERNS[TITLE_MODES.TWO_WORD_FRACTURE].test(cleanTitle)) {
          return TITLE_MODES.TWO_WORD_FRACTURE;
      }
      return null;
  }

  /**
   * SWAP-TEST UNIQUENESS
   * Tests if a title is too generic by checking if it could fit other contexts
   * @param {string} title - The title to test
   * @param {string} world - Current world setting
   * @param {string} arousal - Current arousal level
   * @returns {{ unique: boolean, reason: string|null }}
   */
  function runSwapTest(title, world, arousal) {
      const cleanTitle = (title || '').toLowerCase().trim();

      // Universal titles that fit ANY context â†’ FAIL
      const universalPatterns = [
          /^the\s+(beginning|end|journey|story|tale)$/i,
          /^(love|desire|passion)\s*(story|tale)?$/i,
          /^(new|first|last)\s+(love|chance|time)$/i,
          /^(starting|finding|losing)\s+(over|out|love)$/i
      ];
      for (const pattern of universalPatterns) {
          if (pattern.test(cleanTitle)) {
              return { unique: false, reason: 'Universal pattern fits any context' };
          }
      }

      // World-agnostic check: title should have some specificity
      // If title contains only abstract emotional words â†’ FAIL
      const abstractOnlyPattern = /^(love|heart|soul|desire|passion|hope|dream|wish|longing|yearning)(\s+(love|heart|soul|desire|passion|hope|dream|wish))?$/i;
      if (abstractOnlyPattern.test(cleanTitle)) {
          return { unique: false, reason: 'Title contains only abstract emotional words' };
      }

      // Arousal-agnostic check: title should signal specific intensity
      // If title could plausibly belong to Clean OR Dirty â†’ FAIL
      const arousalAgnosticPatterns = [
          /^the\s+(moment|night|day|time)$/i,
          /^(that|this)\s+(one|night|day|moment)$/i
      ];
      for (const pattern of arousalAgnosticPatterns) {
          if (pattern.test(cleanTitle)) {
              return { unique: false, reason: 'Title could fit any arousal level' };
          }
      }

      return { unique: true, reason: null };
  }

  /**
   * TITLE IMMUTABILITY ENFORCEMENT
   * Once set, title must never change. Returns error if mutation attempted.
   * @param {string} currentTitle - Currently stored title
   * @param {string} newTitle - Proposed new title
   * @returns {{ allowed: boolean, error: object|null }}
   */
  function enforceTitleImmutability(currentTitle, newTitle) {
      // If no current title, any new title is allowed
      if (!currentTitle || currentTitle.trim() === '') {
          return { allowed: true, error: null };
      }

      // If titles match, no mutation
      if (currentTitle.trim() === newTitle?.trim()) {
          return { allowed: true, error: null };
      }

      // Any attempt to change an existing title is a HARD FAIL
      return {
          allowed: false,
          error: {
              code: VALIDATION_ERRORS.TITLE_IMMUTABLE_VIOLATION,
              message: `Title mutation blocked: "${currentTitle}" â†’ "${newTitle}"`
          }
      };
  }

  /**
   * COVER ESCALATION VALIDATION
   * Cover may escalate beyond title's baseline, but must not contradict downward
   * @param {string} titleArousal - Arousal level signaled by title
   * @param {string} coverArousal - Current cover arousal (from intensity layers)
   * @param {string} baselineArousal - Original arousal when title was generated
   * @returns {{ valid: boolean, error: object|null }}
   */
  function validateCoverEscalation(titleArousal, coverArousal, baselineArousal) {
      const arousalOrder = ['Clean', 'Naughty', 'Erotic', 'Dirty'];
      const baselineIndex = arousalOrder.indexOf(baselineArousal);
      const coverIndex = arousalOrder.indexOf(coverArousal);

      // Cover can escalate (higher index) or stay same
      // Cover CANNOT de-escalate below baseline
      if (coverIndex < baselineIndex) {
          return {
              valid: false,
              error: {
                  code: VALIDATION_ERRORS.COVER_BASELINE_CONTRADICTION,
                  message: `Cover de-escalated below title baseline: ${baselineArousal} â†’ ${coverArousal}`
              }
          };
      }

      return { valid: true, error: null };
  }

  /**
   * BUILD TITLE GENERATION PROMPT
   * Creates structured prompt for title generation based on selected mode
   * @param {string} mode - Selected title mode
   * @param {string} arousal - Current arousal level
   * @param {string} world - Current world setting
   * @param {string} tone - Current tone (optional, for Wry Confessional override)
   * @returns {string} - Prompt text
   */
  function buildTitlePrompt(mode, arousal, world, tone) {
      // Wry Confessional: Return directly from vocabulary pool (no AI generation needed)
      // WRY CONFESSION IS THE MODEL â€” other tones should aspire to its semantic standard
      if (tone === 'Wry Confessional') {
          const pool = WRY_CONFESSIONAL_VOCABULARY[mode]
              || WRY_CONFESSIONAL_VOCABULARY.OBSERVATIONAL;
          return pool[Math.floor(Math.random() * pool.length)];
      }

      const modeVocab = TITLE_MODE_VOCABULARY[mode];
      const arousalSignals = AROUSAL_TITLE_SIGNALS[arousal];

      let modeInstruction = '';
      switch (mode) {
          case TITLE_MODES.POSSESSIVE_POWER:
              // CHANGED: Removed "Your Obedience" (resolution) from examples
              modeInstruction = `Generate a POSSESSIVE POWER title.
Format: [Possessive] [Noun]
Possessives: ${modeVocab.possessives.join(', ')}
Nouns for ${arousal}: ${modeVocab.nouns[arousal]?.join(', ') || 'Silence, Distance, Terms'}
Examples: "Her Silence", "My Hesitation", "Your Temptation"`;
              break;
          case TITLE_MODES.FORBIDDEN_OBJECT:
              modeInstruction = `Generate a FORBIDDEN OBJECT title.
Format: The [Object]
Objects for ${arousal}: ${modeVocab.objects[arousal]?.join(', ') || 'Door, Key, Contract'}
Examples: "The Key", "The Question", "The Threshold"`;
              break;
          case TITLE_MODES.VERB_LOCKED:
              // CHANGED: Now uses PRESENT tense, not past tense
              modeInstruction = `Generate a VERB-LOCKED title (PRESENT or CONDITIONAL tense â€” NOT past).
Format: [What/Where/If/Whether] [Subject] [Present Verb]
Verbs for ${arousal}: ${modeVocab.verbs[arousal]?.join(', ') || 'Means, Waits, Wants'}
Examples: "What She Wants", "If He Stays", "Whether You Dare"`;
              break;
          case TITLE_MODES.TWO_WORD_FRACTURE:
              // CHANGED: Removed "Sacred Damage" (aftermath) from examples
              modeInstruction = `Generate a TWO-WORD FRACTURE title.
Format: [Adjective] [Noun]
Adjectives for ${arousal}: ${modeVocab.adjectives[arousal]?.join(', ') || 'Quiet, Hidden, Burning'}
Nouns: ${modeVocab.nouns.join(', ')}
Examples: "Quiet Hunger", "Burning Silence", "Desperate Waiting"`;
              break;
      }

      return `${modeInstruction}

AROUSAL SIGNAL REQUIRED: ${arousal} â†’ ${arousalSignals?.description || 'clear intensity'}
WORLD: ${world}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
REGIME RULE â€” UNRESOLVED TENSION ONLY (ST1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
This title is generated at story START. The ending has not happened.

A title is the Story's ADMISSION of tension, NOT a promise of outcome.

BANNED â€” RESOLUTION VOCABULARY (HARD FAIL):
- Past-tense completion verbs: "took", "claimed", "broke", "ruined", "gave"
- Possessive resolution: "her surrender", "your obedience", "my ruin"
- Aftermath nouns: "reckoning", "downfall", "betrayal", "destruction"
- Completion states: "finally", "at last", "what remained"

BANNED â€” GENERIC PATTERNS (HARD FAIL):
- "Shadows of", "Echoes of", "Whispers"
- "Beneath", "Within", "Beyond"
- Destiny/fate language
- Multi-clause poetic phrasing
- Marketing copy tone

The title must name WHAT IS UNRESOLVED, not what will be resolved.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Return ONLY the title, no quotes or explanation.`;
  }

  /**
   * SELECT TITLE MODE
   * Deterministically selects which title mode to use
   * @param {string} world - Current world setting
   * @param {string} arousal - Current arousal level
   * @param {string} genre - Current genre
   * @param {string} tone - Current tone (optional, for Wry Confessional override)
   * @returns {string} - Selected mode
   */
  function selectTitleMode(world, arousal, genre, tone) {
      // Wry Confessional uses its own mode set
      if (tone === 'Wry Confessional') {
          const modes = Object.values(WRY_CONFESSIONAL_TITLE_MODES);
          return modes[Math.floor(Math.random() * modes.length)];
      }

      // Use hash for deterministic but varied selection
      const seed = (world || 'Modern') + (arousal || 'Naughty') + (genre || 'Romance');
      const hash = simpleHash(seed);
      const modes = Object.values(TITLE_MODES);
      return modes[hash % modes.length];
  }

  // Expose pipeline functions globally
  window.detectTitleMode = detectTitleMode;
  window.runSwapTest = runSwapTest;
  window.enforceTitleImmutability = enforceTitleImmutability;
  window.validateCoverEscalation = validateCoverEscalation;
  window.buildTitlePrompt = buildTitlePrompt;
  window.selectTitleMode = selectTitleMode;
  window.TITLE_MODES = TITLE_MODES;

  // ============================================================
  // TRIPLE-FORK CONTINUATION SYSTEM
  // ============================================================
  // Three paths at story completion:
  // 1. Continue this story (same world instance, sequel title)
  // 2. New story, same world (same world ID, world-marked title)
  // 3. Completely new story (new world ID, fresh title)
  // ============================================================

  const CONTINUATION_PATHS = {
      CONTINUE: 'continue',
      SAME_WORLD: 'same_world',
      NEW_STORY: 'new_story'
  };

  const WORLD_STORY_SUFFIXES = ['Story', 'Tale', 'Chronicle', 'Affair', 'ExposÃ©', 'Adventure'];

  /**
   * Generate a unique World Instance ID
   * @returns {string}
   */
  function generateWorldInstanceId() {
      return 'world_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
  }

  /**
   * Generate a unique World Name based on world + flavor
   * @param {string} world - Current world setting
   * @param {string} genre - Current genre
   * @returns {string} - Unique world name (e.g., "The Veiled Courts", "Obsidian Towers")
   */
  function generateWorldName(world, genre) {
      const WORLD_NAME_PREFIXES = {
          Modern: ['The Glass', 'The Steel', 'The Gilded', 'The Shadow'],
          Historical: ['The Veiled', 'The Crown', 'The Silver', 'The Crimson'],
          Fantasy: ['The Arcane', 'The Sundered', 'The Moonlit', 'The Thornwood'],
          SciFi: ['The Obsidian', 'The Nebula', 'The Quantum', 'The Orbital'],
          Noir: ['The Smoke', 'The Neon', 'The Midnight', 'The Velvet'],
          Gothic: ['The Hollow', 'The Raven', 'The Ashen', 'The Shrouded'],
          Paranormal: ['The Liminal', 'The Spectral', 'The Twilight', 'The Veil']
      };
      const WORLD_NAME_SUFFIXES = {
          Modern: ['Towers', 'District', 'Circle', 'Heights'],
          Historical: ['Courts', 'Houses', 'Halls', 'Estates'],
          Fantasy: ['Realm', 'Kingdom', 'Dominion', 'Throne'],
          SciFi: ['Station', 'Sector', 'Frontier', 'Array'],
          Noir: ['Corners', 'Streets', 'District', 'Alleys'],
          Gothic: ['Manor', 'Abbey', 'Estate', 'Grounds'],
          Paranormal: ['Crossing', 'Threshold', 'Boundary', 'Gate']
      };

      const prefixes = WORLD_NAME_PREFIXES[world] || WORLD_NAME_PREFIXES.Modern;
      const suffixes = WORLD_NAME_SUFFIXES[world] || WORLD_NAME_SUFFIXES.Modern;

      const seed = (world || '') + (genre || '') + Date.now();
      const prefixIndex = simpleHash(seed) % prefixes.length;
      const suffixIndex = simpleHash(seed + 'suffix') % suffixes.length;

      return prefixes[prefixIndex] + ' ' + suffixes[suffixIndex];
  }

  /**
   * Get world story suffix based on world/tone
   * @param {string} world - Current world
   * @param {string} tone - Current tone
   * @returns {string}
   */
  function getWorldStorySuffix(world, tone) {
      // Different tones get different suffixes
      if (tone === 'Dark' || tone === 'Horror') return 'Chronicle';
      if (tone === 'Comedic') return 'Adventure';
      if (tone === 'WryConfession') return 'ExposÃ©';
      if (world === 'Noir') return 'Affair';
      return 'Tale';
  }

  /**
   * Build continuation title prompt for CONTINUE path
   * Must use SAME mode, echo structure, share NO exact words
   * @param {string} previousTitle - The title to echo
   * @param {string} previousMode - The mode to maintain
   * @param {string} arousal - Current arousal
   * @returns {string}
   */
  function buildContinuationTitlePrompt(previousTitle, previousMode, arousal) {
      const modeVocab = TITLE_MODE_VOCABULARY[previousMode];

      return `Generate a SEQUEL title that echoes the previous title.

PREVIOUS TITLE: "${previousTitle}"
TITLE MODE: ${previousMode} (MUST use same structure)

RULES:
1. Use the EXACT SAME title mode/structure as "${previousTitle}"
2. Echo its semantic feel and rhythm
3. Share NO EXACT WORDS with the previous title
4. Signal ${arousal} arousal level

${previousMode === TITLE_MODES.POSSESSIVE_POWER ?
    `Format: [Possessive] [Noun] â€” Use: ${modeVocab.possessives.join(', ')}` :
    previousMode === TITLE_MODES.FORBIDDEN_OBJECT ?
    `Format: The [Object]` :
    previousMode === TITLE_MODES.VERB_LOCKED ?
    `Format: [What/Where/When/How] [Subject] [Past Verb]` :
    `Format: [Adjective] [Noun]`}

Example: "The Hitched Breath" â†’ "The Forbidden Sigh"

Return ONLY the title, no quotes or explanation.`;
  }

  /**
   * Build same-world title with world-marking subtitle
   * @param {string} primaryTitle - The main title
   * @param {string} worldName - The persistent world name
   * @param {string} suffix - Story/Tale/Chronicle etc.
   * @returns {string}
   */
  function buildWorldMarkedTitle(primaryTitle, worldName, suffix) {
      return `${primaryTitle}\nA ${worldName} ${suffix}`;
  }

  /**
   * Validate continuation title based on path
   * @param {string} title - Generated title
   * @param {string} path - CONTINUE | SAME_WORLD | NEW_STORY
   * @param {object} context - { previousTitle, worldName, priorNouns }
   * @returns {{ valid: boolean, errors: Array<{code: string, message: string}> }}
   */
  function validateContinuationTitle(title, path, context) {
      const errors = [];
      const cleanTitle = (title || '').trim();

      if (path === CONTINUATION_PATHS.CONTINUE) {
          // Must share no exact words with previous title
          if (context.previousTitle) {
              const prevWords = context.previousTitle.toLowerCase().split(/\s+/);
              const newWords = cleanTitle.toLowerCase().split(/\s+/);
              const sharedWords = newWords.filter(w => prevWords.includes(w) && w.length > 2);
              if (sharedWords.length > 0) {
                  errors.push({
                      code: 'CONTINUATION_WORD_REUSE',
                      message: `Continuation title shares words with previous: ${sharedWords.join(', ')}`
                  });
              }
          }
      }

      if (path === CONTINUATION_PATHS.SAME_WORLD) {
          // Must include world-marking subtitle
          if (!cleanTitle.includes('\n') && !cleanTitle.includes(':')) {
              errors.push({
                  code: 'SAME_WORLD_MISSING_SUBTITLE',
                  message: 'Same-world title must include world-marking subtitle'
              });
          }
          // Must include world name
          if (context.worldName && !cleanTitle.includes(context.worldName)) {
              errors.push({
                  code: 'SAME_WORLD_MISSING_WORLD_NAME',
                  message: `Same-world title must include world name: "${context.worldName}"`
              });
          }
      }

      if (path === CONTINUATION_PATHS.NEW_STORY) {
          // Must not reference prior world nouns
          if (context.priorNouns && context.priorNouns.length > 0) {
              const titleLower = cleanTitle.toLowerCase();
              const reusedNouns = context.priorNouns.filter(n => titleLower.includes(n.toLowerCase()));
              if (reusedNouns.length > 0) {
                  errors.push({
                      code: 'NEW_STORY_PRIOR_NOUN_REUSE',
                      message: `New story title references prior world: ${reusedNouns.join(', ')}`
                  });
              }
          }
      }

      return { valid: errors.length === 0, errors };
  }

  /**
   * Initialize continuation state for a path
   * @param {string} path - Selected continuation path
   */
  function initializeContinuationPath(path) {
      state.continuationPath = path;

      if (path === CONTINUATION_PATHS.CONTINUE) {
          // Keep same world instance, store previous title for reference
          // worldInstanceId stays the same
          console.log('[Continuation] CONTINUE: Same world instance, sequel title');
      } else if (path === CONTINUATION_PATHS.SAME_WORLD) {
          // Keep world instance ID and name, new story ID
          state.storyId = null; // Will be regenerated
          state.previousTitle = state.immutableTitle;
          console.log('[Continuation] SAME_WORLD: Same world, new narrative');
      } else {
          // NEW_STORY: Reset everything
          state.worldInstanceId = generateWorldInstanceId();
          state.worldName = null;
          state.previousTitle = null;
          state.previousTitleMode = null;
          state.storyId = null;
          console.log('[Continuation] NEW_STORY: Fresh start, new world instance');
      }
  }

  /**
   * Route title generation based on continuation path
   * @param {string} path - Continuation path
   * @param {object} context - Generation context
   * @returns {object} - { prompt: string, mode: string, worldMarked: boolean }
   */
  function routeTitleGeneration(path, context) {
      const { world, arousal, genre, tone } = context;

      if (path === CONTINUATION_PATHS.CONTINUE) {
          // Use previous mode, build continuation prompt
          const mode = state.previousTitleMode || detectTitleMode(state.previousTitle) || selectTitleMode(world, arousal, genre, tone);
          return {
              prompt: buildContinuationTitlePrompt(state.previousTitle, mode, arousal),
              mode: mode,
              worldMarked: false
          };
      } else if (path === CONTINUATION_PATHS.SAME_WORLD) {
          // Standard title generation, will add world suffix after
          if (!state.worldName) {
              state.worldName = generateWorldName(world, genre);
          }
          const mode = selectTitleMode(world, arousal, genre, tone);
          return {
              prompt: buildTitlePrompt(mode, arousal, world, tone),
              mode: mode,
              worldMarked: true,
              worldName: state.worldName,
              suffix: getWorldStorySuffix(world, tone)
          };
      } else {
          // NEW_STORY: Standard title generation
          const mode = selectTitleMode(world, arousal, genre, tone);
          return {
              prompt: buildTitlePrompt(mode, arousal, world, tone),
              mode: mode,
              worldMarked: false
          };
      }
  }

  /**
   * Store prior world proper nouns for new story validation
   * @returns {string[]}
   */
  function collectPriorWorldNouns() {
      const nouns = [];
      if (state.worldName) nouns.push(state.worldName);
      if (state.rawPlayerName) nouns.push(state.rawPlayerName);
      if (state.rawPartnerName) nouns.push(state.rawPartnerName);
      // Could add location names, institution names from story if tracked
      return nouns.filter(n => n && n.length > 2);
  }

  // Expose continuation system globally
  window.CONTINUATION_PATHS = CONTINUATION_PATHS;
  window.generateWorldInstanceId = generateWorldInstanceId;
  window.generateWorldName = generateWorldName;
  window.validateContinuationTitle = validateContinuationTitle;
  window.initializeContinuationPath = initializeContinuationPath;
  window.routeTitleGeneration = routeTitleGeneration;
  window.buildWorldMarkedTitle = buildWorldMarkedTitle;
  window.collectPriorWorldNouns = collectPriorWorldNouns;

  /**
   * Show the triple-fork continuation modal
   * Called at story completion or when user requests new story
   */
  function showContinuationFork() {
      const modal = document.getElementById('continuationForkModal');
      if (modal) {
          modal.classList.remove('hidden');
          console.log('[Continuation] Fork modal shown');
      }
  }

  /**
   * Hide the continuation fork modal
   */
  function hideContinuationFork() {
      const modal = document.getElementById('continuationForkModal');
      if (modal) {
          modal.classList.add('hidden');
      }
  }

  /**
   * Handle user selection of continuation path
   * @param {string} path - 'continue' | 'same_world' | 'new_story'
   */
  function selectContinuationPath(path) {
      // Map string to constant
      const pathMap = {
          'continue': CONTINUATION_PATHS.CONTINUE,
          'same_world': CONTINUATION_PATHS.SAME_WORLD,
          'new_story': CONTINUATION_PATHS.NEW_STORY
      };
      const selectedPath = pathMap[path] || CONTINUATION_PATHS.NEW_STORY;

      console.log('[Continuation] Path selected:', selectedPath);

      // Store prior world nouns before path initialization (for NEW_STORY validation)
      const priorNouns = collectPriorWorldNouns();
      state._priorWorldNouns = priorNouns;

      // Preserve world for SAME_WORLD path before any resets
      const preservedWorld = state.picks?.world;
      const preservedTitle = state.immutableTitle;
      const preservedTitleMode = state.previousTitleMode;

      // Initialize the path (sets continuation state)
      initializeContinuationPath(selectedPath);

      // Hide modal
      hideContinuationFork();

      // Handle path-specific state management
      if (selectedPath === CONTINUATION_PATHS.CONTINUE) {
          // Direct sequel â€” preserve most state, just reset story position
          state.storyEnded = false;
          state.turnCount = 0;
          clearStoryContent();
          // Title should echo previous title's mode
          state.previousTitle = preservedTitle;
          console.log('[Continuation] CONTINUE: Story state reset for sequel');
          window.showScreen('setup');
      } else if (selectedPath === CONTINUATION_PATHS.SAME_WORLD) {
          // Same world, new story â€” reset story but keep world
          resetForNewStory();
          state.picks.world = preservedWorld; // Restore world selection
          state.previousTitle = preservedTitle;
          state.previousTitleMode = preservedTitleMode;
          // Pre-select the world card in UI
          preselectWorldCard(preservedWorld);
          console.log('[Continuation] SAME_WORLD: Fresh story in', preservedWorld);
          window.showScreen('setup');
      } else {
          // Completely new story â€” full reset
          resetForNewStory();
          console.log('[Continuation] NEW_STORY: Full reset');
          window.showScreen('setup');
      }
  }

  /**
   * Clear story content without resetting picks
   */
  function clearStoryContent() {
      state.currentStoryContent = '';
      state.storyHistory = [];
      localStorage.removeItem('sb_saved_story');
      // Clear pagination if available
      if (typeof StoryPagination !== 'undefined' && StoryPagination.clear) {
          StoryPagination.clear();
      }
      const storyEl = document.getElementById('storyText');
      if (storyEl) storyEl.innerHTML = '';
  }

  /**
   * Reset state for a new story (preserves subscription/payment state)
   */
  function resetForNewStory() {
      state.storyEnded = false;
      state.turnCount = 0;
      state.storyLength = 'tease';
      state.storyId = null;
      clearStoryContent();

      // Reset DSP state for new story
      if (typeof resetDSPState === 'function') resetDSPState();

      // Reset title state
      state.immutableTitle = null;
      state.coverArchetype = null;

      // Reset visual state
      state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} }, sceneBudgets: {}, visualizedScenes: {} };

      // Reset per-story visualization credits (preserve globalCredits and payAsYouGoEnabled)
      if (state.vizEconomy) {
          state.vizEconomy.storyCredits = 0;
          state.vizEconomy.lastCreditedSceneCount = 0;
          state.vizEconomy.awardedMilestones = [];
      }

      // Clear cover state
      if (_coverAbortController) { _coverAbortController.abort(); _coverAbortController = null; }
      if (typeof resetBookState === 'function') resetBookState();
      const coverImg = document.getElementById('bookCoverImg');
      if (coverImg) coverImg.src = '';
      const coverLoading = document.getElementById('coverLoadingState');
      if (coverLoading) coverLoading.classList.add('hidden');
      const bookObj = document.getElementById('bookObject');
      if (bookObj) bookObj.classList.add('hidden');

      // Reset Storyturn state
      if (typeof resetStoryturnState === 'function') resetStoryturnState();
  }

  /**
   * Pre-select a world card in the setup UI
   */
  function preselectWorldCard(world) {
      if (!world) return;
      // Find and select the world card
      const worldCards = document.querySelectorAll('.sb-card[data-grp="world"]');
      worldCards.forEach(card => {
          card.classList.remove('selected', 'flipped');
          if (card.dataset.val === world) {
              card.classList.add('selected', 'flipped');
          }
      });
  }

  /**
   * Default to new story if modal closed without selection
   */
  function defaultContinuationPath() {
      console.log('[Continuation] Default path: NEW_STORY');
      selectContinuationPath('new_story');
  }

  // Expose fork modal handlers globally
  window.showContinuationFork = showContinuationFork;
  window.hideContinuationFork = hideContinuationFork;
  window.selectContinuationPath = selectContinuationPath;
  window.defaultContinuationPath = defaultContinuationPath;

  /**
   * FALLBACK TITLE GENERATOR
   * Creates a deterministic name-based title when validation fails.
   * Pattern A: [FirstName]'s [Qualifier]
   * Pattern B: [FullName]: [Qualifier]
   *
   * @param {object} opts - { playerName, partnerName, world, tone, genre }
   * @returns {string} - Fallback title (never fails)
   */
  function generateFallbackTitle(opts) {
      const { playerName, partnerName, world, tone, genre } = opts;

      // Get qualifiers for this world (fallback to Modern)
      const qualifiers = TITLE_FALLBACK_QUALIFIERS[world] || TITLE_FALLBACK_QUALIFIERS.Modern;

      // Deterministic qualifier selection via hash of tone+genre
      const hashSeed = (tone || 'Earnest') + (genre || 'Romance');
      const qualifierIndex = simpleHash(hashSeed) % qualifiers.length;
      const qualifier = qualifiers[qualifierIndex];

      // Prefer love interest name for more intrigue, fallback to player
      const primaryName = partnerName || playerName;
      const firstName = extractFirstName(primaryName);

      // If we have a valid first name, use Pattern A
      if (firstName && firstName.length > 1 && !/^(the|a)\s/i.test(firstName)) {
          return `${firstName}'s ${qualifier}`;
      }

      // If we have a full name with 2+ parts, use Pattern B
      if (primaryName && primaryName.includes(' ')) {
          return `${primaryName}: ${qualifier}`;
      }

      // Last resort: use qualifier alone with dramatic framing
      return `The ${qualifier}`;
  }

  // Expose validators globally for Dev HUD
  window.validateTitle = validateTitle;
  window.generateFallbackTitle = generateFallbackTitle;

  // ============================================================
  // TITLE â†” COVER SIGNAL ALIGNMENT LAYER
  // ============================================================
  // Ensures title and cover art signal the SAME dominant axis.
  // Primary axis: exactly one (usually Arousal)
  // Secondary axis: optional (max one)
  // All other axes: neutral
  // ============================================================

  /**
   * SIGNAL AXIS DEFINITIONS
   * Each axis has detection patterns for both title and cover
   */
  const SIGNAL_AXES = {
      AROUSAL: 'arousal',
      TONE: 'tone',
      GENRE: 'genre'
  };

  /**
   * AROUSAL SIGNAL PATTERNS
   * Title/cover must independently signal the arousal tier
   */
  const AROUSAL_SIGNALS = {
      Clean: {
          title: {
              allow: /\b(distance|restraint|waiting|watching|almost|nearly|silence|apart)\b/i,
              forbid: /\b(burn|ache|want|hunger|possession|devour|consume|claim)\b/i
          },
          cover: {
              allow: ['separation', 'stillness', 'restraint', 'waiting', 'longing from afar'],
              forbid: ['touch', 'embrace', 'intimacy', 'skin', 'heat', 'tension']
          },
          signal: 'restraint, distance'
      },
      Naughty: {
          title: {
              allow: /\b(almost|want|tempt|tease|forbidden|secret|risk|dare|edge)\b/i,
              forbid: /\b(claim|possess|devour|consume|take|surrender|yield)\b/i
          },
          cover: {
              allow: ['suggestion', 'withholding', 'anticipation', 'almost-touch', 'nearness'],
              forbid: ['explicit intimacy', 'possession', 'surrender', 'exposure']
          },
          signal: 'suggestion, withholding'
      },
      Erotic: {
          title: {
              allow: /\b(want|ache|burn|claim|mine|yours|possess|surrender|give|take)\b/i,
              forbid: /\b(filth|raw|intrude|force|use|ruin|wreck|break)\b/i
          },
          cover: {
              allow: ['intimacy', 'possession', 'surrender', 'closeness', 'heat', 'connection'],
              forbid: ['clinical', 'crude', 'explicit anatomy', 'shock']
          },
          signal: 'intimacy, possession'
      },
      Dirty: {
          title: {
              allow: /\b(filth|raw|ruin|wreck|use|break|devour|consume|claim|take)\b/i,
              forbid: /\b(sweet|gentle|soft|tender|pure|innocent|chaste)\b/i
          },
          cover: {
              allow: ['intrusion', 'bluntness', 'rawness', 'edge', 'danger', 'intensity'],
              forbid: ['sweetness', 'gentleness', 'purity', 'innocence']
          },
          signal: 'intrusion, bluntness'
      }
  };

  /**
   * TONE SIGNAL PATTERNS
   * Secondary axis - tone signals in title/cover
   */
  const TONE_AXIS_SIGNALS = {
      WryConfession: {
          title: /\b(almost|anyway|still|wrong|mistake|lie|truth|never)\b/i,
          cover: ['irony', 'self-awareness', 'confession', 'doubt']
      },
      Comedic: {
          title: /\b(oops|wrong|disaster|mess|trouble|help|chaos)\b/i,
          cover: ['lightness', 'absurdity', 'playfulness', 'mischief']
      },
      Surreal: {
          title: /\b(dream|strange|nowhere|forgot|remember|almost|maybe)\b/i,
          cover: ['dream-logic', 'dissolution', 'unreality', 'drift']
      },
      Dark: {
          title: /\b(blood|bone|ash|ruin|end|last|only|never|death)\b/i,
          cover: ['weight', 'shadow', 'gravity', 'consequence', 'doom']
      },
      Earnest: {
          title: null, // Most permissive
          cover: ['sincerity', 'hope', 'warmth', 'openness']
      }
  };

  /**
   * GENRE SIGNAL PATTERNS
   * Secondary axis - genre signals in title/cover
   */
  const GENRE_AXIS_SIGNALS = {
      Billionaire: {
          title: /\b(empire|fortune|deal|contract|merger|penthouse|heir)\b/i,
          cover: ['wealth', 'power', 'luxury', 'corporate', 'skyline']
      },
      CrimeSyndicate: {
          title: /\b(blood|family|loyalty|debt|oath|boss|territory)\b/i,
          cover: ['danger', 'shadows', 'underworld', 'loyalty']
      },
      Espionage: {
          title: /\b(secret|agent|cover|mission|asset|handler|burn)\b/i,
          cover: ['mystery', 'concealment', 'danger', 'surveillance']
      },
      Noir: {
          title: /\b(smoke|rain|night|shadow|dame|case|trouble)\b/i,
          cover: ['shadow', 'mystery', 'urban night', 'smoke', 'rain']
      },
      Heist: {
          title: /\b(score|job|crew|vault|mark|inside|take)\b/i,
          cover: ['precision', 'tension', 'planning', 'stakes']
      }
  };

  /**
   * Extract dominant signal axis from title
   * @param {string} title - The book title
   * @param {string} arousal - Current arousal level
   * @param {string} tone - Current tone
   * @param {string} genre - Current genre
   * @returns {{ primary: string, secondary: string|null, arousalMatch: boolean, signals: object }}
   */
  function extractTitleSignals(title, arousal, tone, genre) {
      const cleanTitle = (title || '').toLowerCase().trim();
      const signals = {
          arousal: null,
          tone: null,
          genre: null
      };

      // Check arousal signals
      const arousalConfig = AROUSAL_SIGNALS[arousal];
      if (arousalConfig?.title?.allow?.test(cleanTitle)) {
          signals.arousal = arousal;
      }
      // Check for arousal contradiction
      const arousalContradiction = arousalConfig?.title?.forbid?.test(cleanTitle);

      // Check tone signals
      const toneConfig = TONE_AXIS_SIGNALS[tone];
      if (toneConfig?.title?.test(cleanTitle)) {
          signals.tone = tone;
      }

      // Check genre signals
      const genreConfig = GENRE_AXIS_SIGNALS[genre];
      if (genreConfig?.title?.test(cleanTitle)) {
          signals.genre = genre;
      }

      // Determine primary axis (priority: arousal > tone > genre)
      let primary = null;
      let secondary = null;

      if (signals.arousal) {
          primary = SIGNAL_AXES.AROUSAL;
          if (signals.tone) secondary = SIGNAL_AXES.TONE;
          else if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.tone) {
          primary = SIGNAL_AXES.TONE;
          if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.genre) {
          primary = SIGNAL_AXES.GENRE;
      }

      return {
          primary,
          secondary,
          arousalMatch: signals.arousal === arousal,
          arousalContradiction,
          signals
      };
  }

  /**
   * Extract dominant signal axis from cover prompt
   * @param {object} coverPrompt - The cover prompt object from buildCoverPrompt
   * @param {string} arousal - Current arousal level
   * @param {string} tone - Current tone
   * @param {string} genre - Current genre
   * @returns {{ primary: string, secondary: string|null, arousalMatch: boolean, signals: object }}
   */
  function extractCoverSignals(coverPrompt, arousal, tone, genre) {
      const promptText = (coverPrompt?.promptText || '').toLowerCase();
      const emotion = (coverPrompt?.emotion || '').toLowerCase();
      const signals = {
          arousal: null,
          tone: null,
          genre: null
      };

      // Check arousal signals in cover
      const arousalConfig = AROUSAL_SIGNALS[arousal];
      if (arousalConfig?.cover?.allow) {
          const hasArousalSignal = arousalConfig.cover.allow.some(sig =>
              promptText.includes(sig.toLowerCase()) || emotion.includes(sig.toLowerCase())
          );
          if (hasArousalSignal) signals.arousal = arousal;
      }

      // Check for arousal contradiction
      let arousalContradiction = false;
      if (arousalConfig?.cover?.forbid) {
          arousalContradiction = arousalConfig.cover.forbid.some(sig =>
              promptText.includes(sig.toLowerCase()) || emotion.includes(sig.toLowerCase())
          );
      }

      // Check tone signals
      const toneConfig = TONE_AXIS_SIGNALS[tone];
      if (toneConfig?.cover) {
          const hasToneSignal = toneConfig.cover.some(sig =>
              promptText.includes(sig.toLowerCase()) || emotion.includes(sig.toLowerCase())
          );
          if (hasToneSignal) signals.tone = tone;
      }

      // Check genre signals
      const genreConfig = GENRE_AXIS_SIGNALS[genre];
      if (genreConfig?.cover) {
          const hasGenreSignal = genreConfig.cover.some(sig =>
              promptText.includes(sig.toLowerCase())
          );
          if (hasGenreSignal) signals.genre = genre;
      }

      // Frame/border state for composed cover validation
      const keyholeEl = document.getElementById('coverKeyholeOverlay');
      const borderEl = document.getElementById('coverEroticBorder');
      const frameType = keyholeEl && !keyholeEl.classList.contains('hidden') ? 'keyhole' : null;
      const borderType = borderEl && !borderEl.classList.contains('hidden') ? 'erotic' : null;

      // DIRTY FRAMING SHORT-CIRCUIT: Frame/border has precedence over image semantics
      // Dirty is signaled by keyhole/metalwork framing, NOT image content
      const hasDirtyFraming = frameType === 'keyhole';
      let primary = null;
      let secondary = null;
      let arousalMatchOverride = false;

      if (arousal === 'Dirty' && hasDirtyFraming) {
          // HARD OVERRIDE: Dirty framing sets arousal axis, image semantics cannot override
          primary = SIGNAL_AXES.AROUSAL;
          arousalMatchOverride = true;
          // Secondary can still be tone or genre from image
          if (signals.tone) secondary = SIGNAL_AXES.TONE;
          else if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.arousal) {
          primary = SIGNAL_AXES.AROUSAL;
          if (signals.tone) secondary = SIGNAL_AXES.TONE;
          else if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.tone) {
          primary = SIGNAL_AXES.TONE;
          if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.genre) {
          primary = SIGNAL_AXES.GENRE;
      }

      return {
          primary,
          secondary,
          arousalMatch: arousalMatchOverride || signals.arousal === arousal,
          arousalContradiction: arousalMatchOverride ? false : arousalContradiction,
          signals,
          // Composed cover signals (framing is part of the cover signal)
          frameType,
          borderType,
          dirtyFramingOverride: hasDirtyFraming && arousal === 'Dirty'
      };
  }

  /**
   * SIGNAL ALIGNMENT VALIDATION
   * Validates that title and cover signal the same dominant axis
   * @param {string} title - The book title
   * @param {object} coverPrompt - Cover prompt from buildCoverPrompt
   * @param {object} context - { arousal, tone, genre }
   * @returns {{ aligned: boolean, errors: Array<{code: string, message: string}>, titleSignals: object, coverSignals: object }}
   */
  function validateSignalAlignment(title, coverPrompt, context) {
      const { arousal, tone, genre } = context;
      const errors = [];

      // Extract signals from both sources
      const titleSignals = extractTitleSignals(title, arousal, tone, genre);
      const coverSignals = extractCoverSignals(coverPrompt, arousal, tone, genre);

      // CHECK 1: Primary axis alignment
      if (titleSignals.primary && coverSignals.primary) {
          if (titleSignals.primary !== coverSignals.primary) {
              errors.push({
                  code: 'SIGNAL_AXIS_MISMATCH',
                  message: `Title signals ${titleSignals.primary}, cover signals ${coverSignals.primary}`
              });
          }
      }

      // CHECK 2: Arousal contradiction (HARD FAIL)
      if (titleSignals.arousalContradiction) {
          errors.push({
              code: 'TITLE_AROUSAL_CONTRADICTION',
              message: `Title contains words forbidden at ${arousal} arousal level`
          });
      }
      if (coverSignals.arousalContradiction) {
          errors.push({
              code: 'COVER_AROUSAL_CONTRADICTION',
              message: `Cover contains signals forbidden at ${arousal} arousal level`
          });
      }

      // CHECK 3: Neither signals arousal (when arousal should be primary)
      // DIRTY EXCEPTION: Keyhole/metalwork framing provides the arousal signal,
      // not the image content. applyCoverIntensityLayers() applies keyhole for Dirty.
      if (arousal === 'Erotic') {
          if (!titleSignals.arousalMatch && !coverSignals.arousalMatch) {
              errors.push({
                  code: 'AROUSAL_SIGNAL_ABSENT',
                  message: `${arousal} intensity but neither title nor cover signals it`
              });
          }
      } else if (arousal === 'Dirty') {
          // Dirty covers signal arousal via keyhole/metalwork framing, NOT image content.
          // The framing is guaranteed by applyCoverIntensityLayers when arousal=Dirty.
          // Therefore: image content may remain Naughty-compatible or symbolic.
          // CHECK: Verify keyhole overlay is/will be present
          const keyholeEl = document.getElementById('coverKeyholeOverlay');
          const hasKeyholeFrame = keyholeEl && !keyholeEl.classList.contains('hidden');
          const willHaveKeyholeFrame = true; // Dirty always gets keyhole via applyCoverIntensityLayers

          if (!hasKeyholeFrame && !willHaveKeyholeFrame) {
              // Only fail if Dirty lacks Dirty-signaling framing
              errors.push({
                  code: 'DIRTY_FRAME_ABSENT',
                  message: 'Dirty intensity requires keyhole/metalwork framing'
              });
          }
          // Note: titleSignals.arousalMatch and coverSignals.arousalMatch NOT required for Dirty
          // The composed cover (image + keyhole frame) is the signal, not image alone
      }

      // CHECK 4: Ambiguity check - no clear primary in either
      if (!titleSignals.primary && !coverSignals.primary) {
          errors.push({
              code: 'SIGNAL_AMBIGUOUS',
              message: 'Neither title nor cover has a clear primary signal axis'
          });
      }

      // CHECK 5: Secondary axis conflict
      if (titleSignals.secondary && coverSignals.secondary) {
          if (titleSignals.secondary !== coverSignals.secondary) {
              // Soft warning, not hard fail
              console.log('[SignalAlignment] Secondary axis differs:', titleSignals.secondary, 'vs', coverSignals.secondary);
          }
      }

      return {
          aligned: errors.length === 0,
          errors,
          titleSignals,
          coverSignals,
          context: {
              expectedArousal: arousal,
              arousalSignal: AROUSAL_SIGNALS[arousal]?.signal || 'neutral'
          }
      };
  }

  /**
   * Quick arousal inference from title alone
   * Used for pre-validation before cover is generated
   * @param {string} title - The book title
   * @returns {string|null} - Inferred arousal tier or null if ambiguous
   */
  function inferArousalFromTitle(title) {
      const cleanTitle = (title || '').toLowerCase().trim();

      // Check in order from most restrictive to least
      for (const level of ['Dirty', 'Erotic', 'Naughty', 'Clean']) {
          const config = AROUSAL_SIGNALS[level];
          if (config?.title?.allow?.test(cleanTitle)) {
              // Also check it doesn't violate this level's forbid
              if (!config.title.forbid?.test(cleanTitle)) {
                  return level;
              }
          }
      }
      return null; // Ambiguous
  }

  // Expose signal alignment functions globally
  window.validateSignalAlignment = validateSignalAlignment;
  window.extractTitleSignals = extractTitleSignals;
  window.extractCoverSignals = extractCoverSignals;
  window.inferArousalFromTitle = inferArousalFromTitle;
  window.SIGNAL_AXES = SIGNAL_AXES;
  window.AROUSAL_SIGNALS = AROUSAL_SIGNALS;

  /**
   * DSP VALIDATION â€” Strict template enforcement
   * DSP must EXACTLY match: "In [WORLD], shaped by [GENRE], a question awaits:
   * Will [ARCH_ADJ] desire redeem this [TONE_ADJ] affair â€” or ruin it?"
   *
   * @param {string} dspText - The DSP text to validate (HTML stripped)
   * @param {object} inputs - { world, genre, archetypeId, tone }
   * @returns {{ pass: boolean, errors: Array<{code: string, message: string}> }}
   */
  function validateDSP(dspText, inputs) {
      const errors = [];
      const { world, genre, archetypeId, tone } = inputs;

      // Strip HTML tags for validation
      const plainText = dspText.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();

      // Get expected phrases from locked dictionaries
      const expectedWorld = DSP_WORLD_PHRASES[world];
      const expectedGenre = DSP_GENRE_PARAPHRASES[genre];
      const expectedArch = DSP_ARCHETYPE_ADJECTIVES[archetypeId];
      const expectedTone = DSP_TONAL_ADJECTIVES[tone];

      // Validate world phrase exists
      if (!expectedWorld) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_WORLD_PHRASE,
              message: `No DSP world phrase for: "${world}"`
          });
      }

      // Validate genre phrase exists
      if (!expectedGenre) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_GENRE_PHRASE,
              message: `No DSP genre paraphrase for: "${genre}"`
          });
      }

      // Validate archetype adjective exists
      if (!expectedArch) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_ARCHETYPE_ADJ,
              message: `No DSP archetype adjective for: "${archetypeId}"`
          });
      }

      // Validate tone adjective exists
      if (!expectedTone) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_TONE_ADJ,
              message: `No DSP tonal adjective for: "${tone}"`
          });
      }

      // If any dictionary lookups failed, return early
      if (errors.length > 0) {
          return { pass: false, errors };
      }

      // Build expected DSP text (exact template)
      const expectedDSP = `In ${expectedWorld}, shaped by ${expectedGenre}, a question awaits: Will ${expectedArch} desire redeem this ${expectedTone} affair â€” or ruin it?`;

      // Normalize both for comparison (handle HTML entities)
      const normalizedExpected = expectedDSP.replace(/\s+/g, ' ').trim();
      const normalizedActual = plainText
          .replace(/&#8201;/g, ' ')
          .replace(/&#8212;/g, 'â€”')
          .replace(/\u2009/g, ' ')  // thin space
          .replace(/\u2014/g, 'â€”')  // em dash
          .replace(/\s+/g, ' ')
          .trim();

      // Check for exact match
      if (normalizedActual !== normalizedExpected) {
          // Diagnose specific failure
          if (!normalizedActual.startsWith('In ')) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_TEMPLATE_VIOLATION,
                  message: 'DSP must start with "In "'
              });
          }
          if (!normalizedActual.includes(expectedWorld)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_WORLD_PHRASE,
                  message: `World phrase "${expectedWorld}" not found in DSP`
              });
          }
          if (!normalizedActual.includes(expectedGenre)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_GENRE_PHRASE,
                  message: `Genre phrase "${expectedGenre}" not found in DSP`
              });
          }
          if (!normalizedActual.includes(expectedArch)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_ARCHETYPE_ADJ,
                  message: `Archetype adjective "${expectedArch}" not found in DSP`
              });
          }
          if (!normalizedActual.includes(expectedTone)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_TONE_ADJ,
                  message: `Tone adjective "${expectedTone}" not found in DSP`
              });
          }

          // STRICT ADJECTIVE POSITION VALIDATION
          // Verify exact adjective appears in correct DSP slot
          const archSlotMatch = normalizedActual.match(/Will\s+(\w+)\s+desire/i);
          if (archSlotMatch && archSlotMatch[1].toLowerCase() !== expectedArch.toLowerCase()) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_ARCHETYPE_ADJ,
                  message: `Wrong adjective in archetype slot: found "${archSlotMatch[1]}", expected "${expectedArch}"`
              });
          }
          const toneSlotMatch = normalizedActual.match(/this\s+(\w+)\s+affair/i);
          if (toneSlotMatch && toneSlotMatch[1].toLowerCase() !== expectedTone.toLowerCase()) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_TONE_ADJ,
                  message: `Wrong adjective in tone slot: found "${toneSlotMatch[1]}", expected "${expectedTone}"`
              });
          }

          // Check for world subtype leakage
          const SUBTYPE_PATTERNS = [
              /\bsmall[- ]town\b/i, /\bcampus\b/i, /\boffice\b/i, /\bold[- ]money\b/i,
              /\bcyberpunk\b/i, /\bspace opera\b/i, /\bgalactic\b/i, /\bVictorian\b/i,
              /\bRegency\b/i, /\bMedieval\b/i, /\bAncient\b/i
          ];
          for (const pattern of SUBTYPE_PATTERNS) {
              if (pattern.test(normalizedActual)) {
                  errors.push({
                      code: VALIDATION_ERRORS.DSP_WORLD_SUBTYPE_LEAK,
                      message: `World subtype leaked into DSP: ${normalizedActual.match(pattern)?.[0]}`
                  });
                  break;
              }
          }

          // Check for extra prose
          if (normalizedActual.length > normalizedExpected.length + 10) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_EXTRA_PROSE,
                  message: 'DSP contains extra prose beyond locked template'
              });
          }

          // Check for legacy phrasing â€” comprehensive list of deprecated DSP text
          const LEGACY_PATTERNS = [
              /\bdestiny story prompt\b/i,
              /\byour story\b/i,
              /\bonce upon\b/i,
              /\bin this tale\b/i,
              // Legacy world phrases (pre-canon)
              /\bstrangers meet\b/i,
              /\bpower lingers\b/i,
              /\bforces move\b/i,
              /\bvows bind\b/i,
              /\bold powers\b/i,
              /\bcity of strangers\b/i,
              /\bthe present day\b/i,
              /\ban earlier era\b/i,
              /\bsupernatural forces\b/i,
              /\bambition and consequence\b/i,
              // Legacy genre phrases (pre-canon)
              /\bdangerous games\b/i,
              /\bshadow and silk\b/i,
              /\bhigh stakes\b/i,
              /\bforbidden fruit\b/i,
              /\bsecret desires\b/i,
              /\bpassion and peril\b/i,
              /\blove and loss\b/i,
              // Meta-narrative leakage
              /\bthe narrative\b/i,
              /\bthe story\b/i,
              /\bthis romance\b/i,
              /\btheir journey\b/i
          ];
          for (const pattern of LEGACY_PATTERNS) {
              if (pattern.test(normalizedActual)) {
                  errors.push({
                      code: VALIDATION_ERRORS.DSP_LEGACY_PHRASING,
                      message: `Legacy phrasing detected: ${normalizedActual.match(pattern)?.[0]}`
                  });
                  break;
              }
          }

          // WORD-SOURCE VALIDATION: DSP output must contain ONLY words from selected phrases
          // Extract content words (skip articles, prepositions, punctuation)
          const STRUCTURAL_WORDS = new Set([
              'in', 'a', 'an', 'the', 'of', 'and', 'or', 'by', 'shaped', 'question', 'awaits',
              'will', 'desire', 'redeem', 'this', 'affair', 'ruin', 'it', 'to', 'for', 'with'
          ]);
          const dspWords = normalizedActual.toLowerCase()
              .replace(/[.,!?;:\u2014\u2013\u2009\u00a0]/g, ' ')
              .split(/\s+/)
              .filter(w => w.length > 2 && !STRUCTURAL_WORDS.has(w));

          // Build allowed word set from selected phrases
          const allowedWords = new Set();
          (expectedWorld || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          (expectedGenre || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          (expectedArch || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          (expectedTone || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          // Add structural words to allowed set
          STRUCTURAL_WORDS.forEach(w => allowedWords.add(w));

          const illegalWords = dspWords.filter(w => !allowedWords.has(w));
          if (illegalWords.length > 0) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_EXTRA_PROSE,
                  message: `DSP contains words not from canonical phrases: ${illegalWords.slice(0, 5).join(', ')}`
              });
          }

          // Generic template violation if no specific error found
          if (errors.length === 0) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_TEMPLATE_VIOLATION,
                  message: `DSP does not match locked template. Expected: "${normalizedExpected.slice(0, 50)}..."`
              });
          }
      }

      return { pass: errors.length === 0, errors };
  }

  /**
   * POV VALIDATION (5th Person) â€” Comprehensive scene validation
   *
   * @param {string} sceneText - The scene prose to validate
   * @param {object} context - { sceneIndex, isErotic, isGodMode }
   * @returns {{ pass: boolean, errors: Array<{code: string, message: string}>, metrics: object }}
   */
  function validatePOV(sceneText, context) {
      const errors = [];
      const { sceneIndex = 0, isErotic = false, isGodMode = false } = context;
      const isSceneOne = sceneIndex === 0;

      // Count Author mentions
      const authorMatches = sceneText.match(/\bThe Author\b/g) || [];
      const authorMentions = authorMatches.length;

      // Extract first words and last paragraph
      const trimmed = sceneText.trim();
      const firstTwoWords = trimmed.split(/\s+/).slice(0, 2).join(' ');
      const paragraphs = trimmed.split(/\n\n+/);
      const lastParagraph = paragraphs[paragraphs.length - 1] || '';
      const sentences = lastParagraph.match(/[^.!?]+[.!?]+/g) || [lastParagraph];
      const lastTwoSentences = sentences.slice(-2).join(' ');

      // RULE 1: First two words = "The Author" (always enforced)
      const hasValidOpener = /^The Author\b/i.test(trimmed);
      if (!hasValidOpener) {
          errors.push({
              code: VALIDATION_ERRORS.POV_INVALID_OPENER,
              message: `Opening must start with "The Author". Found: "${firstTwoWords}"`
          });
      }

      // RULE 2: Final perspective = The Author (structural check)
      const AUTHOR_CLOSING_VERBS = [
          'held', 'tilted', 'set', 'arranged', 'steered', 'coaxed', 'seeded', 'threaded',
          'watched', 'waited', 'considered', 'wondered', 'doubted', 'resisted', 'smiled',
          'frowned', 'paused', 'knew', 'felt', 'sensed', 'released', 'tightened', 'loosened'
      ];
      const closingVerbPattern = new RegExp(
          'The Author\\s+(' + AUTHOR_CLOSING_VERBS.join('|') + ')\\b', 'i'
      );
      const authorReflectionPattern = /The Author.{0,60}(uncertain|doubt|wonder|question|resist|perhaps|might|whether|if only)/i;
      const hasValidCloser = closingVerbPattern.test(lastTwoSentences) || authorReflectionPattern.test(lastTwoSentences);

      if (!hasValidCloser && !isErotic) {
          errors.push({
              code: VALIDATION_ERRORS.POV_INVALID_CLOSER,
              message: 'Scene must end with The Author as final perspective (action verb or reflection)'
          });
      }

      // RULE 3: Scene prose = strict 3rd person limited
      const firstPersonPattern = /\b(I|me|my|mine|myself)\b(?!\s*["'])/gi;
      const firstPersonMatches = sceneText.match(firstPersonPattern) || [];
      // Filter out dialogue (rough heuristic: not near quotes)
      const nonDialogueFirstPerson = firstPersonMatches.filter(match => {
          const idx = sceneText.indexOf(match);
          const nearbyText = sceneText.slice(Math.max(0, idx - 20), idx + 20);
          return !/"[^"]*$/.test(nearbyText.slice(0, 20)) && !/^[^"]*"/.test(nearbyText.slice(20));
      });
      if (nonDialogueFirstPerson.length > 2) {
          errors.push({
              code: VALIDATION_ERRORS.POV_NON_3RD_PERSON,
              message: `Scene contains ${nonDialogueFirstPerson.length} first-person references outside dialogue`
          });
      }

      // RULE 4: Author NEVER narrates action or scenery (banned voyeur verbs)
      const BANNED_AUTHOR_VERBS = ['watched', 'observed', 'saw', 'looked on', 'gazed at', 'witnessed', 'noticed', 'perceived'];
      const bannedPattern = new RegExp('The Author\\s+(' + BANNED_AUTHOR_VERBS.join('|') + ')\\b', 'gi');
      const bannedMatches = sceneText.match(bannedPattern) || [];
      if (bannedMatches.length > 0) {
          errors.push({
              code: VALIDATION_ERRORS.POV_AUTHOR_NARRATES_ACTION,
              message: `Author uses banned voyeur verbs: ${bannedMatches.slice(0, 3).join(', ')}`
          });
      }

      // RULE 5: Frequency requirements
      if (isSceneOne && authorMentions < 6) {
          errors.push({
              code: VALIDATION_ERRORS.POV_SCENE1_FREQUENCY,
              message: `Scene 1 requires â‰¥6 Author mentions. Found: ${authorMentions}`
          });
      } else if (!isSceneOne && !isErotic && (authorMentions < 1 || authorMentions > 3)) {
          errors.push({
              code: VALIDATION_ERRORS.POV_LATER_FREQUENCY,
              message: `Later scenes require 1-3 Author mentions. Found: ${authorMentions}`
          });
      }

      // RULE 6: Erotic scenes = 0 Author mentions
      if (isErotic && authorMentions > 0) {
          errors.push({
              code: VALIDATION_ERRORS.POV_EROTIC_AUTHOR_PRESENT,
              message: `Erotic scenes must have 0 Author mentions. Found: ${authorMentions}`
          });
      }

      // RULE 7: Meta-awareness spike ~5% (check for excess)
      const metaAwarenessPatterns = [
          /\b(character|story|narrative|plot|author|reader|page|chapter)\b/gi,
          /\b(as if|somehow|knew|felt|sensed)\s+(that|the|this)\s+(story|tale|narrative)/gi
      ];
      let metaCount = 0;
      metaAwarenessPatterns.forEach(p => {
          const matches = sceneText.match(p);
          if (matches) metaCount += matches.length;
      });
      const wordCount = sceneText.split(/\s+/).length;
      const metaRatio = metaCount / wordCount;
      if (metaRatio > 0.08) { // ~8% threshold
          errors.push({
              code: VALIDATION_ERRORS.POV_META_AWARENESS_EXCESS,
              message: `Meta-awareness exceeds 5% threshold. Ratio: ${(metaRatio * 100).toFixed(1)}%`
          });
      }

      // RULE 8: God Mode â€” Author does NOT know Player exists
      if (isGodMode) {
          const playerAwarenessPatterns = [
              /\bThe Author\b.{0,50}\b(player|user|you|your)\b/gi,
              /\bThe Author\b.{0,50}\b(knew|sensed|felt)\b.{0,30}\b(was being|someone)\b/gi
          ];
          for (const pattern of playerAwarenessPatterns) {
              if (pattern.test(sceneText)) {
                  errors.push({
                      code: VALIDATION_ERRORS.POV_GODMODE_PLAYER_AWARENESS,
                      message: 'God Mode: Author must NOT know Player exists'
                  });
                  break;
              }
          }
      }

      const metrics = {
          authorMentions,
          isSceneOne,
          isErotic,
          isGodMode,
          hasValidOpener,
          hasValidCloser,
          wordCount
      };

      return { pass: errors.length === 0, errors, metrics };
  }

  /**
   * Get current validation state for Dev HUD
   * Runs all validators against current story state
   */
  function getValidationStatus() {
      const results = {};

      // DSP validation
      const dspEl = document.getElementById('synopsisText');
      if (dspEl && state.picks) {
          const dspResult = validateDSP(dspEl.textContent || '', {
              world: state.picks.world || 'Modern',
              genre: state.picks.genre || 'Billionaire',
              archetypeId: (state.archetype?.primary) || 'BEAUTIFUL_RUIN',
              tone: state.picks.tone || 'Earnest'
          });
          results.dsp = dspResult;
      }

      // POV validation (last generated scene)
      if (state.povMode === 'author5th' && window.StoryPagination) {
          const lastContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const lastScene = lastContent.slice(-2000);
          const povResult = validatePOV(lastScene, {
              sceneIndex: state.turnCount || 0,
              isErotic: ['Erotic', 'Dirty'].includes(state.intensity) && state.turnCount > 0,
              isGodMode: state.godModeActive || false
          });
          results.pov = povResult;
      }

      // Tone validation
      if (state.picks?.tone && window.StoryPagination) {
          const lastContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const lastScene = lastContent.slice(-2000);
          const toneResult = validateTone(lastScene, state.picks.tone);
          results.tone = toneResult;
      }

      // Erotic escalation validation
      if (['Erotic', 'Dirty'].includes(state.intensity) && window.StoryPagination) {
          const lastContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const lastScene = lastContent.slice(-2000);
          const eroticResult = validateEroticEscalation(lastScene, state.intensity);
          results.erotic = eroticResult;
      }

      // Title validation
      const titleEl = document.getElementById('storyTitle');
      if (titleEl && titleEl.textContent) {
          const titleResult = validateTitle(titleEl.textContent.trim(), state.picks?.tone);
          results.title = titleResult;
      }

      // Signal alignment validation
      if (titleEl && titleEl.textContent) {
          const currentTitle = titleEl.textContent.trim();
          const mockCoverPrompt = {
              promptText: 'emotion: ' + (state.coverEmotion || 'mystery'),
              emotion: state.coverEmotion || 'mystery'
          };
          const signalResult = validateSignalAlignment(currentTitle, mockCoverPrompt, {
              arousal: state.intensity || 'Naughty',
              tone: state.picks?.tone || 'Earnest',
              genre: state.picks?.genre || 'Romance'
          });
          results.signal = signalResult;
      }

      return results;
  }

  // Expose validators globally for Dev HUD access
  window.validateDSP = validateDSP;
  window.validatePOV = validatePOV;
  window.validateTone = validateTone;
  window.validateEroticEscalation = validateEroticEscalation;
  window.getValidationStatus = getValidationStatus;
  window.VALIDATION_ERRORS = VALIDATION_ERRORS;

  // ============================================================
  // NARRATIVE VOCABULARY BANS â€” POST-GENERATION ENFORCEMENT
  // ============================================================
  // System-internal terms that must NEVER appear in reader-facing text.
  // "The Author" is exempt ONLY in 5th-person (Fate POV) prose.
  // Archetype names influence structure/pacing/framing but are invisible
  // to readers â€” they must never surface in prose, dialogue, or synopsis.
  // ============================================================

  const VOCAB_BAN_PATTERNS = [
      // "The Author" â€” banned except in Fate POV meta blocks
      { id: 'AUTHOR_LEAK',          rx: /The Author\b/g,                                           fatePOVExempt: true },
      // Any X Warden compound (Heart Warden, Shadow Warden, Blood Warden, etc.)
      { id: 'WARDEN_COMPOUND',      rx: /(?:Heart|Shadow|Blood|\w+)\s+Warden\b/gi,                 fatePOVExempt: false },
      // Cover-composition archetype names leaked into prose
      { id: 'ARCHETYPE_THRESHOLD',  rx: /\bThreshold\b/g,                                          fatePOVExempt: false },
      { id: 'ARCHETYPE_EMBLEM',     rx: /\bEmblem\b/g,                                             fatePOVExempt: false },
      // Canonical 7-archetype display names
      { id: 'ARCHETYPE_OPEN_VEIN',  rx: /\bOpen Vein\b/gi,                                         fatePOVExempt: false },
      { id: 'ARCHETYPE_SPELLBINDER',rx: /\bSpellbinder\b/gi,                                       fatePOVExempt: false },
      { id: 'ARCHETYPE_ARMORED_FOX',rx: /\bArmored Fox\b/gi,                                       fatePOVExempt: false },
      { id: 'ARCHETYPE_DARK_VICE',  rx: /\bDark Vice\b/gi,                                         fatePOVExempt: false },
      { id: 'ARCHETYPE_BEAUTIFUL_RUIN', rx: /\bBeautiful Ruin\b/gi,                                fatePOVExempt: false },
      { id: 'ARCHETYPE_ETERNAL_FLAME',  rx: /\bEternal Flame\b/gi,                                 fatePOVExempt: false },
      // Archetype section titles â€” metadata only, never in prose
      { id: 'ARCHETYPE_STORYBEAU',   rx: /\bStorybeau\b/gi,                                        fatePOVExempt: false },
      { id: 'ARCHETYPE_STORYBELLE',  rx: /\bStorybelle\b/gi,                                       fatePOVExempt: false },
      { id: 'ARCHETYPE_STORYBOO',    rx: /\bStoryboo\b/gi,                                         fatePOVExempt: false }
  ];

  // Human-readable ban description per pattern (for negative-constraint injection)
  const VOCAB_BAN_LABELS = {
      AUTHOR_LEAK:            '"The Author" â€” meta-narrator term forbidden outside Fate POV',
      WARDEN_COMPOUND:        'X Warden compound â€” system-internal archetype name',
      ARCHETYPE_THRESHOLD:    '"Threshold" â€” internal cover-composition archetype',
      ARCHETYPE_EMBLEM:       '"Emblem" â€” internal cover-composition archetype',
      ARCHETYPE_OPEN_VEIN:    '"Open Vein" â€” internal character archetype',
      ARCHETYPE_SPELLBINDER:  '"Spellbinder" â€” internal character archetype',
      ARCHETYPE_ARMORED_FOX:  '"Armored Fox" â€” internal character archetype',
      ARCHETYPE_DARK_VICE:    '"Dark Vice" â€” internal character archetype',
      ARCHETYPE_BEAUTIFUL_RUIN: '"Beautiful Ruin" â€” internal character archetype',
      ARCHETYPE_ETERNAL_FLAME:  '"Eternal Flame" â€” internal character archetype',
      ARCHETYPE_STORYBEAU:      '"Storybeau" â€” LI category label, metadata only',
      ARCHETYPE_STORYBELLE:     '"Storybelle" â€” LI category label, metadata only',
      ARCHETYPE_STORYBOO:       '"Storyboo" â€” LI category label, metadata only'
  };

  /**
   * Scan text for vocabulary ban violations.
   * @param {string} text          - The generated text to check
   * @param {object} context       - { type: 'prose'|'synopsis'|'title'|'cover', isFatePOV: boolean }
   * @returns {{ clean: boolean, violations: Array<{id:string, matches:string[]}> }}
   */
  function scrubNarrativeVocabulary(text, context) {
      if (!text || typeof text !== 'string') return { clean: true, violations: [] };

      const violations = [];
      const isFatePOV = context.isFatePOV && context.type === 'prose';

      for (const ban of VOCAB_BAN_PATTERNS) {
          // "The Author" is allowed in Fate POV prose (5th-person mode)
          if (ban.fatePOVExempt && isFatePOV) continue;

          // Reset regex lastIndex (global flag)
          ban.rx.lastIndex = 0;
          const matches = text.match(ban.rx);
          if (matches && matches.length > 0) {
              violations.push({ id: ban.id, matches });
          }
      }

      return { clean: violations.length === 0, violations };
  }

  /**
   * Build a negative-constraint instruction string from violations.
   * Injected into the system prompt on regeneration.
   */
  function buildVocabBanConstraint(violations) {
      const lines = violations.map(v =>
          `- NEVER use ${VOCAB_BAN_LABELS[v.id] || v.id}. Found: "${v.matches.join('", "')}" â€” remove or rephrase.`
      );
      return `\n\nCRITICAL VOCABULARY BAN â€” the following terms are system-internal and MUST NOT appear in your output:\n${lines.join('\n')}\nRewrite any sentence that would contain these terms. They are invisible to the reader and must never surface in prose, dialogue, synopsis, or titles.\n`;
  }

  /**
   * Enforce vocabulary bans with one-shot regeneration.
   *
   * @param {string}   text          - generated text to check
   * @param {object}   context       - { type, isFatePOV }
   * @param {function} regenerateFn  - async (negativeConstraint: string) => string
   *                                   Called once on violation. Receives the negative-constraint
   *                                   string to append to the system prompt. Must return new text.
   * @returns {string} clean (or best-effort) text
   */
  async function enforceVocabularyBans(text, context, regenerateFn) {
      const result = scrubNarrativeVocabulary(text, context);
      if (result.clean) return text;

      console.warn('[VOCAB_BAN] Violations in ' + context.type + ':', result.violations);

      if (!regenerateFn) {
          console.error('[VOCAB_BAN] No regeneration function provided â€” returning dirty text');
          return text;
      }

      // Regenerate once with explicit negative constraint
      const constraint = buildVocabBanConstraint(result.violations);
      console.log('[VOCAB_BAN] Regenerating with negative constraint');
      const regenerated = await regenerateFn(constraint);

      // Re-check â€” if still dirty, log hard warning but return anyway
      const recheck = scrubNarrativeVocabulary(regenerated, context);
      if (!recheck.clean) {
          console.error('[VOCAB_BAN] Regeneration STILL violates bans:', recheck.violations.map(v => v.id));
      } else {
          console.log('[VOCAB_BAN] Regeneration passed vocabulary check');
      }

      return regenerated;
  }

  var state = window.state;

  // LATCH for Visualize Re-entrancy
  let _vizInFlight = false;

  // --- HELPERS ---
  function $(id){ return document.getElementById(id); }
  function toggle(id){ const el = document.getElementById(id); if(el) el.classList.toggle('hidden'); }
  function resetTurnSnapshotFlag(){ state._snapshotThisTurn = false; }
  function escapeHTML(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
  }

  // --- THEME & FONT HELPERS ---
  // Reader settings apply ONLY to story content, not the entire app UI
  window.setTheme = function(name) {
      const storyContent = document.getElementById('storyContent');
      if (!storyContent) return;
      storyContent.classList.remove('theme-sepia', 'theme-midnight', 'theme-print', 'theme-easy');
      if (name && name !== 'default') {
          storyContent.classList.add('theme-' + name);
      }
  };

  window.setFont = function(fontValue) {
      const storyContent = document.getElementById('storyContent');
      if (storyContent) {
          storyContent.style.setProperty('--font-story', fontValue);
      }
  };

  window.setFontSize = function(size) {
      const storyContent = document.getElementById('storyContent');
      if (storyContent) {
          storyContent.style.setProperty('--story-size', size + 'px');
      }
  };

  window.setGameIntensity = function(level) {
      // STORYTURN ASSERTION: Erotic/Dirty blocked on Tease
      const storyLength = (window.state.storyLength || 'tease').toLowerCase();
      if (storyLength === 'tease' && STORYTURN_CONFIG.teaseRules.paywalledArousal.includes(level)) {
          console.error(`[STORYTURN] ${level} intensity blocked on Tease. Upgrade required.`);
          window.showPaywall('upgrade_required');
          return;
      }

      // SUBSCRIPTION SHORT-CIRCUIT: Subscribers have full access
      if (window.state.subscribed) {
          window.state.intensity = level;
          updateIntensityUI();
          return;
      }
      // Non-subscribers: Check content restrictions
      const tempState = { ...window.state, intensity: level };
      if (!isStorypassAllowed(tempState)) {
          window.showPaywall('sub_only'); return;
      }
      if (level === 'Erotic' && window.state.access === 'free') { window.openEroticPreview(); return; }
      window.state.intensity = level;
      updateIntensityUI();
  };

  window.checkCustom = function(selectEl, inputId) {
      const input = document.getElementById(inputId);
      if (input) {
          input.classList.toggle('hidden', selectEl.value !== 'Custom');
      }
  };

  function syncPovDerivedFlags(){
      if(!window.state) return;
      const pov = (window.state.picks?.pov || '').toLowerCase();
      const is5th = /fifth|5th|author/.test(pov) || window.state.povMode === 'author5th';
      if(is5th){
          window.state.povMode = 'author5th';
          window.state.authorPresence = 'frequent';
          window.state.fateCardVoice = 'authorial';
      } else {
          window.state.povMode = 'normal';
          window.state.authorPresence = 'normal';
          window.state.fateCardVoice = 'neutral';
      }
  }

  // =========================
  // AUTH GATING FOR PERSISTENCE
  // =========================
  // Persistence is ONLY allowed when logged in.
  // Without login, app behaves stateless (no story/purchase restoration on reload).

  function isLoggedIn() {
      return !!state.isLoggedIn;
  }

  // Login function - sets persistence gate
  window.login = function() {
      state.isLoggedIn = true;
      localStorage.setItem('sb_logged_in', '1');
      // AUTH RESET: Fresh session on login
      performAuthReset();
      renderBurgerMenu();
      updateContinueButtons();
  };

  // Logout function - clears persistence gate and all persisted state
  window.logout = function() {
      state.isLoggedIn = false;
      localStorage.removeItem('sb_logged_in');
      // Clear all persisted story/purchase state
      clearAnonymousState();
      // AUTH RESET: Fresh session on logout
      performAuthReset();
      renderBurgerMenu();
      updateContinueButtons();
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTH RESET â€” Full story creation state reset on login/logout
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // After auth change, app must behave like a fresh session.
  // Resets: state.story, storyId, _synopsisMetadata, picks, intensity,
  // reader page index, cover + setting generation promises, all generation flags
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function performAuthReset() {
      console.log('[AUTH:RESET] Performing full story creation state reset');

      // Reset story state
      state.story = null;
      state.storyId = null;
      state._synopsisMetadata = null;
      state.storyHistory = [];
      state.storyEnded = false;
      state.storyLength = 'tease';
      state.storyOrigin = null;
      state.storyStage = null;
      state.intimacyInterrupted = { first_kiss: false, first_sex: false };
      state.turnCount = 0;

      // Reset Guided Fate selections
      state.picks = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', era: 'Medieval', pov: 'First' };
      state.intensity = 'Naughty';
      state.storypassEligible = undefined; // Reset - will be computed at story creation
      state.lenses = [];
      state.withheldCoreVariant = null;

      // Reset character state
      state.normalizedPlayerKernel = null;
      state.normalizedPartnerKernel = null;
      state.rawPlayerName = null;
      state.rawPartnerName = null;

      // Reset background story state
      state._backgroundStoryText = null;
      state._backgroundStoryTitle = null;
      state._backgroundStorySynopsis = null;

      // Reset title state
      state.immutableTitle = null;
      state.coverArchetype = null;

      // Reset cover Assembly object tracking (visual canon)
      state._coverAssemblyObjectShown = false;
      state._coverAssemblyObject = null;
      state._coverWorldKey = null;

      // Reset visual state
      state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} }, sceneBudgets: {}, visualizedScenes: {} };

      // Reset cover/story generation flags (via window interface)
      if (window.clearPreGeneratedCover) window.clearPreGeneratedCover();
      if (window.resetBackgroundStory) window.resetBackgroundStory();
      if (window.resetCoverGenerationFlags) window.resetCoverGenerationFlags();
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();
      // Reset story shape snapshot (forces "Begin Story" on new session)
      state._lastGeneratedShapeSnapshot = null;
      // Update Cover$ credit display (daily credits persist across sessions)
      if (window.updateCoverCreditDisplay) window.updateCoverCreditDisplay();

      // Reset reader page index
      if (typeof resetBookState === 'function') resetBookState();

      // Reset DSP state
      if (typeof resetDSPState === 'function') resetDSPState();

      // Reset UI elements
      const coverImg = document.getElementById('bookCoverImg');
      if (coverImg) coverImg.src = '';
      const storyTitle = document.getElementById('storyTitle');
      if (storyTitle) storyTitle.textContent = '';

      // Reset name inputs
      const playerInput = document.getElementById('playerNameInput');
      if (playerInput) playerInput.value = '';
      const partnerInput = document.getElementById('partnerNameInput');
      if (partnerInput) partnerInput.value = '';

      // Reset card UI to match default state
      const cardDefaults = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', intensity: 'Naughty', length: 'tease', pov: 'First' };
      Object.entries(cardDefaults).forEach(([grp, val]) => {
          document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
              c.classList.remove('selected', 'flipped');
          });
          const def = document.querySelector(`.sb-card[data-grp="${grp}"][data-val="${val}"]`);
          if (def) def.classList.add('selected', 'flipped');
      });

      console.log('[AUTH:RESET] Complete â€” app is now in fresh session state');
  }

  // Clear all persisted state for anonymous/testing mode
  function clearAnonymousState() {
      localStorage.removeItem('sb_saved_story');
      localStorage.removeItem('sb_story_in_idb');
      localStorage.removeItem('sb_current_story_id');
      localStorage.removeItem('sb_subscribed');
      localStorage.removeItem('sb_billing_status');
      localStorage.removeItem('sb_god_mode_owned');
      // Clear all story pass keys
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('sb_storypass_')) {
              keysToRemove.push(key);
          }
      }
      keysToRemove.forEach(k => localStorage.removeItem(k));
      // Clear IndexedDB story data
      if (window.indexedDB) {
          try {
              const request = indexedDB.deleteDatabase(STORY_DB_NAME);
              request.onerror = () => console.warn('Failed to clear IndexedDB');
          } catch (e) { /* ignore */ }
      }
  }

  // Render burger menu auth section
  function renderBurgerMenu() {
      const section = document.getElementById('menuAuthSection');
      if (!section) return;
      if (isLoggedIn()) {
          section.innerHTML = '<button class="small-btn" onclick="window.logout()">Logout</button>';
      } else {
          section.innerHTML = '<button class="small-btn" onclick="window.login()">Login</button>';
      }
  }

  // NAV HELPER
  function closeAllOverlays() {
      ['payModal', 'vizModal', 'menuOverlay', 'eroticPreviewModal', 'coupleConsentModal', 'coupleInvite', 'strangerModal', 'edgeCovenantModal', 'previewModal', 'gameQuillVetoModal'].forEach(id => {
          const el = document.getElementById(id);
          if(el) el.classList.add('hidden');
      });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NAVIGATION CONTRACT â€” STORYBOUND READER FLOW (AUTHORITATIVE)
  // TAG: storybound/navigation-contract-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 1 â€” CANONICAL STORY CREATION FLOW (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The authoritative forward navigation order for a new story is:
  //
  // 1. Shape Your Story
  // 2. Cover Display (single cover view, NOT gallery)
  // 3. Setting
  // 4. Story (Scene 1)
  //
  // This order must be preserved.
  //
  // Notes:
  // - The Cover Display is part of the main flow.
  // - The Cover Gallery is NOT part of the main flow.
  // - The Cover Display shows the current cover state
  //   (Sketch / Thumbnail / Final), if available.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 2 â€” RESTART / RESUME FLOW (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When a user resumes an existing story:
  //
  // 1. Show the Cover Display (single cover view)
  // 2. Then load the most recent Story scene
  //
  // This applies regardless of:
  // - cover completion state
  // - number of scenes written
  // - story length tier
  //
  // Rationale:
  // - The cover re-orients tone and promise.
  // - Every reading session begins at the book's cover.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 3 â€” BACK BUTTON CONTRACT (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The Back button must reverse the canonical flow
  // and must never route to side chambers by default.
  //
  // Back behavior by context:
  //
  // - From Story:
  //   â†’ Setting
  //
  // - From Setting:
  //   â†’ Cover Display (single view)
  //
  // - From Cover Display:
  //   â†’ Shape Your Story
  //
  // - From Shape Your Story:
  //   â†’ Exit / Mode Select (existing behavior)
  //
  // At no point may the Back button route to:
  // - Cover Gallery
  // - Cover regeneration views
  // - Any modal or optional artifact browser
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 4 â€” SIDE CHAMBERS (NON-PARENTAL)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The following are side chambers, not navigation parents:
  //
  // - Cover Gallery
  // - Fate Card detail views
  // - Visualizer previews
  // - Help / Settings modals
  //
  // Rules:
  // - Side chambers are entered only via explicit user action.
  // - Exiting a side chamber returns the user
  //   to the immediate prior context.
  // - Side chambers must never appear in Back history
  //   unless explicitly navigated to.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 5 â€” PRECEDENCE CLAUSE (FAILSAFE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If any conflict exists between:
  // - legacy navigation logic
  // - modal history
  // - inferred routing
  // - Back-button heuristics
  //
  // This Navigation Contract overrides them.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CANONICAL STATES â€” FIRST-CLASS NAVIGATION STATES (AUTHORITATIVE)
  // TAG: storybound/canonical-states-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 1 â€” CANONICAL STATES (ORDERED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. SHAPE_YOUR_STORY  (screen: 'setup')
  // 2. COVER_DISPLAY     (screen: 'game', _readerPage: 0)
  // 3. SETTING           (screen: 'game', _readerPage: 'setting')
  // 4. STORY_READER      (screen: 'game', _readerPage: >= 1)
  //
  // Notes:
  // - COVER_DISPLAY is a single-cover view, not a gallery.
  // - SETTING is a full page/state, not a modal or overlay.
  // - STORY_READER begins at Scene 1.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const CANONICAL_STATES = {
      SHAPE_YOUR_STORY: 'setup',
      COVER_DISPLAY: 'coverDisplay',
      SETTING: 'setting',
      STORY_READER: 'storyReader'
  };

  const CANONICAL_STATE_ORDER = [
      CANONICAL_STATES.SHAPE_YOUR_STORY,
      CANONICAL_STATES.COVER_DISPLAY,
      CANONICAL_STATES.SETTING,
      CANONICAL_STATES.STORY_READER
  ];

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 2 â€” COVER_DISPLAY STATE (DEFINITION)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Behavior:
  // - Renders the current story's primary cover only.
  // - If no cover exists, render a placeholder + CTA.
  // - Must not allow browsing alternate covers.
  // - Must not auto-open Cover Gallery.
  //
  // Rules:
  // - COVER_DISPLAY is part of the main flow.
  // - COVER_DISPLAY is NOT a modal.
  // - COVER_DISPLAY has a Back destination and a Forward destination.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 3 â€” SETTING STATE (RESTORATION)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Behavior:
  // - Displays world, location, and initial conditions.
  // - Occurs after COVER_DISPLAY and before STORY_READER.
  // - Is revisitable via Back navigation from STORY_READER.
  //
  // Rules:
  // - SETTING must not be collapsed into Shape or Story.
  // - SETTING must not be implemented as a modal.
  // - SETTING participates in Back-button reversal.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 4 â€” FORWARD NAVIGATION (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Canonical forward flow:
  //
  // SHAPE_YOUR_STORY
  // â†’ COVER_DISPLAY
  // â†’ SETTING
  // â†’ STORY_READER (Scene 1)
  //
  // This flow must be respected for:
  // - new stories
  // - regenerated stories
  // - restarted stories
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 5 â€” RESTART / RESUME FLOW (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When resuming an existing story:
  //
  // 1. Enter COVER_DISPLAY
  // 2. Then proceed to the most recent STORY_READER scene
  //
  // SETTING is skipped on resume unless explicitly navigated to.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 6 â€” BACK BUTTON INTEGRATION (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Back behavior must reverse the canonical state order:
  //
  // - From STORY_READER â†’ SETTING
  // - From SETTING â†’ COVER_DISPLAY
  // - From COVER_DISPLAY â†’ SHAPE_YOUR_STORY
  //
  // At no point may Back route to:
  // - Cover Gallery
  // - Any modal
  // - Any non-canonical state
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 7 â€” FAILURE PREVENTION CLAUSE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // "If a state does not exist as a first-class state,
  // it may not be used as a Back or Forward destination."
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // --- NAVIGATION STATE ---
  let _navHistory = [];
  let _currentScreenId = 'ageGate'; 

  function updateNavUI() {
      const backBtn = document.getElementById('globalBackBtn');
      const burger = document.getElementById('burgerBtn');

      if(backBtn) {
          const hidden = ['ageGate', 'tosGate', 'tierGate'].includes(_currentScreenId);
          if(hidden) backBtn.classList.add('hidden');
          else backBtn.classList.remove('hidden');
      }
      
      if(burger) {
          if(_currentScreenId === 'ageGate') burger.classList.add('hidden');
          else burger.classList.remove('hidden');
      }
  }

  function goBack() {
      // LINEAR READER NAVIGATION (book system disabled)
      if (_currentScreenId === 'game') {
          if (!USE_OPENING_BOOK) {
              // Simplified linear navigation: SCENE â†’ COVER GALLERY â†’ stay in reader
              if (_readerPage >= 1) {
                  // From any Scene â†’ open Cover Gallery Modal (NOT legacy cover view)
                  // User stays in reader context with working cover gallery
                  if (_gallerySelectedStage) {
                      // Focus on current primary or latest generated
                      _gallerySelectedStage = _primaryCoverStage || getCurrentCoverStage();
                  }
                  openCoverGalleryModal();
                  return;
              }
              // At Cover (page 0) â€” open cover gallery modal instead of exiting
              openCoverGalleryModal();
              return;
          } else {
              // BOOK SYSTEM (disabled â€” this branch won't run when USE_OPENING_BOOK = false)
              const bookCover = document.getElementById('bookCover');
              const isBookOpen = bookCover?.classList.contains('hinge-open') || _bookOpened;

              if (isBookOpen && _bookPageIndex > 0) {
                  if (typeof previousBookPage === 'function' && previousBookPage()) {
                      return;
                  }
              }

              if (isBookOpen && _bookPageIndex === 0) {
                  const bookCoverPage = document.getElementById('bookCoverPage');
                  const storyContent = document.getElementById('storyContent');
                  if (bookCover) {
                      bookCover.classList.remove('hinge-open', 'courtesy-peek');
                  }
                  if (bookCoverPage) {
                      bookCoverPage.classList.remove('hidden');
                  }
                  if (storyContent) {
                      storyContent.classList.add('hidden');
                  }
                  _bookOpened = false;
                  setBookPage(0);
                  return;
              }
          }
      }

      // modeSelect clears _navHistory â€” explicit back to tierGate
      if (_currentScreenId === 'modeSelect') {
          window.showScreen('tierGate', true);
          return;
      }

      if (_navHistory.length === 0) {
          if(typeof coupleCleanup === 'function' && state.mode === 'couple') coupleCleanup();
          window.showScreen('modeSelect');
          return;
      }
      const prev = _navHistory.pop();
      window.showScreen(prev, true);
  }

  window.showScreen = function(id, isBack = false){
      closeAllOverlays();
      // PASS 1 FIX: Clear any stuck toasts on screen change
      if (typeof clearToasts === 'function') clearToasts();

      // Capture previous screen for BACK-TO-CONFIG detection
      const previousScreen = _currentScreenId;

      // UX-2 FIX: Clean up fate visuals when leaving setup screen
      // GUARD: Skip cleanup if Guided Fate visuals are still active (will be torn down later)
      if (_currentScreenId === 'setup' && id !== 'setup') {
          if (!_guidedFateVisualsActive && typeof cleanupFateVisuals === 'function') cleanupFateVisuals();
      }

      // Hide corridor Continue button when leaving setup screen
      if (id !== 'setup') {
          const controlPlaneBtn = document.getElementById('continueButton');
          if (controlPlaneBtn) controlPlaneBtn.classList.remove('visible');
      }

      if(id === 'modeSelect') {
          _navHistory = [];
          // Update Solo subtitle based on permission gradient
          if (typeof updateSoloSubtitle === 'function') updateSoloSubtitle();
          // Reset mode cards so they start face-down each time
          if (window.resetModeCards) window.resetModeCards();
      } else if (!isBack && _currentScreenId && _currentScreenId !== id) {
         if(!['ageGate', 'tosGate', 'tierGate'].includes(_currentScreenId)) {
             _navHistory.push(_currentScreenId);
         }
      }

      document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));

      const target = document.getElementById(id);
      if(target) target.classList.remove('hidden');
      
      const app = document.getElementById('app');
      if (app && target) {
          if (app.contains(target)) app.classList.remove('hidden');
          else app.classList.add('hidden');
      }

      // CORRECTIVE PASS FIX 4: Do NOT scroll when entering game screen
      // The game screen uses a fixed book cover page overlay that handles its own viewport.
      // Scrolling to top during the loading transition causes a jarring jump.
      if (id !== 'game') {
          window.scrollTo(0,0);
      }
      _currentScreenId = id;
      updateNavUI();

      // Update DSP visibility based on screen (state-based, not scroll-based)
      if (typeof updateDSPVisibility === 'function') {
          updateDSPVisibility(id);
      }

      // Initialize fate hand system when entering setup screen
      if(id === 'setup') {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // BACK-TO-CONFIG RESET â€” Re-arm generation when navigating back
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // When user navigates back to Story Settings:
          // - Guided Fate cards become active again
          // - Prior story/cover is discarded (treated as new session)
          // - Clear "already generated" flags
          // - Do NOT auto-generate, just re-arm the system
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (isBack && previousScreen === 'game') {
              console.log('[BACK-TO-CONFIG] User navigated back to setup â€” re-arming generation system');

              // Clear prior story/cover assets
              state._backgroundStoryText = null;
              state._backgroundStoryTitle = null;
              state._backgroundStorySynopsis = null;
              state._synopsisMetadata = null;

              // Reset cover Assembly object tracking (treat as new story)
              state._coverAssemblyObjectShown = false;
              state._coverAssemblyObject = null;
              state._coverWorldKey = null;

              // Reset cover generation flags (re-arms for new cover)
              if (window.resetCoverGenerationFlags) window.resetCoverGenerationFlags();

              // Reset cover shape hash (allows regeneration with new selections)
              if (window.clearCoverShapeHash) window.clearCoverShapeHash();

              // Reset background story flags
              if (window.resetBackgroundStory) window.resetBackgroundStory();

              // Reset DSP state for fresh generation
              if (typeof resetDSPState === 'function') resetDSPState();

              // Clear cover image
              const coverImg = document.getElementById('bookCoverImg');
              if (coverImg) coverImg.src = '';

              // Clear title (will be regenerated)
              const storyTitle = document.getElementById('storyTitle');
              if (storyTitle) storyTitle.textContent = '';

              // Re-activate Guided Fate cards (they should be interactive again)
              // The initFateHandSystem call below will reinitialize them

              console.log('[BACK-TO-CONFIG] Complete â€” next Generate action will be treated as first-time');
          }

          initFateHandSystem();
          // Start ambient sparkles around the Guided Fate card
          if (typeof startAmbientCardSparkles === 'function') startAmbientCardSparkles();
          // Couple subhead: show ONLY when mode === 'couple', no other conditions
          const coupleSubhead = document.getElementById('coupleSubhead');
          if (coupleSubhead) coupleSubhead.classList.toggle('hidden', state.mode !== 'couple');
          // Show breadcrumb at 'shape' step
          if (window.updateBreadcrumb) window.updateBreadcrumb('shape');
          // Update Cover$ credit display
          if (window.updateCoverCreditDisplay) window.updateCoverCreditDisplay();
      } else if (id === 'game') {
          // Game screen breadcrumb is managed by Cover/Setting/Story views
          // Don't update here â€” let the view functions handle it
      } else {
          if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();
          // Stop fate card sparkle cycle when leaving game screen
          if (window.stopSparkleCycle) window.stopSparkleCycle();
          // Hide breadcrumb on non-story screens (modeSelect, tierGate, etc.)
          if (window.hideBreadcrumb) window.hideBreadcrumb();
      }
  };

  function initNavBindings() {
      const app = document.getElementById('app');
      if (app) {
          Array.from(app.children).forEach(el => {
              if (el.tagName === 'DIV') el.classList.add('screen');
          });
      }
      ['ageGate', 'tosGate', 'tierGate'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.classList.add('screen');
      });

      const backBtn = document.getElementById('globalBackBtn');
      if(backBtn && !backBtn.dataset.navBound) {
          backBtn.dataset.navBound = "true";
          backBtn.addEventListener('click', goBack);
      }
      
      // Global Locked Click Delegation
      // Allows preview buttons within locked cards to still function
      if (!document._lockedClickBound) {
          document._lockedClickBound = true;
          document.addEventListener('click', (e) => {
              // Allow preview buttons to work even in locked cards
              // Check both the target and all ancestors for .preview-btn
              const previewBtn = e.target.closest('.preview-btn');
              if (previewBtn) {
                  // Explicitly show preview and stop - don't let anything else handle this
                  e.stopPropagation();
                  const previewText = document.getElementById('previewText');
                  const previewModal = document.getElementById('previewModal');
                  if (previewText && previewModal && previewBtn.dataset.txt) {
                      previewText.textContent = previewBtn.dataset.txt;
                      previewModal.classList.remove('hidden');
                  }
                  return;
              }

              const lockedTarget = e.target.closest('.locked, .locked-style, .locked-input, .locked-tease, .locked-pass, [data-locked]');
              if (lockedTarget) {
                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();

                  window.openPaywall(lockedTarget.dataset.paywallMode || 'unlock');
              }
          }, true);
      } 

      document.addEventListener('keydown', (e) => {
          if (e.ctrlKey && e.shiftKey && (e.key === 'a' || e.key === 'A')) {
              const p = document.getElementById('auth-panel');
              if(p) p.classList.toggle('hidden');
          }
      });
  }

  // --- SAFETY & CONSENT ---
  // PASS 1 FIX: Toast system with proper auto-dismiss and anti-stacking
  let _toastTimer = null;

  function showToast(msg) {
      const t = document.getElementById('toast');
      if (!t) return;

      // Clear any existing toast timer to prevent stacking
      if (_toastTimer) {
          clearTimeout(_toastTimer);
          _toastTimer = null;
      }

      // Set content and show
      t.textContent = msg;
      t.classList.remove('hidden');

      // Reset animation by forcing reflow
      t.style.animation = 'none';
      void t.offsetWidth;
      t.style.animation = 'toastFadeInOut 3s forwards';

      // Explicit hide after animation completes (failsafe)
      _toastTimer = setTimeout(() => {
          t.classList.add('hidden');
          t.style.animation = 'none';
          _toastTimer = null;
      }, 3100);
  }

  // Clear any stuck toasts (call on state changes)
  function clearToasts() {
      const t = document.getElementById('toast');
      if (t) {
          t.classList.add('hidden');
          t.style.animation = 'none';
      }
      if (_toastTimer) {
          clearTimeout(_toastTimer);
          _toastTimer = null;
      }
  }

  function sanitizeUserIntent(action, dialogue) {
      const input = (action + " " + dialogue).toLowerCase();
      const nonConPatterns = [
          /\brape\b/i, /\b(non[-\s]?consensual|without consent)\b/i,
          /\bagainst (her|his|their) will\b/i, /\bforce\b/i
      ];
      
      if(nonConPatterns.some(rx => rx.test(input))) {
          const now = Date.now();
          if (now - (state.lastNonConPushAt || 0) > 15 * 60 * 1000) state.nonConPushCount = 0;
          state.nonConPushCount = (state.nonConPushCount || 0) + 1;
          state.lastNonConPushAt = now;

          const directive = "ABSOLUTE SAFETY RULE: User input implied non-consensual dynamics. 1. DO NOT depict the act. NO sexual violence. 2. REFRAME: Partner deflects safely OR shifts to explicit, enthusiastic consent negotiation.";
          return { safeAction: undefined, safeDialogue: undefined, flags: ["redirect_nonconsent"], directive };
      }
      return { safeAction: undefined, safeDialogue: undefined, flags: [], directive: "" };
  }

  function buildConsentDirectives() {
      let s = "SAFETY & CONSENT RULES: ABSOLUTELY NO depiction of explicit sexual violence or non-consensual sexual acts. ";
      if (!state.safety.nonConImplied) s += "NO implied non-consent. All dynamics must be clearly enthusiastic. ";
      else s += "Implied non-consent (CNC/Dubcon) is PERMITTED if contextually appropriate, but keep explicit assaults off-screen. ";
      if (!state.safety.violence) s += "MINIMIZE VIOLENCE. Focus on emotional conflict. ";
      if (state.safety.boundaries.length > 0) s += "HARD BOUNDARIES (NEVER VIOLATE): " + state.safety.boundaries.join(", ") + ". ";
      return s;
  }

  // --- ACCESS HELPERS ---
  // PASS 1 FIX: Canonical access resolver - ALL access checks must use this
  function resolveAccess() {
    // Read subscribed status from localStorage (source of truth)
    if (localStorage.getItem('sb_subscribed') === '1') {
        state.subscribed = true;
    }

    // Check billing validity
    const inGrace = (state.billingStatus === 'grace' && Date.now() < state.billingGraceUntil);
    const invalidSub = state.billingStatus === 'canceled' || (state.billingStatus === 'past_due' && !inGrace);

    // Determine access tier (priority order: sub > pass > free)
    if (state.subscribed && !invalidSub) {
        return 'sub';
    }

    if (state.mode === 'couple') {
        const roomAcc = state.roomAccess || 'free';
        return roomAcc;
    }

    if (state.storyId && hasStoryPass(state.storyId)) {
        return 'pass';
    }

    return 'free';
  }

  // PASS 1 FIX: Single function to sync state from canonical resolver
  function syncTierFromAccess() {
    // Resolve access from canonical source
    const resolvedAccess = resolveAccess();

    // Update state
    state.access = resolvedAccess;
    state.tier = (resolvedAccess === 'free') ? 'free' : 'paid';

    console.log('[ENTITLEMENT] syncTierFromAccess:', {
        access: state.access,
        tier: state.tier,
        subscribed: state.subscribed,
        storyId: state.storyId,
        hasPass: state.storyId ? hasStoryPass(state.storyId) : false
    });

    return resolvedAccess;
  }

  window.openPaywall = function(reason) {
      if(typeof window.showPaywall === 'function') {
          // Close Quill/Veto modal if open (prevents z-index stacking)
          const qvModal = document.getElementById('gameQuillVetoModal');
          if (qvModal && !qvModal.classList.contains('hidden')) {
              qvModal.classList.add('hidden');
          }
          // Respect explicit 'sub_only' from caller (e.g., Dirty/Soulmates cards)
          const mode = (reason === 'god' || reason === 'sub_only') ? reason : getPaywallMode();
          window.showPaywall(mode);
      }
  };

  function currentStoryWordCount(){
    // Get all content across all pages for accurate word count
    const allContent = StoryPagination.getAllContent();
    if (!allContent) return 0;
    // Strip HTML tags and count words
    const txt = allContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
    if(!txt) return 0;
    return txt.split(/\s+/).filter(Boolean).length;
  }

  function getSexAllowedAtWordCount() {
    if(state.godModeActive) return 0; 
    const target = state.storyTargetWords;
    switch(state.intensity){
        case "Clean":   return Infinity;
        case "Naughty": return Math.floor(target * 0.55);
        case "Erotic":  return Math.floor(target * 0.30);
        case "Dirty":   return Math.floor(target * 0.20);
        default: return Math.floor(target * 0.55);
    }
  }

  function maybeFlipConsummation(text){
     if(state.godModeActive || state.batedBreathActive || state.mode !== 'solo') return;
     if(state.storyStage !== 'pre-intimacy') return; 

     let flipped = false;
     const wc = currentStoryWordCount();
     if(wc >= getSexAllowedAtWordCount()) flipped = true;
     if(/(only you|forever with you|marry me|my wife|my husband)/i.test(text)) flipped = true;
     if(state.intensity === 'Dirty') flipped = true;

     if(flipped){
         state.storyStage = 'post-consummation';
         saveStorySnapshot();
     }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INTIMACY MILESTONE INTERRUPTION SYSTEM
  // Interrupts first_kiss and first_sex on FIRST attempt only (latch rule)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Detect if user input signals a kiss attempt
   * @param {string} action - User's action input
   * @param {string} dialogue - User's dialogue input
   * @returns {boolean}
   */
  function detectKissAttempt(action, dialogue) {
      const combined = `${action} ${dialogue}`.toLowerCase();
      const kissSignals = /\b(kiss|lean in|lips|mouth to|pull (her|him|them) close|faces inches|breath mingles|almost touching)\b/i;
      return kissSignals.test(combined);
  }

  /**
   * Detect if user input signals a sex/intimacy attempt
   * @param {string} action - User's action input
   * @param {string} dialogue - User's dialogue input
   * @returns {boolean}
   */
  function detectSexAttempt(action, dialogue) {
      const combined = `${action} ${dialogue}`.toLowerCase();
      const sexSignals = /\b(undress|take off|bed|make love|have sex|inside|push (her|him|them) down|straddle|between (her|his|their) legs|naked|clothes off)\b/i;
      return sexSignals.test(combined);
  }

  /**
   * Build interruption directive for story prompt
   * Returns empty string if no interruption needed (milestone already latched)
   * @param {string} action - User's action input
   * @param {string} dialogue - User's dialogue input
   * @returns {{ directive: string, milestone: string|null }}
   */
  function buildIntimacyInterruptionDirective(action, dialogue) {
      // Skip if both milestones already cleared
      if (state.intimacyInterrupted.first_kiss && state.intimacyInterrupted.first_sex) {
          return { directive: '', milestone: null };
      }

      // Check for sex attempt first (higher priority)
      if (!state.intimacyInterrupted.first_sex && detectSexAttempt(action, dialogue)) {
          return {
              directive: `INTIMACY INTERRUPT (first_sex): The characters clearly INTEND physical intimacy. Telegraph the approach â€” closeness, tension, breath, almost-contact. But INTERRUPT the act before completion. Use a grounded cause:
- Internal: "Not ready," "This feels wrong," sudden hesitation, emotional wall rises
- External: Phone rings, alarm sounds, someone knocks, unexpected news arrives
The interruption must land with narrative weight. Maintain unresolved sexual tension. Do NOT consummate.`,
              milestone: 'first_sex'
          };
      }

      // Check for kiss attempt
      if (!state.intimacyInterrupted.first_kiss && detectKissAttempt(action, dialogue)) {
          return {
              directive: `INTIMACY INTERRUPT (first_kiss): The characters clearly INTEND to kiss. Telegraph the moment â€” faces close, breath held, eyes locked. But INTERRUPT before lips meet. Use a grounded cause:
- Internal: One pulls back, "I can't," fear flashes in eyes
- External: Sudden noise, someone approaches, phone buzzes
The near-miss must ache. Maintain romantic tension. Do NOT complete the kiss.`,
              milestone: 'first_kiss'
          };
      }

      return { directive: '', milestone: null };
  }

  /**
   * Latch an intimacy milestone after interruption occurs
   * @param {string} milestone - 'first_kiss' or 'first_sex'
   */
  function latchIntimacyMilestone(milestone) {
      if (milestone && state.intimacyInterrupted.hasOwnProperty(milestone)) {
          state.intimacyInterrupted[milestone] = true;
          console.log(`[INTIMACY:LATCH] ${milestone} milestone latched â€” future attempts will not interrupt`);
          saveStorySnapshot();
      }
  }

  function checkStoryEndCaps() {
      const wc = currentStoryWordCount();
      const turns = state.turnCount || 0;
      const len = state.storyLength || 'tease';

      if (len === 'tease' && (wc > 7000 || turns > 28) && !state.storyEnded) {
          state.storyEnded = true;
          document.getElementById('submitBtn').disabled = true;
          const div = document.createElement('div');
          div.className = 'box';
          div.style.textAlign = 'center';
          div.style.border = '1px solid var(--gold)';
          div.innerHTML = `<p style="font-style:italic; color:var(--gold)">The moment hangs, unresolved.</p>`;
          // Append ending to current page
          StoryPagination.appendToCurrentPage(div.outerHTML);
          // Show continuation fork after delay for user to read ending
          setTimeout(() => {
              showContinuationFork();
          }, 3000);
          return;
      }

      if (len === 'fling' && !state.storyEnded) {
          const overCap = (wc > 15000 || turns > 60);
          if (state.flingClimaxDone && state.flingConsequenceShown && overCap) {
              state.storyEnded = true;
              document.getElementById('submitBtn').disabled = true;
              renderFlingEnd();
              // Show continuation fork after delay for user to read ending
              setTimeout(() => {
                  showContinuationFork();
              }, 3000);
          }
      }
  }

  function getQuillReady() {
      if(state.godModeActive) return true; 
      return currentStoryWordCount() >= (state.quill.nextReadyAtWords || 0);
  }

  function computeNextCooldownWords() {
      if(state.godModeActive) return 0;
      // Base 1200, +600 per use, cap at 3600
      const base = 1200;
      const perUse = 600;
      const cap = 3600;
      return Math.min(cap, base + (state.quill.uses * perUse));
  }

  function checkAuthorChairUnlock() {
      const totalWords = Number(localStorage.getItem('sb_global_word_count') || 0);
      return totalWords >= 250000;
  }

  // Veto patterns that indicate scene/event demands (rejected)
  const VETO_SCENE_PATTERNS = [
      /^(make|have|let|force|ensure|require|demand|insist|want|need)\s+(them|him|her|it|the|a)\b/i,
      /^bring\s+(them|him|her)\s+to/i,
      /^start\s+a\s+(scene|chapter|sequence)/i,
      /^introduce\s+(a|the|new)\b/i,
      /^add\s+(a|the|new)\s+(scene|character|kink|setting)/i
  ];

  async function parseVetoInput(rawText) {
      if(!rawText) return { exclusions:[], corrections:[], ambientMods:[], rejected:[] };

      // RUNTIME NORMALIZATION: All veto input flows through ChatGPT normalization layer
      // CRITICAL: Never store raw text - always use normalized kernel
      const vetoNorm = await callNormalizationLayer({
          axis: 'veto',
          user_text: rawText,
          context_signals: state.picks?.world || []
      });
      // Extract kernel - prefer archetype/burden format, then normalized_text, NEVER raw
      const kernel = vetoNorm.archetype || vetoNorm.burden || vetoNorm.normalized_text || vetoNorm.canonical_instruction;
      const canonicalized = kernel || 'excluded element';

      const lines = canonicalized.split('\n');
      const result = { exclusions:[], corrections:[], ambientMods:[], rejected:[] };

      lines.forEach(line => {
          const l = line.trim();
          if(!l) return;
          const lower = l.toLowerCase();

          // Check if this is a scene/event demand (reject it)
          const isSceneDemand = VETO_SCENE_PATTERNS.some(p => p.test(l));
          if(isSceneDemand) {
              result.rejected.push(l);
              return;
          }

          // HARD EXCLUSIONS: ban:, no , never
          if(lower.startsWith('ban:') || lower.startsWith('ban ')) {
              result.exclusions.push(l.replace(/^ban[:\s]+/i, '').trim());
          } else if(lower.startsWith('no ') || lower.startsWith('never ')) {
              result.exclusions.push(l);
          }
          // EDITORIAL CORRECTIONS: rename:, replace:, call
          else if(lower.startsWith('rename:') || lower.startsWith('replace:')) {
              result.corrections.push(l);
          } else if(lower.includes('->') || lower.includes('â†’')) {
              result.corrections.push(l);
          } else if(lower.startsWith('call ') && lower.includes(' not ')) {
              result.corrections.push(l);
          }
          // AMBIENT MODIFIERS: add more, increase, keep, make it, let the
          else if(/^(add\s+more|increase|decrease|keep|make\s+it|let\s+the|more\s+)/i.test(l)) {
              result.ambientMods.push(l);
          }
          // Default: treat as exclusion
          else {
              result.exclusions.push(l);
          }
      });
      return result;
  }

  async function applyVetoFromInput() {
      const el = document.getElementById('vetoInput');
      if(!el) return;
      const parsed = await parseVetoInput(el.value);

      // Show rejection toast if any lines were rejected
      if(parsed.rejected.length > 0) {
          showToast("Veto removes elements or applies ambient constraints. It can't be used to make events happen.");
      }

      // Map to existing state.veto structure
      state.veto.bannedWords = parsed.exclusions;
      state.veto.excluded = parsed.exclusions;
      state.veto.corrections = parsed.corrections;
      state.veto.ambientMods = parsed.ambientMods;
  }

  // Legacy compatibility wrapper
  async function parseStoryControls(rawText) {
      const vetoResult = await parseVetoInput(rawText);
      return {
          veto: {
              bannedWords: vetoResult.exclusions,
              bannedNames: [],
              excluded: vetoResult.exclusions,
              tone: vetoResult.ambientMods
          },
          quillDraft: ""
      };
  }

  async function applyVetoFromControls() {
      await applyVetoFromInput();
  }

  // --- FATE HAND SYSTEM (Replaces pill system) ---
  // Suggestion pools for rotating placeholders and fate draws
  const FATE_SUGGESTIONS = {
      ancestry: [
          // Intermixed ~50% fantasy, ~50% real-world
          "Fae", "Celtic", "Half-elf", "Nordic", "Starborn", "Andean",
          "Clockwork", "Levantine", "Night Court", "Korean", "Shadow-born", "Persian",
          "Mer-touched", "Japanese", "Dragon-blooded", "West African", "Storm-caller", "Greek",
          "Dusk Walker", "Mediterranean", "Moon-kissed", "Slavic", "Fire-veined", "Indian",
          "Void-touched", "Pacific Islander", "Iron-blooded", "Southeast Asian", "Sylvan", "Chinese",
          "Dream-walker", "Afro-Caribbean", "Changeling", "Latin American", "Forgotten royal line", "Middle Eastern"
      ],
      world: [
          // Generic fallback (kept for compatibility)
          "Ancient empire ruins", "Clockwork city", "Floating islands", "Underground kingdom",
          "Endless library", "Frozen wasteland", "Desert oasis", "Living forest",
          "Crystal caverns", "Storm-wracked coast", "Sunken civilization", "Sky citadel",
          "Volcanic archipelago", "Haunted frontier", "Merchant crossroads", "Border fortress",
          "Hidden valley", "Plague quarantine", "Orbital station", "Dream realm"
      ],
      veto: [
          "No humiliation", "No betrayal", 'No "M\'Lady"', "No tattoos", "No scars",
          "No cheating", "No amnesia", "No pregnancy", "No ghosts", "No death",
          "No love triangles", "No supernatural", "No time skips", "No flowery language",
          "No second person", "No violence", "No crying scenes", "No miscommunication trope"
      ],
      quill: [
          "Public Bathhouse Setting", "Make it bigger", "Make it a Musical",
          "More tension", "Confession scene", "Jealousy beat", "Stolen glance",
          "Only one bed", "Enemies to lovers", "Forced proximity", "Vulnerability scene",
          "Take them somewhere private", "Build tension slowly", "Unexpected interruption",
          "Moonlit garden", "Charged silence", "Near miss moment", "Secret revealed"
      ],
      visualize: [
          "more muscular", "more elegant", "brighter lighting", "darker mood",
          "cuter", "softer facial features", "strong jawline", "hourglass figure",
          "athletic build", "blonde hair", "dark hair", "natural expression",
          "cinematic lighting", "high detail", "dreamlike", "painterly",
          "leading-actor looks", "movie poster style", "anime style", "photo-realistic"
      ],
      archetypeModifier: [
          "Romantic", "Cloistered", "Rogue", "Dangerous", "Guardian",
          "Sovereign", "Enchanting", "Devoted", "Strategist"
      ]
  };

  // PASS 9D: World-specific custom setting suggestions
  const WORLD_CUSTOM_SUGGESTIONS = {
      Modern: [
          "Manhattan penthouse", "Small coastal town", "College campus", "Underground club scene",
          "Tech startup hub", "Old Hollywood glamour", "Fashion district", "Hidden supernatural society",
          "Political dynasty estate", "Art gallery scene", "Beach resort town", "Urban rooftop gardens"
      ],
      Historical: [
          "Regency England ballroom", "Victorian London fog", "Renaissance Florence court", "Ancient Rome villa",
          "Medieval castle keep", "Roaring Twenties speakeasy", "Gilded Age mansion", "Tudor court intrigue",
          "Ming Dynasty palace", "French Revolution Paris", "Viking settlement", "Ottoman Empire harem"
      ],
      Fantasy: [
          "Enchanted forest glade", "Floating sky citadel", "Dragon-ruled kingdom", "Fae court realm",
          "Underwater mer-kingdom", "Crystal cave sanctuary", "Witch's hidden academy", "Cursed castle ruins",
          "Living forest heart", "Elemental nexus", "Shadow realm border", "Phoenix empire capital"
      ],
      SciFi: [
          "Space station colony", "Terraformed Mars city", "Generation ship deck", "Cyberpunk megacity",
          "Alien embassy quarter", "Virtual reality nexus", "Clone facility lab", "Time loop station",
          "Quantum research hub", "First contact zone", "Post-singularity haven", "Asteroid mining outpost"
      ],
      Dystopia: [
          "Biometric monitoring hub", "Mandatory pleasure pavilion", "Human valuation exchange", "Doctrinal enforcement hall",
          "Breeding compatibility center", "Consent tribunal archive", "Identity revision clinic", "Sensor-blind alley",
          "Underground feeling house", "Asset depreciation ward", "Accusation records vault", "Memory continuity shrine"
      ],
      PostApocalyptic: [
          "Ruined city overgrowth", "Survivor settlement", "Irradiated wasteland edge", "Flooded coastal ruins",
          "Bunker community", "Reclaimed factory", "Nomad caravan camp", "Plague quarantine zone",
          "Fallen skyscraper shelter", "Clean water spring", "Tech scavenger den", "Nature-reclaimed highway"
      ]
  };

  let fateHandInitialized = false;
  let placeholderAnimations = {};

  // Tease mode check
  function isTeaseMode() {
      return state.storyLength === 'tease' && state.access === 'free';
  }

  // Get random suggestion from pool
  function getRandomSuggestion(type, exclude = []) {
      const pool = FATE_SUGGESTIONS[type] || [];
      const available = pool.filter(s => !exclude.includes(s));
      if (available.length === 0) return pool[Math.floor(Math.random() * pool.length)];
      return available[Math.floor(Math.random() * available.length)];
  }

  // Initialize rotating placeholder for a field
  function initRotatingPlaceholder(inputId, type) {
      const input = document.getElementById(inputId);
      const placeholder = document.querySelector(`.rotating-placeholder[data-for="${inputId}"]`);
      if (!input || !placeholder) return;

      const suggestions = FATE_SUGGESTIONS[type] || [];
      if (suggestions.length === 0) return;

      // Build scrolling content (duplicate for seamless loop)
      const buildContent = () => {
          let html = '<span class="rotating-placeholder-inner">';
          // Double the suggestions for seamless scroll
          const doubled = [...suggestions, ...suggestions];
          doubled.forEach((s, i) => {
              const glowClass = Math.random() < 0.1 ? ' glow' : '';
              html += `<span class="suggestion${glowClass}">${s}</span>`;
              if (i < doubled.length - 1) html += '<span class="separator">â€¢</span>';
          });
          html += '</span>';
          return html;
      };

      placeholder.innerHTML = buildContent();

      // Show/hide placeholder based on input content
      const updateVisibility = () => {
          if (input.value.trim()) {
              placeholder.classList.add('hidden');
          } else {
              placeholder.classList.remove('hidden');
          }
      };

      // Pause animation on focus
      input.addEventListener('focus', () => {
          const inner = placeholder.querySelector('.rotating-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'paused';
      });
      input.addEventListener('blur', () => {
          const inner = placeholder.querySelector('.rotating-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'running';
          updateVisibility();
      });
      input.addEventListener('input', updateVisibility);

      // PASS 9F: Enter commits text, not clears it
      // Scrolling examples do NOT overwrite user-entered text on Enter
      input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              e.preventDefault();
              // Just blur to commit - do NOT clear the value
              input.blur();
          }
      });

      updateVisibility();

      // Random glow effect
      setInterval(() => {
          const spans = placeholder.querySelectorAll('.suggestion');
          spans.forEach(s => s.classList.remove('glow'));
          if (spans.length > 0 && Math.random() < 0.3) {
              const randomSpan = spans[Math.floor(Math.random() * spans.length)];
              randomSpan.classList.add('glow');
              setTimeout(() => randomSpan.classList.remove('glow'), 2000);
          }
      }, 4000);
  }

  // Expose for corridor mount (identity row is unmounted when initFateHandSystem runs)
  window.initRotatingPlaceholder = initRotatingPlaceholder;

  // Handle fate hand click - reveal card and populate field
  function handleFateHandClick(hand) {
      const targetId = hand.dataset.target;
      const type = hand.dataset.type;
      const input = document.getElementById(targetId);
      const treeCard = document.querySelector(`.fate-tree-card[data-target="${targetId}"]`);

      if (!input || !treeCard) return;

      // TEASE MODE: Quill fate hand triggers paywall
      if (type === 'quill' && isTeaseMode()) {
          if (window.openPaywall) window.openPaywall('unlock');
          return;
      }

      // Get all cards in the hand
      const cards = hand.querySelectorAll('.fate-hand-card');
      const centerCard = cards[2]; // Middle card

      // Flip center card
      centerCard.classList.add('flipping');

      // Fade out other cards
      cards.forEach((card, i) => {
          if (i !== 2) card.classList.add('fading');
      });

      // After flip completes
      setTimeout(() => {
          // Hide the hand, show the tree card
          hand.style.display = 'none';
          treeCard.classList.remove('hidden');

          // Populate the field
          const suggestion = getRandomSuggestion(type);
          if (input.tagName === 'TEXTAREA') {
              input.value = input.value ? input.value + '\n' + suggestion : suggestion;
          } else {
              if (!input.value.trim()) {
                  input.value = suggestion;
              }
          }

          // Hide placeholder
          const placeholder = document.querySelector(`.rotating-placeholder[data-for="${targetId}"]`);
          if (placeholder) placeholder.classList.add('hidden');

          // Initialize leaf state (static, no animation until clicked)
          const leaf = treeCard.querySelector('.falling-leaf');
          if (leaf) {
              leaf.dataset.leafClicks = '0';
          }
      }, 450);
  }

  // Handle tree card click - invoke fate again (two-stage leaf animation)
  function handleTreeCardClick(treeCard) {
      const targetId = treeCard.dataset.target;
      const hand = document.querySelector(`.fate-hand[data-target="${targetId}"]`);
      const input = document.getElementById(targetId);
      const leaf = treeCard.querySelector('.falling-leaf');

      if (!input || !hand) return;

      const type = hand.dataset.type;

      // TEASE MODE: Quill tree card triggers paywall
      if (type === 'quill' && isTeaseMode()) {
          if (window.openPaywall) window.openPaywall('unlock');
          return;
      }

      // Two-stage leaf animation state machine
      if (leaf) {
          const clicks = parseInt(leaf.dataset.leafClicks || '0', 10);

          if (clicks === 0) {
              // First click: animate from mid-air to ground
              leaf.classList.add('leaf-fall-1');
              leaf.dataset.leafClicks = '1';
          } else if (clicks === 1) {
              // Second click: reset to lower branch, then fall to mid-air stop
              leaf.classList.remove('leaf-fall-1');
              leaf.classList.add('leaf-reset-2');
              void leaf.offsetWidth; // Force reflow

              // Brief pause at reset position, then animate
              setTimeout(() => {
                  leaf.classList.remove('leaf-reset-2');
                  leaf.classList.add('leaf-fall-2');
                  leaf.dataset.leafClicks = '2';

                  // After animation completes, set final resting state
                  setTimeout(() => {
                      leaf.classList.remove('leaf-fall-2');
                      leaf.classList.add('leaf-final');
                  }, 1000);
              }, 50);
          }
          // clicks >= 2: ignore further clicks
      }

      // Populate with new suggestion
      const suggestion = getRandomSuggestion(type, [input.value]);
      if (input.tagName === 'TEXTAREA') {
          input.value = input.value ? input.value + '\n' + suggestion : suggestion;
      } else {
          input.value = suggestion;
      }
  }

  // Initialize the entire fate hand system
  function initFateHandSystem() {
      if (fateHandInitialized) return;
      fateHandInitialized = true;

      // Initialize rotating placeholders
      initRotatingPlaceholder('ancestryInputPlayer', 'ancestry');
      initRotatingPlaceholder('ancestryInputLI', 'ancestry');
      initRotatingPlaceholder('vetoInput', 'veto');
      initRotatingPlaceholder('quillInput', 'quill');
      // Game modal rotating placeholders
      initRotatingPlaceholder('gameVetoInput', 'veto');
      initRotatingPlaceholder('gameQuillInput', 'quill');
      // Visualize modifier suggestions
      initRotatingPlaceholder('vizModifierInput', 'visualize');

      // Initialize destiny flip cards (Quill/Veto)
      initDestinyFlipCards();

      // Initialize character destiny cards (name + ancestry per character)
      initCharacterDestinyCards();
  }

  function initCharacterDestinyCards() {
      // Character destiny cards - fill name + ancestry for each character
      // ISOLATED: Never triggers story start, loading, or global fate state
      document.querySelectorAll('.character-destiny-card').forEach(card => {
          card.addEventListener('click', (e) => {
              // CRITICAL: Stop propagation to prevent any parent/global handlers
              e.stopPropagation();

              const character = card.dataset.character; // 'player' or 'loveInterest'

              // Flip the card (visual only - NEVER toggles back)
              if (!card.classList.contains('flipped')) {
                  card.classList.add('flipped');
              }

              // PASS 9F: Populate fields based on character type
              if (character === 'player') {
                  // Get player gender to select appropriate name list
                  const playerGender = document.getElementById('playerGender')?.value || 'Female';
                  const nameList = getNameListForGender(playerGender);
                  const randomName = nameList[Math.floor(Math.random() * nameList.length)];
                  const randomAncestry = getRandomSuggestion('ancestry');

                  // Fill name
                  const nameInput = document.getElementById('playerNameInput');
                  if (nameInput) {
                      nameInput.value = randomName;
                      nameInput.dispatchEvent(new Event('blur', { bubbles: true }));
                  }

                  // Fill ancestry
                  const ancestryInput = document.getElementById('ancestryInputPlayer');
                  if (ancestryInput) {
                      ancestryInput.value = randomAncestry;
                      const placeholder = document.querySelector('.rotating-placeholder[data-for="ancestryInputPlayer"]');
                      if (placeholder) placeholder.classList.add('hidden');
                  }

                  // Age field removed
              } else if (character === 'loveInterest') {
                  // Get love interest gender to select appropriate name list
                  const liGender = document.getElementById('loveInterestGender')?.value || 'Male';
                  const nameList = getNameListForGender(liGender);
                  const randomName = nameList[Math.floor(Math.random() * nameList.length)];
                  const randomAncestry = getRandomSuggestion('ancestry');

                  // Fill name
                  const nameInput = document.getElementById('partnerNameInput');
                  if (nameInput) {
                      nameInput.value = randomName;
                      nameInput.dispatchEvent(new Event('blur', { bubbles: true }));
                  }

                  // Fill ancestry
                  const ancestryInput = document.getElementById('ancestryInputLI');
                  if (ancestryInput) {
                      ancestryInput.value = randomAncestry;
                      const placeholder = document.querySelector('.rotating-placeholder[data-for="ancestryInputLI"]');
                      if (placeholder) placeholder.classList.add('hidden');
                  }

                  // Age field removed
              }

              // Character destiny cards ONLY populate fields
              // They NEVER trigger story start, loading, or navigation
          });
      });
  }

  // Helper to get appropriate name list based on gender
  function getNameListForGender(gender) {
      const g = (gender || '').toLowerCase();
      if (g === 'female') return FATE_FEMALE_NAMES;
      if (g === 'male') return FATE_MALE_NAMES;
      // Non-Binary or Custom: randomly pick from either list
      return Math.random() < 0.5 ? FATE_FEMALE_NAMES : FATE_MALE_NAMES;
  }

  function initDestinyFlipCards() {
      // Destiny flip cards (Quill/Veto) - flip in place + insert random suggestion
      document.querySelectorAll('.destiny-flip-card').forEach(flipCard => {
          flipCard.addEventListener('click', () => {
              const targetId = flipCard.dataset.target;
              const type = flipCard.dataset.type;
              const input = document.getElementById(targetId);

              // Flip the card
              flipCard.classList.toggle('flipped');

              // Insert random suggestion from the appropriate pool
              if (input && type) {
                  const suggestion = getRandomSuggestion(type);
                  if (input.tagName === 'TEXTAREA') {
                      // For textareas (Quill/Veto), append on new line
                      input.value = input.value ? input.value + '\n' + suggestion : suggestion;
                  } else {
                      // For inputs, replace
                      input.value = suggestion;
                  }
                  // Hide placeholder
                  const placeholder = document.querySelector(`.rotating-placeholder[data-for="${targetId}"]`);
                  if (placeholder) placeholder.classList.add('hidden');
              }
          });
      });
  }

  function updateQuillUI() {
      const btn = document.getElementById('btnCommitQuill'); // May not exist (removed from UI)
      const status = document.getElementById('quillStatus');
      const godToggle = document.getElementById('godModeToggle');
      const quillBox = document.getElementById('quillBox');
      if(!status) return;

      if(state.mode === 'solo') {
          if(godToggle) godToggle.classList.remove('hidden');
          const chk = document.getElementById('godModeCheck');
          if(chk) {
              chk.checked = state.godModeActive;
              chk.disabled = state.godModeActive;
              if(state.godModeActive) {
                  const lbl = document.getElementById('godModeLabel');
                  if(lbl) { lbl.innerHTML = "GOD MODE ACTIVE"; lbl.style.color = "var(--hot)"; }
              }
          }
      } else {
          if(godToggle) godToggle.classList.add('hidden');
      }

      const ready = getQuillReady();
      const wc = currentStoryWordCount();
      const needed = state.quill.nextReadyAtWords;

      // Quill unlocks with: subscription, story pass, or god mode
      const quillUnlocked = state.subscribed || state.godModeActive || (state.storyId && hasStoryPass(state.storyId));

      if (!quillUnlocked) {
          // Quill is paywalled
          status.textContent = "Quill: Locked";
          status.style.color = "var(--gold)";
          if(quillBox) {
              quillBox.classList.add('locked-input');
              // CANONICAL: Use isStorypassAllowed() for correct paywall mode
              quillBox.onclick = () => window.showPaywall(getPaywallMode());
          }
          if(btn) btn.disabled = true;
          // PLAQUE REGIME: No opacity mutation â€” CSS handles disabled state
      } else if(ready) {
          status.textContent = state.authorChairActive ? "ğŸª‘ Quill: Poised" : "Quill: Poised";
          status.style.color = "var(--pink)";
          if(btn) {
              btn.disabled = false;
              btn.classList.remove('quill-btn-spent');
              btn.classList.add('quill-btn-ready');
              btn.textContent = state.godModeActive ? "Commit Quill (God Mode)" : "Commit Quill";
          }
          if(quillBox) {
              quillBox.classList.remove('locked-input');
              quillBox.onclick = null;
          }
      } else {
          const remain = Math.max(0, needed - wc);
          status.textContent = `Quill: Spent (${remain} words to recharge)`;
          status.style.color = "var(--gold)";
          // Don't lock for cooldown - just disable button
          if(quillBox) {
              quillBox.classList.remove('locked-input');
              quillBox.onclick = null;
          }
          if(btn) {
              btn.disabled = true;
              btn.classList.remove('quill-btn-ready');
              btn.classList.add('quill-btn-spent');
          }
      }
  }
  
  function updateBatedBreathState(){
      state.batedBreathActive = (state.storyOrigin === 'couple' && !state.player2Joined && !state.inviteRevoked);
      const el = document.getElementById('batedBreathIndicator');
      if(el) el.classList.toggle('hidden', !state.batedBreathActive);
  }

  function getBatedBreathDirective() {
      if (!state.batedBreathActive) return "";
      return `\nBATED BREATH STATE ACTIVE: The true love is absent. Tone: Longing, fidelity, bittersweet desire.`;
  }
  
  function filterFateCardsForBatedBreath(cards) {
      if (!state.batedBreathActive) return cards;
      return cards.map(c => {
          if (/(fall in love|replace|consummate)/i.test(c.action)) {
              return { ...c, action: "You feel the sharp ache of their absence.", dialogue: "(Silence)" };
          }
          return c;
      });
  }

  // --- BILLING HELPERS ---
  function computeBillingStatusNow() {
      if (state.subscribed) {
          if (state.billingStatus !== 'active') {
              state.billingStatus = 'active';
              state.billingGraceUntil = 0;
              state.billingLastError = '';
              // AUTH GATE: Only persist to storage when logged in
              if (isLoggedIn()) localStorage.setItem('sb_billing_status', 'active');
          }
          return;
      }
      if (state.billingStatus === 'grace' && Date.now() > state.billingGraceUntil) {
          endBillingGrace();
      }
  }

  function startBillingGrace(msg, hours = 48) {
      state.billingStatus = 'grace';
      state.billingGraceUntil = Date.now() + (hours * 3600 * 1000);
      state.billingLastError = msg;
      // AUTH GATE: Only persist to storage when logged in
      if (isLoggedIn()) {
          localStorage.setItem('sb_billing_status', state.billingStatus);
          localStorage.setItem('sb_billing_grace_until', state.billingGraceUntil);
      }
      if(typeof applyAccessLocks === 'function') applyAccessLocks();
  }

  function endBillingGrace() {
      state.billingStatus = 'past_due';
      // AUTH GATE: Only persist to storage when logged in
      if (isLoggedIn()) localStorage.setItem('sb_billing_status', 'past_due');
      if(typeof applyAccessLocks === 'function') applyAccessLocks();
  }

  function renderBillingBanner() {
      let banner = document.getElementById('billingBanner');
      if (!banner) {
          const game = document.getElementById('game');
          if(game) {
              banner = document.createElement('div');
              banner.id = 'billingBanner';
              banner.style.cssText = "background:rgba(50,0,0,0.9); border-bottom:1px solid var(--pink); color:#ffcccc; padding:12px; font-size:0.9em; text-align:center; margin-bottom:15px; display:none; border-radius:4px;";
              game.prepend(banner);
          }
      }
      if (!banner) return;

      const subOnlyStory = ['affair', 'soulmates'].includes(state.storyLength);
      if (!subOnlyStory) {
          banner.style.display = 'none';
          return;
      }

      if (state.billingStatus === 'grace') {
          banner.innerHTML = `<strong>Payment Issue:</strong> Youâ€™re in a grace period.`;
          banner.style.display = 'block';
      } else if (state.billingStatus === 'past_due' || state.billingStatus === 'canceled') {
          banner.innerHTML = `Subscription inactive. <button onclick="window.showPaywall('sub_only')" style="margin-left:10px; background:var(--pink); color:black;">Resume the Affair</button>`;
          banner.style.display = 'block';
      } else {
          banner.style.display = 'none';
      }
  }

  // --- VISUAL HELPERS ---
  async function ensureVisualBible(textContext) {
      // Guard against null/undefined - initialize safe defaults
      if (!state.visual) {
          state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} } };
      }
      if (!state.visual.bible) {
          state.visual.bible = { style: "", setting: "", characters: {} };
      }
      if (!state.visual.bible.characters || typeof state.visual.bible.characters !== 'object') {
          state.visual.bible.characters = {};
      }
      // Check if bible is already populated
      if (state.visual.bible.style && Object.keys(state.visual.bible.characters).length > 0) return;
      
      const genre = state?.picks?.genre || 'Billionaire';
      const vbWorld = state?.picks?.world || 'Modern';
      const vbEra = state?.picks?.world === 'Historical' ? (state?.picks?.era || 'Medieval') : null;
      const visualPowerRole = resolvePowerRole(vbWorld, vbEra, genre);
      const sys = `You are a Visual Director. Extract consistent visual anchors into STRICT JSON with this structure:
{
  "style": "visual style description",
  "setting": "location/environment description",
  "characters": {
    "CharacterName": {
      "face": "detailed facial features (eyes, skin tone, expression style)",
      "hair": "color, length, style",
      "clothing": "current outfit description",
      "build": "body type/physique"
    }
  }
}
Extract details for ALL named characters. Be specific about face, hair, clothing, and build.`;

      try {
          const raw = await Promise.race([
              callChat([{role:'system', content: sys}, {role:'user', content: `Genre: ${visualPowerRole}. Extract visual anchors from: ${textContext.slice(-2000)}`}]),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Bible timeout")), 15000))
          ]);
          const jsonMatch = raw.match(/\{[\s\S]*\}/);
          if (jsonMatch) state.visual.bible = JSON.parse(jsonMatch[0]);
      } catch(e) { console.warn("Bible build failed (silent)", e); }
  }

  function buildVisualAnchorsText() {
      const b = state.visual.bible;
      if (!b || !b.style) return "";
      let txt = `VISUAL CONTINUITY: STYLE: ${b.style} SETTING: ${b.setting} `;

      // If locked, include specific character details for face/hair/clothing persistence
      if (state.visual.locked) {
          txt += "CHARACTER LOCK ACTIVE - MAINTAIN EXACT APPEARANCE: ";
          if (b.characters && typeof b.characters === 'object') {
              Object.entries(b.characters).forEach(([name, details]) => {
                  if (details && typeof details === 'object') {
                      txt += `${name}: `;
                      if (details.face) txt += `FACE: ${details.face}; `;
                      if (details.hair) txt += `HAIR: ${details.hair}; `;
                      if (details.clothing) txt += `CLOTHING: ${details.clothing}; `;
                      if (details.build) txt += `BUILD: ${details.build}; `;
                  }
              });
          }
          txt += "DO NOT CHANGE CHARACTER APPEARANCE. ";
      }
      return txt;
  }

  let _inputGuardsBound = false;
  function bindFreeInputGuards(){
      if(_inputGuardsBound) return;
      _inputGuardsBound = true;
      const blockIfFree = (e) => {
          if(state.access === 'free' && state.mode !== 'couple') {
              e.preventDefault();
              e.stopPropagation();
              return false;
          }
      };
      ['actionInput', 'dialogueInput'].forEach(id => {
          const el = document.getElementById(id);
          if(el) {
              el.addEventListener('beforeinput', blockIfFree, { passive: false });
              el.addEventListener('paste', blockIfFree, { passive: false });
              el.addEventListener('drop', blockIfFree, { passive: false });
              // Selection aura on focus
              el.addEventListener('focus', () => {
                  if (typeof applySelectionAura === 'function') applySelectionAura(el);
              });
              el.addEventListener('blur', () => {
                  if (typeof removeSelectionAura === 'function') removeSelectionAura(el);
              });
          }
      });

      // Fate Resolution Glow â€” brief visual pulse on every in-story Fate card click
      document.addEventListener('click', function(e) {
          const card = e.target.closest('.fate-card');
          if (!card || !card.closest('#cardMount')) return;
          if (card.classList.contains('locked')) return;
          if (window.state && window.state.fateCommitted) return;

          // Card pulse (replayable â€” remove + reflow + add)
          card.classList.remove('fate-resolve-pulse');
          void card.offsetWidth;
          card.classList.add('fate-resolve-pulse');
          setTimeout(() => card.classList.remove('fate-resolve-pulse'), 400);

          // Input glow at text-injection time (~600ms matches fatecards.js apply delay)
          setTimeout(() => {
              ['actionInput', 'dialogueInput'].forEach(id => {
                  const el = document.getElementById(id);
                  if (!el) return;
                  el.classList.remove('fate-resolve-glow');
                  void el.offsetWidth;
                  el.classList.add('fate-resolve-glow');
                  setTimeout(() => el.classList.remove('fate-resolve-glow'), 400);
              });
          }, 600);
      });
  }

  // FIX: Added paywallMode parameter to support sub_only for Dirty intensity
  function setPaywallClickGuard(el, enabled, paywallMode = 'unlock', paywallSource = null){
    if(!el) return;
    if (!el.dataset.paywallBound) {
        el.dataset.paywallBound = "true";
        el.addEventListener('click', (e) => {
            if (el.dataset.paywallActive === "true") {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                // Use element's stored paywall mode and source
                const mode = el.dataset.paywallMode || 'unlock';
                const source = el.dataset.paywallSource || null;
                // Pass as object if source exists, otherwise string for backward compat
                if (source) {
                    window.showPaywall({ mode: mode, source: source });
                } else {
                    window.showPaywall(mode);
                }
            }
        }, { capture: true });
    }
    el.dataset.paywallActive = enabled ? "true" : "false";
    el.dataset.paywallMode = paywallMode;
    if (paywallSource) {
        el.dataset.paywallSource = paywallSource;
    } else {
        el.removeAttribute('data-paywall-source');
    }
  }

  function applyTierUI(){
      computeBillingStatusNow();
      renderBillingBanner();
      syncTierFromAccess();
      bindFreeInputGuards();

      const paid = (state.tier === 'paid');
      const isFree = (state.access === 'free');
      const couple = (state.mode === 'couple');
      
      const subOnlyStory = ['affair', 'soulmates'].includes(state.storyLength);
      const subActive = (state.access === 'sub');
      const inGrace = (state.billingStatus === 'grace' && Date.now() < state.billingGraceUntil);
      const billingLock = subOnlyStory && !(subActive || inGrace);
      const shouldLock = !couple && (billingLock || isFree);

      ['actionInput', 'dialogueInput'].forEach(id => {
          const el = document.getElementById(id);
          if(el) {
              el.disabled = false;
              el.readOnly = shouldLock;
          }
      });

      const quillCtrl = document.getElementById('quillInput');
      if(quillCtrl) {
          quillCtrl.disabled = false;
          quillCtrl.readOnly = !paid;
      }

      // Determine paywall mode from story metadata (persisted, immutable per-story)
      const lockPaywallMode = getPaywallMode();

      ['quillBox', 'actionWrapper', 'dialogueWrapper'].forEach(id => {
        const wrap = document.getElementById(id);
        if(wrap) {
            if (shouldLock) {
                 wrap.classList.add('locked-input');
                 setPaywallClickGuard(wrap, true, lockPaywallMode);
            } else {
                 wrap.classList.remove('locked-input');
                 setPaywallClickGuard(wrap, false);
            }
        }
      });

      const submitBtn = document.getElementById('submitBtn');
      if (submitBtn) {
          submitBtn.disabled = false;
          if (billingLock && !couple) {
              submitBtn.textContent = "Resume Affair to Continue";
              setPaywallClickGuard(submitBtn, true, lockPaywallMode);
          } else {
              submitBtn.textContent = "Submit Turn";
              setPaywallClickGuard(submitBtn, false);
          }
      }

      // Save button follows paywall rules (uses story metadata for mode)
      const saveBtn = document.getElementById('saveBtn');
      if(saveBtn) {
          if(couple || paid) saveBtn.classList.remove('locked-style');
          else saveBtn.classList.add('locked-style');
          setPaywallClickGuard(saveBtn, !(couple || paid), lockPaywallMode);
      }

      // Quill & Veto button is ALWAYS unlocked (even in Tease)
      const controlsBtn = document.getElementById('gameControlsBtn');
      if(controlsBtn) {
          controlsBtn.classList.remove('locked-style');
          setPaywallClickGuard(controlsBtn, false);
      }

      if (!couple) {
          applyLengthLocks();
          applyIntensityLocks();
          applyStyleLocks();
      }
  }

  function applyAccessLocks(){ applyTierUI(); }

  // FIX #4: Expose for post-render tier rehydration
  window.applyAccessLocks = applyAccessLocks;
  window.applyTierUI = applyTierUI;

  // PASS 1 FIX: Length locks with strict enforcement
  function applyLengthLocks(){
    // Always resolve access first
    syncTierFromAccess();

    const section = document.getElementById('lengthSection');
    if(section) section.classList.toggle('hidden', state.turnCount > 0);

    const cards = document.querySelectorAll('#lengthGrid .sb-card[data-grp="length"]');

    console.log('[ENTITLEMENT] applyLengthLocks:', {
        access: state.access,
        currentStoryLength: state.storyLength,
        cardsFound: cards.length
    });

    cards.forEach(card => {
      const val = card.dataset.val;
      let locked = true;  // Default: locked
      let hidden = false;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENTITLEMENT RULES FOR STORY LENGTH CARDS:
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // - free: only tease unlocked
      // - pass ($3): fling unlocked (NOT affair, NOT soulmates)
      // - sub ($6): fling, affair, soulmates ALL unlocked
      // SOULMATES: Subscription-only ($6) â€” NO StoryPass option
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      if (state.access === 'free' && val === 'tease') {
          locked = false;
      } else if (val === 'soulmates') {
          // SOULMATES: Subscription-only â€” locked unless subscriber
          locked = (state.access !== 'sub');
      } else if (state.access === 'pass') {
          // CRITICAL: Pass ONLY unlocks Fling
          if (val === 'fling') locked = false;
          // affair stays locked = true
      } else if (state.access === 'sub') {
          // Sub unlocks fling, affair, soulmates
          if (['fling', 'affair', 'soulmates'].includes(val)) locked = false;
      }

      // Hide tease for paid users
      if (state.access !== 'free' && val === 'tease') {
          locked = true;
          hidden = true;
      }

      // Apply classes
      card.classList.toggle('locked', locked);
      card.style.display = hidden ? 'none' : '';

      // CRITICAL FIX: Remove data-locked attribute when unlocked (CSS targets [data-locked])
      if (locked) {
          // Keep or set data-locked attribute for CSS styling
          if (!card.dataset.locked) {
              card.dataset.locked = (val === 'fling') ? 'pass' : 'sub';
          }
      } else {
          // Remove attribute so CSS [data-locked] selector doesn't apply
          card.removeAttribute('data-locked');
      }

      // Set paywall mode based on story LENGTH requirements (not content eligibility)
      // Fling/Affair = StoryPass eligible, Soulmates = Subscribe required
      const paywallMode = (val === 'soulmates') ? 'sub_only' : 'unlock';
      setPaywallClickGuard(card, locked, paywallMode);

      // Selection state - toggle both selected and flipped
      const isSelected = val === state.storyLength;
      card.classList.toggle('selected', isSelected);
      card.classList.toggle('flipped', isSelected);

      console.log('[ENTITLEMENT] Card:', val, 'locked:', locked, 'hidden:', hidden);
    });

    // ENFORCEMENT: If pass user has affair or soulmates selected, downgrade
    // (Soulmates is subscription-only, Affair requires subscription)
    // NOTE: storypassEligible is computed at story creation and persists - no runtime flag needed
    if (state.access === 'pass' && ['affair', 'soulmates'].includes(state.storyLength)) {
        console.log('[ENTITLEMENT] Downgrading story length from', state.storyLength, 'to fling');
        state.storyLength = 'fling';
    }

    // Auto-select fling if pass tier and current selection is tease (now hidden)
    if (state.access === 'pass' && state.storyLength === 'tease') {
        state.storyLength = 'fling';
    }

    bindLengthHandlers();
  }

  // REMOVED: Separate length click handlers - now using unified handler
  // Length cards are handled by the single unified card handler in initSelectionCardSystem()
  function bindLengthHandlers(){
      // No-op: click handling moved to unified handler
  }

  function applyIntensityLocks(){
      syncTierFromAccess();
      const access = state.access;
      // DEV LOGGING: arousal gating decision
      console.log('[DEV:IntensityGate] access:', access, '| intensity:', state.intensity, '| subscribed:', state.subscribed);
      const setupCards = document.querySelectorAll('#intensityGrid .sb-card');
      const gameBtns = document.querySelectorAll('#gameIntensity button');

      const updateLock = (el, level, isCard) => {
          let locked = false;
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // INTENSITY LOCKING RULES:
          // - Erotic: Locked for free users (requires tease/preview)
          // - Dirty: Subscription-only ($6) â€” locked for ALL non-subscribers
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (access === 'free' && level === 'Erotic') locked = true;
          // DIRTY: Subscription-only â€” locked on BOTH Setup and Reader for non-subscribers
          if (level === 'Dirty' && access !== 'sub') locked = true;

          el.classList.toggle('locked', locked);
          // CRITICAL FIX: Remove preset locked-tease/locked-pass classes when unlocked
          if (!locked) {
              el.classList.remove('locked-tease', 'locked-pass');
              // BUGFIX: Remove data-locked attribute so CSS [data-locked] selector
              // and global click handler no longer treat this as locked
              el.removeAttribute('data-locked');
          } else {
              // Ensure data-locked is set for CSS styling when locked
              if (!el.dataset.locked) {
                  el.dataset.locked = (level === 'Dirty') ? 'sub' : 'tease';
              }
          }
          if(locked) el.classList.remove(isCard ? 'selected' : 'active');
          // Use canonical isStorypassAllowed() for paywall mode
          const tempState = { ...state, intensity: level };
          const paywallMode = isStorypassAllowed(tempState) ? 'unlock' : 'sub_only';
          // ğŸ”´ DIRTY HARD RULE: Pass source='dirty_intensity' for Dirty cards/buttons
          const paywallSource = (level === 'Dirty') ? 'dirty_intensity' : null;
          setPaywallClickGuard(el, locked, paywallMode, paywallSource);
      };

      setupCards.forEach(c => updateLock(c, c.dataset.val, true));
      gameBtns.forEach(b => updateLock(b, b.innerText.trim(), false));

      // FALLBACK: Downgrade forbidden intensities for non-subscribers
      // - Dirty: Subscription-only, downgrade to Erotic (or Naughty if also forbidden)
      // - Erotic: Free users must preview first, downgrade to Naughty
      // NOTE: storypassEligible is computed at story creation and persists - no runtime flag needed
      if (state.intensity === 'Dirty' && access !== 'sub') {
          console.log('[ENTITLEMENT] Downgrading intensity from Dirty to Naughty (subscription required)');
          state.intensity = 'Naughty';
      }
      if (state.intensity === 'Erotic' && access === 'free') state.intensity = 'Naughty';
      updateIntensityUI();
  }

  function applyStyleLocks() {
      if (state.mode === 'couple') return;
      const paid = (state.tier === 'paid');
      const cards = document.querySelectorAll('.sb-card[data-grp="style"]');
      cards.forEach(card => {
          const raw = card.dataset.val || '';
          const v = raw.toLowerCase().trim();
          let locked = !paid && v !== 'breathless';
          card.classList.toggle('locked', locked);
          // CRITICAL FIX: Remove data-locked attribute when unlocked
          if (locked) {
              if (!card.dataset.locked) card.dataset.locked = 'true';
          } else {
              card.removeAttribute('data-locked');
          }
          setPaywallClickGuard(card, locked);
      });
  }

  function updateIntensityUI(){
      const setCard = (c) => {
          const isSelected = c.dataset.val === state.intensity;
          c.classList.toggle('selected', isSelected);
          c.classList.toggle('flipped', isSelected);
      };
      const setGame = (b) => b.classList.toggle('active', b.innerText.trim() === state.intensity);
      document.querySelectorAll('#intensityGrid .sb-card').forEach(setCard);
      document.querySelectorAll('#gameIntensity button').forEach(setGame);
  }

  // REMOVED: Separate intensity card handlers - now using unified handler
  // Intensity cards are handled by the single unified card handler in initSelectionCardSystem()
  function wireIntensityHandlers(){
      // Game buttons still need handlers (they are not .sb-card elements)
      document.querySelectorAll('#gameIntensity button').forEach(btn => btn.onclick = (e) => {
          const level = btn.innerText.trim();
          // SUBSCRIPTION SHORT-CIRCUIT: Subscribers have full access
          if (state.subscribed) {
              state.intensity = level;
              state.picks.intensity = level;
              updateIntensityUI();
              return;
          }
          // Non-subscribers: Check content restrictions
          const tempState = { ...state, intensity: level };
          if (!isStorypassAllowed(tempState)) {
              // ğŸ”´ DIRTY HARD RULE: Pass source='dirty_intensity' for Dirty button
              const source = (level === 'Dirty') ? 'dirty_intensity' : null;
              window.showPaywall({ mode: 'sub_only', source: source });
              return;
          }
          if(level === 'Erotic' && state.access === 'free'){ window.openEroticPreview(); return; }
          state.intensity = level;
          state.picks.intensity = level;
          updateIntensityUI();
      });
  }

  window.openEroticPreview = function(){
      const pText = document.getElementById('eroticPreviewText');
      if(pText) pText.innerText = EROTIC_PREVIEW_TEXT;

      // Toggle StoryPass vs Subscribe button based on story metadata (persisted, immutable per-story)
      const storypassBtn = document.getElementById('eroticPreviewStorypassBtn');
      const subBtn = document.getElementById('eroticPreviewSubBtn');
      const storypassAllowed = getPaywallMode() === 'unlock';

      if (storypassBtn) storypassBtn.classList.toggle('hidden', !storypassAllowed);
      if (subBtn) subBtn.classList.toggle('hidden', storypassAllowed);

      document.getElementById('eroticPreviewModal')?.classList.remove('hidden');
  };

  window.showPaywall = function(modeOrOptions){
    const pm = document.getElementById('payModal');
    if(!pm) return;

    // Close Quill/Veto modal if open (prevents z-index stacking)
    const qvModal = document.getElementById('gameQuillVetoModal');
    if (qvModal && !qvModal.classList.contains('hidden')) {
        qvModal.classList.add('hidden');
    }

    // Support both string mode and object { mode, source }
    let mode, source;
    if (typeof modeOrOptions === 'object' && modeOrOptions !== null) {
        mode = modeOrOptions.mode || 'unlock';
        source = modeOrOptions.source || null;
    } else {
        mode = modeOrOptions;
        source = null;
    }

    // Normalize legacy 'sub' to canonical 'sub_only'
    if (mode === 'sub') {
        mode = 'sub_only';
    }

    // Guard: defer paywall until story eligibility is resolved
    if (state.storypassEligible === undefined && state.storyId) {
        setTimeout(() => showPaywall(mode), 0);
        return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SUBSCRIPTION-ONLY CONTEXTS â€” Use persisted story eligibility
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Uses getPaywallMode() which checks persisted storypassEligible (not downgraded state)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (mode !== 'god' && mode !== 'sub_only' && getPaywallMode() === 'sub_only') {
        console.log('[PAYWALL] StoryPass excluded by story metadata â€” Subscribe-only');
        mode = 'sub_only';
    }

    // SUBSCRIPTION SHORT-CIRCUIT: Subscribers should never see paywall
    // (except for God Mode which is a separate $20 purchase)
    if (state.subscribed && mode !== 'god') {
        console.warn('[PAYWALL] showPaywall called for subscriber â€” this should not happen');
        return; // Silently ignore â€” subscriber has full access
    }

    // Cancel any running Fate ceremony â€” paywall interrupts it completely
    if (_fateRunning) {
        _fateOverridden = true;
        if (typeof cleanupFateVisuals === 'function') cleanupFateVisuals();
        // Also stop fatecards emanations and sparkle cycle
        if (window.stopAllEmanations) window.stopAllEmanations();
        if (window.stopSparkleCycle) window.stopSparkleCycle();
        state._paywallCancelledCeremony = true;
    }

    if(document.getElementById('tierGate') && !document.getElementById('tierGate').classList.contains('hidden')) state.purchaseContext = 'tierGate';
    else if(document.getElementById('setup') && !document.getElementById('setup').classList.contains('hidden')) state.purchaseContext = 'setup';
    else if(document.getElementById('game') && !document.getElementById('game').classList.contains('hidden')) state.purchaseContext = 'game';
    else state.purchaseContext = null;

    // Track sub-view context for cover/setting navigation on cancel
    const coverView = document.getElementById('coverViewButtons');
    const settingView = document.getElementById('settingView');
    if (settingView && !settingView.classList.contains('hidden')) {
        state._paywallSubContext = 'setting';
    } else if (coverView && !coverView.classList.contains('hidden')) {
        state._paywallSubContext = 'cover';
    } else {
        state._paywallSubContext = null;
    }

    const gm = document.getElementById('godModePay');
    const sp = document.getElementById('standardPay');

    if(mode === 'god') {
        if(gm) gm.classList.remove('hidden');
        if(sp) sp.classList.add('hidden');
    } else {
        if(gm) gm.classList.add('hidden');
        if(sp) sp.classList.remove('hidden');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STORYPASS STATE: HIDE when excluded by registry (STORYPASS_EXCLUSIONS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const hasPassNow = state.storyId && hasStoryPass(state.storyId);
    const optUnlock = document.getElementById('optUnlock');
    const disabledNotice = document.getElementById('storypassDisabledNotice');

    if (optUnlock) {
        // ROOT RULE: StoryPass hidden if caller passes 'sub_only', else check eligibility
        const storypassAllowed = (mode !== 'sub_only') && (getPaywallMode() === 'unlock');
        const hideStoryPass = !storypassAllowed || state.subscribed || hasPassNow;

        optUnlock.classList.toggle('hidden', hideStoryPass);
        optUnlock.classList.remove('storypass-disabled');
        if (disabledNotice) disabledNotice.classList.add('hidden');

        if (!storypassAllowed) {
            console.log('[PAYWALL] StoryPass hidden (storypassEligible:', state.storypassEligible, ')');
        }
    }

    // Disable Say/Do inputs while paywall is visible
    const _actInput = document.getElementById('actionInput');
    const _diaInput = document.getElementById('dialogueInput');
    if (_actInput) _actInput.disabled = true;
    if (_diaInput) _diaInput.disabled = true;

    pm.classList.remove('hidden');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DIAGNOSTIC: #optUnlock visibility check (NO BEHAVIOR CHANGE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const _diagOptUnlock = document.getElementById('optUnlock');
    if (_diagOptUnlock) {
        const hasHiddenClass = _diagOptUnlock.classList.contains('hidden');
        const isRendered = _diagOptUnlock.offsetParent !== null;
        console.log('[DIAG:STORYPASS] showPaywall() complete:', {
            mode,
            'optUnlock.hidden': hasHiddenClass,
            'optUnlock.offsetParent!==null': isRendered,
            'VISIBLE': !hasHiddenClass && isRendered
        });

        // Check again after DOM settles
        setTimeout(() => {
            const settled = document.getElementById('optUnlock');
            if (settled) {
                const settledHidden = settled.classList.contains('hidden');
                const settledRendered = settled.offsetParent !== null;
                console.log('[DIAG:STORYPASS] After DOM settle (setTimeout 0):', {
                    mode,
                    'optUnlock.hidden': settledHidden,
                    'optUnlock.offsetParent!==null': settledRendered,
                    'VISIBLE': !settledHidden && settledRendered
                });
            }
        }, 0);
    }
  };

  // Re-enable inputs when paywall is dismissed without purchase
  window.onPaywallDismiss = function() {
    const actInput = document.getElementById('actionInput');
    const diaInput = document.getElementById('dialogueInput');
    if (actInput) actInput.disabled = false;
    if (diaInput) diaInput.disabled = false;
    state._paywallCancelledCeremony = false;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANCEL NAVIGATION â€” Return to previous valid screen
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // From setting â†’ back to cover (hide setting view, show cover view)
    // From cover â†’ stay on cover (no navigation needed)
    // Never leave user on blank/empty state
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (state._paywallSubContext === 'setting') {
        // Hide setting view, return to cover view
        const settingView = document.getElementById('settingView');
        const coverViewButtons = document.getElementById('coverViewButtons');
        const bookCoverPage = document.getElementById('bookCoverPage');
        if (settingView) settingView.classList.add('hidden');
        if (coverViewButtons) coverViewButtons.classList.remove('hidden');
        if (bookCoverPage) bookCoverPage.classList.remove('hidden');
        if (window.updateBreadcrumb) window.updateBreadcrumb('cover');
        console.log('[PAYWALL:CANCEL] Returned to Cover View from Setting');
    } else if (state._paywallSubContext === 'cover') {
        // Ensure cover view elements are visible (safety check)
        const coverViewButtons = document.getElementById('coverViewButtons');
        const bookCoverPage = document.getElementById('bookCoverPage');
        if (coverViewButtons) coverViewButtons.classList.remove('hidden');
        if (bookCoverPage) bookCoverPage.classList.remove('hidden');
        console.log('[PAYWALL:CANCEL] Stayed on Cover View');
    }
    // Clear sub-context after handling
    state._paywallSubContext = null;
  };

  /**
   * VALIDATION GUARD: Paywall routing integrity check
   * Ensures StoryPass is never USABLE for Dirty or Soulmates
   * StoryPass ($3) unlocks Clean, Naughty, and Erotic
   * Returns { valid: true } or { valid: false, error: string }
   */
  function validatePaywallRouting() {
      const optUnlock = document.getElementById('optUnlock');
      const payModal = document.getElementById('payModal');

      // Only validate when paywall is visible
      if (!payModal || payModal.classList.contains('hidden')) {
          return { valid: true, skipped: true };
      }

      // StoryPass is USABLE if visible AND not disabled (Dirty shows disabled, not hidden)
      const storyPassUsable = optUnlock &&
          !optUnlock.classList.contains('hidden') &&
          !optUnlock.classList.contains('storypass-disabled');

      // CANONICAL VALIDATION: StoryPass must NEVER be USABLE in forbidden contexts
      // Uses isStorypassAllowed() as single source of truth
      if (storyPassUsable && !isStorypassAllowed()) {
          const reason = state.intensity === 'Dirty' ? 'Dirty intensity' :
                         state.storyLength === 'soulmates' ? 'Soulmates length' : 'forbidden context';
          console.error(`[PAYWALL VALIDATION] HARD FAIL: StoryPass usable for ${reason}`);
          return {
              valid: false,
              error: state.intensity === 'Dirty' ? VALIDATION_ERRORS.STORYPASS_DIRTY_LEAK :
                     VALIDATION_ERRORS.STORYPASS_SOULMATES_LEAK,
              context: { intensity: state.intensity, storyLength: state.storyLength }
          };
      }

      return { valid: true };
  }

  // Expose for DevHUD
  window.validatePaywallRouting = validatePaywallRouting;

  // PASS 1 FIX: Refactored completePurchase with canonical access resolution
  function completePurchase() {
      // Clear any stuck toasts first
      clearToasts();

      const pm = document.getElementById('payModal');
      if (pm) pm.classList.add('hidden');

      const purchaseType = state.lastPurchaseType;
      const previousAccess = state.access;

      console.log('[ENTITLEMENT] completePurchase START:', {
          purchaseType,
          previousAccess,
          storyLength: state.storyLength,
          storyId: state.storyId
      });

      // Persist subscription if this was a subscription purchase
      if (state.pendingUpgradeToAffair || purchaseType === 'sub') {
          state.subscribed = true;
          // AUTH GATE: Only persist to storage when logged in
          if (isLoggedIn()) {
              localStorage.setItem('sb_subscribed', '1');
              console.log('[ENTITLEMENT] Subscription persisted to localStorage');
          }
      }

      // Resolve access from canonical source (reads from localStorage)
      const newAccess = syncTierFromAccess();

      console.log('[ENTITLEMENT] Access resolved:', {
          previousAccess,
          newAccess,
          tier: state.tier
      });

      // Determine story length upgrades based on purchase type
      let upgraded = false;
      let toastMessage = null;

      // RULE: Storypass $3 upgrades ONLY to Fling (never Affair/Soulmates)
      if (purchaseType === 'pass' && newAccess === 'pass') {
          if (state.storyLength === 'tease') {
              state.storyLength = 'fling';
              upgraded = true;
              toastMessage = "Story expanded to Fling.";
          }
          // Pass users CANNOT access Affair or Soulmates - enforce this
          if (['affair', 'soulmates'].includes(state.storyLength)) {
              state.storyLength = 'fling';
              console.log('[ENTITLEMENT] Downgraded story length to Fling (pass cannot access affair/soulmates)');
          }
      }

      // RULE: Subscription can upgrade to Affair
      if (purchaseType === 'sub' && newAccess === 'sub') {
          if (['fling', 'tease'].includes(state.storyLength)) {
              state.storyLength = 'affair';
              upgraded = true;
              toastMessage = "You have shed your limitations.";
          }
      }

      // STORYTURN: Handle Tease cliffhanger resume on upgrade
      if (upgraded && typeof handleTeaseUpgradeResume === 'function') {
          handleTeaseUpgradeResume(state.storyLength);
      }

      if (upgraded) {
          state.storyEnded = false;
      }

      // Clear purchase state
      state.lastPurchaseType = null;
      state.pendingUpgradeToAffair = false;

      // CRITICAL: Apply all lock states AFTER access is resolved
      console.log('[ENTITLEMENT] Applying UI locks with access:', state.access);

      // Apply locks to all systems
      if (typeof applyLengthLocks === 'function') applyLengthLocks();
      if (typeof applyIntensityLocks === 'function') applyIntensityLocks();
      if (typeof applyStyleLocks === 'function') applyStyleLocks();
      if (typeof applyTierUI === 'function') applyTierUI();

      // CRITICAL FIX: Update Quill UI on both setup and game screens
      if (typeof updateQuillUI === 'function') updateQuillUI();
      if (typeof updateGameQuillUI === 'function') updateGameQuillUI();

      // Reset Fate ceremony state â€” full restart after paywall
      _fateRunning = false;
      _fateOverridden = false;
      _revealedDSPAxes = null;
      _dspGuidedFateActive = false;
      state.fateCommitted = false;

      // Clear DSP pending classes
      const synopsisText = document.getElementById('synopsisText');
      if (synopsisText) {
          synopsisText.querySelectorAll('.dsp-pending').forEach(span => {
              span.classList.remove('dsp-pending');
          });
          synopsisText.classList.remove('dsp-dissolving', 'dsp-revealing');
      }

      // Re-enable Say/Do inputs
      const actInput = document.getElementById('actionInput');
      const diaInput = document.getElementById('dialogueInput');
      if (actInput) { actInput.disabled = false; actInput.value = ''; }
      if (diaInput) { diaInput.disabled = false; diaInput.value = ''; }

      // Full card re-deal (not just init) â€” gives clickable, flippable, unlocked cards
      if (window.dealFateCards) window.dealFateCards();
      else if (window.initCards) window.initCards();
      // REBIND: Ensure FX handlers are attached after navigation
      if (window.initFateCards) window.initFateCards();

      // Clear the ceremony-cancelled flag
      state._paywallCancelledCeremony = false;

      // Save state
      saveStorySnapshot();

      // Only show toast if access actually changed
      if (toastMessage && newAccess !== previousAccess) {
          showToast(toastMessage);
      } else if (newAccess !== 'free' && previousAccess === 'free') {
          showToast("Content unlocked.");
      }

      // Navigate based on context
      if (state.purchaseContext === 'tierGate') {
          window.showScreen('modeSelect');
      }

      console.log('[ENTITLEMENT] completePurchase END:', {
          access: state.access,
          storyLength: state.storyLength,
          upgraded
      });
  }

  function renderFlingEnd() {
      const div = document.createElement('div');
      div.className = 'box';
      div.style.textAlign = 'center';
      div.style.border = '1px solid var(--pink)';
      div.innerHTML = `<h3 style="color:var(--pink)">Not finished.</h3><p>A Fling burns hot and leaves a mark. But an Affair lingers.</p><button onclick="window.upgradeFlingToAffair()" style="background:var(--pink); color:black; font-weight:bold; margin-top:10px;">Make it an Affair</button>`;
      // Append fling ending to current page
      StoryPagination.appendToCurrentPage(div.outerHTML);
  }

  window.upgradeFlingToAffair = function() {
      state.pendingUpgradeToAffair = true;
      state.lastPurchaseType = 'sub';
      if(state.access === 'sub') {
          completePurchase(); // Already subbed, just process upgrade
      } else {
          window.showPaywall('sub_only'); // Affair requires subscription
      }
  };

  const gmCheck = $('godModeCheck');
  if(gmCheck) {
      gmCheck.addEventListener('change', (e) => {
          if(!e.target.checked) return; 
          e.target.checked = false; 
          const unlocked = localStorage.getItem('sb_god_mode_owned') === '1';
          if(!unlocked) window.showPaywall('god');
          else if(confirm("WARNING: God Mode permanently removes this story from canon.")) activateGodMode();
      });
  }

  function activateGodMode() {
      state.sandbox = true;
      state.godModeActive = true;
      state.storyStage = 'sandbox'; 
      updateQuillUI();
      alert("God Mode Active.");
  }

  function makeStoryId(){
    const existing = localStorage.getItem('sb_current_story_id');
    if(existing) return existing;
    const id = 'sb_' + Date.now().toString(36);
    localStorage.setItem('sb_current_story_id', id);
    return id;
  }

  function getStoryPassKey(storyId){ return `sb_storypass_${storyId}`; }
  function hasStoryPass(storyId){ return localStorage.getItem(getStoryPassKey(storyId)) === '1'; }
  // Purchase is the authorization â€” pass must always be granted when paid
  function grantStoryPass(storyId){ if(storyId) localStorage.setItem(getStoryPassKey(storyId), '1'); }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * CANONICAL STORYPASS ELIGIBILITY â€” SINGLE SOURCE OF TRUTH
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * StoryPass ($3 one-time) allowed ONLY for:
   *   - Standard Fate Cards (non-Dirty, non-Soulmates)
   *   - Story Reader access for non-Dirty content
   *   - Any legacy "unlock this story" moments below Dirty intensity
   *
   * Subscription ($6) required for:
   *   - Dirty Fate Card
   *   - Dirty button in Story Reader
   *   - Soulmates Fate Card
   *   - Any Dirty-intensity continuation
   *
   * ğŸš« StoryPass must NEVER be offered in Dirty or Soulmates context.
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * @param {object} context - { intensity, cardType, uiSurface }
   *   - intensity: 'Clean' | 'Naughty' | 'Erotic' | 'Dirty'
   *   - cardType: 'standard' | 'soulmates' | 'dirty' (optional, derived from state if not provided)
   *   - uiSurface: 'card' | 'reader' | 'button' (optional, for debugging)
   * @returns {boolean} true if StoryPass is allowed, false if Subscribe-only
   */
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORYPASS EXCLUSION REGISTRY â€” AUTHORITATIVE DATA-LEVEL CONFIGURATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Cards with storypassAllowed: false NEVER show StoryPass option.
  // This is the source of truth. HTML cards have data-storypass-allowed="false".
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const STORYPASS_EXCLUSIONS = {
    intensity: {
      'Dirty': false    // Dirty intensity: subscription-only, NO StoryPass
    },
    length: {
      'soulmates': false  // Soulmates length: subscription-only, NO StoryPass
    }
  };

  function isStorypassAllowed(context = {}) {
    const intensity = context.intensity || state.intensity;
    const storyLength = context.storyLength || state.storyLength;

    // DATA-LEVEL EXCLUSION: Check registry (mirrors HTML data-storypass-allowed)
    if (STORYPASS_EXCLUSIONS.intensity[intensity] === false) return false;
    if (STORYPASS_EXCLUSIONS.length[storyLength] === false) return false;

    // All other contexts: StoryPass is allowed
    return true;
  }

  // Legacy alias for backward compatibility during transition
  function isStoryPassEligible(st) {
    return isStorypassAllowed({ intensity: st.intensity, storyLength: st.storyLength });
  }

  // Expose canonical function globally for fatecards.js and other modules
  window.isStorypassAllowed = isStorypassAllowed;

  /**
   * Get paywall mode based on StoryPass eligibility.
   * - For existing stories: uses persisted state.storypassEligible (immutable per-story)
   * - For setup (no story yet): uses isStorypassAllowed() based on current selections
   * @returns {'unlock' | 'sub_only'}
   */
  function getPaywallMode() {
    // If story exists (storypassEligible is defined), use persisted value
    if (state.storypassEligible !== undefined) {
      return state.storypassEligible ? 'unlock' : 'sub_only';
    }
    // No story yet - check current selections
    return isStorypassAllowed() ? 'unlock' : 'sub_only';
  }
  window.getPaywallMode = getPaywallMode;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY SHAPE SNAPSHOT â€” Begin/Continue Story Logic
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Tracks story-defining inputs to determine if story should regenerate.
  //
  // STORY-DEFINING INPUTS (included in snapshot):
  //   - world, genre, tone, dynamic, pov, worldSubtype
  //   - archetype.primary, archetype.modifier
  //
  // RUNTIME MODIFIERS (EXCLUDED â€” do NOT invalidate story):
  //   - intensity (arousal level)
  //   - storyLength (especially Dirty/Soulmates)
  //
  // BEHAVIOR:
  //   - Snapshot matches â†’ "Continue Story" (navigate only, no generation)
  //   - Snapshot differs â†’ "Begin Story" (generate new story)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Compute the current story shape snapshot.
   * ONLY includes story-defining inputs, NOT runtime modifiers.
   */
  function computeStoryShapeSnapshot() {
    return {
      // Four-axis selections (story-defining)
      world: state.picks?.world || null,
      genre: state.picks?.genre || null,
      tone: state.picks?.tone || null,
      dynamic: state.picks?.dynamic || null,
      pov: state.picks?.pov || null,
      worldSubtype: state.picks?.worldSubtype || null,
      // Archetype selections (story-defining)
      archetypePrimary: state.archetype?.primary || null,
      archetypeModifier: state.archetype?.modifier || null
      // NOTE: intensity and storyLength are EXCLUDED â€” they are runtime modifiers
    };
  }

  /**
   * Compare two story shape snapshots for deep equality.
   * Returns true if snapshots match (same story shape).
   */
  function compareShapeSnapshots(a, b) {
    if (!a || !b) return false;
    const keys = ['world', 'genre', 'tone', 'dynamic', 'pov', 'worldSubtype', 'archetypePrimary', 'archetypeModifier'];
    for (const key of keys) {
      if (a[key] !== b[key]) return false;
    }
    return true;
  }

  /**
   * Check if current story shape matches the last generated story.
   * Returns true if "Continue Story" should be shown.
   */
  function canContinueExistingStory() {
    // Must have an existing story
    if (!state.storyId) return false;
    // Must have a stored snapshot
    if (!state._lastGeneratedShapeSnapshot) return false;
    // Compare current shape to stored snapshot
    const currentSnapshot = computeStoryShapeSnapshot();
    return compareShapeSnapshots(currentSnapshot, state._lastGeneratedShapeSnapshot);
  }

  /**
   * Store the current story shape as the last generated snapshot.
   * Called when a new story is created.
   */
  function storeGeneratedShapeSnapshot() {
    state._lastGeneratedShapeSnapshot = computeStoryShapeSnapshot();
    console.log('[STORY:SHAPE] Snapshot stored:', state._lastGeneratedShapeSnapshot);
  }

  /**
   * Reset Guided Fate card visual state (dim/disabled appearance).
   * Called when story shape is invalidated to allow re-use.
   * Does NOT reset Fate logic, counters, or usage limits.
   */
  function resetGuidedFateVisualState() {
    const fateCard = $('fateDestinyCard');
    if (fateCard) {
      fateCard.dataset.fateUsed = 'false';
      fateCard.style.opacity = '1';
      fateCard.style.pointerEvents = 'auto';
    }
  }

  /**
   * Invalidate the stored snapshot (forces "Begin Story" on next check).
   * Called when story-defining inputs change.
   */
  function invalidateShapeSnapshot() {
    if (state._lastGeneratedShapeSnapshot) {
      console.log('[STORY:SHAPE] Snapshot invalidated â€” story-defining input changed');
      state._lastGeneratedShapeSnapshot = null;
      updateBeginButtonLabel();
      // Re-enable Guided Fate card when shape changes (allows re-use for new shape)
      resetGuidedFateVisualState();
    }
  }

  /**
   * Update the Begin Story button label based on snapshot state.
   * Also toggles passive save affordance hints.
   */
  function updateBeginButtonLabel() {
    const beginBtn = $('beginBtn');
    const btnBeginStory = $('btnBeginStory');
    const btnSettingBeginStory = $('btnSettingBeginStory');
    const continueFromDynamic = $('continueFromDynamic');

    const canContinue = canContinueExistingStory();
    const label = canContinue ? 'Continue Story' : 'Begin Story';

    // Update all button labels
    if (beginBtn) beginBtn.textContent = label;
    if (btnBeginStory) btnBeginStory.textContent = label;
    if (btnSettingBeginStory) btnSettingBeginStory.textContent = label;
    if (continueFromDynamic) continueFromDynamic.textContent = label;

    // Toggle passive save affordance hints
    const hints = [
      $('beginBtnHint'),
      $('btnBeginStoryHint'),
      $('btnSettingBeginStoryHint'),
      $('continueFromDynamicHint')
    ];
    hints.forEach(hint => {
      if (hint) {
        if (canContinue) {
          hint.classList.remove('hidden');
        } else {
          hint.classList.add('hidden');
        }
      }
    });

    console.log('[STORY:SHAPE] Button label updated:', label, '| canContinue:', canContinue);
  }

  // Expose for external modules
  window.invalidateShapeSnapshot = invalidateShapeSnapshot;
  window.updateBeginButtonLabel = updateBeginButtonLabel;
  window.canContinueExistingStory = canContinueExistingStory;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY STATE LOCKING â€” Destructive Change Protection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // LOCKED FIELDS (changing destroys story AND cover):
  // - pressure, world, tone, dynamic, genre
  // - pov, worldSubtype, flavor
  //
  // SAFE FIELDS (can change without destroying story/cover):
  // - intensity (arousal level) â€” COVER EVOLVES, NOT DESTROYED
  // - storyLength
  // - archetype (affects framing, not story)
  // - character names (cosmetic)
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER PERSISTENCE & RESET AUTHORITY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // COVER IS BOUND TO:
  //   âœ“ Story ID
  //   âœ“ Story Shape (world, tone, pressure, dynamic)
  //   âœ“ Characters (names + roles)
  //   âœ“ Storyturn progression
  //   âœ“ Arousal tier (for overlay evolution)
  //
  // COVER IS NOT BOUND TO:
  //   âœ— UI navigation
  //   âœ— User curiosity
  //   âœ— Accidental back clicks
  //
  // NAVIGATION BEHAVIOR:
  //   If user navigates BACK to Story Shape/Setting/Cover AND story exists:
  //   â†’ Story PAUSES (does not reset)
  //   â†’ Button shows "Continue Story"
  //   â†’ Cover REMAINS visible
  //   â†’ Guided Fate remains DISABLED
  //   â†’ NO regeneration occurs
  //
  // AROUSAL EXCEPTION (ONLY EXCEPTION):
  //   User MAY change arousal level WITHOUT destroying cover.
  //   â†’ Cover may EVOLVE (border â†” keyhole)
  //   â†’ Core visual idea MUST remain unchanged
  //   â†’ This is handled by applyCoverIntensityLayers()
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Fields that are locked once a story exists (changing destroys story AND cover)
  const STORY_LOCKED_FIELDS = ['pressure', 'world', 'tone', 'dynamic', 'genre', 'pov', 'worldSubtype', 'flavor'];

  // Fields that can change without destroying cover (cover evolves instead)
  const COVER_SAFE_FIELDS = ['intensity', 'storyLength', 'archetype'];

  // Pending destructive change (stored while modal is shown)
  let pendingDestructiveChange = null;

  /**
   * Check if a story currently exists (Scene 1 has been generated)
   * @returns {boolean}
   */
  function hasExistingStory() {
    // Story exists if we have a storyId AND content
    if (!state.storyId) return false;
    if (typeof StoryPagination !== 'undefined' && StoryPagination.getAllContent) {
      const content = StoryPagination.getAllContent();
      return content && content.trim().length > 0;
    }
    return state.turnCount > 0;
  }

  /**
   * Check if a field is locked (changing it would destroy the story)
   * @param {string} grp - The field/group being changed
   * @returns {boolean}
   */
  function isLockedField(grp) {
    return STORY_LOCKED_FIELDS.includes(grp);
  }

  /**
   * Check if a change would be destructive (story exists + locked field)
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {boolean}
   */
  function wouldDestroyStory(grp, newVal) {
    if (!hasExistingStory()) return false;
    if (!isLockedField(grp)) return false;
    // Check if actually changing to a different value
    const currentVal = state.picks[grp];
    return currentVal !== newVal;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER PERSISTENCE VALIDATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Check if a cover currently exists
   * @returns {boolean}
   */
  function hasExistingCover() {
    return state.coverGenerated === true || state.primaryCoverId != null;
  }

  /**
   * Check if a change would destroy the cover
   * Covers are destroyed when story is destroyed (same locked fields)
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {boolean}
   */
  function wouldDestroyCover(grp, newVal) {
    if (!hasExistingCover()) return false;
    // Cover is destroyed when story is destroyed
    return wouldDestroyStory(grp, newVal);
  }

  /**
   * Check if a change would cause cover evolution (not destruction)
   * Only arousal changes cause evolution, not destruction.
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {boolean}
   */
  function wouldEvolveCover(grp, newVal) {
    if (!hasExistingCover()) return false;
    // Only intensity (arousal) causes cover evolution
    if (grp !== 'intensity') return false;
    const currentVal = state.intensity;
    return currentVal !== newVal;
  }

  /**
   * Get cover persistence status for a potential change
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {{persists: boolean, evolves: boolean, destroys: boolean, reason: string}}
   */
  function getCoverPersistenceStatus(grp, newVal) {
    if (!hasExistingCover()) {
      return { persists: false, evolves: false, destroys: false, reason: 'No cover exists' };
    }

    if (wouldDestroyCover(grp, newVal)) {
      return {
        persists: false,
        evolves: false,
        destroys: true,
        reason: `Changing ${grp} destroys cover (locked field)`
      };
    }

    if (wouldEvolveCover(grp, newVal)) {
      return {
        persists: true,
        evolves: true,
        destroys: false,
        reason: `Changing arousal from ${state.intensity} to ${newVal} â€” cover evolves`
      };
    }

    return {
      persists: true,
      evolves: false,
      destroys: false,
      reason: 'Field is safe â€” cover persists unchanged'
    };
  }

  // Export cover persistence functions
  window.hasExistingCover = hasExistingCover;
  window.wouldDestroyCover = wouldDestroyCover;
  window.wouldEvolveCover = wouldEvolveCover;
  window.getCoverPersistenceStatus = getCoverPersistenceStatus;

  /**
   * Show the destructive change warning modal
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @param {HTMLElement} card - The card element being clicked
   * @param {Function} onConfirm - Callback if user confirms
   */
  function showDestructiveChangeWarning(grp, newVal, card, onConfirm) {
    pendingDestructiveChange = { grp, newVal, card, onConfirm };

    const modal = document.getElementById('destructiveChangeModal');
    if (modal) {
      modal.classList.remove('hidden');
    }
  }

  /**
   * Hide the destructive change warning modal
   */
  function hideDestructiveChangeWarning() {
    const modal = document.getElementById('destructiveChangeModal');
    if (modal) {
      modal.classList.add('hidden');
    }
    pendingDestructiveChange = null;
  }

  /**
   * Handle "Save & Start New Story" button
   */
  function handleSaveAndStartNew() {
    if (!pendingDestructiveChange) return;

    // Save current story first
    if (typeof saveCurrentStory === 'function') {
      saveCurrentStory().then(() => {
        proceedWithDestructiveChange();
      }).catch(err => {
        console.error('[STORY:LOCK] Save failed:', err);
        showToast('Failed to save story. Please try again.');
      });
    } else {
      // Fallback: just proceed
      proceedWithDestructiveChange();
    }
  }

  /**
   * Handle "Start New Story" button (no save)
   */
  function handleStartNewNoSave() {
    if (!pendingDestructiveChange) return;
    proceedWithDestructiveChange();
  }

  /**
   * Execute the destructive change after confirmation
   */
  function proceedWithDestructiveChange() {
    if (!pendingDestructiveChange) return;

    const { grp, newVal, card, onConfirm } = pendingDestructiveChange;

    // Clear story state
    clearStoryForNewStart();

    // Hide modal
    hideDestructiveChangeWarning();

    // Execute the original selection
    if (onConfirm) {
      onConfirm(grp, newVal, card);
    }

    console.log('[STORY:LOCK] Destructive change confirmed, story cleared');
  }

  /**
   * Clear all story state for a fresh start
   */
  function clearStoryForNewStart() {
    // Clear story identifiers
    state.storyId = null;
    state.turnCount = 0;
    state.storyEnded = false;
    state._lastGeneratedShapeSnapshot = null;

    // Clear story content
    if (typeof clearStoryContent === 'function') {
      clearStoryContent();
    } else {
      state.currentStoryContent = '';
      state.storyHistory = [];
      localStorage.removeItem('sb_saved_story');
      if (typeof StoryPagination !== 'undefined' && StoryPagination.clear) {
        StoryPagination.clear();
      }
      const storyEl = document.getElementById('storyText');
      if (storyEl) storyEl.innerHTML = '';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COVER DESTRUCTION (bound to story state)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Cover is destroyed when story is destroyed.
    // This is NOT reversible. Core visual idea is lost.
    const hadCover = state.coverGenerated || state.primaryCoverId;
    if (typeof resetCoverLayers === 'function') {
      resetCoverLayers();
    }
    state.coverGenerated = false;
    state.primaryCoverId = null;
    state.coverCoreIdea = null; // Clear the core visual idea
    if (hadCover) {
      console.log('[COVER:DESTROY] Cover destroyed â€” story state invalidated');
    }

    // Reset Guided Fate (becomes ACTIVE again after story destruction)
    if (typeof resetGuidedFateVisualState === 'function') {
      resetGuidedFateVisualState();
    }

    // Reset breadcrumb flow if in use
    if (typeof resetBreadcrumbFlow === 'function') {
      resetBreadcrumbFlow();
    }

    // Clear current story ID from storage
    clearCurrentStoryId();

    // Update button label
    updateBeginButtonLabel();

    console.log('[STORY:LOCK] Story and cover state cleared for new start');
  }

  /**
   * Initialize destructive change modal handlers
   */
  function initDestructiveChangeModal() {
    const btnSave = document.getElementById('btnSaveAndStartNew');
    const btnNoSave = document.getElementById('btnStartNewNoSave');
    const btnCancel = document.getElementById('btnCancelDestructive');

    if (btnSave) {
      btnSave.addEventListener('click', handleSaveAndStartNew);
    }
    if (btnNoSave) {
      btnNoSave.addEventListener('click', handleStartNewNoSave);
    }
    if (btnCancel) {
      btnCancel.addEventListener('click', hideDestructiveChangeWarning);
    }

    // Close on backdrop click
    const modal = document.getElementById('destructiveChangeModal');
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          hideDestructiveChangeWarning();
        }
      });
    }
  }

  // Expose functions globally
  window.hasExistingStory = hasExistingStory;
  window.wouldDestroyStory = wouldDestroyStory;
  window.showDestructiveChangeWarning = showDestructiveChangeWarning;
  window.hideDestructiveChangeWarning = hideDestructiveChangeWarning;
  window.clearStoryForNewStart = clearStoryForNewStart;
  window.initDestructiveChangeModal = initDestructiveChangeModal;

  function clearCurrentStoryId(){ localStorage.removeItem('sb_current_story_id'); }
  // CORRECTIVE: IndexedDB for large story data when localStorage fails
  const STORY_DB_NAME = 'StoryBoundDB';
  const STORY_DB_VERSION = 1;
  const STORY_STORE_NAME = 'stories';

  function openStoryDB() {
      return new Promise((resolve, reject) => {
          if (!window.indexedDB) {
              reject(new Error('IndexedDB not supported'));
              return;
          }
          const request = indexedDB.open(STORY_DB_NAME, STORY_DB_VERSION);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains(STORY_STORE_NAME)) {
                  db.createObjectStore(STORY_STORE_NAME, { keyPath: 'id' });
              }
          };
      });
  }

  async function saveToIndexedDB(snapshot) {
      try {
          const db = await openStoryDB();
          const tx = db.transaction(STORY_STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORY_STORE_NAME);
          await new Promise((resolve, reject) => {
              const req = store.put({ id: 'current_story', ...snapshot });
              req.onsuccess = resolve;
              req.onerror = () => reject(req.error);
          });
          db.close();
          localStorage.setItem('sb_story_in_idb', '1');
          return true;
      } catch (e) {
          console.error('IndexedDB save failed', e);
          return false;
      }
  }

  async function loadFromIndexedDB() {
      try {
          const db = await openStoryDB();
          const tx = db.transaction(STORY_STORE_NAME, 'readonly');
          const store = tx.objectStore(STORY_STORE_NAME);
          const data = await new Promise((resolve, reject) => {
              const req = store.get('current_story');
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
          });
          db.close();
          return data;
      } catch (e) {
          console.error('IndexedDB load failed', e);
          return null;
      }
  }

  function hasSavedStory() {
      // AUTH GATE: No saved story visible unless logged in
      if (!isLoggedIn()) return false;
      return !!localStorage.getItem('sb_saved_story') || localStorage.getItem('sb_story_in_idb') === '1';
  }

  function saveStorySnapshot(){
    // AUTH GATE: Persistence only allowed when logged in
    if (!isLoggedIn()) return;
    const el = document.getElementById('storyText');
    if(!el) return;
    const currentWc = currentStoryWordCount();
    if (currentWc > state.lastSavedWordCount) {
        const globalWc = Number(localStorage.getItem('sb_global_word_count') || 0);
        try {
            localStorage.setItem('sb_global_word_count', globalWc + (currentWc - state.lastSavedWordCount));
        } catch(e) { console.warn('Word count save failed', e); }
        state.lastSavedWordCount = currentWc;
    }
    // Create clean state snapshot without heavy data
    const cleanState = { ...state };
    // Prevent storing large visual bible data that causes QuotaExceededError
    if (cleanState.visual) {
        cleanState.visual = {
            ...cleanState.visual,
            lastImageUrl: '', // Don't persist images
            bible: { style: cleanState.visual.bible?.style || '', setting: cleanState.visual.bible?.setting || '', characters: {} }
        };
    }
    // CORRECTIVE: Remove sysPrompt from state snapshot (it's stored separately)
    delete cleanState.sysPrompt;

    const snapshot = {
      storyId: state.storyId,
      subscribed: !!state.subscribed,
      tier: state.tier,
      sysPrompt: state.sysPrompt,
      title: document.getElementById('storyTitle')?.textContent || '',
      synopsis: state._synopsisMetadata || '', // Metadata only, never rendered
      storyHTML: StoryPagination.getAllContent(),  // Full content for fallback
      storyPages: StoryPagination.getPages(),       // Individual pages for pagination
      stateSnapshot: cleanState
    };

    // CORRECTIVE: Try localStorage first, fall back to IndexedDB on quota error
    try {
        // Remove old data first to free space
        localStorage.removeItem('sb_saved_story');
        localStorage.removeItem('sb_story_in_idb');
        localStorage.setItem('sb_saved_story', JSON.stringify(snapshot));
    } catch(e) {
        // QuotaExceededError - try IndexedDB
        console.warn('localStorage quota exceeded, trying IndexedDB...', e);
        try {
            localStorage.removeItem(SB_ANALYTICS_KEY); // Free space
            localStorage.removeItem('sb_saved_story');
        } catch(e2) { /* ignore */ }

        // Save to IndexedDB asynchronously
        saveToIndexedDB(snapshot).then(success => {
            if (success) {
                console.log('Story saved to IndexedDB');
            } else {
                showToast('Save failed. Storage full.');
            }
        });
    }
    updateContinueButtons();
  }

  // CORRECTIVE: Load story data from localStorage or IndexedDB
  async function loadStoryData() {
      // Try localStorage first
      const raw = localStorage.getItem('sb_saved_story');
      if (raw) {
          try {
              return JSON.parse(raw);
          } catch (e) {
              console.warn('Failed to parse localStorage story', e);
          }
      }
      // Try IndexedDB if localStorage failed
      if (localStorage.getItem('sb_story_in_idb') === '1') {
          const idbData = await loadFromIndexedDB();
          if (idbData) return idbData;
      }
      return null;
  }

  window.continueStory = async function(){
    // AUTH GATE: Continue Story only available when logged in
    if (!isLoggedIn()) {
        showToast('Please login to continue a saved story.');
        return;
    }
    const data = await loadStoryData();
    if (!data) {
        showToast('No saved story found.');
        return;
    }

    state.storyId = data.storyId || makeStoryId();
    // AUTH GATE: Only persist when logged in (redundant but safe)
    if (isLoggedIn()) localStorage.setItem('sb_current_story_id', state.storyId);

    if(data.stateSnapshot) Object.assign(state, data.stateSnapshot);
    state.sysPrompt = data.sysPrompt || state.sysPrompt;
    state.subscribed = !!data.subscribed;
    state.authorChairActive = checkAuthorChairUnlock();

    updateBatedBreathState();
    applyAccessLocks();

    document.getElementById('storyTitle').textContent = data.title || '';
    // BOOK FLOW SPEC: Synopsis is metadata only, never rendered
    // Inside cover = blank paper, Setting plate = visual only
    state._synopsisMetadata = data.synopsis || '';

    // Load story into pagination system
    StoryPagination.clear();
    if (data.storyPages && Array.isArray(data.storyPages) && data.storyPages.length > 0) {
        // Load saved pages
        StoryPagination.setPages(data.storyPages);
    } else if (data.storyHTML) {
        // Fallback: load as single page
        StoryPagination.addPage(data.storyHTML, true);
    }
    state.lastSavedWordCount = currentStoryWordCount();

    // Setting shot removed from auto-load - requires explicit user action

    window.showScreen('game');
    if (state.fateOptions && state.fateOptions.length) state.fateOptions = filterFateCardsForBatedBreath(state.fateOptions);
    // FIX: Use dealFateCards (not initCards) to get clickable, flippable cards with handlers
    if(window.dealFateCards) window.dealFateCards();
    else if(window.initCards) window.initCards();
    // REBIND: Ensure FX handlers are attached after navigation
    if (window.initFateCards) window.initFateCards();
    resetTurnSnapshotFlag();
    updateQuillUI();

    // EARNED COVER SYSTEM: Update cover button for continued story
    _lastNotifiedCoverStage = getCurrentCoverStage();
    updateReaderCoverButton();
  };

  function updateContinueButtons(){
    const show = hasSavedStory();
    const btn1 = document.getElementById('continueStoryBtn');
    const btn2 = document.getElementById('continueFromTierBtn');
    if(btn1) btn1.classList.toggle('hidden', !show);
    if(btn2) btn2.classList.toggle('hidden', !show);
  }

  window.restart = function(){
    if(state.mode === 'couple') window.coupleCleanup();
    if (window.stopSparkleCycle) window.stopSparkleCycle(); // Clear any active fate card sparkles
    state.mode = 'solo';
    clearCurrentStoryId();
    state.storyId = null;
    state.access = state.subscribed ? 'sub' : 'free';
    syncTierFromAccess();
    localStorage.removeItem('sb_saved_story');
    // Reset state
    state.turnCount = 0;
    state.storyLength = 'tease';
    state.storyEnded = false;
    state.archetype = { primary: 'BEAUTIFUL_RUIN', modifier: null };

    // FIX: Full 4-axis + world state reset (prevents Ash Quarter / Warden-Cadre leak)
    state.picks = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', era: 'Medieval', pov: 'First' };
    state.intensity = 'Naughty';
    state.storypassEligible = undefined; // Reset - will be computed at story creation
    state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} }, sceneBudgets: {} };
    // SPECULATIVE PRELOAD: Reset on restart
    state.speculativeNextScene = null;
    state.isPreloadingNextScene = false;
    state.coverArchetype = null;
    state.lenses = [];
    state.withheldCoreVariant = null;
    state.normalizedPlayerKernel = null;
    state.normalizedPartnerKernel = null;
    state.rawPlayerName = null;
    state.rawPartnerName = null;
    // Reset story shape snapshot (forces "Begin Story" on new session)
    state._lastGeneratedShapeSnapshot = null;

    // FIX: Cover regeneration reset â€” allow new cover without hard refresh
    if (_coverAbortController) { _coverAbortController.abort(); _coverAbortController = null; }
    resetBookState();
    // Reset DSP state for fresh intro/placeholder cycle
    if (typeof resetDSPState === 'function') resetDSPState();
    const coverImg = document.getElementById('bookCoverImg');
    if (coverImg) coverImg.src = '';
    const coverLoading = document.getElementById('coverLoadingState');
    if (coverLoading) coverLoading.classList.add('hidden');
    const bookObj = document.getElementById('bookObject');
    if (bookObj) bookObj.classList.add('hidden');
    if (_coverPhraseInterval) { clearInterval(_coverPhraseInterval); _coverPhraseInterval = null; }
    if (_coverProgressInterval) { clearInterval(_coverProgressInterval); _coverProgressInterval = null; }

    // Reset card UI to match default state
    const cardDefaults = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', intensity: 'Naughty', length: 'tease', pov: 'First' };
    Object.entries(cardDefaults).forEach(([grp, val]) => {
        document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
            c.classList.remove('selected', 'flipped');
        });
        const def = document.querySelector(`.sb-card[data-grp="${grp}"][data-val="${val}"]`);
        if (def) def.classList.add('selected', 'flipped');
    });

    // Reset name inputs
    const pInput = $('playerNameInput');
    if (pInput) pInput.value = '';
    const lInput = $('partnerNameInput');
    if (lInput) lInput.value = '';

    // Clear pagination system
    StoryPagination.clear();
    // Re-render archetype cards to show default selection
    if (typeof renderArchetypeCards === 'function') renderArchetypeCards();
    if (typeof updateArchetypeSelectionSummary === 'function') updateArchetypeSelectionSummary();

    // PASS 9E: Reset fate card state
    const fateCard = $('fateDestinyCard');
    if (fateCard) {
        fateCard.dataset.fateUsed = 'false';
        fateCard.style.opacity = '1';
        fateCard.style.pointerEvents = 'auto';
        fateCard.classList.remove('flipped');
    }

    updateContinueButtons();
    window.showScreen('setup');
    // FIX: Explicit lock re-application ensures intensity cards reflect current access tier
    applyAccessLocks();
    applyIntensityLocks();
    updateQuillUI();
    updateBatedBreathState();
  };

  window.changeTier = function(){ window.showScreen('tierGate'); };

  $('saveBtn')?.addEventListener('click', (e) => {
      const hasAccess = (window.state.access !== 'free') || (window.state.mode === 'couple');
      if (!hasAccess) {
          e.stopPropagation();
          // CANONICAL: Use story metadata for paywall mode (persisted, immutable per-story)
          window.showPaywall(getPaywallMode());
          return;
      }
      saveStorySnapshot();
      showToast("Story saved.");
  });

  // Story Controls button - toggle Quill & Veto modal (always opens, Quill locked in Tease)
  $('gameControlsBtn')?.addEventListener('click', (e) => {
      // Clear inputs for new entries (committed entries are shown separately)
      const quillInput = document.getElementById('gameQuillInput');
      const vetoInput = document.getElementById('gameVetoInput');
      if (quillInput) quillInput.value = '';
      if (vetoInput) vetoInput.value = '';

      // CORRECTIVE: Render committed veto phrases in game modal (with remove buttons)
      const gameVetoCommitted = document.getElementById('gameVetoCommitted');
      if (gameVetoCommitted && state.committedVeto) {
          renderGameVetoPills(gameVetoCommitted);
      }

      // Render committed quill phrases in game modal (with remove buttons)
      const gameQuillCommitted = document.getElementById('gameQuillCommitted');
      if (gameQuillCommitted && state.committedQuill) {
          renderGameQuillPills(gameQuillCommitted);
      }

      updateGameQuillUI();
      document.getElementById('gameQuillVetoModal')?.classList.remove('hidden');
  });

  // Game Quill commit button
  $('btnGameCommitQuill')?.addEventListener('click', async (e) => {
      e.preventDefault(); // Prevent scroll to top
      e.stopPropagation();

      // Save scroll position before any DOM changes
      const scrollY = window.scrollY;
      const scrollX = window.scrollX;

      if (!getQuillReady()) return;
      const quillEl = document.getElementById('gameQuillInput');
      if (!quillEl) return;
      const rawQuillText = quillEl.value.trim();
      if (!rawQuillText) { showToast("No Quill edit to commit."); return; }

      // RUNTIME NORMALIZATION: Quill input flows through ChatGPT normalization layer
      const quillNorm = await callNormalizationLayer({
          axis: 'quill',
          user_text: rawQuillText,
          context_signals: state.picks?.world || []
      });
      const quillText = quillNorm.canonical_instruction || quillNorm.normalized_text || rawQuillText;

      // Also apply any pending veto constraints from game modal
      await applyGameVetoFromInput();

      // Add to committed phrases (parity with setup modal)
      state.committedQuill.push(quillText);
      window.state.quillIntent = quillText;

      // Re-render committed pills in game modal
      const gameQuillCommitted = document.getElementById('gameQuillCommitted');
      if (gameQuillCommitted) renderGameQuillPills(gameQuillCommitted);

      if (quillText) {
          const quillHtml = `<div class="quill-intervention" style="color:var(--gold); font-style:italic; border-left:3px solid var(--gold); padding-left:12px; margin:15px 0;">${formatStory(quillText)}</div>`;
          StoryPagination.appendToCurrentPage(quillHtml);
      }
      window.state.quillCommittedThisTurn = true;
      window.state.quill.uses++;
      window.state.quill.nextReadyAtWords = currentStoryWordCount() + computeNextCooldownWords();
      quillEl.value = '';
      updateQuillUI();
      updateGameQuillUI();
      document.getElementById('gameQuillVetoModal')?.classList.add('hidden');
      showToast("Quill committed.");

      // Restore scroll position after all DOM changes
      requestAnimationFrame(() => {
          window.scrollTo(scrollX, scrollY);
      });
  });

  // Game Veto commit button
  $('btnGameCommitVeto')?.addEventListener('click', async () => {
      const vetoEl = document.getElementById('gameVetoInput');
      if (!vetoEl) return;
      const vetoText = vetoEl.value.trim();
      if (!vetoText) { showToast("No Veto rules to commit."); return; }

      await applyGameVetoFromInput();
      vetoEl.value = '';
      document.getElementById('gameQuillVetoModal')?.classList.add('hidden');
      showToast(`Excluded: "${vetoText}"`);
  });

  function updateGameQuillUI() {
      const btn = document.getElementById('btnGameCommitQuill');
      const status = document.getElementById('gameQuillStatus');
      const quillBox = document.getElementById('gameQuillBox');
      const quillSection = quillBox?.closest('.qv-section');
      if (!btn || !status) return;

      // TEASE MODE: Lock entire Quill section
      if (isTeaseMode()) {
          status.textContent = "Quill: Locked (Upgrade to unlock)";
          btn.disabled = true;
          // PLAQUE REGIME: No opacity mutation â€” CSS handles disabled state
          btn.textContent = "Commit Quill";
          if (quillBox) quillBox.classList.add('locked-input');
          if (quillSection) quillSection.classList.add('locked-section');
          // Add click handler for paywall on quill section
          if (quillBox && !quillBox.dataset.paywallBound) {
              quillBox.dataset.paywallBound = '1';
              quillBox.addEventListener('click', () => {
                  if (isTeaseMode() && window.openPaywall) window.openPaywall('unlock');
              });
          }
          return;
      }

      // Paid users: normal Quill logic
      if (quillSection) quillSection.classList.remove('locked-section');
      // CRITICAL FIX: Ensure paywall click guard is disabled for paid users
      if (quillBox) {
          quillBox.dataset.paywallActive = 'false';
      }

      const ready = getQuillReady();
      const needed = state.quill.nextReadyAtWords;
      const wc = currentStoryWordCount();
      const remain = Math.max(0, needed - wc);

      if (ready || state.godModeActive) {
          status.textContent = state.authorChairActive ? "Quill: Poised" : "Quill: Poised";
          btn.disabled = false;
          // PLAQUE REGIME: No opacity mutation â€” material is static
          btn.textContent = state.godModeActive ? "Commit Quill (God Mode)" : "Commit Quill";
          if (quillBox) quillBox.classList.remove('locked-input');
      } else {
          status.textContent = `Quill: Spent (${remain} words to recharge)`;
          btn.disabled = true;
          // PLAQUE REGIME: No opacity mutation â€” CSS handles disabled state
          if (quillBox) quillBox.classList.add('locked-input');
      }
  }

  async function applyGameVetoFromInput() {
      const vetoEl = document.getElementById('gameVetoInput');
      if (!vetoEl) return;
      const rawTxt = vetoEl.value.trim();
      if (!rawTxt) return;

      // RUNTIME NORMALIZATION: Game veto input flows through ChatGPT normalization layer
      // CRITICAL: Never store raw text - always use normalized kernel
      const vetoNorm = await callNormalizationLayer({
          axis: 'veto',
          user_text: rawTxt,
          context_signals: state.picks?.world || []
      });
      // Extract kernel - prefer archetype/burden format, then normalized_text, NEVER raw
      const kernel = vetoNorm.archetype || vetoNorm.burden || vetoNorm.normalized_text || vetoNorm.canonical_instruction;
      const txt = kernel || 'excluded element';

      // Parse and add to veto state (same as setup veto)
      txt.split('\n').forEach(line => {
          line = line.trim();
          if (!line) return;
          if (line.toLowerCase().startsWith('ban:')) {
              const word = line.slice(4).trim();
              if (word && !state.veto.bannedWords.includes(word)) state.veto.bannedWords.push(word);
          } else if (line.toLowerCase().startsWith('rename:')) {
              const parts = line.slice(7).split('->').map(s => s.trim());
              if (parts.length === 2 && parts[0] && parts[1]) {
                  state.veto.corrections.push({ from: parts[0], to: parts[1] });
              }
          } else {
              if (!state.veto.excluded.includes(line)) state.veto.excluded.push(line);
          }
      });
      vetoEl.value = '';
  }

  $('burgerBtn')?.addEventListener('click', () => {
      if (typeof renderBurgerMenu === 'function') renderBurgerMenu();
      document.getElementById('menuOverlay')?.classList.remove('hidden');
  });
  $('ageYes')?.addEventListener('click', () => window.showScreen('tosGate'));
  $('tosCheck')?.addEventListener('change', (e) => $('tosBtn').disabled = !e.target.checked);
  $('tosBtn')?.addEventListener('click', () => window.showScreen('tierGate'));

  $('btnTease')?.addEventListener('click', () => {
    state.tier = 'free';
    state.access = 'free';
    applyAccessLocks();
    window.showScreen('modeSelect');
    if(window.initCards) window.initCards();
  });

  $('btnIndulge')?.addEventListener('click', () => window.showPaywall('sub_only'));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARALLEL COVER + STORY GENERATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // When "Generate Cover" is clicked:
  //   - Start cover generation
  //   - Start story generation in background
  //   - Add sparkle FX to button
  // When cover completes:
  //   - Stop sparkle FX with fade
  //   - Replace button with "See Your Book Cover"
  // When "See Your Book Cover" clicked:
  //   - Navigate to Cover View (book display with buttons)
  // Cover View has:
  //   - "See Your Story Setting" (paywalled, generates setting image)
  //   - "Begin Story" (goes directly to Scene 1)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER$ SYSTEM â€” Cover Credit Microtransaction System
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // - 3 free covers per day (all users, including subscribers)
  // - $0.25 per additional cover after limit
  // - Paid covers allow prompt editing before generation
  // - God Mode excluded from this system
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const COVER_DAILY_FREE_LIMIT = 3;
  const COVER_PAID_PRICE = 0.25;

  // Verboten terms that may cause image generation to fail
  const COVER_BLOCKED_TERMS = [
      'nude', 'naked', 'sex', 'explicit', 'pornographic', 'nsfw',
      'child', 'minor', 'underage', 'gore', 'blood', 'violence',
      'weapon', 'gun', 'knife', 'death', 'kill', 'murder',
      'drugs', 'cocaine', 'heroin', 'meth', 'racist', 'hate'
  ];

  // Get today's date key for localStorage
  function getCoverDateKey() {
      return new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  }

  // Get current cover credit state
  function getCoverCredits() {
      const stored = localStorage.getItem('storybound_cover_credits');
      if (!stored) return { date: getCoverDateKey(), used: 0, purchased: 0 };
      try {
          const data = JSON.parse(stored);
          // Reset if new day
          if (data.date !== getCoverDateKey()) {
              return { date: getCoverDateKey(), used: 0, purchased: 0 };
          }
          return data;
      } catch (e) {
          return { date: getCoverDateKey(), used: 0, purchased: 0 };
      }
  }

  // Save cover credit state
  function saveCoverCredits(credits) {
      credits.date = getCoverDateKey();
      localStorage.setItem('storybound_cover_credits', JSON.stringify(credits));
      updateCoverCreditDisplay();
  }

  // Check if user has free covers remaining
  function hasFreeCoverCredits() {
      // God Mode excluded from credit system
      if (state.godModeEnabled) return true;
      const credits = getCoverCredits();
      return credits.used < COVER_DAILY_FREE_LIMIT;
  }

  // Get remaining free covers
  function getRemainingFreeCovers() {
      if (state.godModeEnabled) return 'âˆ';
      const credits = getCoverCredits();
      return Math.max(0, COVER_DAILY_FREE_LIMIT - credits.used);
  }

  // Use a free cover credit
  function useFreeCredit() {
      const credits = getCoverCredits();
      credits.used++;
      saveCoverCredits(credits);
      console.log('[COVER$] Free credit used. Remaining:', COVER_DAILY_FREE_LIMIT - credits.used);
  }

  // Record a paid cover purchase
  function recordPaidCover() {
      const credits = getCoverCredits();
      credits.purchased++;
      credits.used++; // Paid covers still count toward usage tracking
      saveCoverCredits(credits);
      console.log('[COVER$] Paid cover recorded. Total purchased today:', credits.purchased);
  }

  // Update the cover credit display UI
  function updateCoverCreditDisplay() {
      const display = $('coverCreditDisplay');
      if (!display) return;
      const remaining = getRemainingFreeCovers();
      if (remaining === 'âˆ') {
          display.textContent = 'God Mode: Unlimited';
          display.classList.add('god-mode');
      } else if (remaining > 0) {
          display.textContent = `${remaining} free cover${remaining !== 1 ? 's' : ''} remaining today`;
          display.classList.remove('god-mode', 'exhausted');
      } else {
          display.textContent = 'Free covers exhausted â€¢ $0.25 per cover';
          display.classList.add('exhausted');
          display.classList.remove('god-mode');
      }
  }

  // Check if prompt contains blocked terms
  function checkPromptSafety(prompt) {
      const lower = (prompt || '').toLowerCase();
      const found = COVER_BLOCKED_TERMS.filter(term => lower.includes(term));
      return {
          safe: found.length === 0,
          blockedTerms: found
      };
  }

  // Auto-sanitize prompt by removing blocked terms
  function sanitizeCoverPrompt(prompt) {
      let sanitized = prompt;
      let modified = false;
      for (const term of COVER_BLOCKED_TERMS) {
          const regex = new RegExp(term, 'gi');
          if (regex.test(sanitized)) {
              sanitized = sanitized.replace(regex, '').replace(/\s+/g, ' ').trim();
              modified = true;
          }
      }
      return { sanitized, modified };
  }

  // Build the cover prompt for user display/editing (paid covers only)
  function buildEditableCoverPrompt() {
      const world = state.picks?.world || 'Modern';
      const genre = state.picks?.genre || 'Billionaire';
      const tone = state.picks?.tone || 'Earnest';
      // Title resolution: render no title if not finalized (no placeholder prose)
      const rawTitle = $('storyTitle')?.textContent?.trim() || state._backgroundStoryTitle?.trim() || '';
      const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';

      // Determine world key and get Assembly object
      const worldKey = world.toLowerCase().includes('fantasy') ? 'fantasy'
          : world.toLowerCase().includes('histor') ? 'historical'
          : world.toLowerCase().includes('sci') ? 'scifi'
          : world.toLowerCase().includes('paranormal') || world.toLowerCase().includes('vampire') ? 'paranormal'
          : 'modern';

      const ASSEMBLY_OBJECTS = {
          modern: ['vintage key', 'silk ribbon', 'pearl earring', 'champagne glass', 'red lipstick', 'leather journal', 'single rose', 'antique locket'],
          fantasy: ['ornate dagger', 'crystal vial', 'wax-sealed letter', 'jeweled crown', 'silver mask', 'enchanted mirror', 'golden chalice', 'raven feather'],
          historical: ['quill pen', 'pocket watch', 'cameo brooch', 'candelabra', 'love letter', 'silk fan', 'brass compass', 'velvet glove'],
          scifi: ['holographic card', 'chrome ring', 'data chip', 'neural interface', 'crystal shard', 'metallic rose', 'quantum locket', 'star map'],
          paranormal: ['blood vial', 'moonstone pendant', 'black candle', 'silver dagger', 'tarot card', 'obsidian mirror', 'wolf fang', 'crimson ribbon']
      };

      const objectList = ASSEMBLY_OBJECTS[worldKey] || ASSEMBLY_OBJECTS.modern;
      const selectedObject = state._coverAssemblyObject || objectList[Math.floor(Math.random() * objectList.length)];

      return {
          title,
          world: worldKey,
          genre,
          tone,
          focalObject: selectedObject,
          prompt: `Book cover for "${title}" - a ${tone.toLowerCase()} ${genre.toLowerCase()} story set in a ${worldKey} world. Focal object: ${selectedObject}. Elegant, cinematic, painterly style. No people or faces.`
      };
  }

  // Show the Cover$ purchase modal for paid covers
  function showCoverPurchaseModal() {
      const modal = $('coverPurchaseModal');
      if (!modal) {
          console.error('[COVER$] Purchase modal not found');
          return;
      }

      // Build editable prompt
      const promptData = buildEditableCoverPrompt();
      const promptInput = $('coverPromptInput');
      const titleDisplay = $('coverPromptTitle');
      const worldDisplay = $('coverPromptWorld');
      const objectDisplay = $('coverPromptObject');
      const safetyWarning = $('coverPromptSafetyWarning');

      if (promptInput) promptInput.value = promptData.prompt;
      if (titleDisplay) titleDisplay.textContent = promptData.title;
      if (worldDisplay) worldDisplay.textContent = promptData.world;
      if (objectDisplay) objectDisplay.textContent = promptData.focalObject;
      if (safetyWarning) safetyWarning.classList.add('hidden');

      // Wire up prompt input safety check
      if (promptInput) {
          promptInput.oninput = () => {
              const check = checkPromptSafety(promptInput.value);
              if (safetyWarning) {
                  if (!check.safe) {
                      safetyWarning.textContent = 'âš ï¸ Some words or combinations may prevent image generation.';
                      safetyWarning.classList.remove('hidden');
                  } else {
                      safetyWarning.classList.add('hidden');
                  }
              }
          };
      }

      modal.classList.remove('hidden');
  }

  // Hide the Cover$ purchase modal
  function hideCoverPurchaseModal() {
      const modal = $('coverPurchaseModal');
      if (modal) modal.classList.add('hidden');
  }

  // Process paid cover purchase and generation
  async function processPaidCoverPurchase() {
      const promptInput = $('coverPromptInput');
      let userPrompt = promptInput?.value || '';

      // Auto-sanitize unsafe inputs
      const sanitizeResult = sanitizeCoverPrompt(userPrompt);
      if (sanitizeResult.modified) {
          userPrompt = sanitizeResult.sanitized;
          showToast('Some inputs were adjusted for image safety.');
      }

      // Final safety check - block if still unsafe
      const safetyCheck = checkPromptSafety(userPrompt);
      if (!safetyCheck.safe) {
          showToast('Cannot generate cover: blocked terms detected. Please edit your prompt.');
          return false;
      }

      // Hide modal (credit recorded AFTER successful generation)
      hideCoverPurchaseModal();

      // Generate cover with user's edited prompt
      const success = await generatePaidCover(userPrompt);

      // Record credit ONLY on success
      if (success) {
          recordPaidCover();
      }
      return success;
  }

  // Generate cover with custom (paid) prompt
  async function generatePaidCover(customPrompt) {
      const btn = $('btnGenerateCover');
      const loading = $('coverGenLoading');
      const complete = $('coverGenComplete');

      if (btn) {
          btn.disabled = true;
          btn.textContent = 'Generating...';
      }
      if (loading) loading.style.display = 'flex';
      if (complete) complete.classList.add('hidden');

      startCoverButtonEmitter(btn);

      // Start background story if not started
      if (!_backgroundStoryStarted) {
          console.log('[PARALLEL:GEN] Starting background story generation');
          _backgroundStoryStarted = true;
          _backgroundStoryPromise = startBackgroundStoryGeneration();
      }

      try {
          // Build full prompt with user customization
          // Title resolution: render no title if not finalized (no placeholder prose)
          const rawTitle = $('storyTitle')?.textContent?.trim() || state._backgroundStoryTitle?.trim() || '';
          const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';
          const world = state.picks?.world || 'Modern';
          const worldKey = world.toLowerCase().includes('fantasy') ? 'fantasy'
              : world.toLowerCase().includes('histor') ? 'historical'
              : world.toLowerCase().includes('sci') ? 'scifi'
              : world.toLowerCase().includes('paranormal') ? 'paranormal' : 'modern';

          const fullPrompt = `BOOK COVER IMAGE â€” PAID CUSTOM GENERATION

TITLE: "${title}"
AUTHOR LINE: "by Anonymous"

USER PROMPT:
${customPrompt}

ABSOLUTE RULES:
- NO people, NO faces, NO figures anywhere in the image
- A subtle human SHADOW is allowed but must be secondary
- Title text: large, high contrast, readable at thumbnail size
- Author line: smaller, elegant, below the title
- Elegant, painterly realism, NOT illustration
- Premium published novel aesthetic

WORLD MATERIAL TREATMENT (${worldKey}):
${worldKey === 'fantasy' ? '- Aged stone, tarnished metal, worn fabric textures' :
  worldKey === 'historical' ? '- Wood, brass, parchment, oil-stained cloth textures' :
  worldKey === 'scifi' ? '- Brushed alloy, polymer, subtle luminescence' :
  worldKey === 'paranormal' ? '- Dark velvet, oxidized silver, candlelit warmth' :
  '- Concrete, glass, leather, modern luxury textures'}

The final image must look like a real published novel cover.`;

          // REGRESSION GUARD: Block cinematic drift for Wry Confessional
          assertWryConfessionalVisual(fullPrompt, 'generatePaidCover');

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: fullPrompt,
                  imageIntent: 'book_cover',
                  size: '1024x1536', // 5:7 portrait ratio (matches Minimal v1)
                  _minimalV1: true   // Use same backend path as free covers
              })
          });

          if (!res.ok) throw new Error(`Image API error: ${res.status}`);

          const data = await res.json();
          const coverUrl = data.url || data.image || data.data?.[0]?.url;

          if (!coverUrl) {
              throw new Error('No cover URL returned');
          }

          _preGeneratedCoverUrl = coverUrl;
          _coverGenUsed = true;
          _lastCoverShapeHash = computeStoryShapeHash();

          stopCoverButtonEmitter();
          if (loading) loading.style.display = 'none';
          if (complete) complete.classList.remove('hidden');

          if (btn) {
              btn.textContent = 'See Your Book Cover';
              btn.disabled = false;
              btn.classList.add('begin-story-ready');
          }
          _coverBtnIsBeginStory = true;

          console.log('[COVER$] Paid cover generated successfully');
          return true;

      } catch (err) {
          console.error('[COVER$] Paid cover generation failed:', err);
          stopCoverButtonEmitter();

          if (btn) {
              btn.textContent = 'Generation Failed';
              btn.disabled = false;
          }
          if (loading) loading.style.display = 'none';

          showToast('Cover generation failed. No credit consumed â€” please retry.');
          return false;
      }
  }

  // Expose Cover$ functions
  window.showCoverPurchaseModal = showCoverPurchaseModal;
  window.hideCoverPurchaseModal = hideCoverPurchaseModal;
  window.processPaidCoverPurchase = processPaidCoverPurchase;
  window.hasFreeCoverCredits = hasFreeCoverCredits;
  window.getRemainingFreeCovers = getRemainingFreeCovers;
  window.updateCoverCreditDisplay = updateCoverCreditDisplay;

  // EARNED COVER SYSTEM exports
  window.getCurrentCoverStage = getCurrentCoverStage;
  window.getMaxCoverStage = getMaxCoverStage;
  window.isCoverStageUnlocked = isCoverStageUnlocked;
  window.updateReaderCoverButton = updateReaderCoverButton;
  window.checkCoverStageUpgrade = checkCoverStageUpgrade;
  window.COVER_STAGES = COVER_STAGES;
  window.COVER_STAGE_LABELS = COVER_STAGE_LABELS;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _coverGenUsed = false;
  let _preGeneratedCoverUrl = null;
  let _backgroundStoryPromise = null;      // Promise for background story generation
  let _backgroundStoryStarted = false;     // Flag: story generation in progress
  let _coverBtnIsBeginStory = false;       // Flag: button has transitioned to "Begin Story"

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER BUTTON SPARKLE EMITTER â€” Multi-tone gold radial emission
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Trigger: Generate Cover button click (runs while generation is in progress)
  // Scope: Anchored to button PERIMETER, particles radiate outward
  // Style: Multi-tone gold palette, per-sparkle variance, short lifetimes
  // Stop: When generation completes, stop spawning, let existing particles fade
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _coverEmitterInterval = null;
  let _coverEmitterActive = false;

  // Multi-tone gold palette for rich sparkle variety
  const COVER_SPARKLE_PALETTE = [
      { core: 'rgba(255, 250, 220, 0.98)', mid: 'rgba(255, 223, 120, 0.85)', glow: 'rgba(255, 200, 50, 0.6)' },   // Bright champagne
      { core: 'rgba(255, 235, 150, 0.95)', mid: 'rgba(255, 215, 0, 0.8)', glow: 'rgba(218, 165, 32, 0.5)' },      // Classic gold
      { core: 'rgba(255, 220, 100, 0.95)', mid: 'rgba(255, 193, 37, 0.85)', glow: 'rgba(184, 134, 11, 0.5)' },    // Deep gold
      { core: 'rgba(255, 245, 200, 0.98)', mid: 'rgba(255, 228, 140, 0.85)', glow: 'rgba(255, 200, 80, 0.55)' },  // Pale gold
      { core: 'rgba(255, 210, 80, 0.95)', mid: 'rgba(230, 180, 30, 0.8)', glow: 'rgba(180, 130, 20, 0.5)' },      // Amber gold
      { core: 'rgba(255, 240, 180, 0.96)', mid: 'rgba(255, 210, 100, 0.82)', glow: 'rgba(200, 160, 40, 0.5)' }    // Warm honey
  ];

  let _coverSparkleOverlay = null;

  function startCoverButtonEmitter(btn) {
      if (!btn || _coverEmitterActive) return;
      _coverEmitterActive = true;

      const rect = btn.getBoundingClientRect();
      const btnWidth = rect.width;
      const btnHeight = rect.height;

      // Create sibling overlay to prevent opacity inheritance from button
      _coverSparkleOverlay = document.createElement('div');
      _coverSparkleOverlay.className = 'cover-sparkle-overlay';
      _coverSparkleOverlay.style.cssText = `
          position: fixed;
          left: ${rect.left}px;
          top: ${rect.top}px;
          width: ${btnWidth}px;
          height: ${btnHeight}px;
          pointer-events: none;
          z-index: 2500;
          overflow: visible;
          opacity: 1 !important;
          filter: none !important;
      `;
      document.body.appendChild(_coverSparkleOverlay);

      // Spawn a sparkle on the button perimeter with radial outward motion
      function spawnSparkle() {
          if (!_coverEmitterActive) return;

          const sparkle = document.createElement('div');
          sparkle.className = 'cover-btn-sparkle';

          // SLOW FLOAT â€” match Fate Card sparkle feel (4-7s)
          const lifetime = 4000 + Math.random() * 3000;
          const fadeInDuration = 300 + Math.random() * 200;
          const fadeOutDuration = 800 + Math.random() * 400;

          // Random palette selection for multi-tone variety
          const palette = COVER_SPARKLE_PALETTE[Math.floor(Math.random() * COVER_SPARKLE_PALETTE.length)];

          // Per-sparkle size variance (2-5px)
          const size = 2 + Math.random() * 3;

          // Per-sparkle opacity â€” FULL brightness, explicit to override button inheritance
          const peakOpacity = 0.85 + Math.random() * 0.15;

          // Per-sparkle glow intensity variance
          const glowSize = 4 + Math.random() * 6;
          const glowSpread = Math.random() * 2;

          // Spawn on button PERIMETER with RADIAL outward emission
          const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
          let startX, startY, driftX, driftY;

          // Radial drift distance â€” slow float outward
          const driftDist = 30 + Math.random() * 40;
          const driftSpread = (Math.random() - 0.5) * 20; // Gentle perpendicular drift

          switch (edge) {
              case 0: // Top edge â€” radiate upward
                  startX = Math.random() * btnWidth;
                  startY = -2;
                  driftX = driftSpread;
                  driftY = -driftDist;
                  break;
              case 1: // Right edge â€” radiate rightward
                  startX = btnWidth + 2;
                  startY = Math.random() * btnHeight;
                  driftX = driftDist;
                  driftY = driftSpread;
                  break;
              case 2: // Bottom edge â€” radiate downward
                  startX = Math.random() * btnWidth;
                  startY = btnHeight + 2;
                  driftX = driftSpread;
                  driftY = driftDist;
                  break;
              case 3: // Left edge â€” radiate leftward
                  startX = -2;
                  startY = Math.random() * btnHeight;
                  driftX = -driftDist;
                  driftY = driftSpread;
                  break;
          }

          // Scale transform â€” gentle grow/shrink for organic float
          const startScale = 0.5 + Math.random() * 0.3;
          const peakScale = 1.0 + Math.random() * 0.3;

          sparkle.style.cssText = `
              position: absolute;
              left: ${startX}px;
              top: ${startY}px;
              width: ${size}px;
              height: ${size}px;
              background: radial-gradient(circle, ${palette.core}, ${palette.mid} 60%, transparent 100%);
              box-shadow: 0 0 ${glowSize}px ${glowSpread}px ${palette.glow};
              border-radius: 50%;
              pointer-events: none;
              opacity: 0;
              z-index: 1000;
              transform: scale(${startScale});
              will-change: transform, opacity, left, top;
          `;

          // Append to sibling overlay (not button) to prevent opacity inheritance
          if (_coverSparkleOverlay) {
              _coverSparkleOverlay.appendChild(sparkle);
          }

          // Animate: fade in + scale up + drift outward
          requestAnimationFrame(() => {
              sparkle.style.transition = `
                  opacity ${fadeInDuration}ms ease-out,
                  transform ${lifetime * 0.6}ms ease-out,
                  left ${lifetime}ms ease-out,
                  top ${lifetime}ms ease-out
              `;
              sparkle.style.opacity = String(peakOpacity);
              sparkle.style.transform = `scale(${peakScale})`;
              sparkle.style.left = (startX + driftX) + 'px';
              sparkle.style.top = (startY + driftY) + 'px';
          });

          // Fade out quickly at end of lifetime
          const fadeOutStart = lifetime - fadeOutDuration;
          setTimeout(() => {
              sparkle.style.transition = `opacity ${fadeOutDuration}ms ease-in, transform ${fadeOutDuration}ms ease-in`;
              sparkle.style.opacity = '0';
              sparkle.style.transform = `scale(${startScale * 0.5})`;
          }, Math.max(0, fadeOutStart));

          // Remove after lifetime
          setTimeout(() => {
              if (sparkle.parentNode) sparkle.remove();
          }, lifetime + 50);
      }

      // Spawn initial burst â€” gentle, staggered
      for (let i = 0; i < 5; i++) {
          setTimeout(() => spawnSparkle(), i * 80);
      }

      // Continuous emission â€” slower spawn rate for floaty feel (1-2 particles every 200-400ms)
      _coverEmitterInterval = setInterval(() => {
          if (!_coverEmitterActive) {
              clearInterval(_coverEmitterInterval);
              _coverEmitterInterval = null;
              return;
          }
          const count = 1 + Math.floor(Math.random() * 2);
          for (let i = 0; i < count; i++) {
              setTimeout(() => spawnSparkle(), Math.random() * 100);
          }
      }, 200 + Math.random() * 200);

      console.log('[FX:COVER-BTN] Multi-tone sparkle emitter started');
  }

  function stopCoverButtonEmitter() {
      if (!_coverEmitterActive) return;
      _coverEmitterActive = false;

      // Clear interval â€” stops spawning new particles
      if (_coverEmitterInterval) {
          clearInterval(_coverEmitterInterval);
          _coverEmitterInterval = null;
      }

      // Fade out and remove overlay after particles finish
      if (_coverSparkleOverlay) {
          _coverSparkleOverlay.style.transition = 'opacity 1s ease-out';
          _coverSparkleOverlay.style.opacity = '0';
          setTimeout(() => {
              if (_coverSparkleOverlay && _coverSparkleOverlay.parentNode) {
                  _coverSparkleOverlay.remove();
              }
              _coverSparkleOverlay = null;
          }, 1500);
      }

      console.log('[FX:COVER-BTN] Sparkle emitter stopped (fading gracefully)');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY SHAPE HASH â€” Track selections to gate cover regeneration
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _lastCoverShapeHash = null;

  function computeStoryShapeHash() {
      // Combine all Story Shape selections into a deterministic string
      const parts = [
          state.picks?.world || '',
          state.picks?.genre || '',
          state.picks?.tone || '',
          state.picks?.dynamic || '',
          state.picks?.pov || '',
          state.archetype?.primary || '',
          state.archetype?.modifier || '',
          state.intensity || '',
          state.storyLength || ''
      ];
      return parts.join('|');
  }

  // Expose function to clear hash when Story Shape changes (called from card click handlers)
  window.clearCoverShapeHash = function() {
      _lastCoverShapeHash = null;
      console.log('[COVER:HASH] Cleared â€” regeneration enabled');
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GENERATE COVER BUTTON CLICK HANDLER â€” DISABLED (Earned Cover Phase B)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Pre-story cover generation is permanently disabled.
  // Use btnReaderCover in Reader mode instead.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnGenerateCover')?.addEventListener('click', async () => {
      // HARD BLOCK: Pre-story cover generation disabled (Earned Cover Phase B)
      console.warn('[COVER:BLOCKED] Pre-story cover generation disabled â€” use Reader cover button');
      showToast('Cover generation is available after starting your story');
      return;

      // === LEGACY CODE BELOW â€” UNREACHABLE ===
      const btn = $('btnGenerateCover');
      const status = $('coverGenStatus');
      const loading = $('coverGenLoading');
      const complete = $('coverGenComplete');
      const locked = $('coverGenLocked');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // IF BUTTON IS IN "SEE COVER" MODE, NAVIGATE TO COVER VIEW
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (_coverBtnIsBeginStory) {
          console.log('[COVER:NAV] Navigating to Cover View');
          showCoverView();
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STORY EXISTENCE GATE â€” Block cover generation if no story exists
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const storyContent = StoryPagination.getAllContent();
      if (!state.storyId || !storyContent || storyContent.trim().length === 0) {
          console.warn('[COVER:GATE] No story exists â€” cover generation blocked');
          showToast('Generate your story first before creating a cover');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STORY SHAPE HASH CHECK â€” Block regeneration if selections unchanged
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const currentHash = computeStoryShapeHash();
      if (_lastCoverShapeHash && _lastCoverShapeHash === currentHash && _coverGenUsed) {
          console.log('[COVER:HASH] Story Shape unchanged â€” regeneration blocked');
          showToast('Change your Story Shape selections to generate a new cover');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COVER$ CREDIT CHECK â€” Free credits or show purchase modal
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!hasFreeCoverCredits()) {
          console.log('[COVER$] Free credits exhausted â€” showing purchase modal');
          showCoverPurchaseModal();
          return;
      }

      // NOTE: Credit consumed AFTER successful generation (see below)

      // Show loading state
      btn.disabled = true;
      btn.textContent = 'Generating...';
      if (status) status.classList.remove('hidden');
      if (loading) loading.style.display = 'flex';
      if (complete) complete.classList.add('hidden');
      if (locked) locked.classList.add('hidden');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TITLE RESOLUTION CHECK â€” Wait for title, proceed with empty if timeout
      // No placeholder prose on covers â€” title renders only when finalized
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const MAX_TITLE_WAIT_MS = 8000; // 8 seconds max wait

      let resolvedTitle = $('storyTitle')?.textContent?.trim() || '';
      const isUnresolved = !resolvedTitle || resolvedTitle === 'Untitled' || resolvedTitle === '';

      if (isUnresolved) {
          console.log('[COVER:TITLE] Title unresolved, waiting for pipeline...');
          btn.textContent = 'Generating title...';

          // Poll for title resolution
          const startWait = Date.now();
          while (Date.now() - startWait < MAX_TITLE_WAIT_MS) {
              await new Promise(r => setTimeout(r, 300));
              resolvedTitle = $('storyTitle')?.textContent?.trim()
                  || state._backgroundStoryTitle?.trim()
                  || '';
              if (resolvedTitle && resolvedTitle !== 'Untitled' && resolvedTitle !== '') {
                  console.log('[COVER:TITLE] Title resolved:', resolvedTitle);
                  break;
              }
          }

          // If still unresolved after timeout, proceed with no title (no placeholder)
          if (!resolvedTitle || resolvedTitle === 'Untitled' || resolvedTitle === '') {
              resolvedTitle = '';
              console.log('[COVER:TITLE] Timeout, proceeding with no title');
          }

          btn.textContent = 'Generating...';
      }

      console.log('[COVER:TITLE] Proceeding with title:', resolvedTitle || '(none)');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // START FIREFLY EMITTER ON BUTTON (continuous while generating)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      startCoverButtonEmitter(btn);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // START STORY GENERATION IN BACKGROUND (parallel with cover)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!_backgroundStoryStarted) {
          console.log('[PARALLEL:GEN] Starting background story generation');
          _backgroundStoryStarted = true;
          _backgroundStoryPromise = startBackgroundStoryGeneration();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // START COVER GENERATION (fire and forget, but await for UI update)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      try {
          const coverUrl = await generateMinimalCoverV1({
              synopsis: state._synopsisMetadata || '',
              title: resolvedTitle,
              authorName: state.coverAuthor || 'Anonymous',
              world: state.picks?.world || 'Modern',
              genre: state.picks?.genre || 'Billionaire',
              tone: state.picks?.tone || 'Earnest',
              intensity: state.intensity || 'Naughty'
          });

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // VALIDATE COVER URL â€” Only proceed if we got a valid image
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (!coverUrl) {
              console.error('[COVER:GEN] Generation returned null/empty URL');
              stopCoverButtonEmitter();
              btn.textContent = 'Generation Failed - Try Again';
              btn.disabled = false;
              if (loading) loading.style.display = 'none';
              // NOTE: No credit consumed on failure
              return;
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // COVER$ CREDIT CONSUMPTION â€” Only on successful image URL
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          useFreeCredit();
          console.log('[COVER$] Free credit consumed on SUCCESS. Remaining:', getRemainingFreeCovers());

          _preGeneratedCoverUrl = coverUrl;
          _coverGenUsed = true;

          // Save Story Shape hash to gate future regeneration
          _lastCoverShapeHash = computeStoryShapeHash();
          console.log('[COVER:HASH] Saved hash:', _lastCoverShapeHash);

          console.log('[COVER:GEN] Cover URL acquired:', coverUrl.substring(0, 80) + '...');

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // COVER COMPLETE: Show success state, stop emitter
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          stopCoverButtonEmitter(); // Stop spawning, let existing particles fade
          if (loading) loading.style.display = 'none';
          if (complete) complete.classList.remove('hidden');

          // Replace button with "See Your Book Cover"
          btn.textContent = 'See Your Book Cover';
          btn.disabled = false;
          // PLAQUE REGIME: No opacity mutation â€” material is static
          btn.classList.add('begin-story-ready');
          _coverBtnIsBeginStory = true; // Mark button as ready to navigate

          console.log('[COVER:GEN] Cover complete, button now "See Your Book Cover"');

      } catch (err) {
          console.error('[COVER:PREGEN] Failed:', err);
          stopCoverButtonEmitter(); // Stop spawning on failure too
          btn.textContent = 'Generation Failed - Try Again';
          btn.disabled = false;
          if (loading) loading.style.display = 'none';
      }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // READER COVER BUTTON â€” Earned Cover System (Reader UI only)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // This is the ONLY authorized cover generation entry point.
  // Requires: state.storyId exists, story content exists
  // Cover stage is determined by story progress (turnCount + storyLength)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // READER COVER BUTTON â€” Opens Cover Gallery Modal (does NOT generate directly)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnReaderCover')?.addEventListener('click', () => {
      // STORY EXISTENCE GATE
      const storyContent = StoryPagination.getAllContent();
      if (!state.storyId || !storyContent || storyContent.trim().length === 0) {
          console.warn('[COVER:READER] No story exists â€” blocked');
          showToast('Generate your story first');
          return;
      }

      // PART B: Start generation IMMEDIATELY before modal opens
      const nextStage = getNextGeneratableStage();
      if (nextStage) {
          // Start generation now (async, don't await)
          _gallerySelectedStage = nextStage;
          generateCoverInGallery();
          console.log('[COVER:READER] Started generation for', nextStage, 'before modal open');
      }

      // Open the Cover Gallery Modal (generation already in progress)
      openCoverGalleryModal();
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER GALLERY MODAL BUTTON WIRING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnGalleryClose')?.addEventListener('click', closeCoverGalleryModal);
  $('btnGalleryGenerate')?.addEventListener('click', generateCoverInGallery);
  $('btnGalleryPrimary')?.addEventListener('click', selectCoverAsPrimary);
  $('btnGalleryPrev')?.addEventListener('click', galleryPrevStage);
  $('btnGalleryNext')?.addEventListener('click', galleryNextStage);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BACKGROUND STORY GENERATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // This function starts story generation in the background.
  // Returns a promise that resolves when story text is ready.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * Build world flavor directives for scene generation prompt.
   * Dystopia flavors inject narrative hook, erotic engine keywords, and scene bias.
   * Other worlds pass through worldSubtype as a simple label.
   */
  function buildWorldFlavorDirectives(world, worldSubtype) {
      if (!worldSubtype) return '';

      // Dystopia flavors have rich data models â€” bias stakes, fear, and intimacy mechanics
      if (world === 'Dystopia' && DYSTOPIA_FLAVORS[worldSubtype]) {
          const f = DYSTOPIA_FLAVORS[worldSubtype];
          const tone = state.picks?.tone || '';
          const isSatirical = tone === 'Satirical';
          let directives = `
WORLD FLAVOR: ${f.title} (${f.subtitle})
SCENE FRAMING (use as guidance, never quote verbatim):
${f.narrativeHook}
EROTIC DRIVERS: ${f.eroticEngine.join(', ')}
SCENE BIAS: pacing=${f.sceneBias.pacing}, intimacy-risk=${f.sceneBias.intimacyRisk}, power=${f.sceneBias.powerDynamic}
FLAVOR RULES:
- Bias STAKES (what intimacy threatens), FEAR (what can go wrong), and SOCIAL CONSEQUENCES.
- Do NOT bias prose style â€” the Tone axis controls that.
- Consequences are social and systemic, not only state punishment.`;
          if (!isSatirical) {
              directives += `
- ZERO comedic, whimsical, or absurdist framing. This is not satire. Play it straight.`;
          }
          return directives;
      }

      // Non-dystopia worlds: simple label pass-through
      const label = getWorldLabel(worldSubtype);
      return label ? `\nWORLD FLAVOR: ${label}` : '';
  }

  async function startBackgroundStoryGeneration() {
      console.log('[BACKGROUND:STORY] Starting background story generation');

      try {
          // Gather required state (same as Begin Story flow)
          const rawPlayerName = $('playerNameInput')?.value.trim() || "The Protagonist";
          const rawPartnerName = $('partnerNameInput')?.value.trim() || "The Love Interest";
          const pGen = $('customPlayerGender')?.value.trim() || $('playerGender')?.value || 'Female';
          const lGen = $('customLoveInterest')?.value.trim() || $('loveInterestGender')?.value || 'Male';
          const pPro = $('customPlayerPronouns')?.value.trim() || $('playerPronouns')?.value || 'She/Her';
          const lPro = $('customLovePronouns')?.value.trim() || $('lovePronouns')?.value || 'He/Him';
          const pAge = $('playerAgeInput')?.value.trim() || '';
          const lAge = $('partnerAgeInput')?.value.trim() || '';

          // Normalization
          let pKernel, lKernel;
          try {
              const playerNorm = await callNormalizationLayer({
                  axis: 'character',
                  user_text: rawPlayerName,
                  context_signals: state.picks?.world || []
              });
              const partnerNorm = await callNormalizationLayer({
                  axis: 'character',
                  user_text: rawPartnerName,
                  context_signals: state.picks?.world || []
              });
              pKernel = playerNorm.normalized_text || playerNorm.archetype || rawPlayerName;
              lKernel = partnerNorm.normalized_text || partnerNorm.archetype || rawPartnerName;
          } catch (normError) {
              console.warn('[BACKGROUND:STORY] Normalization failed, using raw names:', normError);
              pKernel = rawPlayerName;
              lKernel = rawPartnerName;
          }

          // Store in state
          state.normalizedPlayerKernel = pKernel;
          state.normalizedPartnerKernel = lKernel;
          state.rawPlayerName = rawPlayerName;
          state.rawPartnerName = rawPartnerName;
          state.gender = pGen;
          state.loveInterest = lGen;

          // Build system prompt (simplified version for background)
          const storyWorld = state.picks?.world || 'Modern';
          const storyGenre = state.picks?.genre || 'Billionaire';
          const storyPowerRole = resolvePowerRole(storyWorld, null, storyGenre);
          const storyPowerFrame = resolvePowerFrame(storyWorld, storyGenre);
          const archetypeDirectives = buildArchetypeDirectives(state.archetype?.primary, state.archetype?.modifier, lGen);
          const safetyStr = buildConsentDirectives();

          // Build world flavor directives (dystopia flavors inject scene bias)
          const worldFlavorDirectives = buildWorldFlavorDirectives(storyWorld, state.picks?.worldSubtype);

          const sysPrompt = `You are a bestselling erotica author.

LONG-FORM STORY ARC RULES (CRITICAL):
You are writing a serialized narrative, not a vignette.
Each response must advance character psychology, not just physical tension.
End most responses with a complication, choice, or destabilizing revelation.

You are writing a story with the following configuration:
- World: ${storyWorld}${state.picks?.worldSubtype ? ` (${getWorldLabel(state.picks.worldSubtype)})` : ''}
- Tone: ${state.picks?.tone || 'Earnest'}
- Genre: ${storyPowerRole}
- Power Frame: ${storyPowerFrame}
- Dynamic: ${state.picks?.dynamic || 'Enemies'}
- POV: ${state.picks?.pov || 'First'}
${worldFlavorDirectives}

Protagonist: ${pKernel} (${pGen}, ${pPro}${pAge ? `, age ${pAge}` : ''}).
Love Interest: ${lKernel} (${lGen}, ${lPro}${lAge ? `, age ${lAge}` : ''}).

${archetypeDirectives}
${safetyStr}

Current Intensity: ${state.intensity || 'Naughty'}
(Clean: Romance only. Naughty: Tension/Heat. Erotic: Explicit. Dirty: Raw/Unfiltered).

RULES:
1. Write in the selected POV.
2. Respond to the player's actions naturally.
3. Keep pacing slow and tense (unless Dirty).
4. Focus on sensory details, longing, and chemistry.
5. Be creative, surprising, and emotionally resonant.
6. BANNED WORDS/TOPICS: ${(state.veto?.bannedWords || []).join(', ')}.
7. TONE ADJUSTMENTS: ${(state.veto?.tone || []).join(', ')}.`;

          const introPrompt = buildScene1IntroPrompt(pKernel, lKernel, pGen, lGen, pPro, lPro);

          // Store system prompt for later use
          state.sysPrompt = sysPrompt;

          console.log('[BACKGROUND:STORY] Calling ChatGPT for Scene 1...');

          // Generate Scene 1
          let text = await callChat([
              { role: 'system', content: sysPrompt },
              { role: 'user', content: introPrompt }
          ]);

          // Check for prose refusal
          const refusalCheck = detectProseRefusal(text);
          if (refusalCheck.isRefusal) {
              console.error('[BACKGROUND:STORY] Prose refusal detected:', refusalCheck.reason);
              throw new ProseRefusalError(refusalCheck.reason, text);
          }

          // Parse and store result
          const { title, synopsis, body } = parseScene1Response(text);

          state.story = state.story || {};
          state.story.title = title;
          state.story.synopsis = synopsis;
          state._synopsisMetadata = synopsis;
          state._backgroundStoryText = body;
          state._backgroundStoryTitle = title;
          state._backgroundStorySynopsis = synopsis;

          console.log('[BACKGROUND:STORY] Scene 1 generated successfully');
          console.log('[BACKGROUND:STORY] Title:', title);

          return { success: true, title, synopsis, body };

      } catch (err) {
          console.error('[BACKGROUND:STORY] Generation failed:', err);
          return { success: false, error: err.message };
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARSE SCENE 1 RESPONSE (extract title, synopsis, body)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function parseScene1Response(text) {
      let title = 'Untitled';
      let synopsis = '';
      let body = text;

      // Try to extract title from [TITLE:...] or **Title:** patterns
      const titleMatch = text.match(/\[TITLE:\s*"?([^"\]]+)"?\]/i) ||
                         text.match(/\*\*Title:\*\*\s*(.+)/i) ||
                         text.match(/^#\s*(.+)/m);
      if (titleMatch) {
          title = titleMatch[1].trim().replace(/^["']|["']$/g, '');
          body = text.replace(titleMatch[0], '').trim();
      }

      // Try to extract synopsis
      const synopsisMatch = text.match(/\[SYNOPSIS:\s*"?([^"\]]+)"?\]/i) ||
                            text.match(/\*\*Synopsis:\*\*\s*(.+)/i);
      if (synopsisMatch) {
          synopsis = synopsisMatch[1].trim();
          body = body.replace(synopsisMatch[0], '').trim();
      }

      return { title, synopsis, body };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BUILD SCENE 1 INTRO PROMPT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function buildScene1IntroPrompt(pKernel, lKernel, pGen, lGen, pPro, lPro) {
      return `Write Scene 1 of this story.

Begin with a captivating opening that establishes:
1. The world and setting through sensory details
2. The protagonist's emotional state and immediate situation
3. The first glimpse or mention of the love interest
4. A hook or tension that draws the reader forward

Include at the start of your response:
[TITLE: "Your chosen title"]
[SYNOPSIS: "A one-sentence hook for this story"]

Then write the scene prose (800-1200 words).

Remember: This is the beginning of a longer story. Plant seeds, don't harvest.`;
  }

  // Expose for use in Begin Story flow
  window.getPreGeneratedCover = () => _preGeneratedCoverUrl;
  window.clearPreGeneratedCover = () => { _preGeneratedCoverUrl = null; };
  window.getBackgroundStoryPromise = () => _backgroundStoryPromise;
  window.isBackgroundStoryStarted = () => _backgroundStoryStarted;
  window.resetBackgroundStory = () => {
      _backgroundStoryPromise = null;
      _backgroundStoryStarted = false;
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RESET COVER GENERATION FLAGS â€” Re-arm system for new cover/story generation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Called by: AUTH RESET, BACK-TO-CONFIG RESET
  // Clears all "already generated" flags to allow fresh generation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window.resetCoverGenerationFlags = () => {
      console.log('[COVER:RESET] Resetting all cover/story generation flags');
      _coverGenUsed = false;
      _preGeneratedCoverUrl = null;
      _backgroundStoryPromise = null;
      _backgroundStoryStarted = false;
      _coverBtnIsBeginStory = false;

      // Reset button UI to initial state
      const btn = document.getElementById('btnGenerateCover');
      if (btn) {
          btn.textContent = 'Generate Your Cover';
          btn.disabled = false;
          // PLAQUE REGIME: No opacity mutation â€” material is static
          btn.classList.remove('begin-story-ready');
      }

      // Hide any completion indicators
      const complete = document.getElementById('coverGenComplete');
      if (complete) complete.classList.add('hidden');
      const locked = document.getElementById('coverGenLocked');
      if (locked) locked.classList.add('hidden');
      const status = document.getElementById('coverGenStatus');
      if (status) status.classList.add('hidden');
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER VIEW â€” Display generated cover with navigation buttons
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function showCoverView() {
      console.log('[COVER:VIEW] Showing Cover View');
      console.log('[COVER:VIEW] _preGeneratedCoverUrl:', _preGeneratedCoverUrl ? 'present' : 'NULL');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SCREEN TRANSITION: Enter 'game' screen for proper navigation
      // This ensures back button returns to setup correctly
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      window.showScreen('game');

      // Enter Cover View mode (disables click-to-open on book)
      if (window.enterCoverViewMode) window.enterCoverViewMode();

      // Update breadcrumb
      if (window.updateBreadcrumb) window.updateBreadcrumb('cover');

      // Set reader page to cover (page 0)
      if (typeof _readerPage !== 'undefined') _readerPage = 0;

      // Show book cover page elements
      const bookCoverPage = $('bookCoverPage');
      const bookObject = $('bookObject');
      const coverButtons = $('coverViewButtons');
      const storyContent = $('storyContent');

      if (bookCoverPage) bookCoverPage.classList.remove('hidden');
      if (bookObject) bookObject.classList.remove('hidden');
      if (coverButtons) coverButtons.classList.remove('hidden');
      if (storyContent) storyContent.classList.add('hidden');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COVER IMAGE OR FALLBACK â€” Never blocks progression
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const coverImg = $('bookCoverImg');
      const fallback = $('coverFallback');
      const fallbackTitle = $('fallbackTitle');

      // Always populate fallback title with current story title
      // Priority: state.story.title â†’ state._backgroundStoryTitle â†’ storyTitle DOM â†’ state.title â†’ fallback
      if (fallbackTitle) {
          const resolvedTitle = state.story?.title
              || state._backgroundStoryTitle
              || $('storyTitle')?.textContent
              || state.title
              || 'Your Story';
          fallbackTitle.textContent = resolvedTitle.replace(/^["']|["']$/g, '');
      }

      if (_preGeneratedCoverUrl) {
          // Show generated cover, hide fallback
          if (coverImg) {
              coverImg.src = _preGeneratedCoverUrl;
              coverImg.style.display = 'block';
              console.log('[COVER:VIEW] Generated cover displayed');
          }
          if (fallback) fallback.classList.add('hidden');
      } else {
          // Show intentional fallback design (no error messaging)
          console.log('[COVER:VIEW] Showing intentional fallback cover');
          if (fallback) fallback.classList.remove('hidden');
          if (coverImg) coverImg.style.display = 'none';
      }

      // Update Setting button state based on entitlement
      updateSettingButtonState();
  }

  function updateSettingButtonState() {
      const btnSeeSetting = $('btnSeeSetting');
      const notice = $('settingBtnDisabledNotice');
      if (!btnSeeSetting) return;

      // Check entitlement: StoryPass OR Subscriber
      const hasAccess = state.subscribed || (state.storyId && hasStoryPass(state.storyId)) || state.access === 'pass' || state.access === 'sub';

      // ALWAYS keep button enabled and clickable â€” paywall on click
      // Button must NEVER be disabled; click handler shows paywall for non-entitled users
      btnSeeSetting.disabled = false;
      btnSeeSetting.classList.remove('disabled');

      // Show/hide premium indicator notice (informational only, doesn't block click)
      if (hasAccess) {
          if (notice) notice.classList.add('hidden');
          btnSeeSetting.classList.remove('premium-locked');
      } else {
          if (notice) notice.classList.remove('hidden');
          btnSeeSetting.classList.add('premium-locked');
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SETTING VIEW â€” Generate and display setting image
  // NON-BLOCKING: User can always proceed; abort-aware; no charges on cancel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // TEST PLAN:
  // 1. Start setting image gen â†’ immediately click "Begin Story â†’" â†’ story loads fast;
  //    toast shows "Setting image skipped. You were not charged."
  // 2. Start setting image gen â†’ wait for success â†’ image shows; no modal trap
  // 3. Provider returns null / timeout â†’ fallback shows "Setting image unavailable";
  //    toast shows "Setting image unavailable. Continue without it.";
  //    "Try Again" button works.
  // 4. Credits do not decrement unless image URL is received and committed (success path only)
  // 5. After 10s, "Still workingâ€¦" hint appears; user can skip at any time
  // 6. "Back to Cover" aborts generation cleanly (no error logs)
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _settingAbortController = null;
  let _settingGenStartTime = null;

  function showSettingView() {
      console.log('[SETTING:VIEW] Showing Setting View');

      // Update breadcrumb
      if (window.updateBreadcrumb) window.updateBreadcrumb('setting');

      const settingView = $('settingView');
      const settingLoading = $('settingViewLoading');
      const settingContent = $('settingViewContent');
      const settingFallback = $('settingViewFallback');

      if (settingView) settingView.classList.remove('hidden');
      if (settingLoading) settingLoading.style.display = 'block';
      if (settingContent) settingContent.classList.add('hidden');
      if (settingFallback) settingFallback.classList.add('hidden');

      // Generate setting image
      generateSettingImage();
  }

  // Abort any in-flight setting image request
  function abortSettingImageGeneration() {
      if (_settingAbortController) {
          console.log('[SETTING:GEN] Aborting in-flight request');
          _settingAbortController.abort();
          _settingAbortController = null;
      }
  }

  // Check if error is an abort (user-initiated cancel)
  function isAbortError(err) {
      if (!err) return false;
      if (err.name === 'AbortError') return true;
      const msg = (err.message || '').toLowerCase();
      return msg.includes('abort') || msg.includes('signal is aborted');
  }

  async function generateSettingImage() {
      console.log('[SETTING:GEN] Starting setting image generation');

      // Abort any previous request
      abortSettingImageGeneration();

      // Create new abort controller for this request
      _settingAbortController = new AbortController();
      _settingGenStartTime = Date.now();

      // Show "still working" hint after 10s
      const longWaitTimer = setTimeout(() => {
          const hint = $('settingLongWaitHint');
          if (hint) hint.classList.remove('hidden');
      }, 10000);

      try {
          // Build a setting description from state
          const world = state.picks?.world || 'Modern';
          const genre = state.picks?.genre || 'Romance';
          const tone = state.picks?.tone || 'Earnest';
          const desc = `A ${tone.toLowerCase()} ${genre.toLowerCase()} setting in a ${world.toLowerCase()} world. Atmospheric, establishing shot. No characters visible.`;

          // Use the existing generateSettingShot function
          const rawUrl = await generateImageWithFallback({
              prompt: `Cinematic establishing shot. ${desc} Rich atmospheric lighting, detailed environment, professional composition. Landscape orientation.`,
              tier: 'Clean',
              shape: 'landscape',
              context: 'setting-view',
              intent: 'setting',
              signal: _settingAbortController?.signal
          });

          clearTimeout(longWaitTimer);

          // Check if aborted during generation
          if (_settingAbortController?.signal?.aborted) {
              console.log('[SETTING:GEN] CANCELLED by user');
              return; // Exit cleanly, no error
          }

          if (rawUrl) {
              let imageUrl = rawUrl;
              if (!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
                  imageUrl = `data:image/png;base64,${rawUrl}`;
              }

              const settingLoading = $('settingViewLoading');
              const settingContent = $('settingViewContent');
              const settingImg = $('settingViewImg');

              if (settingImg) settingImg.src = imageUrl;
              if (settingLoading) settingLoading.style.display = 'none';
              if (settingContent) settingContent.classList.remove('hidden');

              console.log('[SETTING:GEN] Setting image generated successfully');
              // BILLING: Only here would credits be charged (if applicable)
          } else {
              throw new Error('No image URL returned');
          }
      } catch (err) {
          clearTimeout(longWaitTimer);

          // Distinguish CANCELLED from FAILED
          if (isAbortError(err)) {
              console.log('[SETTING:GEN] CANCELLED (user navigation or abort)');
              // No toast needed here â€” shown by the function that triggered abort
              return;
          }

          console.error('[SETTING:GEN] FAILED:', err);
          // Show fallback view with "Begin Story" button (never blocks progression)
          const settingLoading = $('settingViewLoading');
          const settingFallback = $('settingViewFallback');
          if (settingLoading) settingLoading.style.display = 'none';
          if (settingFallback) settingFallback.classList.remove('hidden');
          console.log('[SETTING:GEN] Showing fallback - image unavailable');
          showToast('Setting image unavailable. Continue without it.');
      } finally {
          _settingAbortController = null;
          const hint = $('settingLongWaitHint');
          if (hint) hint.classList.add('hidden');
      }
  }

  function hideSettingView() {
      // Abort any in-flight setting image generation
      abortSettingImageGeneration();

      const settingView = $('settingView');
      const settingFallback = $('settingViewFallback');
      const settingContent = $('settingViewContent');
      const settingLoading = $('settingViewLoading');
      const settingLongWaitHint = $('settingLongWaitHint');
      if (settingView) settingView.classList.add('hidden');
      if (settingFallback) settingFallback.classList.add('hidden');
      if (settingContent) settingContent.classList.add('hidden');
      if (settingLoading) settingLoading.style.display = 'block'; // Reset for next time
      if (settingLongWaitHint) settingLongWaitHint.classList.add('hidden');
  }

  function hideCoverView() {
      const bookCoverPage = $('bookCoverPage');
      const coverButtons = $('coverViewButtons');
      if (bookCoverPage) bookCoverPage.classList.add('hidden');
      if (coverButtons) coverButtons.classList.add('hidden');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY ENTRY â€” Begin Scene 1 immediately
  // Aborts any in-flight setting image; user was not charged if cancelled
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  async function beginStoryEntry() {
      console.log('[STORY:ENTRY] Beginning story');

      // Check if setting image was still generating (user skipped)
      const wasGenerating = _settingAbortController !== null;

      // Exit Cover View mode (re-enables click navigation on book)
      if (window.exitCoverViewMode) window.exitCoverViewMode();

      // Update breadcrumb
      if (window.updateBreadcrumb) window.updateBreadcrumb('story');

      hideCoverView();
      hideSettingView(); // This aborts any in-flight setting image

      // Show toast if user skipped an in-progress generation
      if (wasGenerating) {
          showToast('Setting image skipped. You were not charged.');
      }

      // Trigger the actual Begin Story flow
      const beginBtn = $('beginBtn');
      if (beginBtn) {
          beginBtn.click();
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER VIEW BUTTON HANDLERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnSeeSetting')?.addEventListener('click', () => {
      // Check entitlement
      const hasAccess = state.subscribed || (state.storyId && hasStoryPass(state.storyId)) || state.access === 'pass' || state.access === 'sub';
      if (!hasAccess) {
          // CANONICAL: Use story metadata for paywall mode (persisted, immutable per-story)
          window.showPaywall(getPaywallMode());
          return;
      }
      showSettingView();
  });

  $('btnBeginStory')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  $('btnSettingBack')?.addEventListener('click', () => {
      hideSettingView();
      // Stay on cover view â€” restore breadcrumb to cover
      if (window.updateBreadcrumb) window.updateBreadcrumb('cover');
  });

  // Setting image click â†’ Begin Story
  $('settingViewContent')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  // Setting fallback "Begin Story" button
  $('btnSettingBeginStory')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  // Setting loading "Skip / Begin Story" button â€” non-blocking escape hatch
  $('btnSettingSkip')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  // Setting fallback "Try Again" button â€” retry generation
  $('btnSettingRetry')?.addEventListener('click', () => {
      const settingFallback = $('settingViewFallback');
      const settingLoading = $('settingViewLoading');
      if (settingFallback) settingFallback.classList.add('hidden');
      if (settingLoading) settingLoading.style.display = 'block';
      generateSettingImage();
  });

  // Expose for external use
  window.showCoverView = showCoverView;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB INDICATOR â€” Non-clickable orientation display
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Updates visual state only. No click handlers, no navigation, no state mutation.
  // Steps: shape â†’ cover â†’ setting â†’ story
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const BREADCRUMB_STEPS = ['shape', 'cover', 'setting', 'story'];

  function updateBreadcrumb(currentStep) {
      const breadcrumb = $('storyBreadcrumb');
      if (!breadcrumb) return;

      const stepIndex = BREADCRUMB_STEPS.indexOf(currentStep);
      if (stepIndex === -1) {
          // Unknown step â€” hide breadcrumb
          breadcrumb.classList.add('hidden');
          return;
      }

      // Show breadcrumb
      breadcrumb.classList.remove('hidden');

      // Update each step's visual state
      BREADCRUMB_STEPS.forEach((step, idx) => {
          const stepEl = breadcrumb.querySelector(`[data-step="${step}"]`);
          if (!stepEl) return;

          // Clear previous states
          stepEl.classList.remove('breadcrumb-current', 'breadcrumb-past', 'breadcrumb-future');

          if (idx === stepIndex) {
              stepEl.classList.add('breadcrumb-current');
          } else if (idx < stepIndex) {
              stepEl.classList.add('breadcrumb-past');
          } else {
              stepEl.classList.add('breadcrumb-future');
          }
      });

      // Update arrows between steps
      const arrows = breadcrumb.querySelectorAll('.breadcrumb-arrow');
      arrows.forEach((arrow, idx) => {
          arrow.classList.remove('breadcrumb-past');
          // Arrow index 0 is between cover and setting (step indices 1 and 2)
          // Arrow index 1 is between setting and story (step indices 2 and 3)
          const afterStepIndex = idx + 2; // arrows start after "cover" (index 1)
          if (afterStepIndex <= stepIndex) {
              arrow.classList.add('breadcrumb-past');
          }
      });

      console.log('[BREADCRUMB] Updated to:', currentStep);
  }

  function hideBreadcrumb() {
      const breadcrumb = $('storyBreadcrumb');
      if (breadcrumb) breadcrumb.classList.add('hidden');
  }

  // Expose for state updates
  window.updateBreadcrumb = updateBreadcrumb;
  window.hideBreadcrumb = hideBreadcrumb;

  document.querySelectorAll('.preview-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      $('previewText').textContent = btn.dataset.txt || '';
      document.getElementById('previewModal').classList.remove('hidden');
    });
  });

  // MODULE-SCOPE: Zoom state variables (accessible to all card systems)
  let currentOpenCard = null;
  let zoomBackdrop = null;
  let zoomPortal = null;
  // Store original parent/sibling for restoring card after zoom
  let zoomOriginalParent = null;
  let zoomOriginalNextSibling = null;

  function initSelectionHandlers(){
    state.safety = state.safety || { mode:'balanced', darkThemes:true, nonConImplied:false, violence:true, boundaries:["No sexual violence"] };

    // Initialize default dynamic (single-select in 4-axis system)
    if (!state.picks.dynamic) {
        state.picks.dynamic = 'Enemies';
    }

    // Bind Visual Auto-Lock
    const chkLock = document.getElementById('chkAutoLockVisual');
    if(chkLock && chkLock.dataset.bound !== '1') {
        chkLock.dataset.bound = '1';
        chkLock.addEventListener('change', (e) => { state.visual.autoLock = e.target.checked; saveStorySnapshot(); });
    }

    // Bind boundary chips (non-locked ones)
    document.querySelectorAll('.boundary-chips .chip-gold[data-boundary]').forEach(chip => {
        if (chip.dataset.bound === '1') return;
        chip.dataset.bound = '1';
        chip.addEventListener('click', () => {
            chip.classList.toggle('active');
            const boundary = chip.textContent.trim();
            if (chip.classList.contains('active')) {
                if (!state.safety.boundaries.includes(boundary)) {
                    state.safety.boundaries.push(boundary);
                }
            } else {
                state.safety.boundaries = state.safety.boundaries.filter(b => b !== boundary);
            }
        });
    });

    bindLengthHandlers();

    // ==========================================================================
    // CANONICAL ORDER: World â†’ Flavor â†’ Tone â†’ Genre â†’ Dynamic
    // ==========================================================================

    // Layer prerequisites - which selections must exist for a layer to be active
    const LAYER_PREREQUISITES = {
      world: [],           // Always active
      worldSubtype: ['world'],  // Requires World
      tone: ['world'],     // Requires World
      pressure: ['world', 'tone'], // Requires World + Tone (replaces genre as primary)
      flavor: ['world', 'tone', 'pressure'], // Requires Pressure
      genre: ['world', 'tone'], // LEGACY: derived from pressure+flavor, kept for compatibility
      dynamic: ['world', 'tone', 'pressure'], // Requires Pressure (not genre)
      era: ['world'],      // Requires World (Historical)
      pov: []              // Always active
    };

    // Tone Ã— Genre compatibility - null means all compatible
    // Format: { tone: [incompatible genres] }
    const TONE_GENRE_INCOMPATIBLE = {
      Comedic: ['Noir'],  // Comedic tone doesn't fit noir fatalism
      Horror: [],         // Horror works with most genres
      Satirical: [],      // Satirical can work with anything
      Mythic: [],         // Mythic is flexible
      Surreal: [],        // Surreal works widely
      Poetic: [],         // Poetic is flexible
      Earnest: [],        // Earnest works with everything
      WryConfession: [],  // Wry works broadly
      Dark: []            // Dark fits everything
    };

    // Genre Ã— Dynamic compatibility - null means all compatible
    // Format: { genre: [incompatible dynamics] }
    const GENRE_DYNAMIC_INCOMPATIBLE = {
      Noir: ['Comedic'],  // Noir fatalism clashes with pure comedy dynamics (if any existed)
      Heist: [],
      CrimeSyndicate: [],
      Billionaire: [],
      Espionage: [],
      Political: []
    };

    // Check if a genre is compatible with the current tone
    function isGenreCompatible(genre, tone) {
      if (!tone) return true;
      const incompatible = TONE_GENRE_INCOMPATIBLE[tone] || [];
      return !incompatible.includes(genre);
    }

    // Check if a dynamic is compatible with the current genre and tone
    function isDynamicCompatible(dynamic, genre, tone) {
      if (!genre) return true;
      const incompatible = GENRE_DYNAMIC_INCOMPATIBLE[genre] || [];
      return !incompatible.includes(dynamic);
    }

    // Check if a layer has its prerequisites met
    function isLayerUnlocked(grp) {
      const prereqs = LAYER_PREREQUISITES[grp] || [];
      return prereqs.every(p => !!state.picks[p]);
    }

    // Update layer visual state (inert/active)
    function updateLayerStates() {
      const layers = ['world', 'worldSubtype', 'tone', 'pressure', 'flavor', 'genre', 'dynamic'];

      layers.forEach(layer => {
        const cards = document.querySelectorAll(`.sb-card[data-grp="${layer}"]`);
        const unlocked = isLayerUnlocked(layer);

        cards.forEach(card => {
          if (!unlocked) {
            card.classList.add('layer-locked');
          } else {
            card.classList.remove('layer-locked');

            // Additional compatibility checks
            const val = card.dataset.val;
            if (layer === 'pressure') {
              const compatible = isPressureCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'flavor') {
              const compatible = isFlavorCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'genre') {
              const compatible = isGenreCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'dynamic') {
              const compatible = isDynamicCompatible(val, state.picks.genre, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            }
          }
        });

        // Update helper text for locked layers
        updateLayerHelperText(layer, unlocked);
      });
    }

    // Show/hide helper text for locked layers
    function updateLayerHelperText(layer, unlocked) {
      const helperTexts = {
        tone: 'Choose a World to continue',
        pressure: 'Choose a Tone to continue',
        genre: 'Choose a Tone to continue', // Legacy
        dynamic: 'Choose a Pressure to continue'
      };

      const sectionTitles = {
        tone: 'Tone',
        pressure: 'Pull',
        genre: 'Genre', // Legacy
        dynamic: 'Polarity'
      };

      // Find section title element
      const sections = document.querySelectorAll('.section-title');
      sections.forEach(section => {
        if (section.textContent.includes(sectionTitles[layer])) {
          let helper = section.querySelector('.layer-helper');
          if (!unlocked && helperTexts[layer]) {
            if (!helper) {
              helper = document.createElement('span');
              helper.className = 'layer-helper';
              section.appendChild(helper);
            }
            helper.textContent = ` â€” ${helperTexts[layer]}`;
            helper.style.display = 'inline';
          } else if (helper) {
            helper.style.display = 'none';
          }
        }
      });
    }

    // Re-evaluate downstream selections and clear only incompatible ones
    function evaluateDownstreamSelections(changedLayer) {
      const order = ['world', 'worldSubtype', 'tone', 'pressure', 'flavor', 'genre', 'dynamic'];
      const changedIdx = order.indexOf(changedLayer);

      // Check each downstream layer
      for (let i = changedIdx + 1; i < order.length; i++) {
        const layer = order[i];
        const currentVal = state.picks[layer];

        if (!currentVal) continue;

        let compatible = true;

        // Check pressure compatibility with tone
        if (layer === 'pressure' && state.picks.tone) {
          compatible = isPressureCompatible(currentVal, state.picks.tone);
        }

        // Check flavor compatibility with tone
        if (layer === 'flavor' && state.picks.tone) {
          compatible = isFlavorCompatible(currentVal, state.picks.tone);
        }

        // Check genre compatibility with tone (legacy)
        if (layer === 'genre' && state.picks.tone) {
          compatible = isGenreCompatible(currentVal, state.picks.tone);
        }

        // Check dynamic compatibility with genre/pressure
        if (layer === 'dynamic' && state.picks.genre) {
          compatible = isDynamicCompatible(currentVal, state.picks.genre, state.picks.tone);
        }

        // Auto-clear only if incompatible
        if (!compatible) {
          autoClearSelection(layer, currentVal);
        }
      }

      // Update flavor grid when tone changes
      if (changedLayer === 'tone' && state.picks.pressure) {
        updateFlavorGridState();
      }

      updateLayerStates();
    }

    // Auto-clear a selection with subtle feedback
    function autoClearSelection(layer, clearedVal) {
      // Clear from state
      state.picks[layer] = null;

      // Update UI
      const card = document.querySelector(`.sb-card[data-grp="${layer}"][data-val="${clearedVal}"]`);
      if (card) {
        card.classList.remove('selected');
        card.classList.add('auto-cleared');

        // Remove feedback after brief moment
        setTimeout(() => {
          card.classList.remove('auto-cleared');
        }, 1500);
      }

      // Dev-only warning
      if (typeof console !== 'undefined' && console.warn) {
        console.warn(`[State Repair] Auto-cleared incompatible ${layer}: ${clearedVal}`);
      }
    }

    // ==========================================================================
    // SELECTION CARD SYSTEM (5Ã—7 Flip Cards)
    // ==========================================================================

    // Sub-options data for each World type
    // Modern: NO custom field | All others: HAS custom field
    const WORLD_SUB_OPTIONS = {
      Modern: [
        { val: 'small_town', label: 'Small Town' },
        { val: 'college', label: 'College' },
        { val: 'friends', label: 'Friends' },
        { val: 'old_money', label: 'Old Money' },
        { val: 'office', label: '9-5 / Office' },
        { val: 'supernatural_modern', label: 'Supernatural' },
        { val: 'superheroic_modern', label: 'Superheroic' }
      ],
      Historical: [
        { val: 'prehistoric', label: 'Prehistoric' },
        { val: 'classical', label: 'Classical' },
        { val: 'medieval', label: 'Medieval' },
        { val: 'renaissance', label: 'Renaissance' },
        { val: 'victorian', label: 'Victorian' },
        { val: '20th_century', label: '20th Century' }
      ],
      Fantasy: [
        { val: 'enchanted_realms', label: 'Enchanted Realms' },
        { val: 'hidden_magic', label: 'Hidden Magic' },
        { val: 'cursed_worlds', label: 'Cursed Worlds' }
      ],
      SciFi: [
        { val: 'galactic_civilizations', label: 'Galactic Civilizations' },
        { val: 'future_of_science', label: 'Future of Science' },
        { val: 'cyberpunk', label: 'Cyberpunk' },
        { val: 'post_human', label: 'Post-Human' },
        { val: 'first_contact', label: 'First Contact' },
        { val: 'simulation', label: 'Simulation' },
        { val: 'final_frontier', label: 'Final Frontier' }
      ],
      Dystopia: [
        { val: 'glass_house', label: 'The Glass House' },
        { val: 'velvet_trap', label: 'The Velvet Trap' },
        { val: 'the_ledger', label: 'The Ledger' },
        { val: 'crimson_veil', label: 'The Crimson Veil' },
        { val: 'perfect_match', label: 'The Perfect Match' },
        { val: 'ministry_of_affection', label: 'The Ministry of Affection' },
        { val: 'endless_edit', label: 'The Endless Edit' }
      ],
      PostApocalyptic: [
        { val: 'nuclear_aftermath', label: 'Nuclear Aftermath' },
        { val: 'pandemic', label: 'Pandemic' },
        { val: 'climate_ruin', label: 'Climate Ruin' },
        { val: 'tech_fallout', label: 'Tech Fallout' },
        { val: 'slow_decay', label: 'Slow Decay' }
      ]
    };

    // Worlds that have custom text fields (all except Modern)
    // PASS 9F: Added Modern to enable custom modifier text field
    const WORLDS_WITH_CUSTOM_FIELD = ['Modern', 'Historical', 'Fantasy', 'SciFi', 'Dystopia', 'PostApocalyptic'];

    // Historical era remapping (legacy values â†’ new values)
    const HISTORICAL_ERA_REMAP = {
      'Ancient': 'prehistoric',
      'ancient': 'prehistoric',
      'Classical': 'classical',
      'Biblical': 'classical',
      'Medieval': 'medieval',
      'Renaissance': 'renaissance',
      'Early Modern': 'renaissance',
      'Victorian': 'victorian',
      'Industrial': 'victorian',
      'Early20th': '20th_century',
      'Mid20th': '20th_century',
      'Early 20th': '20th_century',
      'Mid-20th': '20th_century',
      '20th Century': '20th_century'
    };

    // Normalize custom field input (IP-safe transformation)
    // Accepts any input, returns normalized kernel
    function normalizeWorldCustom(input) {
      if (!input || typeof input !== 'string') return '';

      // Trim and clean whitespace
      let normalized = input.trim().replace(/\s+/g, ' ');

      // Cap length to prevent abuse
      if (normalized.length > 500) {
        normalized = normalized.substring(0, 500);
      }

      return normalized;
    }

    // Apply Historical era remapping (legacy â†’ new values)
    function applyHistoricalEraRemap() {
      // Check if we have a legacy era value that needs remapping
      if (state.picks.era && !state.picks.worldSubtype) {
        const remapped = HISTORICAL_ERA_REMAP[state.picks.era];
        if (remapped) {
          state.picks.worldSubtype = remapped;
        }
      }

      // Also check worldSubtype itself for legacy values
      if (state.picks.worldSubtype && HISTORICAL_ERA_REMAP[state.picks.worldSubtype]) {
        state.picks.worldSubtype = HISTORICAL_ERA_REMAP[state.picks.worldSubtype];
      }
    }

    function initSelectionCardSystem() {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ZOOM PORTAL ARCHITECTURE
      // Structure: body > backdrop (dims) > portal (holds zoomed card)
      // Backdrop: pointer-events:auto to catch clicks for closing
      // Portal: pointer-events:auto, sits ABOVE backdrop
      // Zoomed card: moved INTO portal, completely isolated from ancestors
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Create zoom backdrop (dims background, catches clicks to close)
      if (!document.getElementById('sbZoomBackdrop')) {
        zoomBackdrop = document.createElement('div');
        zoomBackdrop.id = 'sbZoomBackdrop';
        zoomBackdrop.className = 'sb-zoom-backdrop';
        document.body.appendChild(zoomBackdrop);

        // Close zoom on backdrop click
        zoomBackdrop.addEventListener('click', () => {
          closeZoomedCard();
        });
      } else {
        zoomBackdrop = document.getElementById('sbZoomBackdrop');
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Zoom Portal Invariant:
      // All zoomed cards MUST be moved into this portal.
      // No zoomed card may remain inside dimmed or transformed ancestors.
      // Do not replace with CSS-based isolation.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!document.getElementById('sbZoomPortal')) {
        zoomPortal = document.createElement('div');
        zoomPortal.id = 'sbZoomPortal';
        zoomPortal.className = 'sb-zoom-portal';
        document.body.appendChild(zoomPortal);
      } else {
        zoomPortal = document.getElementById('sbZoomPortal');
      }

      // Keyboard handler for Escape and arrow keys
      document.addEventListener('keydown', (e) => {
        if (!currentOpenCard) return;
        if (e.key === 'Escape') {
          closeZoomedCard();
          return;
        }
        // Arrow key navigation for archetype zoom
        if (currentOpenCard.classList.contains('archetype-card') && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
          const curId = currentOpenCard.dataset.archetype;
          if (!curId) return;
          const idx = ARCHETYPE_ORDER.indexOf(curId);
          if (idx === -1) return;
          const newIdx = e.key === 'ArrowLeft'
            ? (idx - 1 + ARCHETYPE_ORDER.length) % ARCHETYPE_ORDER.length
            : (idx + 1) % ARCHETYPE_ORDER.length;
          navigateZoomedArchetype(ARCHETYPE_ORDER[newIdx]);
        }
      });

      // REMOVED: convertCardsToSelectionCards() - World, Tone, Genre, Dynamic now use .sb-card system
    }

    function convertCardsToSelectionCards() {
      // Process each layer's card grid
      const grids = [
        { id: 'worldGrid', grp: 'world' },
        { id: 'toneGrid', grp: 'tone' },
        { id: 'genreGrid', grp: 'genre' }
      ];

      grids.forEach(({ id, grp }) => {
        const grid = document.getElementById(id);
        if (!grid) return;

        // Get existing cards
        const oldCards = grid.querySelectorAll('.sb-card[data-grp]');
        const cardData = [];

        oldCards.forEach(card => {
          cardData.push({
            val: card.dataset.val,
            title: card.querySelector('h3')?.textContent || '',
            desc: card.querySelector('p')?.textContent || '',
            selected: card.classList.contains('selected')
          });
        });

        // Clear and convert to selection grid
        grid.classList.remove('style-cards');
        grid.classList.add('selection-grid');
        grid.innerHTML = '';

        cardData.forEach(data => {
          const selCard = createSelectionCard(grp, data);
          grid.appendChild(selCard);
        });
      });

      // Handle dynamic cards (grouped structure)
      const dynamicGrid = document.getElementById('dynamicGrid');
      if (dynamicGrid) {
        const allDynamicCards = dynamicGrid.querySelectorAll('.sb-card[data-grp="dynamic"]');
        const cardData = [];

        allDynamicCards.forEach(card => {
          cardData.push({
            val: card.dataset.val,
            title: card.querySelector('h3')?.textContent || '',
            desc: card.querySelector('p')?.textContent || '',
            selected: card.classList.contains('selected')
          });
        });

        // Replace with flat selection grid
        dynamicGrid.innerHTML = '';
        dynamicGrid.classList.add('selection-grid');
        dynamicGrid.classList.remove('dynamic-grouped');

        cardData.forEach(data => {
          const selCard = createSelectionCard('dynamic', data);
          dynamicGrid.appendChild(selCard);
        });
      }

      // Update layer states for new cards
      updateSelectionCardStates();
    }

    function createSelectionCard(grp, data) {
      const card = document.createElement('div');
      card.className = 'selection-card';
      card.dataset.grp = grp;
      card.dataset.val = data.val;
      if (data.selected) card.classList.add('selected');

      card.innerHTML = `
        <div class="selection-card-inner">
          <div class="selection-card-face selection-card-front">
            <span class="card-title">${data.title}</span>
          </div>
          <div class="selection-card-face selection-card-back">
            <h4 class="card-title">${data.title}</h4>
            <p class="card-desc">${data.desc}</p>
          </div>
        </div>
      `;

      card.addEventListener('click', () => openSelectionCard(card, grp, data));

      return card;
    }

    // Legacy openSelectionCard - now uses portal zoom for .selection-card elements
    // NOTE: .selection-card system is deprecated - .sb-card is the canonical system
    function openSelectionCard(card, grp, data) {
      // Check if layer is unlocked
      if (!isLayerUnlocked(grp)) return;

      // Check if card is incompatible
      if (card.classList.contains('incompatible')) return;

      // Close any currently open card
      if (currentOpenCard) {
        closeZoomedCard();
      }

      currentOpenCard = card;

      // Dim all other cards
      document.querySelectorAll('.selection-card').forEach(c => {
        if (c !== card) c.classList.add('dimmed');
      });

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Store original DOM position for restoration
      zoomOriginalParent = card.parentNode;
      zoomOriginalNextSibling = card.nextElementSibling;

      // Store original position for animation reference
      card.dataset.zoomOriginalLeft = rect.left;
      card.dataset.zoomOriginalTop = rect.top;

      // TAROT ASPECT RATIO: 2.75 / 4.75 (canonical proportions)
      // Calculate zoomed size based on aspect ratio, not original rect
      const tarotAspect = 2.75 / 4.75;
      const sidePadding = 60;
      const topPadding = 40;
      const bottomPadding = 90; // modifier box + continue button + portal padding
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;

      // Calculate max dimensions that fit viewport while maintaining aspect ratio
      let zoomedWidth, zoomedHeight;
      if (maxWidth / maxHeight > tarotAspect) {
        // Height-constrained: fill height, calculate width from aspect
        zoomedHeight = maxHeight;
        zoomedWidth = zoomedHeight * tarotAspect;
      } else {
        // Width-constrained: fill width, calculate height from aspect
        zoomedWidth = maxWidth;
        zoomedHeight = zoomedWidth / tarotAspect;
      }

      // PORTAL MOVE: Move card into zoom portal
      if (zoomPortal) {
        zoomPortal.appendChild(card);
      }

      // Apply zoom styling - flexbox in portal handles centering
      card.classList.add('zoomed');
      card.style.width = `${zoomedWidth}px`;
      card.style.height = `${zoomedHeight}px`;
      card.style.transform = 'none';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';

      // Show backdrop
      if (zoomBackdrop) {
        zoomBackdrop.classList.add('active');
      }
    }

    function selectFromZoomedCard(grp, val) {
      // Update state
      state.picks[grp] = val;

      // Clear cover shape hash â€” selection changed, enable regeneration
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();

      // Update card selection states
      document.querySelectorAll(`.selection-card[data-grp="${grp}"]`).forEach(c => {
        const isSelected = c.dataset.val === val;
        c.classList.toggle('selected', isSelected);
        c.classList.toggle('flipped', isSelected);
      });

      // Also update old-style cards if any remain
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        const isSelected = c.dataset.val === val;
        c.classList.toggle('selected', isSelected);
        c.classList.toggle('flipped', isSelected);
      });

      // Handle World-specific updates
      if (grp === 'world') {
        updateWorldSubtypeVisibility(val, state.picks.tone);
        // Clear subtype if world changed
        if (state.picks.worldSubtype && !WORLD_SUB_OPTIONS[val]?.some(o => o.val === state.picks.worldSubtype)) {
          state.picks.worldSubtype = null;
        }
      }

      // Handle Tone-specific updates
      if (grp === 'tone') {
        updateWorldSubtypeVisibility(state.picks.world, val);
      }

      // Evaluate downstream selections
      evaluateDownstreamSelections(grp);

      // Increment DSP activation count (explicit Story Shape choice)
      incrementDSPActivation();

      // Update synopsis
      updateSynopsisPanel(true); // User action: card selection

      // Close after brief delay
      setTimeout(() => closeSelectionCard(), 300);
    }

    // Close zoomed card - returns card to original DOM position
    function closeZoomedCard() {
      if (!currentOpenCard) return;

      const wasArchetype = currentOpenCard.classList.contains('archetype-card');

      // Stop and remove zoom side sparkle emitters
      ['left', 'right', 'top', 'bottom'].forEach(side => {
        const id = `zoomSideSparkles_${side}`;
        stopSparkleEmitter(id);
        const el = currentOpenCard.querySelector(`#${id}`);
        if (el) el.remove();
      });

      // Remove zoom nav arrows and zoom continue button from portal
      if (zoomPortal) {
        zoomPortal.querySelectorAll('.zoom-nav-arrow, .zoom-continue-btn').forEach(el => el.remove());
      }

      // Remove any dynamically added zoom content
      const zoomContent = currentOpenCard.querySelector('.sb-zoom-content');
      if (zoomContent) {
        zoomContent.remove();
      }
      // Remove zoom flavor arc (world/pressure cards)
      const zoomFlavorArc = currentOpenCard.querySelector('.sb-zoom-flavor-arc');
      if (zoomFlavorArc) {
        zoomFlavorArc.remove();
      }

      // Remove zoom class and restore original positioning
      currentOpenCard.classList.remove('zoomed');
      currentOpenCard.style.transform = '';
      currentOpenCard.style.transformOrigin = '';
      currentOpenCard.style.left = '';
      currentOpenCard.style.top = '';
      currentOpenCard.style.width = '';
      currentOpenCard.style.height = '';
      currentOpenCard.style.position = '';

      // Remove inlined backgrounds (grid-scoped selectors take over once card is back)
      removeInlinedBackgrounds(currentOpenCard);

      // PORTAL RESTORE: Move card back to original DOM position
      if (zoomOriginalParent) {
        if (zoomOriginalNextSibling) {
          zoomOriginalParent.insertBefore(currentOpenCard, zoomOriginalNextSibling);
        } else {
          zoomOriginalParent.appendChild(currentOpenCard);
        }
      }
      zoomOriginalParent = null;
      zoomOriginalNextSibling = null;

      // Clean up stored position data
      delete currentOpenCard.dataset.zoomOriginalLeft;
      delete currentOpenCard.dataset.zoomOriginalTop;
      delete currentOpenCard.dataset.zoomOriginalWidth;
      delete currentOpenCard.dataset.zoomOriginalHeight;

      // Remove dimming from all cards (both .sb-card and .selection-card)
      document.querySelectorAll('.sb-card.dimmed, .selection-card.dimmed').forEach(c => {
        c.classList.remove('dimmed');
      });

      // Hide backdrop
      if (zoomBackdrop) {
        zoomBackdrop.classList.remove('active');
      }

      currentOpenCard = null;

      // Re-apply layer states
      updateSelectionCardStates();

      // Post-close: start corridor sparkles for archetype cards
      if (wasArchetype) {
        startLastZoomedSparkles();
      }
    }

    // Resize zoomed card on window resize (flexbox handles centering)
    function recenterZoomedCard() {
      if (!currentOpenCard || !currentOpenCard.classList.contains('zoomed')) return;

      const origWidth = parseFloat(currentOpenCard.dataset.zoomOriginalWidth) || 112;
      const origHeight = parseFloat(currentOpenCard.dataset.zoomOriginalHeight) || 193;
      const sidePadding = 60;
      const topPadding = 40;
      const bottomPadding = 90;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / origWidth, maxHeight / origHeight);

      // Flexbox handles centering, just update scale
      currentOpenCard.style.transform = `scale(${scale})`;
    }

    // Add resize listener for zoomed card centering
    window.addEventListener('resize', recenterZoomedCard);

    // Legacy alias for compatibility
    function closeSelectionCard() {
      closeZoomedCard();
    }

    // Inline computed background properties on card faces before portal move.
    // Grid-scoped selectors (#worldGrid .sb-card .sb-card-front, etc.) break
    // when the card is moved to the zoom portal, so we bake styles inline.
    function inlineCardFaceBackgrounds(card) {
      card.querySelectorAll('.sb-card-face').forEach(face => {
        if (face.dataset.bgInlined) return;
        const cs = getComputedStyle(face);
        const bg = cs.backgroundImage;
        if (bg && bg !== 'none') {
          face.style.backgroundImage = bg;
          face.style.backgroundSize = cs.backgroundSize;
          face.style.backgroundPosition = cs.backgroundPosition;
          face.style.backgroundRepeat = cs.backgroundRepeat;
          face.dataset.bgInlined = '1';
        }
      });
    }

    // Remove inlined backgrounds when card returns to grid
    function removeInlinedBackgrounds(card) {
      card.querySelectorAll('.sb-card-face').forEach(face => {
        if (face.dataset.bgInlined) {
          face.style.backgroundImage = '';
          face.style.backgroundSize = '';
          face.style.backgroundPosition = '';
          face.style.backgroundRepeat = '';
          delete face.dataset.bgInlined;
        }
      });
    }

    // STATE 3: Open zoomed view for .sb-card elements
    // PORTAL ARCHITECTURE: Card is MOVED into zoom portal (not just position:fixed)
    // This breaks out of ALL ancestor stacking contexts and filters
    function openSbCardZoom(card, grp, val) {
      // Close any currently open card
      if (currentOpenCard) {
        closeZoomedCard();
      }

      currentOpenCard = card;

      // Dim all other cards in same group
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        if (c !== card) c.classList.add('dimmed');
      });

      // For World cards, add flavor content to the front face
      if (grp === 'world') {
        populateWorldZoomContent(card, val);
      }

      // For Story Pull (pressure) cards, add flavor content to the front face
      if (grp === 'pressure') {
        populatePressureZoomContent(card, val);
      }

      // Inline background-image before portal move (grid-scoped selectors break in portal)
      inlineCardFaceBackgrounds(card);

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Store original DOM position for restoration
      zoomOriginalParent = card.parentNode;
      zoomOriginalNextSibling = card.nextElementSibling;

      // Store original position and dimensions for scale calculation
      card.dataset.zoomOriginalLeft = rect.left;
      card.dataset.zoomOriginalTop = rect.top;
      card.dataset.zoomOriginalWidth = rect.width;
      card.dataset.zoomOriginalHeight = rect.height;

      // SCALE ZOOM: Card stays at original size, scale() enlarges uniformly
      // This preserves the PNG art contract â€” text, buttons, art all scale together
      const sidePadding = 60;
      const topPadding = 40;
      const bottomPadding = 90;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / rect.width, maxHeight / rect.height);

      // PORTAL MOVE: Move card into zoom portal (breaks ALL ancestor contexts)
      if (zoomPortal) {
        zoomPortal.appendChild(card);
      }

      // Apply zoom: lock original dimensions, scale uniformly like a physical card
      card.classList.add('zoomed');
      card.style.width = `${rect.width}px`;
      card.style.height = `${rect.height}px`;
      card.style.transform = `scale(${scale})`;
      card.style.transformOrigin = 'center center';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';

      // Show backdrop
      if (zoomBackdrop) {
        zoomBackdrop.classList.add('active');
      }

      // Add left/right navigation arrows
      if (zoomPortal) {
        const siblings = zoomOriginalParent
          ? Array.from(zoomOriginalParent.querySelectorAll(`.sb-card[data-grp="${grp}"]`))
          : [];

        if (siblings.length > 1) {
          const leftArrow = document.createElement('div');
          leftArrow.className = 'zoom-nav-arrow zoom-nav-left';
          leftArrow.innerHTML = '&#8249;';
          leftArrow.addEventListener('click', (e) => {
            e.stopPropagation();
            navigateZoomedSbCard(-1);
          });
          zoomPortal.appendChild(leftArrow);

          const rightArrow = document.createElement('div');
          rightArrow.className = 'zoom-nav-arrow zoom-nav-right';
          rightArrow.innerHTML = '&#8250;';
          rightArrow.addEventListener('click', (e) => {
            e.stopPropagation();
            navigateZoomedSbCard(1);
          });
          zoomPortal.appendChild(rightArrow);
        }

        // Add Continue button
        const zoomContinueBtn = document.createElement('button');
        zoomContinueBtn.className = 'zoom-continue-btn';
        zoomContinueBtn.textContent = 'Continue';
        zoomContinueBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          commitSbCardFromZoom();
        });
        zoomPortal.appendChild(zoomContinueBtn);
      }

      // Add sparkle emitters to world/pressure zoomed cards (doubled rate on left/right)
      if (grp === 'world' || grp === 'pressure') {
        const frontFace = card.querySelector('.sb-card-front');
        if (frontFace) {
          ['left', 'right', 'top', 'bottom'].forEach(side => {
            const sparkleContainer = document.createElement('div');
            sparkleContainer.className = 'zoom-side-sparkles';
            sparkleContainer.id = `zoomSideSparkles_${side}`;
            sparkleContainer.dataset.side = side;
            frontFace.appendChild(sparkleContainer);
            const rate = (side === 'left' || side === 'right') ? 16 : 8;
            startSparkleEmitter(sparkleContainer.id, 'destinyDeck', rate);
          });
        }
      }
    }

    /**
     * Navigate between corridor cards while in zoom view.
     * direction: -1 for previous, +1 for next
     */
    function navigateZoomedSbCard(direction) {
      if (!currentOpenCard || !zoomPortal || !zoomOriginalParent) return;

      const grp = currentOpenCard.dataset.grp;
      const oldCard = currentOpenCard;

      // Get all sibling cards from the original grid (includes old card which is in portal)
      // Old card is in portal, so query grid siblings + include old card
      const gridSiblings = Array.from(
        zoomOriginalParent.querySelectorAll(`.sb-card[data-grp="${grp}"]`)
      );
      // Add old card back in to determine index
      const allCards = [...gridSiblings];
      // Find where old card WAS by looking at zoomOriginalNextSibling
      let oldIdx = -1;
      if (zoomOriginalNextSibling) {
        const nextIdx = allCards.indexOf(zoomOriginalNextSibling);
        oldIdx = nextIdx >= 0 ? nextIdx : allCards.length;
      } else {
        oldIdx = allCards.length;
      }
      // Insert old card reference at its original position
      allCards.splice(oldIdx, 0, oldCard);

      const currentIdx = allCards.indexOf(oldCard);
      const newIdx = (currentIdx + direction + allCards.length) % allCards.length;
      const newCard = allCards[newIdx];
      if (!newCard || newCard === oldCard) return;

      const newGrp = newCard.dataset.grp;
      const newVal = newCard.dataset.val;

      // Remove old zoom content and flavor arc
      const oldZoomContent = oldCard.querySelector('.sb-zoom-content');
      if (oldZoomContent) oldZoomContent.remove();
      const oldFlavorArc = oldCard.querySelector('.sb-zoom-flavor-arc');
      if (oldFlavorArc) oldFlavorArc.remove();

      // Stop and remove zoom side sparkle emitters from old card
      ['left', 'right', 'top', 'bottom'].forEach(side => {
        const id = `zoomSideSparkles_${side}`;
        stopSparkleEmitter(id);
        const el = oldCard.querySelector(`#${id}`);
        if (el) el.remove();
      });

      // Remove inlined backgrounds and restore old card to grid
      removeInlinedBackgrounds(oldCard);
      oldCard.classList.remove('zoomed');
      oldCard.style.transform = '';
      oldCard.style.width = '';
      oldCard.style.height = '';
      oldCard.style.position = '';
      if (zoomOriginalParent) {
        if (zoomOriginalNextSibling) {
          zoomOriginalParent.insertBefore(oldCard, zoomOriginalNextSibling);
        } else {
          zoomOriginalParent.appendChild(oldCard);
        }
      }
      delete oldCard.dataset.zoomOriginalLeft;
      delete oldCard.dataset.zoomOriginalTop;

      // Dim/undim cards
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        c.classList.toggle('dimmed', c !== newCard);
      });

      // Populate zoom content for new card
      if (newGrp === 'world') populateWorldZoomContent(newCard, newVal);
      if (newGrp === 'pressure') populatePressureZoomContent(newCard, newVal);

      // Inline backgrounds before portal move
      inlineCardFaceBackgrounds(newCard);

      // Store new card's position and move to portal
      const rect = newCard.getBoundingClientRect();
      zoomOriginalParent = newCard.parentNode;
      zoomOriginalNextSibling = newCard.nextElementSibling;
      newCard.dataset.zoomOriginalLeft = rect.left;
      newCard.dataset.zoomOriginalTop = rect.top;

      // SCALE ZOOM: Card stays at original size, scale() enlarges uniformly
      const sidePadding = 60;
      const topPadding = 40;
      const bottomPadding = 90;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / rect.width, maxHeight / rect.height);

      newCard.dataset.zoomOriginalWidth = rect.width;
      newCard.dataset.zoomOriginalHeight = rect.height;

      // Insert before nav arrows
      const firstArrow = zoomPortal.querySelector('.zoom-nav-arrow');
      if (firstArrow) {
        zoomPortal.insertBefore(newCard, firstArrow);
      } else {
        zoomPortal.appendChild(newCard);
      }

      newCard.classList.add('zoomed');
      newCard.style.width = `${rect.width}px`;
      newCard.style.height = `${rect.height}px`;
      newCard.style.transform = `scale(${scale})`;
      newCard.style.transformOrigin = 'center center';
      newCard.style.position = '';
      newCard.style.left = '';
      newCard.style.top = '';

      currentOpenCard = newCard;

      // Add sparkle emitters to new world/pressure card (doubled rate on left/right)
      if (newGrp === 'world' || newGrp === 'pressure') {
        const frontFace = newCard.querySelector('.sb-card-front');
        if (frontFace) {
          ['left', 'right', 'top', 'bottom'].forEach(side => {
            const sparkleContainer = document.createElement('div');
            sparkleContainer.className = 'zoom-side-sparkles';
            sparkleContainer.id = `zoomSideSparkles_${side}`;
            sparkleContainer.dataset.side = side;
            frontFace.appendChild(sparkleContainer);
            const rate = (side === 'left' || side === 'right') ? 16 : 8;
            startSparkleEmitter(sparkleContainer.id, 'destinyDeck', rate);
          });
        }
      }
    }

    /**
     * Commit selection from zoomed corridor card view.
     * Selects the card, creates breadcrumb, closes zoom, advances corridor.
     */
    function commitSbCardFromZoom() {
      if (!currentOpenCard) return;

      const grp = currentOpenCard.dataset.grp;
      const val = currentOpenCard.dataset.val;
      if (!grp || !val) return;

      // Update state (same as selectFromZoomedCard but without auto-close)
      state.picks[grp] = val;
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();

      // Mark card as selected
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        const isSelected = c.dataset.val === val;
        c.classList.toggle('selected', isSelected);
        c.classList.toggle('flipped', isSelected);
      });

      // Handle World-specific updates
      if (grp === 'world') {
        updateWorldSubtypeVisibility(val, state.picks.tone);
        if (state.picks.worldSubtype && !WORLD_SUB_OPTIONS[val]?.some(o => o.val === state.picks.worldSubtype)) {
          state.picks.worldSubtype = null;
        }
      }
      if (grp === 'tone') {
        updateWorldSubtypeVisibility(state.picks.world, val);
      }

      evaluateDownstreamSelections(grp);
      incrementDSPActivation();
      updateSynopsisPanel(true);

      // Get card title for breadcrumb
      const titleEl = currentOpenCard.querySelector('.sb-card-title');
      const selectedTitle = titleEl ? titleEl.textContent : val;

      // Close zoom
      closeZoomedCard();

      // Create breadcrumb and advance corridor
      createBreadcrumbDirect(grp, val, selectedTitle);

      // Find and hide the corridor continue button for this stage
      const stageMap = { world: 'world', tone: 'tone', pressure: 'pressure', pov: 'pov', length: 'length', dynamic: 'dynamic', intensity: 'arousal' };
      const stage = stageMap[grp] || grp;
      hideCorridorContinueButton(stage);

      setTimeout(() => advanceCorridorRow(), 600);
    }

    // Populate World card zoom view with flavor buttons and optional custom field
    function populateWorldZoomContent(card, worldVal) {
      const frontFace = card.querySelector('.sb-card-front');
      if (!frontFace) return;

      // Remove any existing zoom content and flavor arc
      const existing = frontFace.querySelector('.sb-zoom-content');
      if (existing) existing.remove();
      const existingArc = frontFace.querySelector('.sb-zoom-flavor-arc');
      if (existingArc) existingArc.remove();

      const flavors = WORLD_SUB_OPTIONS[worldVal] || [];
      const hasCustomField = WORLDS_WITH_CUSTOM_FIELD.includes(worldVal);

      // === FLAVOR ARC in the half-circle: ONLY the number ===
      if (flavors.length > 0) {
        var arcContainer = document.createElement('div');
        arcContainer.className = 'sb-zoom-flavor-arc';

        var num = document.createElement('span');
        num.className = 'arc-flavor-number';
        num.textContent = flavors.length;
        arcContainer.appendChild(num);
        frontFace.appendChild(arcContainer);
      }

      // === ZOOM CONTENT: "FLAVORS" label + flavor buttons + custom setting ===
      const zoomContent = document.createElement('div');
      zoomContent.className = 'sb-zoom-content';

      // "FLAVORS" curved text â€” bottom-of-circle arc, sits below the arch, above buttons
      if (flavors.length > 0) {
        var ns = 'http://www.w3.org/2000/svg';
        var svg = document.createElementNS(ns, 'svg');
        svg.setAttribute('class', 'sb-zoom-flavor-label');
        svg.setAttribute('viewBox', '0 0 100 18');
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

        var defs = document.createElementNS(ns, 'defs');
        var path = document.createElementNS(ns, 'path');
        var pathId = 'zoomFlavorArc_' + (++_flavorArcUid);
        path.setAttribute('id', pathId);
        // Downward arc (bottom of circle) â€” sweep-flag=0 curves down
        path.setAttribute('d', 'M 15,6 A 100,100 0 0,0 85,6');
        path.setAttribute('fill', 'none');
        defs.appendChild(path);
        svg.appendChild(defs);

        var text = document.createElementNS(ns, 'text');
        text.setAttribute('fill', '#c9a84c');
        text.setAttribute('font-size', '6');
        text.setAttribute('font-family', 'Cinzel, serif');
        text.setAttribute('font-variant', 'small-caps');
        text.setAttribute('letter-spacing', '2');

        var textPath = document.createElementNS(ns, 'textPath');
        textPath.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + pathId);
        textPath.setAttribute('startOffset', '50%');
        textPath.setAttribute('text-anchor', 'middle');
        textPath.textContent = 'flavors';

        text.appendChild(textPath);
        svg.appendChild(text);
        zoomContent.appendChild(svg);
      }

      // Flavor buttons directly under the FLAVORS label
      if (flavors.length > 0) {
        const flavorGrid = document.createElement('div');
        flavorGrid.className = 'sb-zoom-flavors';

        flavors.forEach(flavor => {
          const btn = document.createElement('button');
          btn.className = 'sb-flavor-btn';
          btn.textContent = flavor.label;
          btn.dataset.val = flavor.val;

          if (state.picks.worldSubtype === flavor.val) {
            btn.classList.add('selected');
          }

          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (state.picks.worldSubtype === flavor.val) {
              state.picks.worldSubtype = null;
              btn.classList.remove('selected');
            } else {
              flavorGrid.querySelectorAll('.sb-flavor-btn').forEach(b => b.classList.remove('selected'));
              state.picks.worldSubtype = flavor.val;
              btn.classList.add('selected');
            }
            incrementDSPActivation();
            updateSynopsisPanel(true);
          });

          flavorGrid.appendChild(btn);
        });

        zoomContent.appendChild(flavorGrid);
      }

      // Custom setting box (above the bottom title text box)
      if (hasCustomField) {
        const customWrapper = document.createElement('div');
        customWrapper.className = 'sb-zoom-custom';

        const customLabel = document.createElement('label');
        customLabel.className = 'sb-zoom-custom-label';
        customLabel.textContent = 'Custom Setting:';

        const inputWrapper = document.createElement('div');
        inputWrapper.className = 'sb-zoom-custom-wrapper';

        const customInput = document.createElement('textarea');
        customInput.className = 'sb-zoom-custom-input';
        customInput.id = 'worldCustomInput-' + Date.now();
        customInput.value = state.worldCustomText || '';
        customInput.rows = 2;

        // Scrolling flavor examples â€” show this world's flavor labels in grey italic
        const rotatingPlaceholder = document.createElement('div');
        rotatingPlaceholder.className = 'sb-zoom-rotating-placeholder';

        const flavorLabels = (WORLD_SUB_OPTIONS[worldVal] || []).map(f => f.label);
        if (flavorLabels.length > 0) {
          const doubled = [...flavorLabels, ...flavorLabels];
          let html = '<span class="sb-zoom-placeholder-inner">';
          doubled.forEach((s, i) => {
            html += `<span class="suggestion">${s}</span>`;
            if (i < doubled.length - 1) html += '<span class="separator">\u2022</span>';
          });
          html += '</span>';
          rotatingPlaceholder.innerHTML = html;
        }

        const updatePlaceholderVisibility = () => {
          if (customInput.value.trim().length > 0) {
            rotatingPlaceholder.classList.add('hidden');
          } else {
            rotatingPlaceholder.classList.remove('hidden');
          }
        };

        customInput.addEventListener('input', (e) => {
          state.worldCustomText = normalizeWorldCustom(e.target.value);
          updatePlaceholderVisibility();
        });

        customInput.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        customInput.addEventListener('focus', () => {
          const inner = rotatingPlaceholder.querySelector('.sb-zoom-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'paused';
        });

        customInput.addEventListener('blur', () => {
          const inner = rotatingPlaceholder.querySelector('.sb-zoom-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'running';
          updatePlaceholderVisibility();
        });

        inputWrapper.appendChild(customInput);
        inputWrapper.appendChild(rotatingPlaceholder);
        customWrapper.appendChild(customLabel);
        customWrapper.appendChild(inputWrapper);
        zoomContent.appendChild(customWrapper);

        updatePlaceholderVisibility();
      }

      frontFace.appendChild(zoomContent);
    }

    // Populate Story Pull (pressure) card zoom view with flavor buttons
    function populatePressureZoomContent(card, pressureVal) {
      const frontFace = card.querySelector('.sb-card-front');
      if (!frontFace) return;

      // Remove any existing zoom content and flavor arc
      const existing = frontFace.querySelector('.sb-zoom-content');
      if (existing) existing.remove();
      const existingArc = frontFace.querySelector('.sb-zoom-flavor-arc');
      if (existingArc) existingArc.remove();

      const flavors = PRESSURE_FLAVORS[pressureVal] || [];
      if (flavors.length === 0) return;

      // === FLAVOR ARC in the half-circle: ONLY the number ===
      var arcContainer = document.createElement('div');
      arcContainer.className = 'sb-zoom-flavor-arc';

      var num = document.createElement('span');
      num.className = 'arc-flavor-number';
      num.textContent = flavors.length;
      arcContainer.appendChild(num);
      frontFace.appendChild(arcContainer);

      // === ZOOM CONTENT: "FLAVORS" label + flavor buttons ===
      const zoomContent = document.createElement('div');
      zoomContent.className = 'sb-zoom-content';

      // "FLAVORS" curved text â€” bottom-of-circle arc, below the arch, above buttons
      var ns = 'http://www.w3.org/2000/svg';
      var svg = document.createElementNS(ns, 'svg');
      svg.setAttribute('class', 'sb-zoom-flavor-label');
      svg.setAttribute('viewBox', '0 0 100 18');
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      var defs = document.createElementNS(ns, 'defs');
      var path = document.createElementNS(ns, 'path');
      var pathId = 'zoomPressureArc_' + (++_flavorArcUid);
      path.setAttribute('id', pathId);
      // Downward arc (bottom of circle) â€” sweep-flag=0 curves down
      path.setAttribute('d', 'M 15,6 A 100,100 0 0,0 85,6');
      path.setAttribute('fill', 'none');
      defs.appendChild(path);
      svg.appendChild(defs);

      var text = document.createElementNS(ns, 'text');
      text.setAttribute('fill', '#c9a84c');
      text.setAttribute('font-size', '6');
      text.setAttribute('font-family', 'Cinzel, serif');
      text.setAttribute('font-variant', 'small-caps');
      text.setAttribute('letter-spacing', '2');

      var textPath = document.createElementNS(ns, 'textPath');
      textPath.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + pathId);
      textPath.setAttribute('startOffset', '50%');
      textPath.setAttribute('text-anchor', 'middle');
      textPath.textContent = 'flavors';

      text.appendChild(textPath);
      svg.appendChild(text);
      zoomContent.appendChild(svg);

      const flavorGrid = document.createElement('div');
      flavorGrid.className = 'sb-zoom-flavors';

      flavors.forEach(flavor => {
        const btn = document.createElement('button');
        btn.className = 'sb-flavor-btn';
        btn.textContent = flavor.label;
        btn.dataset.val = flavor.id;
        btn.title = flavor.description || '';

        if (state.picks.flavor === flavor.id) {
          btn.classList.add('selected');
        }

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (state.picks.flavor === flavor.id) {
            state.picks.flavor = null;
            btn.classList.remove('selected');
          } else {
            flavorGrid.querySelectorAll('.sb-flavor-btn').forEach(b => b.classList.remove('selected'));
            state.picks.flavor = flavor.id;
            btn.classList.add('selected');
          }
          state.picks.genre = getEffectiveGenre(pressureVal, state.picks.flavor);
          incrementDSPActivation();
          updateSynopsisPanel(true);
        });

        flavorGrid.appendChild(btn);
      });

      zoomContent.appendChild(flavorGrid);
      frontFace.appendChild(zoomContent);
    }

    function updateSelectionCardStates() {
      const layers = ['world', 'tone', 'genre', 'dynamic'];

      layers.forEach(layer => {
        const cards = document.querySelectorAll(`.selection-card[data-grp="${layer}"]`);
        const unlocked = isLayerUnlocked(layer);

        cards.forEach(card => {
          const val = card.dataset.val;

          // Layer locking
          card.classList.toggle('layer-locked', !unlocked);

          // Compatibility check for genre/dynamic
          if (unlocked) {
            if (layer === 'genre') {
              const compatible = isGenreCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'dynamic') {
              const compatible = isDynamicCompatible(val, state.picks.genre, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else {
              card.classList.remove('incompatible');
            }
          }

          // Selection state - toggle both selected and flipped
          const isSelected = state.picks[layer] === val;
          card.classList.toggle('selected', isSelected);
          card.classList.toggle('flipped', isSelected);
        });
      });
    }

    // UNIFIED SINGLE-SELECT: ALL card groups use this handler - NO separate handlers
    const SINGLE_SELECT_AXES = ['world', 'tone', 'pressure', 'flavor', 'genre', 'dynamic', 'era', 'pov', 'worldSubtype', 'intensity', 'length'];

    document.querySelectorAll('.sb-card[data-grp]').forEach(card => {
      if(card.dataset.bound === '1') return;
      card.dataset.bound = '1';
      card.addEventListener('click', (e) => {
        if(e.target.closest('.preview-btn')) return;
        const grp = card.dataset.grp;
        const val = card.dataset.val;
        if(!grp || !val) return;

        // Length cards locked after game starts
        if (grp === 'length' && state.turnCount > 0) return;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SUBSCRIPTION SHORT-CIRCUIT: Subscribers bypass all paywall checks
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!state.subscribed) {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // DATA-LEVEL STORYPASS CHECK: Read from card's data attribute
          // Cards with data-storypass-allowed="false" ONLY show Subscribe
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const storypassAllowedAttr = card.dataset.storypassAllowed;
          const isSubOnlyCard = storypassAllowedAttr === 'false';

          if (isSubOnlyCard) {
            console.log(`[PAYWALL:DATA] Card ${grp}/${val} has storypassAllowed=false, Subscribe-only`);
            window.showPaywall('sub_only');
            return;
          }

          // Intensity/length paywall checks using canonical eligibility
          if (grp === 'intensity' || grp === 'length') {
            const tempState = grp === 'intensity'
              ? { ...state, intensity: val }
              : { ...state, storyLength: val };
            if (!isStorypassAllowed(tempState)) {
              window.showPaywall('sub_only'); return;
            }
            if (grp === 'intensity' && val === 'Erotic' && state.access === 'free') {
              window.openEroticPreview(); return;
            }
          }

          // Locked card: use correct paywall mode based on canonical eligibility
          if(card.classList.contains('locked')) {
            // CANONICAL: Use story metadata for paywall mode (persisted, immutable per-story)
            window.showPaywall(getPaywallMode());
            return;
          }
        }

        // Check if layer is unlocked (prerequisites met)
        if (!isLayerUnlocked(grp)) {
          // Layer is inert - do nothing
          return;
        }

        // Check if card is incompatible
        if (card.classList.contains('incompatible')) {
          // Incompatible selection - do nothing
          return;
        }

        // THREE-STATE CARD INTERACTION MODEL:
        // STATE 1 (face-down) â†’ STATE 2 (face-up/selected): First click on unselected card
        // STATE 2 (face-up) â†’ STATE 3 (zoomed): Second click on already-selected card
        // NEVER deselect by clicking same card - only another card in group can deselect

        const isAlreadySelected = card.classList.contains('selected') && card.classList.contains('flipped');

        if (isAlreadySelected) {
          // STATE 2 â†’ STATE 3: Open zoom view (NEVER deselect)
          openSbCardZoom(card, grp, val);
          return;
        }

        // STATE 1 â†’ STATE 2: Select this card, deselect others in same group

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DESTRUCTIVE CHANGE CHECK: Warn before changing locked fields
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (typeof wouldDestroyStory === 'function' && wouldDestroyStory(grp, val)) {
          // Show warning modal, defer actual selection until confirmed
          showDestructiveChangeWarning(grp, val, card, (confirmedGrp, confirmedVal, confirmedCard) => {
            // Execute the selection after confirmation
            executeCardSelection(confirmedGrp, confirmedVal, confirmedCard);
          });
          return;
        }

        // Proceed with selection
        executeCardSelection(grp, val, card);
      });
    });

    // Build flavor arc element: number in arch + curved "FLAVORS" text
    var _flavorArcUid = 0;
    function buildFlavorArc(count) {
      var container = document.createElement('div');
      container.className = 'sb-card-arc-flavors';

      // Number
      var num = document.createElement('span');
      num.className = 'arc-flavor-number';
      num.textContent = count;
      container.appendChild(num);

      // SVG with curved "FLAVORS" text along underside of arch
      var ns = 'http://www.w3.org/2000/svg';
      var svg = document.createElementNS(ns, 'svg');
      svg.setAttribute('class', 'arc-flavor-svg');
      svg.setAttribute('viewBox', '0 0 100 14');
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

      var defs = document.createElementNS(ns, 'defs');
      var path = document.createElementNS(ns, 'path');
      var pathId = 'flavorArcPath_' + (++_flavorArcUid);
      path.setAttribute('id', pathId);
      // Arc curving upward â€” text hangs below the half-circle, following its shape
      path.setAttribute('d', 'M 20,2 A 35,35 0 0,1 80,2');
      path.setAttribute('fill', 'none');
      defs.appendChild(path);
      svg.appendChild(defs);

      var text = document.createElementNS(ns, 'text');
      text.setAttribute('fill', 'rgba(218,165,32,0.7)');
      text.setAttribute('font-size', '6');
      text.setAttribute('font-family', 'Cinzel, serif');
      text.setAttribute('font-variant', 'small-caps');
      text.setAttribute('letter-spacing', '2');
      text.setAttribute('dominant-baseline', 'hanging');

      var textPath = document.createElementNS(ns, 'textPath');
      textPath.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + pathId);
      textPath.setAttribute('startOffset', '50%');
      textPath.setAttribute('text-anchor', 'middle');
      textPath.textContent = 'flavors';

      text.appendChild(textPath);
      svg.appendChild(text);
      container.appendChild(svg);
      return container;
    }

    /**
     * Execute a card selection (extracted to allow deferred execution after destructive change confirmation)
     */
    function executeCardSelection(grp, val, card) {
        // Update state based on card group
        if (grp === 'intensity') {
          state.intensity = val;
          state.picks.intensity = val;
          // NOTE: intensity is a RUNTIME MODIFIER â€” does NOT invalidate story shape
        } else if (grp === 'length') {
          state.storyLength = val;
          applyLengthLocks(); // Re-apply locks after selection
          // NOTE: storyLength is a RUNTIME MODIFIER â€” does NOT invalidate story shape
        } else {
          state.picks[grp] = val;
          // STORY-DEFINING INPUT: Invalidate snapshot â†’ forces "Begin Story"
          if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();
        }

        // Clear cover shape hash â€” selection changed, enable regeneration
        if (window.clearCoverShapeHash) window.clearCoverShapeHash();

        // Deselect all other cards in this group, select this one
        document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
          c.classList.remove('selected', 'flipped');
          // Remove any flavor count indicators (old pill + new arc)
          const oldFlavorCount = c.querySelector('.sb-card-flavor-count');
          if (oldFlavorCount) oldFlavorCount.remove();
          const oldArc = c.querySelector('.sb-card-arc-flavors');
          if (oldArc) oldArc.remove();
          // Fade out sparkles on deselected cards
          const oldSparkleContainer = c.querySelector('.card-selection-sparkles');
          if (oldSparkleContainer && typeof stopSparkleEmitter === 'function') {
            stopSparkleEmitter(oldSparkleContainer.id);
            oldSparkleContainer.classList.add('sparkles-fading');
            setTimeout(() => oldSparkleContainer.remove(), 1200);
          }
        });
        card.classList.add('selected', 'flipped');

        // Start sparkles on selected card
        let sparkleContainer = card.querySelector('.card-selection-sparkles');
        if (!sparkleContainer) {
          sparkleContainer = document.createElement('div');
          sparkleContainer.className = 'card-selection-sparkles';
          sparkleContainer.id = `cardSparkles_${grp}_${val}`;
          card.appendChild(sparkleContainer);
        }
        if (typeof startSparkleEmitter === 'function') {
          startSparkleEmitter(sparkleContainer.id, 'destinyDeck', 6);
        }

        // Add flavor arc indicator for World cards (number + curved "FLAVORS" in top arch)
        if (grp === 'world') {
          const flavors = WORLD_SUB_OPTIONS[val] || [];
          if (flavors.length > 0) {
            const frontFace = card.querySelector('.sb-card-front');
            if (frontFace && !frontFace.querySelector('.sb-card-arc-flavors')) {
              frontFace.appendChild(buildFlavorArc(flavors.length));
            }
          }
          updateWorldSubtypeVisibility(val, state.picks.tone);
        }

        // PRESSURE SELECTION: Flavor lives INSIDE zoomed pressure card, NOT as separate row
        // Flavor options rendered via populatePressureZoomContent() when card is zoomed
        if (grp === 'pressure') {
          // Clear any previous flavor selection (new pressure = fresh slate)
          state.picks.flavor = null;
          // Sync to legacy genre using pressure's default
          state.picks.genre = getEffectiveGenre(val, null);
          // Add flavor arc indicator to selected pressure card
          const flavors = PRESSURE_FLAVORS[val] || [];
          if (flavors.length > 0) {
            const frontFace = card.querySelector('.sb-card-front');
            if (frontFace && !frontFace.querySelector('.sb-card-arc-flavors')) {
              frontFace.appendChild(buildFlavorArc(flavors.length));
            }
          }
        }

        // FLAVOR SELECTION: Sync to legacy genre and update world breadcrumb
        if (grp === 'flavor') {
          state.picks.genre = getEffectiveGenre(state.picks.pressure, val);
          // Update world breadcrumb to show nested flavor
          if (typeof updateWorldBreadcrumbFlavor === 'function') {
            updateWorldBreadcrumbFlavor();
          }
        }

        // POV SELECTION: Dissolve ephemeral breadcrumbs (Mode)
        if (grp === 'pov') {
          // Ephemeral layers (Solo/Couple mode) dissolve when POV is committed
          if (typeof dissolveEphemeralBreadcrumbs === 'function') {
            dissolveEphemeralBreadcrumbs();
            console.log('[Breadcrumb] POV selected â€” ephemeral breadcrumbs dissolving');
          }
        }

        // Special handling: show/hide Horror subtypes when Tone changes
        if (grp === 'tone') {
          updateWorldSubtypeVisibility(state.picks.world, val);
        }

        // Evaluate downstream selections for compatibility
        evaluateDownstreamSelections(grp);

        // Increment DSP activation count (explicit Story Shape choice)
        incrementDSPActivation();

        // Update DSP segment based on selection axis
        if (grp === 'world' && DSP_WORLD_PHRASES[val]) {
          activateDSPSegment('world', 'In ' + DSP_WORLD_PHRASES[val]);
        } else if (grp === 'pressure') {
          // Pressure selection: use pressure DSP phrase (flavor may override later)
          const dspPhrase = getPressureDSPPhrase(val, state.picks.flavor);
          activateDSPSegment('genre', ', shaped by ' + dspPhrase);
        } else if (grp === 'flavor') {
          // Flavor selection: update DSP with flavor-specific phrase
          const dspPhrase = getPressureDSPPhrase(state.picks.pressure, val);
          activateDSPSegment('genre', ', shaped by ' + dspPhrase);
        } else if (grp === 'genre' && DSP_GENRE_PARAPHRASES[val]) {
          // Legacy genre selection (backward compatibility)
          activateDSPSegment('genre', ', shaped by ' + DSP_GENRE_PARAPHRASES[val]);
        } else if (grp === 'dynamic' && state.archetype?.primary && DSP_ARCHETYPE_ADJECTIVES[state.archetype.primary]) {
          activateDSPSegment('archetype', ', a question awaits: Will ' + DSP_ARCHETYPE_ADJECTIVES[state.archetype.primary]);
        } else if (grp === 'tone' && DSP_TONAL_ADJECTIVES[val]) {
          activateDSPSegment('tone', ' desire redeem this ' + DSP_TONAL_ADJECTIVES[val]);
        } else if (grp === 'length') {
          const AFFAIR_WORD_MAP = { tease: 'tease', fling: 'fling', affair: 'affair', soulmates: 'cosmic connection' };
          activateDSPSegment('length', ' ' + (AFFAIR_WORD_MAP[val] || 'affair') + '\u2009\u2014\u2009or ruin it?');
        } else if (grp === 'pov') {
          // POV changes the pronoun in the archetype clause â€” full re-render
        }

        // Update floating synopsis panel
        updateSynopsisPanel(true); // User action: card click

        // Update corridor Continue button visibility (card selected â†’ show Continue)
        if (typeof window.updateCorridorContinueButtonVisibility === 'function') {
          window.updateCorridorContinueButtonVisibility();
        }
    }

    // Initialize World Subtype visibility based on initial selections
    updateWorldSubtypeVisibility(state.picks.world, state.picks.tone);
    // Flavor: Lives INSIDE zoomed pressure card, no global initialization needed
    // Initialize synopsis panel (not a user action - keeps placeholder)
    updateSynopsisPanel();
    // Initialize layer states (gating, compatibility)
    updateLayerStates();
    // Initialize selection card system
    initSelectionCardSystem();
    // Apply any legacy Historical era remapping
    applyHistoricalEraRemap();
    // Initialize Breadcrumb Flow System
    initBreadcrumbFlow();
    // Initialize Archetype System BEFORE corridor (corridor unmounts the grid from DOM)
    initArchetypeUI();
    // Initialize Corridor State Machine (9-row single-screen selection)
    if (typeof initCorridor === 'function') {
      initCorridor();
    }
    // Initialize Destructive Change Modal
    if (typeof initDestructiveChangeModal === 'function') {
      initDestructiveChangeModal();
    }

    // Name refining indicator helpers
    function showNameRefiningIndicator(inputEl) {
      let indicator = inputEl.parentElement?.querySelector('.name-refining-indicator');
      if (!indicator) {
        indicator = document.createElement('span');
        indicator.className = 'name-refining-indicator';
        indicator.innerHTML = '<span class="refining-dot">â—</span> Refining nameâ€¦';
        inputEl.parentElement?.appendChild(indicator);
      }
      indicator.style.display = 'inline';
    }

    function hideNameRefiningIndicator(inputEl) {
      const indicator = inputEl.parentElement?.querySelector('.name-refining-indicator');
      if (indicator) indicator.style.display = 'none';
    }

    // Player name normalization (DSP no longer includes names â€” no DSP refresh needed)
    const playerNameInput = $('playerNameInput');
    if (playerNameInput) {
      playerNameInput.addEventListener('input', () => {
        state.normalizedPlayerKernel = playerNameInput.value.trim() || 'the one who carries the story';
        // Name entry does NOT trigger DSP update â€” names are not in DSP
      });
      playerNameInput.addEventListener('blur', async () => {
        const raw = playerNameInput.value.trim();
        if (!raw) return;
        showNameRefiningIndicator(playerNameInput);
        const norm = await callNormalizationLayer({
          axis: 'character',
          user_text: raw,
          context_signals: state.picks?.world || []
        });
        hideNameRefiningIndicator(playerNameInput);
        const kernel = norm.normalized_text || norm.archetype || 'the one who carries the story';
        state.normalizedPlayerKernel = kernel;
        state.rawPlayerName = raw;
        playerNameInput.value = kernel;
        // Name entry does NOT trigger DSP update â€” names are not in DSP
      });
    }

    // Normalize partner name on blur (DSP no longer includes names â€” no DSP refresh needed)
    const partnerNameInput = $('partnerNameInput');
    if (partnerNameInput) {
      partnerNameInput.addEventListener('input', () => {
        // Update archetype row title with Love Interest name
        if (typeof updateArchetypeSectionTitle === 'function') {
          updateArchetypeSectionTitle();
        }
      });
      partnerNameInput.addEventListener('blur', async () => {
        const raw = partnerNameInput.value.trim();
        if (!raw) return;
        showNameRefiningIndicator(partnerNameInput);
        const norm = await callNormalizationLayer({
          axis: 'character',
          user_text: raw,
          context_signals: state.picks?.world || []
        });
        hideNameRefiningIndicator(partnerNameInput);
        const kernel = norm.normalized_text || norm.archetype || 'the one who draws them forward';
        state.normalizedPartnerKernel = kernel;
        state.rawPartnerName = raw;
        partnerNameInput.value = kernel;
        // Update archetype row title with normalized name
        if (typeof updateArchetypeSectionTitle === 'function') {
          updateArchetypeSectionTitle();
        }
      });
    }

    // Expose closeZoomedCard for module-scope callers (archetype overlay, zoom continue)
    window.closeZoomedCard = closeZoomedCard;
  }

  // Debounce utility for input handlers
  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WORLD SUBTYPE VISIBILITY - Show/hide subtype selections per world
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * Maps world values to their subtype selection container IDs.
   * Only these worlds have subtype options:
   * - SciFi, Fantasy, Horror (tone-based), Dystopia, PostApocalyptic
   */
  const WORLD_SUBTYPE_MAP = {
    Modern: 'modernSubtypeSelection',
    SciFi: 'scifiSubtypeSelection',
    Fantasy: 'fantasySubtypeSelection',
    Dystopia: 'dystopiaSubtypeSelection',
    PostApocalyptic: 'apocalypseSubtypeSelection'
  };

  // Horror subtypes are shown when Horror TONE is selected with certain worlds
  const HORROR_ELIGIBLE_WORLDS = ['Fantasy', 'Modern'];

  function updateWorldSubtypeVisibility(worldValue, toneValue) {
    // CORRECTIVE: World flavors now appear ONLY in the zoomed card popup
    // Hide all below-card subtype sections permanently
    Object.values(WORLD_SUBTYPE_MAP).forEach(id => {
      const section = document.getElementById(id);
      if (section) section.classList.add('hidden');
    });
    const horrorSection = document.getElementById('horrorSubtypeSelection');
    if (horrorSection) horrorSection.classList.add('hidden');

    // Clear worldSubtype from state when world changes
    if (state.picks.worldSubtype) {
      delete state.picks.worldSubtype;
    }

    // DISABLED: Below-card sections are no longer shown
    // Flavors now only appear in the zoomed world card popup
    return;

    // Show relevant subtype section based on world
    const subtypeSectionId = WORLD_SUBTYPE_MAP[worldValue];
    if (subtypeSectionId) {
      const section = document.getElementById(subtypeSectionId);
      if (section) section.classList.remove('hidden');
    }

    // Show horror subtypes if Horror tone is selected with eligible world
    if (toneValue === 'Horror' && HORROR_ELIGIBLE_WORLDS.includes(worldValue)) {
      if (horrorSection) horrorSection.classList.remove('hidden');
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FLAVOR GRID â€” Optional refinement for Primary Pressure selection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Show or hide the flavor grid
   * @param {boolean} show - Whether to show the grid
   */
  function showFlavorGrid(show) {
    const flavorTitle = document.getElementById('flavorTitle');
    const flavorGrid = document.getElementById('flavorGrid');
    if (flavorTitle) flavorTitle.style.display = show ? '' : 'none';
    if (flavorGrid) flavorGrid.style.display = show ? '' : 'none';
  }

  /**
   * Populate the flavor grid with options for the selected pressure
   * @param {string} pressureId - The selected primary pressure
   */
  function populateFlavorGrid(pressureId) {
    const flavorGrid = document.getElementById('flavorGrid');
    if (!flavorGrid) return;

    const flavors = PRESSURE_FLAVORS[pressureId] || [];
    flavorGrid.innerHTML = '';

    if (flavors.length === 0) {
      showFlavorGrid(false);
      return;
    }

    flavors.forEach(flavor => {
      const card = document.createElement('div');
      card.className = 'sb-card';
      card.dataset.grp = 'flavor';
      card.dataset.val = flavor.id;

      // Check if this flavor is currently selected
      if (state.picks.flavor === flavor.id) {
        card.classList.add('selected', 'flipped');
      }

      // Check flavor compatibility with current tone
      if (!isFlavorCompatible(flavor.id, state.picks.tone)) {
        card.classList.add('incompatible');
      }

      card.innerHTML = `
        <div class="sb-card-inner">
          <div class="sb-card-face sb-card-back">
            <span class="sb-card-title">${flavor.label}</span>
          </div>
          <div class="sb-card-face sb-card-front">
            <span class="sb-card-title">${flavor.label}</span>
            <span class="sb-card-desc">${flavor.description}</span>
          </div>
        </div>
      `;

      // Bind click handler (same as other sb-cards)
      card.dataset.bound = '1';
      card.addEventListener('click', (e) => {
        if (e.target.closest('.preview-btn')) return;
        const grp = card.dataset.grp;
        const val = card.dataset.val;

        // Check layer unlock
        if (!isLayerUnlocked(grp)) return;
        if (card.classList.contains('incompatible')) return;

        // FLAVOR TOGGLE: Clicking selected flavor deselects it (flavors are optional)
        if (card.classList.contains('selected') && card.classList.contains('flipped')) {
          // Deselect flavor
          card.classList.remove('selected', 'flipped');
          state.picks.flavor = null;
          state.picks.genre = getEffectiveGenre(state.picks.pressure, null);
          // Update DSP with pressure-only phrase
          const dspPhrase = getPressureDSPPhrase(state.picks.pressure, null);
          activateDSPSegment('genre', ', shaped by ' + dspPhrase);
          updateSynopsisPanel(true);
          return;
        }

        // Select this flavor, deselect others
        state.picks[grp] = val;
        state.picks.genre = getEffectiveGenre(state.picks.pressure, val);

        // Clear cover shape hash
        if (window.clearCoverShapeHash) window.clearCoverShapeHash();

        // Update card states
        flavorGrid.querySelectorAll('.sb-card[data-grp="flavor"]').forEach(c => {
          c.classList.remove('selected', 'flipped');
        });
        card.classList.add('selected', 'flipped');

        // Update DSP
        const dspPhrase = getPressureDSPPhrase(state.picks.pressure, val);
        activateDSPSegment('genre', ', shaped by ' + dspPhrase);

        // Invalidate shape snapshot
        if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();
        incrementDSPActivation();
        updateSynopsisPanel(true);
      });

      flavorGrid.appendChild(card);
      if (window.applyCardGleam) window.applyCardGleam(card);
    });
  }

  /**
   * Update flavor grid when pressure or tone changes
   * Called after pressure selection or tone change to refresh compatibility
   */
  function updateFlavorGridState() {
    const flavorGrid = document.getElementById('flavorGrid');
    if (!flavorGrid) return;

    flavorGrid.querySelectorAll('.sb-card[data-grp="flavor"]').forEach(card => {
      const val = card.dataset.val;
      // Update compatibility
      const compatible = isFlavorCompatible(val, state.picks.tone);
      card.classList.toggle('incompatible', !compatible);
      // Update selection state
      const isSelected = state.picks.flavor === val;
      card.classList.toggle('selected', isSelected);
      card.classList.toggle('flipped', isSelected);
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB FLOW SYSTEM â€” Sequential card selection with committed breadcrumbs
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // INTERACTION MODEL:
  // 1. One row of cards at a time
  // 2. Selection â†’ Continue â†’ Breadcrumb
  // 3. Selected card animates to breadcrumb row
  // 4. Other cards dissipate with sparkles
  // 5. Next row fades in
  //
  // FLOW ORDER: pressure â†’ world â†’ tone â†’ dynamic
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB PERSISTENCE AUTHORITY (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PERSISTENT BREADCRUMBS (Final State - 8Â±1 items):
  //   guidedFate, storybeau, length, world, tone, pressure, pov, dynamic
  //   Flavor is NESTED inside World breadcrumb (sub-label), not its own item
  //
  // DROPPED AFTER USE (Dissolve at POV selection):
  //   mode (Solo/Couple) â€” temporary mode indicator
  //   Note: Tease is a Story Length value, persists if selected
  //
  // NEVER BECOMES BREADCRUMB:
  //   intensity (arousal) â€” NEVER collapses to breadcrumb at any phase
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Layers that persist as final breadcrumbs
   * Order matches approximate selection flow
   */
  const BREADCRUMB_PERSISTENT_LAYERS = [
    'guidedFate',  // Destiny card click (special handling)
    'archetype',   // Storybeau selection
    'length',      // Story length (tease/fling/affair/soulmates)
    'world',       // World setting
    'tone',        // Narrative tone
    'pressure',    // Story pressure
    'pov',         // Point of view
    'dynamic'      // Relationship dynamic
  ];

  /**
   * Layers that show temporarily but dissolve at POV selection
   * These sparkle-dissipate when POV is committed
   */
  const BREADCRUMB_EPHEMERAL_LAYERS = [
    'mode'         // Solo/Couple â€” dissolves at POV
  ];

  /**
   * Layers that NEVER become breadcrumbs
   * Arousal is the primary exclusion â€” it can change without destroying cover
   */
  const BREADCRUMB_EXCLUDED_LAYERS = [
    // (intensity/arousal now gets a breadcrumb)
  ];

  /**
   * Check if a layer should become a breadcrumb
   * @param {string} grp - The layer group name
   * @returns {boolean} True if layer can become breadcrumb
   */
  function canBecomeBreadcrumb(grp) {
    // EXCLUDED: Never becomes breadcrumb
    if (BREADCRUMB_EXCLUDED_LAYERS.includes(grp)) {
      console.log(`[Breadcrumb] EXCLUDED: ${grp} â€” never becomes breadcrumb`);
      return false;
    }
    // PERSISTENT or EPHEMERAL: Can become breadcrumb
    return BREADCRUMB_PERSISTENT_LAYERS.includes(grp) ||
           BREADCRUMB_EPHEMERAL_LAYERS.includes(grp);
  }

  /**
   * Check if a layer should dissolve at POV selection
   * @param {string} grp - The layer group name
   * @returns {boolean} True if layer dissolves at POV
   */
  function shouldDissolveAtPOV(grp) {
    return BREADCRUMB_EPHEMERAL_LAYERS.includes(grp);
  }

  /**
   * Dissolve ephemeral breadcrumbs when POV is selected
   * Called when POV selection is committed
   */
  function dissolveEphemeralBreadcrumbs() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    BREADCRUMB_EPHEMERAL_LAYERS.forEach(grp => {
      const ephemeralCard = breadcrumbRow.querySelector(`.breadcrumb-card[data-grp="${grp}"]`);
      if (ephemeralCard) {
        console.log(`[Breadcrumb] Dissolving ephemeral: ${grp}`);

        // Create sparkle effect before removal
        createDissipationSparkles(ephemeralCard);

        // Add dissolve animation
        ephemeralCard.classList.add('breadcrumb-dissolving');

        // Remove after animation
        setTimeout(() => {
          ephemeralCard.remove();
          console.log(`[Breadcrumb] Ephemeral removed: ${grp}`);
        }, 600);
      }
    });
  }

  /**
   * Get display label for a breadcrumb, with flavor nested in world
   * @param {string} grp - The layer group
   * @param {string} val - The selected value
   * @returns {object} { title, subtitle } for breadcrumb display
   */
  function getBreadcrumbLabel(grp, val) {
    const labels = {
      authorship: { title: val === 'manual' ? 'Choose Your Hand' : 'Guided Fate', subtitle: null },
      identity: {
        // Use displayName for UI (breadcrumb), canonicalName stored separately for prose
        title: state.picks?.identity?.displayPlayerName
          ? state.picks.identity.displayPlayerName
          : (state.picks?.identity?.playerName || val),
        subtitle: 'Character'
      },
      archetype: { title: val, subtitle: 'Storybeau' },
      length: { title: val, subtitle: 'Length' },
      world: {
        title: val,
        subtitle: state.picks?.flavor ? state.picks.flavor : null
      },
      tone: { title: val, subtitle: null },
      pressure: {
        title: val,
        subtitle: 'Story Pull'  // Renamed from "Pull" to "Story Pull"
      },
      pov: { title: val, subtitle: 'POV' },
      dynamic: { title: val, subtitle: 'Polarity' },
      intensity: { title: val, subtitle: 'Intensity' },
      safety: { title: 'Safety', subtitle: null },
      vetoquill: { title: 'Veto/Quill', subtitle: null },
      beginstory: { title: 'Begin Story', subtitle: null },
      mode: { title: val, subtitle: 'Mode' }
    };

    return labels[grp] || { title: val, subtitle: grp };
  }

  /**
   * Update world breadcrumb to include nested flavor
   * Called when flavor selection changes
   */
  function updateWorldBreadcrumbFlavor() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    const worldBreadcrumb = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="world"]');
    if (!worldBreadcrumb) return;

    const flavor = state.picks?.flavor;
    const subtitleEl = worldBreadcrumb.querySelector('.breadcrumb-subtitle');

    if (flavor) {
      if (subtitleEl) {
        subtitleEl.textContent = flavor;
      } else {
        // Create subtitle element if it doesn't exist
        const titleEl = worldBreadcrumb.querySelector('.sb-card-title');
        if (titleEl) {
          const newSubtitle = document.createElement('span');
          newSubtitle.className = 'breadcrumb-subtitle';
          newSubtitle.textContent = flavor;
          titleEl.insertAdjacentElement('afterend', newSubtitle);
        }
      }
      console.log(`[Breadcrumb] World flavor nested: ${flavor}`);
    } else if (subtitleEl) {
      subtitleEl.remove();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB CORRIDOR STATE MACHINE (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // CORRIDOR ORDER (9 rows, single-screen one-at-a-time):
  // 0: guidedFate   â€” Destiny card (auto-select or manual)
  // 1: storybeau    â€” Archetype selection
  // 2: world        â€” Story world setting
  // 3: tone         â€” Narrative tone
  // 4: pressure     â€” Story pressure axis
  // 5: pov          â€” Story point of view
  // 6: length       â€” Story length selection
  // 7: dynamic      â€” Relationship dynamic
  // 8: arousal      â€” Intensity (EXCLUDED from breadcrumbs)
  //
  // BREADCRUMBS: Rows 0-7 become breadcrumbs on selection
  // Arousal (row 8) NEVER becomes a breadcrumb
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const CORRIDOR_STAGES = [
    'authorship',  // Row 0 - Authorship choice (Choose Your Hand / Guided Fate)
    'identity',    // Row 1 - Character names (only shown if Choose Your Hand)
    'storybeau',   // Row 2 - Archetype
    'world',       // Row 3 - Story world
    'tone',        // Row 4 - Narrative tone
    'pressure',    // Row 5 - Story Pull
    'pov',         // Row 6 - Point of view
    'length',      // Row 7 - Story length
    'dynamic',     // Row 8 - Polarity
    'arousal',     // Row 9 - Intensity
    'safety',      // Row 10 - Safety & Boundaries
    'vetoquill',   // Row 11 - Veto / Quill
    'beginstory'   // Row 12 - Begin Story (terminal row)
  ];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STAGE_INDEX â€” SINGLE AUTHORITATIVE MAP: grp â†’ fixed corridor index
  // All breadcrumb placement MUST use this map. No positional inference or fallbacks.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const STAGE_INDEX = {
    authorship: 0,   // Choice I: Authorship (Choose Your Hand / Guided Fate)
    identity: 1,     // Choice II: Character names (only if Choose Your Hand)
    storybeau: 2,    // Choice III: Archetype/Storybeau
    archetype: 2,    // Alias for storybeau
    world: 3,        // Choice IV: Story World
    tone: 4,         // Choice V: Narrative Tone
    pressure: 5,     // Choice VI: Story Pull
    pov: 6,          // Choice VII: Point of View
    length: 7,       // Choice VIII: Story Length
    dynamic: 8,      // Choice IX: Polarity/Dynamic
    arousal: 9,      // Choice X: Intensity/Arousal
    intensity: 9,    // Alias for arousal
    safety: 10,      // Choice XI: Safety & Boundaries
    vetoquill: 11,   // Choice XII: Veto / Quill
    beginstory: 12   // Terminal: Begin Story (no breadcrumb)
  };

  // Map corridor stage names to their data-grp values (for DOM queries)
  const CORRIDOR_GRP_MAP = {
    authorship: 'authorship',
    identity: 'identity',
    storybeau: 'archetype',
    world: 'world',
    tone: 'tone',
    pressure: 'pressure',
    pov: 'pov',
    length: 'length',
    dynamic: 'dynamic',
    arousal: 'intensity',
    safety: 'safety',
    vetoquill: 'vetoquill',
    beginstory: 'beginstory'
  };

  // Expose STAGE_INDEX globally for breadcrumb system
  window.STAGE_INDEX = STAGE_INDEX;

  // Map corridor stage names to their container IDs
  const CORRIDOR_ROW_IDS = {
    authorship: 'authorshipChoiceRow',
    storybeau: 'corridorRowStorybeau',
    world: 'corridorRowWorld',
    tone: 'corridorRowTone',
    pressure: 'corridorRowPressure',
    pov: 'corridorRowPov',
    length: 'corridorRowLength',
    dynamic: 'corridorRowDynamic',
    arousal: 'corridorRowArousal',
    safety: 'safetyRow',
    vetoquill: 'vetoquillRow',
    beginstory: 'beginStoryRow'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORRIDOR CONTRACT (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INVARIANT 1: Exactly ONE corridor row may be active at any time
  // INVARIANT 2: All completed/future rows must be unmounted from DOM, not CSS-hidden
  // INVARIANT 3: corridorActiveRowIndex is the ONLY source of truth for visibility
  // INVARIANT 4: No visual fix may mask a state or logic bug
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Corridor state machine - SINGLE SOURCE OF TRUTH
  let corridorActiveRowIndex = 0;
  const corridorSelections = new Map();

  // DOM mount/unmount storage - stores elements and their insertion anchors
  // Structure: Map<stage, { elements: Element[], anchors: Comment[] }>
  const corridorRowStore = new Map();

  // Legacy BREADCRUMB_FLOW_STAGES kept for button ID compatibility only
  const BREADCRUMB_FLOW_STAGES = ['pressure', 'world', 'tone', 'dynamic'];

  /**
   * Initialize the breadcrumb flow system
   */
  function initBreadcrumbFlow() {
    // Bind continue buttons
    const continueButtons = {
      pressure: document.getElementById('continueFromPressure'),
      world: document.getElementById('continueFromWorld'),
      tone: document.getElementById('continueFromTone'),
      dynamic: document.getElementById('continueFromDynamic')
    };

    Object.entries(continueButtons).forEach(([stage, btn]) => {
      if (btn) {
        btn.addEventListener('click', () => handleFlowContinue(stage));
      }
    });

    // Update continue button visibility on card selection
    document.querySelectorAll('.card-flow-row .sb-card[data-grp]').forEach(card => {
      card.addEventListener('click', () => {
        setTimeout(() => updateContinueButtonVisibility(), 100);
      });
    });

    // Initialize first stage
    updateFlowStageIndicator();
    updateContinueButtonVisibility();
  }

  /**
   * Check if a selection exists for the current flow stage
   */
  function hasSelectionForStage(stage) {
    const grp = stage; // pressure, world, tone, dynamic map directly
    const selectedCard = document.querySelector(
      `#flowRow${stage.charAt(0).toUpperCase() + stage.slice(1)} .sb-card[data-grp="${grp}"].selected`
    );
    return !!selectedCard;
  }

  /**
   * Update continue button visibility based on selection state
   * Uses corridorActiveRowIndex as single source of truth
   */
  function updateContinueButtonVisibility() {
    const activeStage = CORRIDOR_STAGES[corridorActiveRowIndex];

    BREADCRUMB_FLOW_STAGES.forEach((stage) => {
      const btn = document.getElementById(`continueFrom${stage.charAt(0).toUpperCase() + stage.slice(1)}`);
      if (btn) {
        const hasSelection = hasSelectionForStage(stage);
        // Map legacy stage to corridor stage for comparison
        const isCurrentStage = (stage === activeStage) ||
          (stage === 'storybeau' && activeStage === 'storybeau') ||
          (CORRIDOR_GRP_MAP[activeStage] === stage);
        btn.classList.toggle('visible', hasSelection && isCurrentStage);
      }
    });
  }

  /**
   * Update flow stage indicator dots
   * DEPRECATED: Breadcrumbs are the ONLY progress indicator per authoritative spec
   * This function now uses corridorActiveRowIndex for any residual dot elements
   */
  function updateFlowStageIndicator() {
    // Breadcrumbs are the only indicator - dots should not exist
    // If dots exist, update them using corridorActiveRowIndex as source of truth
    const dots = document.querySelectorAll('.flow-stage-dot');
    dots.forEach((dot, idx) => {
      dot.classList.remove('active', 'completed');
      if (idx < corridorActiveRowIndex) {
        dot.classList.add('completed');
      } else if (idx === corridorActiveRowIndex) {
        dot.classList.add('active');
      }
    });
  }

  /**
   * Handle continue button click â€” commit selection and advance flow
   * Uses corridorActiveRowIndex as SINGLE SOURCE OF TRUTH
   */
  function handleFlowContinue(stage) {
    // Map legacy stage to corridor index
    const corridorIdx = CORRIDOR_STAGES.indexOf(stage);
    if (corridorIdx === -1) {
      // Try mapping via CORRIDOR_GRP_MAP
      const mappedIdx = CORRIDOR_STAGES.findIndex(s => CORRIDOR_GRP_MAP[s] === stage);
      if (mappedIdx === -1 || mappedIdx !== corridorActiveRowIndex) return;
    } else if (corridorIdx !== corridorActiveRowIndex) {
      return;
    }

    const activeStage = CORRIDOR_STAGES[corridorActiveRowIndex];
    const selectors = CORRIDOR_SECTION_SELECTORS[activeStage];
    if (!selectors) return;

    // Find the flow row element (may be stored or mounted)
    const stored = corridorRowStore.get(activeStage);
    const flowRow = stored?.elements?.[0] || document.querySelector(selectors.split(',')[0].trim());
    if (!flowRow) return;

    const grp = CORRIDOR_GRP_MAP[activeStage] || activeStage;
    const selectedCard = flowRow.querySelector(`.sb-card[data-grp="${grp}"].selected`) ||
                         flowRow.querySelector('.sb-card.selected');
    if (!selectedCard) return;

    // Get selected value for breadcrumb label
    const selectedVal = selectedCard.dataset.val;
    const titleEl = selectedCard.querySelector('.sb-card-title');
    const selectedTitle = titleEl ? titleEl.textContent : selectedVal;

    // Hide continue button
    const continueBtn = document.getElementById(`continueFrom${stage.charAt(0).toUpperCase() + stage.slice(1)}`);
    if (continueBtn) continueBtn.classList.remove('visible');

    // Animate selected card to breadcrumb
    animateCardToBreadcrumb(selectedCard, grp, selectedVal, selectedTitle, () => {
      // Dissipate other cards
      const otherCards = flowRow.querySelectorAll(`.sb-card[data-grp="${grp}"]:not(.selected)`);
      dissipateCards(otherCards, () => {
        // Advance corridor using SINGLE SOURCE OF TRUTH
        corridorActiveRowIndex++;
        updateCorridorVisibility();  // DOM mount/unmount
        updateFlowStageIndicator();

        // Check if flow complete
        if (corridorActiveRowIndex >= CORRIDOR_STAGES.length) {
          onBreadcrumbFlowComplete();
        } else {
          updateContinueButtonVisibility();
        }
      });
    });
  }

  /**
   * Animate selected card to breadcrumb row via SPARKLE TELEPORT
   * Phase 1: Card dissolves in place with sparkles
   * Phase 2: Sparkles travel to breadcrumb position
   * Phase 3: Breadcrumb materializes from sparkles
   * BREADCRUMB PERSISTENCE AUTHORITY applies â€” excluded layers skip breadcrumb
   */
  function animateCardToBreadcrumb(card, grp, val, title, onComplete) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) {
      onComplete?.();
      return;
    }

    // BREADCRUMB EXCLUSION CHECK â€” intensity (arousal) never becomes breadcrumb
    if (!canBecomeBreadcrumb(grp)) {
      console.log(`[Breadcrumb] Skipping excluded layer: ${grp}`);
      onComplete?.();
      return;
    }

    // Get positions
    const cardRect = card.getBoundingClientRect();
    const cardCenterX = cardRect.left + cardRect.width / 2;
    const cardCenterY = cardRect.top + cardRect.height / 2;

    // Target the ghost step that this breadcrumb will replace
    const stageIdx = STAGE_INDEX[grp];
    const ghostStep = breadcrumbRow.querySelector(`.ghost-step[data-ghost-index="${stageIdx}"]`);
    let targetX, targetY;
    if (ghostStep) {
      const ghostRect = ghostStep.getBoundingClientRect();
      targetX = ghostRect.left + ghostRect.width / 2;
      targetY = ghostRect.top + ghostRect.height / 2;
    } else {
      // Fallback: center of breadcrumb row
      const breadcrumbRect = breadcrumbRow.getBoundingClientRect();
      targetX = breadcrumbRect.left + breadcrumbRect.width / 2;
      targetY = breadcrumbRect.top + breadcrumbRect.height / 2;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: Dissolve card in place
    // Card stays put, emits sparkles, fades to 0
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    card.classList.add('dissolving-to-breadcrumb');

    // Create dissolution sparkles from card surface
    const dissolutionCount = 12 + Math.floor(Math.random() * 6);
    for (let i = 0; i < dissolutionCount; i++) {
      setTimeout(() => {
        const sparkle = document.createElement('div');
        sparkle.className = 'dissolution-sparkle';

        // Random position on card surface
        const startX = cardRect.left + Math.random() * cardRect.width;
        const startY = cardRect.top + Math.random() * cardRect.height;

        sparkle.style.cssText = `
          left: ${startX}px;
          top: ${startY}px;
        `;
        document.body.appendChild(sparkle);

        // Remove after brief glow
        setTimeout(() => sparkle.remove(), 400);
      }, i * 30); // Stagger sparkle creation
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: Sparkle travel (teleport illusion)
    // Sparkles arc from card to breadcrumb â€” card is not visible during transit
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      const travelCount = 8 + Math.floor(Math.random() * 4);
      for (let i = 0; i < travelCount; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.className = 'traveling-sparkle';

          // Start from random position around card center
          const offsetX = (Math.random() - 0.5) * cardRect.width * 0.6;
          const offsetY = (Math.random() - 0.5) * cardRect.height * 0.6;
          const startX = cardCenterX + offsetX;
          const startY = cardCenterY + offsetY;

          // Calculate arc control point (curved path)
          const midX = (startX + targetX) / 2 + (Math.random() - 0.5) * 100;
          const midY = Math.min(startY, targetY) - 50 - Math.random() * 80; // Arc upward

          sparkle.style.cssText = `
            left: ${startX}px;
            top: ${startY}px;
            --target-x: ${targetX - startX}px;
            --target-y: ${targetY - startY}px;
            --arc-x: ${midX - startX}px;
            --arc-y: ${midY - startY}px;
          `;
          document.body.appendChild(sparkle);

          // Remove after travel animation
          setTimeout(() => sparkle.remove(), 600);
        }, i * 50); // Stagger travel starts
      }
    }, 250); // Start travel after dissolution begins

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: Breadcrumb materializes
    // Sparkles converge, breadcrumb appears with reveal animation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      // Hide original card completely
      card.style.visibility = 'hidden';
      card.classList.remove('dissolving-to-breadcrumb');

      // Get structured label with optional subtitle
      const label = getBreadcrumbLabel(grp, val);
      const subtitleHtml = label.subtitle
        ? `<span class="breadcrumb-subtitle">${label.subtitle}</span>`
        : '';

      // Mark ephemeral layers for later dissolution
      const ephemeralClass = shouldDissolveAtPOV(grp) ? ' breadcrumb-ephemeral' : '';

      // Create breadcrumb card with materializing class
      const breadcrumb = document.createElement('div');
      breadcrumb.className = 'breadcrumb-card materializing' + ephemeralClass;
      breadcrumb.dataset.grp = grp;
      breadcrumb.dataset.val = val;
      breadcrumb.dataset.stageIndex = STAGE_INDEX[grp];
      breadcrumb.dataset.breadcrumbLabel = grp.charAt(0).toUpperCase() + grp.slice(1);
      breadcrumb.innerHTML = `
        <div class="sb-card-inner">
          <div class="sb-card-face sb-card-back">
            <span class="sb-card-title">${label.title}</span>
            ${subtitleHtml}
          </div>
          <div class="sb-card-face sb-card-front">
            <span class="sb-card-title">${label.title}</span>
            ${subtitleHtml}
          </div>
        </div>
      `;
      // Insert before the first ghost step (breadcrumbs accumulate on left)
      const firstGhost = breadcrumbRow.querySelector('.ghost-step');
      if (firstGhost) {
        breadcrumbRow.insertBefore(breadcrumb, firstGhost);
      } else {
        breadcrumbRow.appendChild(breadcrumb);
      }

      // Remove the corresponding ghost step
      const stageIdxForGhost = STAGE_INDEX[grp];
      if (stageIdxForGhost >= 0) {
        removeGhostStep(stageIdxForGhost);
      }

      // Create convergence sparkles at breadcrumb
      for (let i = 0; i < 6; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'convergence-sparkle';
        const angle = (Math.PI * 2 * i) / 6;
        const dist = 20 + Math.random() * 15;
        sparkle.style.cssText = `
          left: ${targetX + Math.cos(angle) * dist}px;
          top: ${targetY + Math.sin(angle) * dist}px;
        `;
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 500);
      }

      // Remove materializing class after animation
      setTimeout(() => {
        breadcrumb.classList.remove('materializing');
      }, 400);

      // DESTRUCTIVE NAVIGATION: Attach click handler for breadcrumb navigation
      attachBreadcrumbNavigation(breadcrumb);

      console.log(`[Breadcrumb] Created via sparkle-teleport: ${grp}=${val}${label.subtitle ? ` (${label.subtitle})` : ''}`);
      onComplete?.();
    }, 700); // Total time for dissolution + travel
  }

  /**
   * Dissipate unselected cards with sparkle effect
   */
  function dissipateCards(cards, onComplete) {
    if (!cards || cards.length === 0) {
      onComplete?.();
      return;
    }

    let completed = 0;
    cards.forEach((card, idx) => {
      // Stagger the dissipation
      setTimeout(() => {
        card.classList.add('dissipating');

        // Create sparkle particles
        createDissipationSparkles(card);

        // Mark completion after animation
        setTimeout(() => {
          completed++;
          if (completed === cards.length) {
            onComplete?.();
          }
        }, 800);
      }, idx * 80); // 80ms stagger between cards
    });
  }

  /**
   * Create sparkle particles for card dissipation
   */
  function createDissipationSparkles(card) {
    const rect = card.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Create 8-12 sparkle particles
    const particleCount = 8 + Math.floor(Math.random() * 5);
    for (let i = 0; i < particleCount; i++) {
      const sparkle = document.createElement('div');
      sparkle.className = 'dissipate-sparkle';

      // Random position around card center
      const angle = (Math.PI * 2 * i) / particleCount + (Math.random() * 0.5);
      const distance = 30 + Math.random() * 60;
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance - 40; // Bias upward

      sparkle.style.cssText = `
        left: ${centerX}px;
        top: ${centerY}px;
        --sparkle-dx: ${dx}px;
        --sparkle-dy: ${dy}px;
      `;

      document.body.appendChild(sparkle);

      // Remove after animation
      setTimeout(() => sparkle.remove(), 1000);
    }
  }

  /**
   * Called when all breadcrumb flow stages are complete
   */
  function onBreadcrumbFlowComplete() {
    // All core selections made â€” user can now proceed to character setup
    // Show any remaining setup sections (intensity, length, etc.)
    console.log('[BreadcrumbFlow] Flow complete. All core selections committed.');

    // Optionally trigger story begin or show remaining options
    // For now, the flow ends here and user can proceed with Begin Story
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB INTERACTION â€” DESTRUCTIVE NAVIGATION (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Breadcrumbs are clickable. On click:
  //   - Navigate to the selected breadcrumb's section
  //   - DESTROY all downstream breadcrumbs
  //   - Resume corridor flow from that point
  // No confirmation dialogs â€” visual signaling alone is sufficient.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Navigate to a breadcrumb's section (NON-DESTRUCTIVE)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * AUTHORITATIVE RULES:
   * - Breadcrumbs are PERMANENT navigation anchors
   * - Clicking a breadcrumb ONLY navigates to that stage
   * - NO deletions, NO resets, NO state mutations beyond navigation
   * - If target is invalid/unlocked, redirect to last valid stage
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * @param {string} grp - The data-grp value of the clicked breadcrumb
   */
  function navigateToBreadcrumb(grp) {
    // Find the corridor stage for this grp
    let targetRowIndex = -1;
    for (let i = 0; i < CORRIDOR_STAGES.length; i++) {
      const stage = CORRIDOR_STAGES[i];
      const stageGrp = CORRIDOR_GRP_MAP[stage];
      if (stageGrp === grp || stage === grp) {
        targetRowIndex = i;
        break;
      }
    }

    // Special handling for authorship/identity grps that map to early rows
    if (targetRowIndex === -1) {
      if (grp === 'authorship' || grp === 'mode') {
        targetRowIndex = 0;
      } else if (grp === 'identity' || grp === 'names') {
        targetRowIndex = 1;
      }
    }

    if (targetRowIndex === -1) {
      console.warn(`[Breadcrumb Nav] Unknown grp: ${grp}, staying at current row`);
      return;
    }

    // Validate target is accessible (has been visited or has selection)
    // If not, redirect to last valid stage
    const isValidTarget = visitedRows.has(targetRowIndex) ||
                          corridorSelections.has(CORRIDOR_STAGES[targetRowIndex]) ||
                          targetRowIndex <= corridorActiveRowIndex;

    if (!isValidTarget) {
      console.warn(`[Breadcrumb Nav] Target row ${targetRowIndex} is not valid, redirecting to current`);
      return; // Stay at current row
    }

    console.log(`[Breadcrumb Nav] Navigating to row ${targetRowIndex} (${grp}) â€” NO state mutations`);

    // NAVIGATION ONLY â€” no deletions, no resets
    corridorActiveRowIndex = targetRowIndex;
    updateCorridorVisibility();
    updateCorridorContinueButtonVisibility();

    // Update DSP visibility (only shows during World, Tone, Pressure, POV, Length)
    updateDSPCorridorVisibility();

    // Ensure exactly one valid stage row is rendered
    ensureValidRowRendered();

    console.log(`[Breadcrumb Nav] Now at row ${corridorActiveRowIndex}`);
  }

  // ensureValidRowRendered defined later in navigation section

  /**
   * Attach click handler to a breadcrumb for NON-DESTRUCTIVE navigation
   * AUTHORITATIVE: Breadcrumbs are permanent anchors, never deleted
   * @param {HTMLElement} breadcrumb - The breadcrumb element
   */
  function attachBreadcrumbNavigation(breadcrumb) {
    breadcrumb.addEventListener('click', (e) => {
      e.stopPropagation();
      const grp = breadcrumb.dataset.grp;
      if (grp) {
        navigateToBreadcrumb(grp);
      }
    });
  }

  // Export for global access
  window.navigateToBreadcrumb = navigateToBreadcrumb;

  /**
   * Reset breadcrumb flow to initial state
   * Called when starting a new story
   * Uses corridorActiveRowIndex as SINGLE SOURCE OF TRUTH
   */
  function resetBreadcrumbFlow() {
    // Reset corridor state - SINGLE SOURCE OF TRUTH
    corridorActiveRowIndex = 0;
    corridorSelections.clear();

    // Clear breadcrumb row
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (breadcrumbRow) breadcrumbRow.innerHTML = '';

    // Reset card state in all stored rows before remounting
    corridorRowStore.forEach((stored) => {
      stored.elements.forEach(el => {
        el.querySelectorAll('.sb-card').forEach(card => {
          card.style.visibility = '';
          card.style.opacity = '';
          card.classList.remove('dissipating', 'selected', 'flipped', 'becoming-breadcrumb');
        });
      });
    });

    // Clear state selections
    state.picks.pressure = null;
    state.picks.world = null;
    state.picks.tone = null;
    state.picks.dynamic = null;
    state.picks.pov = null;
    state.picks.length = null;
    state.picks.intensity = null;

    // Apply corridor visibility via DOM mount/unmount
    updateCorridorVisibility();
    updateFlowStageIndicator();
    updateContinueButtonVisibility();

    // DSP VISIBILITY GATE: Hide DSP on reset (corridor back to row 0)
    if (typeof updateDSPCorridorVisibility === 'function') {
      updateDSPCorridorVisibility();
    }
  }

  // Expose reset function globally for restart functionality
  window.resetBreadcrumbFlow = resetBreadcrumbFlow;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORRIDOR STATE MACHINE â€” 9-row single-screen selection system
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Map corridor stages to their actual DOM container selectors
   * These are the existing HTML elements that contain each row's cards
   * Note: Using IDs and classes that exist in the current HTML structure
   *
   * ALL rows follow the same visibility rules - only active row is shown.
   * Guided Fate is row 0 and obeys corridor visibility like all others.
   */
  const CORRIDOR_SECTION_SELECTORS = {
    // Authorship choice row (Continue button inside row)
    authorship: '#authorshipChoiceRow, #continueFromAuthorship',
    // Identity/character section (shown after Choose Your Hand)
    identity: '#characterSectionRow, #continueFromCharacters',
    storybeau: '#archetypeSectionTitle, #archetypeCardGrid, .archetype-header-text, .archetype-subtext, #archetypeSelectionSummary, #continueFromStorybeau',
    world: '#flowRowWorld',
    tone: '#flowRowTone',
    pressure: '#flowRowPressure',
    pov: '#povSectionTitle, #povGrid, #continueFromPov',
    length: '#lengthSection, #continueFromLength',
    dynamic: '#flowRowDynamic, #continueFromDynamic',
    arousal: '#arousalSectionTitle, #intensityGrid, #continueFromArousal',
    safety: '#safetyRow, #continueFromSafety',
    vetoquill: '#vetoquillRow, #continueFromVetoquill',
    beginstory: '#beginStoryRow'
  };

  /**
   * Measure sticky header height and set CSS variable for corridor centering
   * Called on init and resize to keep centering accurate
   */
  function measureAndSetHeaderHeight() {
    const header = document.querySelector('.shape-your-story-header');
    if (header) {
      const height = header.offsetHeight;
      document.documentElement.style.setProperty('--sb-header-height', `${height}px`);
      console.log(`[Corridor] Header height measured: ${height}px`);
    }
  }

  /**
   * Initialize the corridor system
   * Implements DOM mount/unmount for corridor contract enforcement
   */
  function initCorridor() {
    console.log('[Corridor] Initializing 9-row corridor system with DOM mount/unmount...');

    // MEASURE HEADER HEIGHT: Set CSS variable for corridor centering
    measureAndSetHeaderHeight();
    window.addEventListener('resize', debounce(measureAndSetHeaderHeight, 100));

    // VIEWPORT ISOLATION: Prevent body scrolling during corridor stages
    document.body.classList.add('corridor-mode');
    document.body.classList.remove('corridor-complete');

    // Reset state - start at row 0 (Guided Fate)
    corridorActiveRowIndex = 0;
    corridorSelections.clear();

    // Initialize DOM row store with elements and insertion anchors
    // INIT SAFETY GUARD: Do NOT clear if already populated (prevents orphaned anchors)
    initCorridorRowStore();

    // Apply initial visibility via DOM mount/unmount
    updateCorridorVisibility();

    // Bind corridor card click handlers
    bindCorridorCardHandlers();

    // Bind corridor continue buttons
    bindCorridorContinueButtons();

    // Initialize ghost step placeholders
    initGhostSteps();

    // Update continue button visibility for initial state
    updateCorridorContinueButtonVisibility();

    // DSP VISIBILITY GATE: Ensure DSP is hidden at corridor start
    updateDSPCorridorVisibility();

    // Start sparkle emitters for authorship cards (first row)
    initAuthorshipSparkles();

    // Initialize row navigation affordances (swipe + arrows)
    initCorridorNavigation();

    console.log('[Corridor] Initialization complete. Active row:', corridorActiveRowIndex);
    console.log('[Corridor] Row store initialized with', corridorRowStore.size, 'stages');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORRIDOR ROW NAVIGATION â€” Free navigation without auto-commit
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Navigation allows browsing all rows without selecting or committing.
  // Breadcrumbs are memory only â€” navigation does not create breadcrumbs.
  // Unresolved required rows tracked but enforced only at Begin Story.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Track which rows have been visited (for validation at Begin Story)
  const visitedRows = new Set();

  /**
   * Navigate to a specific corridor row (no selection, no commit)
   * @param {number} targetIndex - Target row index
   */
  // Track navigation attempts per stage (for tooltip logic)
  // Key: stage name, Value: number of navigation attempts without Continue
  const navigationAttemptsPerStage = new Map();
  // Track which stages have shown the tooltip (shows once ever)
  const tooltipShownForStage = new Set();

  function navigateToCorridorRow(targetIndex) {
    // Bounds check
    if (targetIndex < 0 || targetIndex >= CORRIDOR_STAGES.length) {
      return false;
    }

    // Skip if already at target
    if (targetIndex === corridorActiveRowIndex) {
      return false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SOFT NAVIGATION FEEDBACK (no hard blocking)
    // Navigation is always allowed. Uncommitted stages show Continue feedback.
    // First attempt: pulse Continue button
    // Second attempt: show tooltip "Continue locks this choice into your story."
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const currentStage = CORRIDOR_STAGES[corridorActiveRowIndex];
    const currentRowCommitted = corridorSelections.has(currentStage);

    if (!currentRowCommitted) {
      const continueBtn = findContinueButtonForStage(currentStage);
      if (continueBtn) {
        // Track navigation attempts for this stage
        const attempts = (navigationAttemptsPerStage.get(currentStage) || 0) + 1;
        navigationAttemptsPerStage.set(currentStage, attempts);

        if (attempts === 1) {
          // First attempt: pulse Continue button only
          triggerContinueButtonFeedback(continueBtn.id);
          console.log(`[Corridor Nav] Soft feedback: pulsed Continue for ${currentStage}`);
        } else if (attempts === 2 && !tooltipShownForStage.has(currentStage)) {
          // Second attempt: show tooltip (once per stage, ever)
          triggerContinueButtonFeedback(continueBtn.id);
          showContinueTooltip(continueBtn);
          tooltipShownForStage.add(currentStage);
          console.log(`[Corridor Nav] Soft feedback: showed tooltip for ${currentStage}`);
        }
        // Navigation proceeds regardless
      }
    }

    // Track current row as visited
    visitedRows.add(corridorActiveRowIndex);

    // Update active row index
    corridorActiveRowIndex = targetIndex;

    // Update visibility (DOM mount/unmount)
    updateCorridorVisibility();
    updateCorridorContinueButtonVisibility();

    // Update DSP visibility (only shows during World, Tone, Pressure, POV, Length)
    updateDSPCorridorVisibility();

    // Track new row as visited
    visitedRows.add(targetIndex);

    // INVARIANT: Ensure exactly one valid row is rendered
    ensureValidRowRendered();

    console.log(`[Corridor Nav] Navigated to row ${targetIndex}: ${CORRIDOR_STAGES[targetIndex]}`);
    return true;
  }

  /**
   * Find the Continue button for a given corridor stage
   */
  function findContinueButtonForStage(stage) {
    const stageToButton = {
      'authorship': 'continueFromAuthorship',
      'identity': 'continueFromCharacters',
      'storybeau': 'continueFromStorybeau',
      'archetype': 'continueFromStorybeau',
      'world': 'continueFromWorld',
      'tone': 'continueFromTone',
      'pressure': 'continueFromPressure',
      'pov': 'continueFromPov',
      'length': 'continueFromLength',
      'dynamic': 'continueFromDynamic',
      'arousal': 'continueFromArousal',
      'safety': 'continueFromSafety',
      'vetoquill': 'continueFromVetoquill',
      'beginstory': 'beginBtn'
    };
    const buttonId = stageToButton[stage];
    return buttonId ? $(buttonId) : null;
  }

  /**
   * Ensure exactly one valid stage row is rendered (INVARIANT)
   * Prevents blank corridor view - if no row is mounted, remount current
   */
  function ensureValidRowRendered() {
    const mountedRows = document.querySelectorAll('.corridor-section.corridor-active');
    if (mountedRows.length !== 1) {
      console.error(`[Corridor INVARIANT] Expected 1 mounted row, found ${mountedRows.length}`);
      // Force remount of current row
      updateCorridorVisibility();
    }
  }

  /**
   * Trigger visual feedback on Continue button when navigation is blocked
   */
  function triggerContinueButtonFeedback(buttonId) {
    const btn = $(buttonId);
    if (!btn) return;

    // Add shake/pulse class
    btn.classList.add('navigation-blocked');
    btn.classList.add('visible'); // Ensure it's visible

    // Remove after animation
    setTimeout(() => {
      btn.classList.remove('navigation-blocked');
    }, 600);
  }

  /**
   * Show tooltip on Continue button explaining commitment
   * Tooltip: "Continue locks this choice into your story."
   * Shows once per stage, then never again.
   */
  function showContinueTooltip(btnElement) {
    if (!btnElement) return;

    // Remove any existing tooltip
    const existingTooltip = document.querySelector('.continue-commitment-tooltip');
    if (existingTooltip) existingTooltip.remove();

    // Create tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'continue-commitment-tooltip';
    tooltip.textContent = 'Continue locks this choice into your story.';

    // Position tooltip above the button
    document.body.appendChild(tooltip);

    const btnRect = btnElement.getBoundingClientRect();
    tooltip.style.left = `${btnRect.left + btnRect.width / 2}px`;
    tooltip.style.top = `${btnRect.top - 10}px`;

    // Animate in
    requestAnimationFrame(() => {
      tooltip.classList.add('visible');
    });

    // Auto-hide after 4 seconds
    setTimeout(() => {
      tooltip.classList.remove('visible');
      setTimeout(() => tooltip.remove(), 300);
    }, 4000);
  }

  /**
   * Navigate to next row (right)
   */
  function navigateNextRow() {
    return navigateToCorridorRow(corridorActiveRowIndex + 1);
  }

  /**
   * Navigate to previous row (left)
   */
  function navigatePrevRow() {
    return navigateToCorridorRow(corridorActiveRowIndex - 1);
  }

  /**
   * Get list of unresolved required rows
   * @returns {Array} Array of { stage, index } for unresolved rows
   */
  function getUnresolvedRows() {
    const unresolved = [];
    CORRIDOR_STAGES.forEach((stage, idx) => {
      // Skip these stages (not required â€” they don't have card-based selection)
      if (stage === 'arousal' || stage === 'safety' || stage === 'vetoquill' || stage === 'beginstory') return;

      let hasSelection = corridorSelections.has(stage);

      // Special cases that don't use state.picks
      if (stage === 'authorship') {
        hasSelection = hasSelection || !!state.mode;
      } else if (stage === 'storybeau') {
        hasSelection = hasSelection || !!state.archetype?.primary;
      } else {
        // Standard corridor stages use state.picks
        const grp = CORRIDOR_GRP_MAP[stage];
        hasSelection = hasSelection ||
          (grp && state.picks && state.picks[grp]) ||
          !!document.querySelector(`.sb-card[data-grp="${grp}"].selected`);
      }

      if (!hasSelection) {
        unresolved.push({ stage, index: idx, grp: CORRIDOR_GRP_MAP[stage] });
      }
    });
    return unresolved;
  }

  /**
   * Validate all required rows are resolved (called at Begin Story)
   * @returns {boolean} True if all required rows are resolved
   */
  function validateCorridorComplete() {
    const unresolved = getUnresolvedRows();
    if (unresolved.length === 0) {
      return true;
    }

    console.warn('[Corridor] Unresolved rows:', unresolved.map(r => r.stage).join(', '));
    // Show missing selections modal
    showMissingSelectionsModal(unresolved);
    return false;
  }

  /**
   * Human-readable labels for corridor stages
   */
  const STAGE_DISPLAY_NAMES = {
    authorship: 'Authorship',
    identity: 'Characters',
    storybeau: 'Archetype',
    archetype: 'Archetype',
    world: 'World',
    tone: 'Tone',
    pressure: 'Story Pull',
    pov: 'POV',
    length: 'Length',
    dynamic: 'Dynamic',
    arousal: 'Intensity',
    safety: 'Safety',
    vetoquill: 'Veto/Quill',
    beginstory: 'Begin Story'
  };

  /**
   * Show modal listing missing selections with clickable navigation
   * Each item navigates to that stage. Offers "Let Fate Choose" option.
   */
  function showMissingSelectionsModal(unresolvedRows) {
    // Remove existing modal if any
    const existingModal = document.querySelector('.missing-selections-modal');
    if (existingModal) existingModal.remove();

    // Create modal
    const modal = document.createElement('div');
    modal.className = 'missing-selections-modal';

    const content = document.createElement('div');
    content.className = 'missing-selections-content';

    const title = document.createElement('h3');
    title.textContent = 'Missing Selections';
    content.appendChild(title);

    const list = document.createElement('ul');
    list.className = 'missing-selections-list';

    unresolvedRows.forEach(row => {
      const item = document.createElement('li');
      item.className = 'missing-selection-item';
      item.textContent = STAGE_DISPLAY_NAMES[row.stage] || row.stage;
      item.addEventListener('click', () => {
        closeMissingSelectionsModal();
        navigateToCorridorRow(row.index);
      });
      list.appendChild(item);
    });
    content.appendChild(list);

    // "Let Fate Choose" button
    const fateBtn = document.createElement('button');
    fateBtn.className = 'missing-selections-fate-btn';
    fateBtn.textContent = 'Let Fate Choose for Me';
    fateBtn.addEventListener('click', () => {
      closeMissingSelectionsModal();
      fillMissingWithFate(unresolvedRows);
    });
    content.appendChild(fateBtn);

    // Close button
    const closeBtn = document.createElement('button');
    closeBtn.className = 'missing-selections-close-btn';
    closeBtn.textContent = 'Close';
    closeBtn.addEventListener('click', closeMissingSelectionsModal);
    content.appendChild(closeBtn);

    modal.appendChild(content);

    // Backdrop click closes modal
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeMissingSelectionsModal();
    });

    document.body.appendChild(modal);
    requestAnimationFrame(() => modal.classList.add('visible'));
  }

  function closeMissingSelectionsModal() {
    const modal = document.querySelector('.missing-selections-modal');
    if (modal) {
      modal.classList.remove('visible');
      setTimeout(() => modal.remove(), 300);
    }
  }

  /**
   * Auto-fill missing selections with random fate choices
   */
  function fillMissingWithFate(unresolvedRows) {
    unresolvedRows.forEach(row => {
      switch (row.stage) {
        case 'authorship':
          state.mode = 'manual';
          corridorSelections.set('authorship', 'manual');
          break;
        case 'storybeau':
          const randomArch = ARCHETYPE_ORDER[Math.floor(Math.random() * ARCHETYPE_ORDER.length)];
          state.archetype = state.archetype || {};
          state.archetype.primary = randomArch;
          corridorSelections.set('storybeau', randomArch);
          createArchetypeBreadcrumbWithMask(randomArch, false);
          break;
        case 'world':
          const worlds = ['Modern', 'Fantasy', 'SciFi', 'Historical'];
          const randomWorld = worlds[Math.floor(Math.random() * worlds.length)];
          state.picks.world = randomWorld;
          corridorSelections.set('world', randomWorld);
          createBreadcrumbDirect('world', randomWorld, randomWorld);
          break;
        case 'tone':
          const tones = ['Earnest', 'Dark', 'Playful', 'Epic'];
          const randomTone = tones[Math.floor(Math.random() * tones.length)];
          state.picks.tone = randomTone;
          corridorSelections.set('tone', randomTone);
          createBreadcrumbDirect('tone', randomTone, randomTone);
          break;
        case 'pressure':
          const pressures = ['Slow', 'Medium', 'Intense'];
          const randomPressure = pressures[Math.floor(Math.random() * pressures.length)];
          state.picks.pressure = randomPressure;
          corridorSelections.set('pressure', randomPressure);
          createBreadcrumbDirect('pressure', randomPressure, randomPressure);
          break;
        case 'pov':
          const povs = ['1st', '3rdLimited', '3rdOmni'];
          const randomPov = povs[Math.floor(Math.random() * povs.length)];
          state.picks.pov = randomPov;
          corridorSelections.set('pov', randomPov);
          createBreadcrumbDirect('pov', randomPov, randomPov);
          break;
        case 'length':
          const lengths = ['Short', 'Medium', 'Long'];
          const randomLength = lengths[Math.floor(Math.random() * lengths.length)];
          state.storyLength = randomLength;
          corridorSelections.set('length', randomLength);
          createBreadcrumbDirect('length', randomLength, randomLength);
          break;
        case 'dynamic':
          const dynamics = ['Chase', 'Surrender', 'Rivalry', 'Worship'];
          const randomDynamic = dynamics[Math.floor(Math.random() * dynamics.length)];
          state.picks.dynamic = randomDynamic;
          corridorSelections.set('dynamic', randomDynamic);
          createBreadcrumbDirect('dynamic', randomDynamic, randomDynamic);
          break;
      }
    });

    console.log('[Fate Fill] Auto-filled missing selections:', unresolvedRows.map(r => r.stage).join(', '));

    // Trigger Begin Story again now that selections are complete
    const beginBtn = $('beginBtn');
    if (beginBtn) beginBtn.click();
  }

  // Expose validation function
  window.validateCorridorComplete = validateCorridorComplete;
  window.getUnresolvedRows = getUnresolvedRows;

  /**
   * Initialize corridor navigation (swipe + arrows)
   */
  function initCorridorNavigation() {
    // Create navigation arrows for desktop
    createNavigationArrows();

    // Bind swipe handlers for mobile
    bindSwipeNavigation();

    console.log('[Corridor Nav] Navigation affordances initialized');
  }

  /**
   * Create left/right navigation arrows (desktop)
   */
  function createNavigationArrows() {
    const setupSection = document.getElementById('setup');
    if (!setupSection) return;

    // Remove existing arrows
    setupSection.querySelectorAll('.corridor-nav-arrow').forEach(a => a.remove());

    // Left arrow
    const leftArrow = document.createElement('button');
    leftArrow.className = 'corridor-nav-arrow corridor-nav-left';
    leftArrow.innerHTML = '&#8249;'; // Single left angle bracket
    leftArrow.setAttribute('aria-label', 'Previous row');
    leftArrow.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      navigatePrevRow();
      updateNavigationArrowVisibility();
    });

    // Right arrow
    const rightArrow = document.createElement('button');
    rightArrow.className = 'corridor-nav-arrow corridor-nav-right';
    rightArrow.innerHTML = '&#8250;'; // Single right angle bracket
    rightArrow.setAttribute('aria-label', 'Next row');
    rightArrow.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      navigateNextRow();
      updateNavigationArrowVisibility();
    });

    setupSection.appendChild(leftArrow);
    setupSection.appendChild(rightArrow);

    // Initial visibility update
    updateNavigationArrowVisibility();
  }

  /**
   * Update arrow visibility based on current position
   */
  function updateNavigationArrowVisibility() {
    const leftArrow = document.querySelector('.corridor-nav-left');
    const rightArrow = document.querySelector('.corridor-nav-right');

    if (leftArrow) {
      leftArrow.classList.toggle('hidden', corridorActiveRowIndex === 0);
    }
    if (rightArrow) {
      rightArrow.classList.toggle('hidden', corridorActiveRowIndex >= CORRIDOR_STAGES.length - 1);
    }
  }

  /**
   * Bind horizontal swipe navigation for mobile
   */
  function bindSwipeNavigation() {
    const setupSection = document.getElementById('setup');
    if (!setupSection) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 50;
    const maxVerticalDistance = 100;

    setupSection.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    setupSection.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;

      const deltaX = touchEndX - touchStartX;
      const deltaY = Math.abs(touchEndY - touchStartY);

      // Only handle horizontal swipes (not vertical scrolling)
      if (deltaY > maxVerticalDistance) return;

      if (Math.abs(deltaX) >= minSwipeDistance) {
        if (deltaX < 0) {
          // Swipe left â†’ next row
          navigateNextRow();
        } else {
          // Swipe right â†’ previous row
          navigatePrevRow();
        }
        updateNavigationArrowVisibility();
      }
    }, { passive: true });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GHOST STEP PLACEHOLDERS â€” Pre-breadcrumb progress indicators
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ghost steps show remaining steps before selection.
  // They are NOT interactive â€” purely presentational scaffolding.
  // Real breadcrumbs replace ghost steps left-to-right as corridor advances.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Ghost step Roman numerals - matches STAGE_INDEX (excluding intensity which has no breadcrumb)
  const GHOST_STEP_NUMERALS = [
    'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'
  ];

  // STAGE_DISPLAY_NAMES defined earlier â€” used for ghost step display names

  /**
   * Initialize ghost step placeholders in the breadcrumb row
   * Ghost steps match STAGE_INDEX slots (excluding intensity)
   */
  function initGhostSteps() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    // Clear any existing ghost steps
    breadcrumbRow.querySelectorAll('.ghost-step').forEach(g => g.remove());

    // Create ghost step for each STAGE_INDEX entry (except aliases and non-breadcrumb stages)
    const stageEntries = Object.entries(STAGE_INDEX).filter(([grp]) =>
      grp !== 'archetype' && grp !== 'safety' && grp !== 'vetoquill' && grp !== 'beginstory'
    );
    stageEntries.sort((a, b) => a[1] - b[1]); // Sort by index

    stageEntries.forEach(([grp, idx]) => {
      const ghost = document.createElement('div');
      ghost.className = 'ghost-step';
      ghost.dataset.ghostIndex = idx;
      ghost.dataset.ghostGrp = grp;
      ghost.innerHTML = `
        <span class="ghost-step-label">CHOICE</span>
        <span class="ghost-step-number">${GHOST_STEP_NUMERALS[idx] || idx + 1}</span>
      `;
      breadcrumbRow.appendChild(ghost);
    });

    console.log('[Ghost Steps] Initialized', stageEntries.length, 'ghost step placeholders');
  }

  /**
   * Remove a ghost step when it's replaced by a real breadcrumb
   * @param {number} stepIndex - The corridor stage index being replaced
   */
  function removeGhostStep(stepIndex) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    const ghost = breadcrumbRow.querySelector(`.ghost-step[data-ghost-index="${stepIndex}"]`);
    if (ghost) {
      ghost.classList.add('replacing');
      setTimeout(() => ghost.remove(), 200);
      console.log(`[Ghost Steps] Removed ghost step ${stepIndex + 1}`);
    }
  }

  /**
   * Clear all remaining ghost steps (called on corridor complete)
   */
  function clearAllGhostSteps() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    breadcrumbRow.querySelectorAll('.ghost-step').forEach(ghost => {
      ghost.classList.add('replacing');
      setTimeout(() => ghost.remove(), 200);
    });
    console.log('[Ghost Steps] Cleared all remaining ghost steps');
  }

  /**
   * Initialize the DOM row store
   * Captures element references and creates insertion anchors for mount/unmount
   * CORRIDOR CONTRACT: Elements will be removed from DOM when not active
   * INIT SAFETY GUARD: Safe to call multiple times - returns early if already populated
   */
  function initCorridorRowStore() {
    // INIT SAFETY GUARD: If store already populated, do not recreate anchors
    if (corridorRowStore.size > 0) {
      console.log('[Corridor] Row store already initialized, skipping anchor creation');
      return;
    }

    CORRIDOR_STAGES.forEach((stage, idx) => {
      const selectors = CORRIDOR_SECTION_SELECTORS[stage];

      // Skip stages with null selectors
      if (!selectors) {
        console.log(`[Corridor] Stage ${stage} has no selectors, skipping store`);
        return;
      }

      const selectorList = selectors.split(',').map(s => s.trim());
      const elements = [];
      const anchors = [];

      selectorList.forEach(selector => {
        const els = document.querySelectorAll(selector);
        els.forEach(el => {
          if (el && el.parentNode) {
            // Tag element with corridor metadata
            el.dataset.corridorStage = stage;
            el.dataset.corridorIndex = idx;
            el.classList.add('corridor-section');

            // Create anchor comment node for re-insertion position
            const anchor = document.createComment(`corridor-anchor:${stage}:${elements.length}`);
            el.parentNode.insertBefore(anchor, el.nextSibling);

            elements.push(el);
            anchors.push(anchor);
          }
        });
      });

      if (elements.length > 0) {
        corridorRowStore.set(stage, { elements, anchors });
        console.log(`[Corridor] Stored ${elements.length} elements for stage: ${stage}`);
      }
    });
  }

  /**
   * Update which corridor row is visible via DOM mount/unmount
   * CORRIDOR CONTRACT ENFORCEMENT:
   *   - INVARIANT 1: Exactly ONE row mounted at any time
   *   - INVARIANT 2: All other rows UNMOUNTED from DOM (not CSS-hidden)
   *   - INVARIANT 3: corridorActiveRowIndex is ONLY source of truth
   */
  function updateCorridorVisibility() {
    let mountedCount = 0;

    CORRIDOR_STAGES.forEach((stage, idx) => {
      const stored = corridorRowStore.get(stage);

      // Skip stages not in store (null selectors)
      if (!stored) return;

      if (idx === corridorActiveRowIndex) {
        // MOUNT: Insert elements back into DOM at anchor positions
        stored.elements.forEach((el, i) => {
          const anchor = stored.anchors[i];
          if (anchor && anchor.parentNode) {
            // Only insert if not already in DOM at correct position
            if (!el.parentNode || el.nextSibling !== anchor) {
              anchor.parentNode.insertBefore(el, anchor);
            }
            // Ensure visible state
            el.classList.remove('corridor-hidden', 'flow-hidden', 'hidden');
            el.classList.add('corridor-active');
            el.style.display = '';
            el.style.visibility = '';
            el.style.opacity = '';
            el.style.pointerEvents = '';
          }
        });
        mountedCount++;

        // Trigger stage-specific mount handlers
        if (stage === 'storybeau' && typeof window.onArchetypeRowMount === 'function') {
            window.onArchetypeRowMount();
        }

        // IDENTITY MOUNT: Restore mini-deck when navigating back
        if (stage === 'identity') {
          const miniDeck = document.getElementById('destinyMiniDeck');
          if (miniDeck) {
            miniDeck.classList.remove('retracted');
            // Restart sparkles on mini-deck
            if (typeof startSparkleEmitter === 'function') {
              startSparkleEmitter('destinyDeckSparkles', 'destinyDeck', 3);
            }
          }
          // Initialize ancestry rotating placeholders (identity row was unmounted
          // when initFateHandSystem ran, so these were skipped)
          ['ancestryInputPlayer', 'ancestryInputLI'].forEach(id => {
            const ph = document.querySelector(`.rotating-placeholder[data-for="${id}"]`);
            if (ph && !ph.innerHTML.trim() && typeof window.initRotatingPlaceholder === 'function') {
              window.initRotatingPlaceholder(id, 'ancestry');
            }
          });
          console.log('[Corridor] Identity mount: Restored mini-deck');
        }

        // VETOQUILL MOUNT: Restore VQ destiny deck + init placeholders
        if (stage === 'vetoquill') {
          const vqDeck = document.getElementById('vqDestinyDeck');
          if (vqDeck) {
            vqDeck.classList.remove('retracted');
            if (typeof startSparkleEmitter === 'function') {
              startSparkleEmitter('vqDeckSparkles', 'destinyDeck', 3);
            }
          }
          // Init rotating placeholders (row unmounted when initFateHandSystem ran)
          ['vetoInput', 'quillInput'].forEach(id => {
            const ph = document.querySelector(`.rotating-placeholder[data-for="${id}"]`);
            if (ph && !ph.innerHTML.trim() && typeof window.initRotatingPlaceholder === 'function') {
              window.initRotatingPlaceholder(id, id === 'vetoInput' ? 'veto' : 'quill');
            }
          });
          console.log('[Corridor] Vetoquill mount: Restored VQ destiny deck');
        }

        // BEGIN STORY MOUNT: Start sparkles around Begin Story button
        if (stage === 'beginstory') {
          if (typeof startSparkleEmitter === 'function') {
            startSparkleEmitter('beginBtnSparkles', 'guidedFate', 12);
          }
          console.log('[Corridor] Begin Story mount: Started sparkles');
        }

        // AUTHORSHIP MOUNT: Restore authorship cards when navigating back
        // resetAuthorshipChoice() handles: card visibility, character section, post-arousal section
        if (stage === 'authorship' && typeof window.resetAuthorshipChoice === 'function') {
          window.resetAuthorshipChoice();
          console.log('[Corridor] Authorship mount: Reset authorship choice for re-selection');
        }
      } else {
        // UNMOUNT: Remove elements from DOM (keep references in store)
        stored.elements.forEach(el => {
          if (el.parentNode) {
            el.classList.remove('corridor-active');
            el.classList.add('corridor-hidden');
            el.parentNode.removeChild(el);
          }
        });
      }
    });

    // INVARIANT ASSERTION: Exactly one row should be mounted
    if (mountedCount !== 1) {
      console.error(`[CORRIDOR INVARIANT VIOLATION] Expected 1 mounted row, found ${mountedCount}`);
      console.error(`  corridorActiveRowIndex: ${corridorActiveRowIndex}`);
      console.error(`  Active stage: ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
    }

    // Verify DOM state matches expected state
    const mountedInDOM = document.querySelectorAll('.corridor-section.corridor-active');
    if (mountedInDOM.length > 0) {
      const actualStages = new Set();
      mountedInDOM.forEach(el => actualStages.add(el.dataset.corridorStage));
      if (actualStages.size > 1) {
        console.error(`[CORRIDOR INVARIANT VIOLATION] Multiple stages active in DOM:`, Array.from(actualStages));
      }
    }

    // Update stage indicator (no-op, breadcrumbs only)
    updateCorridorStageIndicator();

    // Update navigation arrow visibility based on current position
    if (typeof updateNavigationArrowVisibility === 'function') {
      updateNavigationArrowVisibility();
    }

    console.log(`[Corridor] DOM updated. Mounted row ${corridorActiveRowIndex}: ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
  }

  /**
   * Update corridor stage indicator
   * REMOVED: Breadcrumbs are the ONLY progress indicator
   * This function is now a no-op for backwards compatibility
   */
  function updateCorridorStageIndicator() {
    // Breadcrumbs are the only progress indicator - no dots
  }

  /**
   * Verify corridor contract invariants (for debugging/testing)
   * Call this to assert all invariants are satisfied
   * @returns {boolean} True if all invariants pass
   */
  function verifyCorridorContract() {
    let valid = true;
    const errors = [];

    // INVARIANT 1: Exactly ONE corridor row mounted in DOM
    const mountedSections = document.querySelectorAll('.corridor-section');
    const mountedByStage = new Map();
    mountedSections.forEach(el => {
      const stage = el.dataset.corridorStage;
      if (stage) {
        if (!mountedByStage.has(stage)) mountedByStage.set(stage, 0);
        mountedByStage.set(stage, mountedByStage.get(stage) + 1);
      }
    });

    const mountedStages = Array.from(mountedByStage.keys());
    if (mountedStages.length > 1) {
      errors.push(`INVARIANT 1 VIOLATION: Multiple stages mounted: [${mountedStages.join(', ')}]`);
      valid = false;
    } else if (mountedStages.length === 1) {
      const expectedStage = CORRIDOR_STAGES[corridorActiveRowIndex];
      if (mountedStages[0] !== expectedStage) {
        errors.push(`INVARIANT 3 VIOLATION: Mounted stage (${mountedStages[0]}) != expected (${expectedStage})`);
        valid = false;
      }
    }

    // INVARIANT 2: No CSS-hidden corridor sections (all should be unmounted)
    const hiddenInDOM = document.querySelectorAll('.corridor-section.corridor-hidden');
    if (hiddenInDOM.length > 0) {
      errors.push(`INVARIANT 2 VIOLATION: ${hiddenInDOM.length} sections CSS-hidden instead of unmounted`);
      valid = false;
    }

    // INVARIANT 3: corridorActiveRowIndex consistency
    if (corridorActiveRowIndex < 0 || corridorActiveRowIndex > CORRIDOR_STAGES.length) {
      errors.push(`INVARIANT 3 VIOLATION: corridorActiveRowIndex out of bounds: ${corridorActiveRowIndex}`);
      valid = false;
    }

    // Report results
    if (valid) {
      console.log('[Corridor Contract] All invariants satisfied âœ“');
    } else {
      errors.forEach(err => console.error(`[Corridor Contract] ${err}`));
    }

    return valid;
  }

  // Expose for testing
  window.verifyCorridorContract = verifyCorridorContract;

  /**
   * Get the current stage name
   */
  function getCurrentCorridorStage() {
    return CORRIDOR_STAGES[corridorActiveRowIndex] || null;
  }

  /**
   * Check if current corridor row has a selection
   */
  function hasCorridorSelectionForCurrentRow() {
    const stage = getCurrentCorridorStage();
    if (!stage) return false;

    const grp = CORRIDOR_GRP_MAP[stage];

    // Check if there's a selected card for this group
    const selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"].selected`);
    return !!selectedCard;
  }

  /**
   * Bind click handlers to corridor cards
   */
  function bindCorridorCardHandlers() {
    // For each corridor stage, bind selection handlers
    CORRIDOR_STAGES.forEach((stage, idx) => {
      const grp = CORRIDOR_GRP_MAP[stage];

      // Find all cards for this group
      const cards = document.querySelectorAll(`.sb-card[data-grp="${grp}"]`);
      cards.forEach(card => {
        card.addEventListener('click', () => {
          // Only handle clicks for the active row
          if (idx === corridorActiveRowIndex) {
            handleCorridorCardClick(stage, card);
          }
        });
      });
    });
  }

  /**
   * Handle card click in corridor
   */
  function handleCorridorCardClick(stage, card) {
    const grp = CORRIDOR_GRP_MAP[stage];
    const val = card.dataset.val;

    // Skip if card is locked
    if (card.classList.contains('locked')) {
      return;
    }

    // Update selection state
    corridorSelections.set(stage, {
      grp: grp,
      val: val,
      card: card
    });

    // Update continue button visibility
    updateCorridorContinueButtonVisibility();

    console.log(`[Corridor] Selection: ${stage} = ${val}`);
  }

  /**
   * Bind corridor continue buttons
   * CONTROL PLANE: Single #continueButton dispatches to current active stage
   */
  function bindCorridorContinueButtons() {
    // CONTROL PLANE: Bind the single Continue button to dispatch based on active stage
    const controlPlaneBtn = document.getElementById('continueButton');
    if (controlPlaneBtn) {
      controlPlaneBtn.addEventListener('click', () => {
        const stage = CORRIDOR_STAGES[corridorActiveRowIndex];
        if (stage) {
          console.log(`[Control Plane] Continue clicked for stage: ${stage}`);

          // SPECIAL CASE: Character section (identity stage or during authorship)
          // Dispatch to continueFromCharacters button
          const characterSection = document.getElementById('characterSectionRow');
          if ((stage === 'identity' || stage === 'authorship') && characterSection && !characterSection.classList.contains('hidden')) {
            const charContinueBtn = document.getElementById('continueFromCharacters');
            if (charContinueBtn) {
              console.log('[Control Plane] Dispatching to character section Continue');
              charContinueBtn.click();
              return;
            }
          }

          // AUTHORSHIP: Has a separate animation handler on continueFromAuthorship
          // (bound at module scope when row 0 is in DOM). Dispatch to it.
          if (stage === 'authorship') {
            const authBtn = document.getElementById('continueFromAuthorship');
            if (authBtn) { authBtn.click(); return; }
          }

          // ALL OTHER STAGES: Call handleCorridorContinue directly.
          // Legacy per-row buttons are unmounted at init (only row 0 is in DOM),
          // so bindCorridorContinueButtons never binds handlers to them.
          // Clicking an unbound button does nothing â€” dispatch directly instead.
          handleCorridorContinue(stage);
        }
      });
    }

    // Legacy: Keep per-stage button bindings for any remaining direct handlers
    CORRIDOR_STAGES.forEach((stage) => {
      const buttonIds = [
        `corridorContinue${stage.charAt(0).toUpperCase() + stage.slice(1)}`,
        `continueFrom${stage.charAt(0).toUpperCase() + stage.slice(1)}`
      ];

      buttonIds.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.addEventListener('click', () => handleCorridorContinue(stage));
        }
      });
    });
  }

  /**
   * Update continue button visibility for current corridor row
   * CONTROL PLANE: Uses single #continueButton, not per-corridor buttons
   */
  function updateCorridorContinueButtonVisibility() {
    const controlPlaneBtn = document.getElementById('continueButton');
    if (!controlPlaneBtn) return;

    const stage = CORRIDOR_STAGES[corridorActiveRowIndex];
    if (!stage) {
      controlPlaneBtn.classList.remove('visible');
      return;
    }

    const grp = CORRIDOR_GRP_MAP[stage];

    // Check for selection via multiple sources (handles auto-filled selections)
    let hasSelection =
      corridorSelections.has(stage) ||
      (grp && state.picks && state.picks[grp]) ||
      document.querySelector(`.sb-card[data-grp="${grp}"].selected`);

    // AUTHORSHIP STAGE: Check state.authorship for pending selection
    // Also check if character section is visible (always show Continue when it is)
    if (stage === 'authorship') {
      const characterSection = document.getElementById('characterSectionRow');
      const charSectionVisible = characterSection && !characterSection.classList.contains('hidden');
      hasSelection = !!state.authorship || charSectionVisible;
    }

    // ARCHETYPE STAGE: Check for primary archetype selection OR last-zoomed card
    if (stage === 'storybeau') {
      hasSelection = (state.archetype && state.archetype.primary != null) ||
                     (lastZoomedArchetype != null);
    }

    // These rows always show their button when active (not card-based selection)
    const alwaysShowForRow = (stage === 'authorship' || stage === 'identity' || stage === 'arousal' || stage === 'safety' || stage === 'vetoquill' || stage === 'beginstory');

    controlPlaneBtn.classList.toggle('visible', hasSelection || alwaysShowForRow);

    // God Mode toggle: only visible on vetoquill stage in solo mode
    const godToggle = document.getElementById('godModeToggle');
    if (godToggle) {
      const showGod = stage === 'vetoquill' && state.mode === 'solo';
      godToggle.classList.toggle('hidden', !showGod);
    }
  }

  /**
   * Handle continue from a corridor stage
   * CORRIDOR INTERACTION: Pure state advance, no animation delays
   * a) Finalizes the current row selection
   * b) Advances corridorActiveRowIndex
   * c) Mounts the next corridor row
   */
  function handleCorridorContinue(stage) {
    const stageIdx = CORRIDOR_STAGES.indexOf(stage);
    if (stageIdx !== corridorActiveRowIndex) {
      console.log(`[Corridor] Ignoring continue for non-active stage: ${stage}`);
      return;
    }

    const grp = CORRIDOR_GRP_MAP[stage];

    // Find selection from DOM or state.picks (handles auto-filled selections)
    let selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"].selected`);
    let selectedVal = selectedCard?.dataset.val || (grp && state.picks ? state.picks[grp] : null);

    // Special case: Authorship stage â€” breadcrumb created by animateAuthorshipCardToBreadcrumb
    // Only hide button here; corridor advancement handled by custom authorship handler
    if (stage === 'authorship') {
      if (!state.authorship) {
        console.log(`[Corridor] No authorship selection yet`);
        return;
      }
      console.log(`[Corridor] Authorship selected: ${state.authorship} â€” breadcrumb via animation`);
      hideCorridorContinueButton(stage);
      // Do NOT advanceCorridorRow here â€” the custom authorship handler does it
      return;
    }

    // Special case: Storybeau (archetype) â€” Continue selects the last-zoomed card
    if (stage === 'storybeau') {
      // Check for last-zoomed card (from zoom view)
      const zoomedId = lastZoomedArchetype;

      // If no card has been zoomed and no prior selection, pulse Continue and block
      if (!zoomedId && !state.archetype?.primary) {
        console.log(`[Corridor] No archetype zoomed â€” blocking Continue`);
        triggerContinueButtonFeedback('continueFromStorybeau');
        return;
      }

      // Use last-zoomed card if available, otherwise use prior selection
      const archetypeId = zoomedId || state.archetype?.primary;

      // Commit the selection (if not already committed)
      if (state.archetype?.primary !== archetypeId) {
        commitArchetypeSelection(archetypeId, false);
      }

      // Stop the focus sparkle emitter
      if (lastZoomedSparkleEmitterId) {
        stopSparkleEmitter(lastZoomedSparkleEmitterId);
        lastZoomedSparkleEmitterId = null;
      }
      // Remove focus indicator
      const focusedCard = document.querySelector('.archetype-card.last-zoomed');
      if (focusedCard) {
        focusedCard.classList.remove('last-zoomed');
        const sparkleContainer = focusedCard.querySelector('.archetype-focus-sparkles');
        if (sparkleContainer) sparkleContainer.remove();
      }

      console.log(`[Corridor] Archetype committed via Continue: ${archetypeId}`);

      const archetype = ARCHETYPES[archetypeId];
      const archetypeName = archetype?.name || archetypeId;

      hideCorridorContinueButton(stage);

      // If selected via Destiny's Choice, breadcrumb was already created â€” just advance
      if (archetypeSelectedViaDestiny) {
        setTimeout(() => advanceCorridorRow(), 600);
        return;
      }

      // Sparkle teleport from selected card to breadcrumb III
      const selectedCard = document.querySelector(
        `#archetypeCardGrid .archetype-card[data-archetype="${archetypeId}"]`
      );
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const archGhostIdx = STAGE_INDEX['storybeau'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${archGhostIdx}"]`);

      let targetX, targetY;
      if (ghostStep) {
        const ghostRect = ghostStep.getBoundingClientRect();
        targetX = ghostRect.left + ghostRect.width / 2;
        targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
        const brRect = breadcrumbRow.getBoundingClientRect();
        targetX = brRect.left + brRect.width / 2;
        targetY = brRect.top + brRect.height / 2;
      }

      if (selectedCard && targetX !== undefined) {
        const cardRect = selectedCard.getBoundingClientRect();
        const cardCenterX = cardRect.left + cardRect.width / 2;
        const cardCenterY = cardRect.top + cardRect.height / 2;

        // Phase 1: Dissolution sparkles + fade card
        selectedCard.style.opacity = '0.3';
        const dissolutionCount = 12 + Math.floor(Math.random() * 5);
        for (let i = 0; i < dissolutionCount; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'dissolution-sparkle';
            const sx = cardRect.left + Math.random() * cardRect.width;
            const sy = cardRect.top + Math.random() * cardRect.height;
            sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 400);
          }, i * 25);
        }

        // Phase 2: Sparkle travel to breadcrumb target
        setTimeout(() => {
          const travelCount = 6 + Math.floor(Math.random() * 3);
          for (let i = 0; i < travelCount; i++) {
            setTimeout(() => {
              const sparkle = document.createElement('div');
              sparkle.className = 'traveling-sparkle';
              const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
              const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
              const sx = cardCenterX + offX;
              const sy = cardCenterY + offY;
              const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
              const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
              sparkle.style.cssText = `
                left: ${sx}px; top: ${sy}px;
                --target-x: ${targetX - sx}px;
                --target-y: ${targetY - sy}px;
                --arc-x: ${midX - sx}px;
                --arc-y: ${midY - sy}px;
              `;
              document.body.appendChild(sparkle);
              setTimeout(() => sparkle.remove(), 600);
            }, i * 40);
          }
        }, 200);

        // Phase 3: Convergence sparkles + breadcrumb + advance
        setTimeout(() => {
          for (let i = 0; i < 5; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'convergence-sparkle';
            const angle = (Math.PI * 2 * i) / 5;
            const dist = 15 + Math.random() * 10;
            sparkle.style.cssText = `
              left: ${targetX + Math.cos(angle) * dist}px;
              top: ${targetY + Math.sin(angle) * dist}px;
            `;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 500);
          }

          selectedCard.style.opacity = '';
          createArchetypeBreadcrumbWithMask(archetypeId, false);

          // Advance after materializing animation
          setTimeout(() => advanceCorridorRow(), 600);
        }, 600);

      } else {
        // Fallback: no animation
        createArchetypeBreadcrumbWithMask(archetypeId, false);
        setTimeout(() => advanceCorridorRow(), 600);
      }
      return;
    }

    // Special case: Arousal â€” create breadcrumb from selected card, then advance
    if (stage === 'arousal') {
      const arousalGrp = CORRIDOR_GRP_MAP[stage]; // 'intensity'
      const arousalCard = document.querySelector(`.sb-card[data-grp="${arousalGrp}"].selected`);
      const arousalVal = arousalCard?.dataset.val || state.picks?.intensity || state.intensity;

      if (arousalCard) {
        const sparkleContainer = arousalCard.querySelector('.card-selection-sparkles');
        if (sparkleContainer && typeof stopSparkleEmitter === 'function') {
          stopSparkleEmitter(sparkleContainer.id);
        }
      }

      if (arousalVal) {
        const titleEl = arousalCard?.querySelector('.sb-card-title');
        const arousalTitle = titleEl ? titleEl.textContent : arousalVal;
        createBreadcrumbDirect(arousalGrp, arousalVal, arousalTitle);
      }

      console.log(`[Corridor] Arousal complete, advancing to safety`);
      hideCorridorContinueButton(stage);
      setTimeout(() => advanceCorridorRow(), 600);
      return;
    }

    // Special case: Safety â€” commit safety/boundary state and advance
    if (stage === 'safety') {
      console.log(`[Corridor] Safety & Boundaries committed`);
      // Collect checkbox states into state.safety
      const darkThemes = document.getElementById('chkDark')?.checked || false;
      const nonCon = document.getElementById('chkNonCon')?.checked || false;
      const violence = document.getElementById('chkViolence')?.checked || false;
      // Collect boundary chips
      const boundaries = [];
      document.querySelectorAll('#boundaryChips .chip-gold.active').forEach(c => {
        boundaries.push(c.textContent.trim());
      });
      state.safety = { darkThemes, nonConImplied: nonCon, violence, boundaries, mode: 'balanced' };
      // Create breadcrumb for safety
      const safetyLabel = darkThemes ? 'Dark OK' : 'No Dark';
      createBreadcrumbDirect('safety', darkThemes ? 'dark' : 'safe', safetyLabel);
      hideCorridorContinueButton(stage);
      // Advance after breadcrumb materializes so user sees it land
      setTimeout(() => advanceCorridorRow(), 600);
      return;
    }

    // Special case: Veto/Quill â€” auto-commit veto, then advance to Begin Story row
    if (stage === 'vetoquill') {
      console.log(`[Corridor] Veto/Quill complete, advancing to Begin Story row`);

      // Auto-commit any pending veto text (Commit button removed from UI)
      const vetoEl = document.getElementById('vetoInput');
      if (vetoEl && vetoEl.value.trim()) {
        const lines = vetoEl.value.trim().split('\n').filter(l => l.trim());
        for (const line of lines) {
          const rawPhrase = line.trim();
          if (!state.committedVeto.includes(rawPhrase)) {
            state.committedVeto.push(rawPhrase);
          }
        }
        renderCommittedPhrases('veto');
        applyVetoFromInput();
      }

      // Auto-commit any pending quill text (Commit button removed from UI)
      const quillEl = document.getElementById('quillInput');
      if (quillEl && quillEl.value.trim()) {
        const rawQuillText = quillEl.value.trim();
        // Store quill intent in state for prompt injection
        window.state.quillIntent = rawQuillText;
        state.committedQuill.push(rawQuillText);
        renderCommittedPhrases('quill');
        window.state.quillCommittedThisTurn = true;
        window.state.quill.uses++;
        window.state.quill.nextReadyAtWords = (typeof currentStoryWordCount === 'function' ? currentStoryWordCount() : 0) + (typeof computeNextCooldownWords === 'function' ? computeNextCooldownWords() : 1200);
        quillEl.value = '';
      }

      hideCorridorContinueButton(stage);
      advanceCorridorRow();
      return;
    }

    // Special case: Begin Story â€” terminal row, transitions to story mode
    // Note: This is handled by beginBtn click handler, not Continue button
    if (stage === 'beginstory') {
      console.log(`[Corridor] Begin Story row â€” terminal action handled by beginBtn`);
      return;
    }

    if (!selectedVal) {
      console.log(`[Corridor] No selection for stage: ${stage}`);
      return;
    }

    console.log(`[Corridor] Continuing from ${stage}: ${selectedVal}`);

    // Hide continue button immediately
    hideCorridorContinueButton(stage);

    // Stop sparkles on the selected card before advancing
    if (selectedCard) {
      const sparkleContainer = selectedCard.querySelector('.card-selection-sparkles');
      if (sparkleContainer && typeof stopSparkleEmitter === 'function') {
        stopSparkleEmitter(sparkleContainer.id);
      }
    }

    // Create breadcrumb for this selection
    if (selectedCard) {
      const titleEl = selectedCard.querySelector('.sb-card-title');
      const selectedTitle = titleEl ? titleEl.textContent : selectedVal;
      createBreadcrumbDirect(grp, selectedVal, selectedTitle);
    }

    // Advance after breadcrumb materializes so user sees it land
    setTimeout(() => advanceCorridorRow(), 600);
  }

  /**
   * Hide the continue button (control plane)
   */
  function hideCorridorContinueButton(stage) {
    const controlPlaneBtn = document.getElementById('continueButton');
    if (controlPlaneBtn) controlPlaneBtn.classList.remove('visible');
  }

  /**
   * Scale breadcrumb title font if text is too long
   * Never clip, truncate, or ellipsize â€” scale font down instead
   * @param {HTMLElement} breadcrumb - The breadcrumb card element
   */
  function scaleBreadcrumbTitle(breadcrumb) {
    const titleEl = breadcrumb.querySelector('.sb-card-title');
    if (!titleEl) return;

    const text = (titleEl.textContent || '').trim();
    if (!text) return;

    // Find the longest word â€” that's the minimum width we must fit
    const words = text.split(/\s+/);
    const cardWidth = breadcrumb.offsetWidth || 45; // fallback to CSS width
    const availWidth = cardWidth - 4; // subtract padding (0 2px each side)

    // Use a canvas to measure text width at a given font size
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontFamily = "'Cinzel', 'Lora', serif";

    function longestWordWidth(size) {
      ctx.font = `700 ${size}px ${fontFamily}`;
      let maxW = 0;
      for (const w of words) {
        const m = ctx.measureText(w).width;
        if (m > maxW) maxW = m;
      }
      return maxW;
    }

    // Start at base size, scale down until the longest word fits
    let fontSize = 7;
    const minSize = 3;
    while (fontSize > minSize && longestWordWidth(fontSize) > availWidth) {
      fontSize -= 0.5;
    }

    titleEl.style.fontSize = `${fontSize}px`;
    titleEl.style.lineHeight = '1.3';
  }

  /**
   * Create a breadcrumb directly without animation
   * CORRIDOR INTERACTION: Pure state, no delays
   * GHOST STEP: Replaces corresponding ghost step placeholder
   */
  function createBreadcrumbDirect(grp, val, title) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    // Check if breadcrumb should be excluded (these stages don't become breadcrumbs)
    if (grp === 'safety' || grp === 'vetoquill' || grp === 'beginstory') {
      console.log(`[Breadcrumb] EXCLUDED: ${grp} â€” never becomes breadcrumb`);
      // Still remove the ghost step for this stage (if any)
      const ghostIdx = STAGE_INDEX[grp];
      if (ghostIdx !== undefined && ghostIdx >= 0) removeGhostStep(ghostIdx);
      return;
    }

    // AUTHORITATIVE: Use STAGE_INDEX for fixed corridor index
    // No positional inference, no fallbacks, no "next available slot" logic
    const stageIdx = STAGE_INDEX[grp];
    if (stageIdx === undefined) {
      console.warn(`[Breadcrumb] Unknown grp: ${grp} â€” not in STAGE_INDEX`);
      return;
    }

    // Remove existing breadcrumb for this stage (prevents duplicates on re-navigation)
    const existingCard = breadcrumbRow.querySelector(`.breadcrumb-card[data-grp="${grp}"]`);
    if (existingCard) existingCard.remove();

    // Get structured label
    const label = typeof getBreadcrumbLabel === 'function'
      ? getBreadcrumbLabel(grp, val)
      : { title: title || val, subtitle: null };

    const subtitleHtml = label.subtitle
      ? `<span class="breadcrumb-subtitle">${label.subtitle}</span>`
      : '';

    // Create breadcrumb card
    const breadcrumb = document.createElement('div');
    breadcrumb.className = 'breadcrumb-card materializing';
    breadcrumb.dataset.grp = grp;
    breadcrumb.dataset.val = val;
    breadcrumb.dataset.stageIndex = stageIdx;
    breadcrumb.dataset.breadcrumbLabel = grp.charAt(0).toUpperCase() + grp.slice(1);
    breadcrumb.innerHTML = `
      <div class="sb-card-inner">
        <div class="sb-card-face sb-card-back">
          <span class="sb-card-title">${label.title}</span>
          ${subtitleHtml}
        </div>
        <div class="sb-card-face sb-card-front">
          <span class="sb-card-title">${label.title}</span>
          ${subtitleHtml}
        </div>
      </div>
    `;

    // Insert breadcrumb at correct position based on stage index
    // Find the first breadcrumb or ghost step with a HIGHER stage index
    const allSlots = breadcrumbRow.querySelectorAll('.breadcrumb-card, .ghost-step');
    let insertBefore = null;
    for (const slot of allSlots) {
      const slotIdx = parseInt(slot.dataset.stageIndex ?? slot.dataset.ghostIndex, 10);
      if (!isNaN(slotIdx) && slotIdx > stageIdx) {
        insertBefore = slot;
        break;
      }
    }
    if (insertBefore) {
      breadcrumbRow.insertBefore(breadcrumb, insertBefore);
    } else {
      breadcrumbRow.appendChild(breadcrumb);
    }

    // Scale font for long titles (never clip/truncate)
    scaleBreadcrumbTitle(breadcrumb);

    // Remove the corresponding ghost step
    if (stageIdx >= 0) {
      removeGhostStep(stageIdx);
    }

    // Remove materializing class after animation completes
    setTimeout(() => breadcrumb.classList.remove('materializing'), 400);

    // Attach destructive navigation handler
    if (typeof attachBreadcrumbNavigation === 'function') {
      attachBreadcrumbNavigation(breadcrumb);
    }

    // Sparkles on the active (most recent) breadcrumb
    updateActiveBreadcrumbSparkles(breadcrumb);

    console.log(`[Breadcrumb] Created: ${grp}=${val} (replaces ghost step ${stageIdx + 1})`);
  }

  /**
   * Move sparkles to the most recently created breadcrumb
   * Removes sparkles from any previous breadcrumb, adds to the new one
   */
  function updateActiveBreadcrumbSparkles(newBreadcrumb) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    // Stop and remove sparkles from all breadcrumbs
    breadcrumbRow.querySelectorAll('.breadcrumb-card .breadcrumb-active-sparkles').forEach(container => {
      if (typeof stopSparkleEmitter === 'function') {
        stopSparkleEmitter(container.id);
      }
      container.remove();
    });

    if (!newBreadcrumb) return;

    // Add sparkle container to the new breadcrumb
    const sparkleContainer = document.createElement('div');
    sparkleContainer.className = 'breadcrumb-active-sparkles';
    sparkleContainer.id = `breadcrumbSparkle_${newBreadcrumb.dataset.grp}_${Date.now()}`;
    newBreadcrumb.appendChild(sparkleContainer);

    if (typeof startSparkleEmitter === 'function') {
      startSparkleEmitter(sparkleContainer.id, 'destinyDeck', 1.5);
    }
  }

  /**
   * Advance to the next corridor row
   */
  function advanceCorridorRow() {
    corridorActiveRowIndex++;

    if (corridorActiveRowIndex < CORRIDOR_STAGES.length) {
      console.log(`[Corridor] Advancing to row ${corridorActiveRowIndex}: ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
      updateCorridorVisibility();
      updateCorridorContinueButtonVisibility();
      // DSP VISIBILITY GATE: Show DSP only after World is committed (index >= 3)
      // Authorship=0, Archetype=1, World=2 â†’ DSP hidden
      // Tone=3 and beyond â†’ DSP visible
      updateDSPCorridorVisibility();
    } else {
      console.log('[Corridor] All rows complete. Flow finished.');
      onCorridorComplete();
    }
  }

  /**
   * DSP VISIBILITY GATE â€” DSP only visible during World, Tone, Pressure, POV, Length
   * Hidden before World and after Length (Dynamic, Arousal, Safety, etc.)
   */
  function updateDSPCorridorVisibility() {
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (!synopsisPanel) return;

    // DSP visible ONLY during these stages:
    // 3=world, 4=tone, 5=pressure, 6=pov, 7=length
    // Hidden during: 0=authorship, 1=identity, 2=storybeau, 8=dynamic, 9=arousal, 10+=safety/vetoquill/beginstory
    const DSP_START_INDEX = 3;  // World
    const DSP_END_INDEX = 7;    // Length

    if (corridorActiveRowIndex >= DSP_START_INDEX && corridorActiveRowIndex <= DSP_END_INDEX) {
      showDSP(); // Populates content AND adds .visible
      console.log(`[DSP] Visible â€” stage ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
    } else {
      hideDSP(); // Removes .visible
      console.log(`[DSP] Hidden â€” stage ${CORRIDOR_STAGES[corridorActiveRowIndex] || corridorActiveRowIndex}`);
    }
  }

  /**
   * Called when all corridor rows are complete
   */
  function onCorridorComplete() {
    console.log('[Corridor] Corridor complete. Proceeding to Safety/Veto/Begin Story.');

    // Clear any remaining ghost steps
    clearAllGhostSteps();

    // Show the post-arousal sections (Safety, Veto, Begin Story)
    // These are now wrapped in a single container that starts hidden
    const postArousalSection = document.getElementById('postArousalSection');
    if (postArousalSection) {
      postArousalSection.classList.remove('hidden');
      console.log('[Corridor] Post-arousal sections revealed');
    }

    // Legacy element references (for backward compatibility)
    const safetySection = document.getElementById('safetySection');
    const beginSection = document.getElementById('beginStorySection');
    if (safetySection) safetySection.classList.remove('hidden');
    if (beginSection) beginSection.classList.remove('hidden');

    // DSP: Fade out after corridor completion (AUTHORITATIVE)
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      synopsisPanel.classList.add('corridor-complete');
      console.log('[Corridor] DSP faded out after corridor completion');
    }

    // VIEWPORT ISOLATION: Exit corridor mode, allow scrolling to final sections
    document.body.classList.remove('corridor-mode');
    document.body.classList.add('corridor-complete');
  }

  /**
   * Reset corridor to initial state
   * Uses corridorRowStore to reset cards (may be unmounted from DOM)
   */
  function resetCorridor() {
    corridorActiveRowIndex = 0;
    corridorSelections.clear();

    // VIEWPORT ISOLATION: Re-enter corridor mode on reset
    document.body.classList.add('corridor-mode');
    document.body.classList.remove('corridor-complete');

    // Reset authorship choice (Choose Your Hand / Guided Fate cards)
    if (typeof window.resetAuthorshipChoice === 'function') {
      window.resetAuthorshipChoice();
    }

    // Clear breadcrumb row
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (breadcrumbRow) breadcrumbRow.innerHTML = '';

    // Reinitialize ghost steps for fresh corridor
    initGhostSteps();

    // Reset all corridor rows using stored element references
    // This works even when elements are unmounted from DOM
    corridorRowStore.forEach((stored, stage) => {
      stored.elements.forEach(el => {
        // Reset card visibility and state within this element
        el.querySelectorAll('.sb-card').forEach(card => {
          card.style.visibility = '';
          card.style.opacity = '';
          card.classList.remove('dissipating', 'selected', 'flipped', 'becoming-breadcrumb');
        });
      });
    });

    // Reset corridor visibility via DOM mount/unmount
    updateCorridorVisibility();
    updateCorridorContinueButtonVisibility();

    // DSP VISIBILITY GATE: Hide DSP on reset (corridor back to row 0)
    updateDSPCorridorVisibility();

    // Restore DSP visibility state (remove corridor-complete class)
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      synopsisPanel.classList.remove('corridor-complete');
    }

    // Clear state picks
    state.picks = state.picks || {};
    state.picks.pressure = null;
    state.picks.world = null;
    state.picks.tone = null;
    state.picks.dynamic = null;
    state.picks.pov = null;
    state.picks.length = null;
    state.picks.intensity = null;
    state.picks.archetype = null;

    console.log('[Corridor] Reset complete. Active row:', corridorActiveRowIndex);
  }

  /**
   * Autoplay corridor row-by-row when Guided Fate is selected
   * Each row appears, card is selected, animates to breadcrumb, others dissolve, advance
   */
  async function autoplayCorridorFromGuidedFate() {
    console.log('[Corridor] Starting row-by-row autoplay from Guided Fate');

    // Start from row 1 (Guided Fate is row 0, already handled)
    // Advance past row 0 first
    corridorActiveRowIndex = 1;
    updateCorridorVisibility();

    // Autoplay timing (ms)
    const ROW_SHOW_DELAY = 400;      // Time to show row before selecting
    const BREADCRUMB_DELAY = 700;    // Time for breadcrumb animation
    const DISSIPATE_DELAY = 500;     // Time for card dissipation
    const INTER_ROW_DELAY = 200;     // Pause between rows

    // Process rows 1 through 8 (storybeau through arousal)
    for (let rowIdx = 1; rowIdx < CORRIDOR_STAGES.length; rowIdx++) {
      const stage = CORRIDOR_STAGES[rowIdx];
      const grp = CORRIDOR_GRP_MAP[stage];

      // Update active row
      corridorActiveRowIndex = rowIdx;
      updateCorridorVisibility();

      // Brief pause to show the row
      await new Promise(r => setTimeout(r, ROW_SHOW_DELAY));

      // Find the selected card for this stage (Guided Fate already set the selection)
      const selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"].selected`);

      if (selectedCard) {
        const selectedVal = selectedCard.dataset.val;
        const titleEl = selectedCard.querySelector('.sb-card-title');
        const selectedTitle = titleEl ? titleEl.textContent : selectedVal;

        // Store in corridor selections
        corridorSelections.set(stage, {
          grp: grp,
          val: selectedVal,
          card: selectedCard
        });

        // Get parent row for card dissipation
        const parentRow = selectedCard.closest('.card-flow-row, .corridor-row, .sb-grid');

        // Animate selected card to breadcrumb
        await new Promise(resolve => {
          animateCardToBreadcrumb(selectedCard, grp, selectedVal, selectedTitle, resolve);
        });

        // Wait for breadcrumb animation
        await new Promise(r => setTimeout(r, BREADCRUMB_DELAY));

        // Dissipate other cards
        if (parentRow) {
          const otherCards = parentRow.querySelectorAll(`.sb-card[data-grp="${grp}"]:not(.selected)`);
          if (otherCards.length > 0) {
            await new Promise(resolve => {
              dissipateCards(otherCards, resolve);
            });
            await new Promise(r => setTimeout(r, DISSIPATE_DELAY));
          }
        }

        // Inter-row pause
        await new Promise(r => setTimeout(r, INTER_ROW_DELAY));
      }

      console.log(`[Corridor] Autoplay completed row ${rowIdx}: ${stage}`);
    }

    // All rows complete
    corridorActiveRowIndex = CORRIDOR_STAGES.length;
    console.log('[Corridor] Autoplay complete. All rows processed.');
    onCorridorComplete();
  }

  // Legacy alias for backwards compatibility
  function completeCorridorFromGuidedFate() {
    autoplayCorridorFromGuidedFate();
  }

  // Expose corridor functions globally
  window.initCorridor = initCorridor;
  window.resetCorridor = resetCorridor;
  window.advanceCorridorRow = advanceCorridorRow;
  window.autoplayCorridorFromGuidedFate = autoplayCorridorFromGuidedFate;
  window.completeCorridorFromGuidedFate = completeCorridorFromGuidedFate; // Legacy alias
  window.updateDSPCorridorVisibility = updateDSPCorridorVisibility;
  window.updateCorridorContinueButtonVisibility = updateCorridorContinueButtonVisibility;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SYNOPSIS PANEL - Live-updating story preview based on 4-axis selections
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  // â•‘                    LOCKED DESIGN RULES                            â•‘
  // â•‘                                                                   â•‘
  // â•‘ 1. The floating synopsis panel must remain visually restrained   â•‘
  // â•‘    and literary. No glassmorphism, glow effects, or color-coded  â•‘
  // â•‘    highlighting. It should feel like an authorial whisper.       â•‘
  // â•‘                                                                   â•‘
  // â•‘ 2. Genres must describe narrative action or fantasy, not setting â•‘
  // â•‘    or life stage. "Sports", "College", "Small Town" are not      â•‘
  // â•‘    genresâ€”they are world modifiers.                              â•‘
  // â•‘                                                                   â•‘
  // â•‘ 3. Relationship Dynamics are single-select and represent         â•‘
  // â•‘    emotional structure, not identity. They describe how          â•‘
  // â•‘    characters relate, not who they are.                          â•‘
  // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP FIXED TEMPLATE â€” ASSEMBLED, NOT AUTHORED
  // Two-sentence ceremonial template with locked phrase injection.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP WORLD PHRASES â€” LOCKED CANON (DO NOT MODIFY)
  // Used as: "In [world] â€¦"
  // Supernatural is a Modern subtype, not a standalone world.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const DSP_WORLD_PHRASES = {
    Modern: 'a modern world of ambition and things left unsaid',
    Historical: 'an era of duty, reputation, and unyielding tradition',
    Fantasy: 'a realm of oaths, myth, and old magic',
    SciFi: 'an age of technological acceleration and alien laws',
    Dystopia: 'a world of surveillance, rationed freedom, and enforced order',
    PostApocalyptic: 'a broken world of scarcity, ruins, and hard bargains'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //                    GENRE REGIME: NESTED PRESSURE MODEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PHILOSOPHY:
  // Genres are PRESSURE ENGINES, not bookshelf categories.
  // They shape pacing, tension, romantic cost, and consequence timing.
  // Worlds are aesthetic lenses. Tone controls narration style.
  //
  // HIERARCHY:
  // Primary Pressure (required) â†’ Flavor (optional)
  // User sees â‰¤8 pressures, then optionally 3-5 flavors.
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // PRIMARY PRESSURES â€” THE ONLY TOP-LEVEL CHOICES (max 8)
  const PRIMARY_PRESSURES = {
    PowerControl: {
      id: 'PowerControl',
      label: 'Power & Control',
      description: 'Someone has leverage. Someone else pays for it.',
      dspPhrase: 'power, leverage, and the cost of control'
    },
    RiskExposure: {
      id: 'RiskExposure',
      label: 'Risk & Exposure',
      description: 'Being seen, known, caught, or revealed is dangerous.',
      dspPhrase: 'secrets, exposure, and the danger of being known'
    },
    EscapePursuit: {
      id: 'EscapePursuit',
      label: 'Escape & Pursuit',
      description: 'Leaving, rescuing, or outrunning something.',
      dspPhrase: 'locked doors, narrow windows, and the clock'
    },
    ObligationBurden: {
      id: 'ObligationBurden',
      label: 'Obligation & Burden',
      description: 'Duty, destiny, or expectation presses inward.',
      dspPhrase: 'duty, expectation, and the weight of what must be'
    },
    DesireObsession: {
      id: 'DesireObsession',
      label: 'Desire & Obsession',
      description: 'Wanting something too much, too soon, or for the wrong reasons.',
      dspPhrase: 'fixation, escalation, and loss of control'
    },
    ReckoningPast: {
      id: 'ReckoningPast',
      label: 'Reckoning & Past',
      description: 'History, guilt, or unfinished business intrudes.',
      dspPhrase: 'old debts, buried identities, and consequences that refuse to stay buried'
    },
    Transformation: {
      id: 'Transformation',
      label: 'Transformation',
      description: 'Someone is becoming something they didn\'t plan to be.',
      dspPhrase: 'becoming, unraveling, and the stranger in the mirror'
    },
    Survival: {
      id: 'Survival',
      label: 'Survival',
      description: 'Staying alive â€” socially, politically, physically, or emotionally.',
      dspPhrase: 'scarcity, endurance, and brutal choices'
    }
  };

  // PRESSURE FLAVORS â€” OPTIONAL REFINEMENTS (never required, never change authority)
  const PRESSURE_FLAVORS = {
    PowerControl: [
      { id: 'Billionaire', label: 'Billionaire', description: 'Ultra-wealth, power plays, golden cages.' },
      { id: 'CrimeSyndicate', label: 'Crime Syndicate', description: 'Organized crime, loyalty, blood oaths.' },
      { id: 'Political', label: 'Political Intrigue', description: 'Power structures, alliances, betrayal.' },
      { id: 'Espionage', label: 'Espionage', description: 'Spies, double lives, dangerous information.' },
      { id: 'CultOrder', label: 'Cult / Order', description: 'Hierarchies of belief, obedience, doctrine.' }
    ],
    RiskExposure: [
      { id: 'Noir', label: 'Noir', description: 'Shadows, moral compromise, fatalism.' },
      { id: 'ForbiddenKnowledge', label: 'Forbidden Knowledge', description: 'Curiosity, revelation, the price of knowing.' },
      { id: 'PublicScandal', label: 'Public Scandal', description: 'Reputation on the line, exposure as weapon.' },
      { id: 'Surveillance', label: 'Surveillance', description: 'Always watched, privacy as currency.' },
      { id: 'DoubleLife', label: 'Double Life', description: 'Two selves, one secret, inevitable collision.' }
    ],
    EscapePursuit: [
      { id: 'Heist', label: 'Heist', description: 'Elaborate plans, trust and betrayal.' },
      { id: 'Rescue', label: 'Rescue / Retrieval', description: 'Someone needs saving. Someone pays the price.' },
      { id: 'OnTheRun', label: 'On the Run', description: 'Fleeing, hunted, no safe harbor.' },
      { id: 'Captivity', label: 'Prison / Captivity', description: 'Cages visible or invisible, escape as obsession.' },
      { id: 'BorderCrossing', label: 'Border Crossing', description: 'Thresholds, checkpoints, forbidden passage.' }
    ],
    ObligationBurden: [
      { id: 'ChosenBurdened', label: 'Chosen / Burdened', description: 'Marked by fate, weighted by purpose.' },
      { id: 'DutyToFamily', label: 'Duty to Family', description: 'Blood obligation, inherited expectation.' },
      { id: 'Prophecy', label: 'Prophecy', description: 'Foreordained, resisted, inevitable.' },
      { id: 'CommandRank', label: 'Command / Rank', description: 'Orders given, orders followed, orders defied.' },
      { id: 'Inheritance', label: 'Inheritance', description: 'Legacy, entitlement, poisoned gifts.' }
    ],
    DesireObsession: [
      { id: 'Obsession', label: 'Obsession', description: 'Fixation, escalation, loss of control.' },
      { id: 'ForbiddenRomance', label: 'Forbidden Romance', description: 'Rules say no. The heart says otherwise.' },
      { id: 'Rivalry', label: 'Rivalry', description: 'Competition as courtship, winning as need.' },
      { id: 'Addiction', label: 'Addiction', description: 'The thing you can\'t stop wanting.' },
      { id: 'Jealousy', label: 'Jealousy', description: 'Possessiveness, comparison, the green edge.' }
    ],
    ReckoningPast: [
      { id: 'RelentlessPast', label: 'Relentless Past', description: 'Identity erosion, old lives resurfacing.' },
      { id: 'Redemption', label: 'Redemption', description: 'Second chances, atonement, becoming worthy.' },
      { id: 'OldDebts', label: 'Old Debts', description: 'What\'s owed never forgets.' },
      { id: 'BetrayalHistory', label: 'Betrayal History', description: 'Trust broken, wounds reopened.' },
      { id: 'LostRelationship', label: 'Lost Relationship', description: 'What was, what ended, what might be again.' }
    ],
    Transformation: [
      { id: 'BecomingPowerful', label: 'Becoming Powerful', description: 'Strength arriving, identity shifting.' },
      { id: 'MoralCorruption', label: 'Moral Corruption', description: 'Lines crossed, self redefined.' },
      { id: 'Awakening', label: 'Awakening', description: 'Dormant becoming active, hidden becoming known.' },
      { id: 'IdentityShift', label: 'Identity Shift', description: 'Who you were is not who you are.' },
      { id: 'Ascension', label: 'Ascension / Mutation', description: 'Evolution, elevation, irreversible change.' }
    ],
    Survival: [
      { id: 'WarZone', label: 'War Zone', description: 'Combat, casualties, survival in conflict.' },
      { id: 'Collapse', label: 'Collapse', description: 'Systems failing, structures crumbling.' },
      { id: 'Exile', label: 'Exile', description: 'Cast out, alone, making do without belonging.' },
      { id: 'Scarcity', label: 'Scarcity', description: 'Not enough, hard choices, rationed hope.' },
      { id: 'EndOfEra', label: 'End of an Era', description: 'The old world dying, the new not yet born.' }
    ]
  };

  // LEGACY GENRE â†’ PRESSURE+FLAVOR MAPPING (Backward Compatibility)
  // Maps old genre values to new pressure system
  const LEGACY_GENRE_TO_PRESSURE = {
    Billionaire: { pressure: 'PowerControl', flavor: 'Billionaire' },
    CrimeSyndicate: { pressure: 'PowerControl', flavor: 'CrimeSyndicate' },
    Political: { pressure: 'PowerControl', flavor: 'Political' },
    Espionage: { pressure: 'PowerControl', flavor: 'Espionage' },
    Noir: { pressure: 'RiskExposure', flavor: 'Noir' },
    ForbiddenKnowledge: { pressure: 'RiskExposure', flavor: 'ForbiddenKnowledge' },
    Heist: { pressure: 'EscapePursuit', flavor: 'Heist' },
    Escape: { pressure: 'EscapePursuit', flavor: 'OnTheRun' },
    Obsession: { pressure: 'DesireObsession', flavor: 'Obsession' },
    RelentlessPast: { pressure: 'ReckoningPast', flavor: 'RelentlessPast' },
    Redemption: { pressure: 'ReckoningPast', flavor: 'Redemption' },
    BuildingBridges: { pressure: 'ReckoningPast', flavor: 'LostRelationship' },
    Purgatory: { pressure: 'Transformation', flavor: 'IdentityShift' },
    Survival: { pressure: 'Survival', flavor: null },
    Sports: { pressure: 'DesireObsession', flavor: 'Rivalry' }
  };

  // FLAVOR â†’ DSP PARAPHRASE OVERRIDES
  // When a flavor is selected, it overrides the pressure's default DSP phrase
  const FLAVOR_DSP_OVERRIDES = {
    Billionaire: 'power, appetite, and polished threat',
    CrimeSyndicate: 'loyalty, leverage, and quiet violence',
    Political: 'alliances, betrayals, and shifting leverage',
    Espionage: 'double lives, coded truths, and invisible wars',
    CultOrder: 'doctrine, hierarchy, and absolute obedience',
    Noir: 'secrets, temptation, and moral compromise',
    ForbiddenKnowledge: 'curiosity, revelation, and the price of knowing',
    PublicScandal: 'reputation, exposure, and public ruin',
    Surveillance: 'watching, being watched, and nowhere to hide',
    DoubleLife: 'two selves, one secret, and inevitable collision',
    Heist: 'precision, misdirection, and nerve',
    Rescue: 'urgency, sacrifice, and the ones left behind',
    OnTheRun: 'flight, pursuit, and vanishing margins',
    Captivity: 'cages, keepers, and the calculus of escape',
    BorderCrossing: 'passage, papers, and the cost of crossing',
    ChosenBurdened: 'fate, purpose, and the weight of being marked',
    DutyToFamily: 'blood, expectation, and the debts we inherit',
    Prophecy: 'foretelling, resistance, and what cannot be escaped',
    CommandRank: 'orders, hierarchy, and the limits of obedience',
    Inheritance: 'legacy, entitlement, and poisoned gifts',
    Obsession: 'fixation, escalation, and loss of control',
    ForbiddenRomance: 'taboo, defiance, and desire against judgment',
    Rivalry: 'competition, obsession, and proving worth',
    Addiction: 'craving, relapse, and the thing you cannot quit',
    Jealousy: 'possession, comparison, and the green edge of love',
    RelentlessPast: 'old debts, buried identities, and consequences that refuse to stay buried',
    Redemption: 'reckoning, mercy, and second chances',
    OldDebts: 'what is owed, what is remembered, and interest accrued',
    BetrayalHistory: 'broken trust, old wounds, and the long memory of love',
    LostRelationship: 'repair, trust, and improbable understanding',
    BecomingPowerful: 'awakening strength, shifting identity, and the cost of power',
    MoralCorruption: 'lines crossed, innocence lost, and the stranger you become',
    Awakening: 'dormant power stirring, hidden truths surfacing',
    IdentityShift: 'unfinished business, reflection, and finding the key to your own lock',
    Ascension: 'evolution, elevation, and irreversible change',
    WarZone: 'combat, survival, and what war takes',
    Collapse: 'systems failing, structures crumbling, adaptation',
    Exile: 'banishment, solitude, and making meaning without belonging',
    Scarcity: 'not enough, hard choices, and rationed hope',
    EndOfEra: 'the old world dying, the new not yet born'
  };

  /**
   * Get DSP paraphrase for current pressure/flavor selection
   * @param {string} pressure - Primary pressure ID
   * @param {string|null} flavor - Optional flavor ID
   * @returns {string} - DSP paraphrase for "shaped by..."
   */
  function getPressureDSPPhrase(pressure, flavor) {
    // If flavor is selected and has an override, use it
    if (flavor && FLAVOR_DSP_OVERRIDES[flavor]) {
      return FLAVOR_DSP_OVERRIDES[flavor];
    }
    // Otherwise use the primary pressure's phrase
    const pressureConfig = PRIMARY_PRESSURES[pressure];
    if (pressureConfig) {
      return pressureConfig.dspPhrase;
    }
    // Fallback for legacy genres
    return 'tension, desire, and unfinished business';
  }

  /**
   * Get effective genre key for legacy systems (cover, title, etc.)
   * Returns flavor if set, otherwise maps pressure to best legacy equivalent
   * @param {string} pressure - Primary pressure ID
   * @param {string|null} flavor - Optional flavor ID
   * @returns {string} - Effective genre key for legacy lookups
   */
  function getEffectiveGenre(pressure, flavor) {
    // If flavor is set, return it directly (many flavors match old genre keys)
    if (flavor) return flavor;

    // Map pressure to default legacy genre
    const PRESSURE_DEFAULT_GENRE = {
      PowerControl: 'Billionaire',
      RiskExposure: 'Noir',
      EscapePursuit: 'Heist',
      ObligationBurden: 'ChosenBurdened',
      DesireObsession: 'Obsession',
      ReckoningPast: 'RelentlessPast',
      Transformation: 'IdentityShift',
      Survival: 'Survival'
    };
    return PRESSURE_DEFAULT_GENRE[pressure] || 'Billionaire';
  }

  /**
   * Migrate legacy genre to pressure+flavor
   * Used for loading old saves
   * @param {string} legacyGenre - Old genre value
   * @returns {{ pressure: string, flavor: string|null }}
   */
  function migrateLegacyGenre(legacyGenre) {
    const mapping = LEGACY_GENRE_TO_PRESSURE[legacyGenre];
    if (mapping) {
      return { pressure: mapping.pressure, flavor: mapping.flavor };
    }
    // Default fallback for unknown genres
    return { pressure: 'PowerControl', flavor: 'Billionaire' };
  }

  /**
   * Check if a pressure is compatible with the current tone
   * @param {string} pressure - Pressure ID
   * @param {string} tone - Tone value
   * @returns {boolean}
   */
  function isPressureCompatible(pressure, tone) {
    // Comedic tone clashes with dark pressures
    if (tone === 'Comedic') {
      // Risk/Exposure (Noir lineage) doesn't fit comedy
      if (pressure === 'RiskExposure') return false;
    }
    return true;
  }

  /**
   * Check if a flavor is compatible with tone
   * @param {string} flavor - Flavor ID
   * @param {string} tone - Tone value
   * @returns {boolean}
   */
  function isFlavorCompatible(flavor, tone) {
    if (!flavor) return true;
    // Noir flavor specifically incompatible with Comedic
    if (tone === 'Comedic' && flavor === 'Noir') return false;
    return true;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP GENRE PARAPHRASES â€” LOCKED CANON (DO NOT MODIFY)
  // Used as: "shaped by â€¦"
  // NOTE: This is retained for backward compatibility. New code should use
  // getPressureDSPPhrase() which understands the pressure+flavor hierarchy.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const DSP_GENRE_PARAPHRASES = {
    CrimeSyndicate: 'loyalty, leverage, and quiet violence',
    Billionaire: 'power, appetite, and polished threat',
    Noir: 'secrets, temptation, and moral compromise',
    Political: 'alliances, betrayals, and shifting leverage',
    Heist: 'precision, misdirection, and nerve',
    Espionage: 'double lives, coded truths, and invisible wars',
    Escape: 'locked doors, narrow windows, and the clock',
    Survival: 'scarcity, endurance, and brutal choices',
    Sports: 'discipline, rivalry, and everything on the line',
    Obsession: 'fixation, escalation, and loss of control',
    Redemption: 'reckoning, mercy, and second chances',
    BuildingBridges: 'repair, trust, and improbable understanding',
    RelentlessPast: 'old debts, buried identities, and consequences that refuse to stay buried',
    ForbiddenKnowledge: 'curiosity, revelation, and the price of knowing',
    Purgatory: 'unfinished business, reflection, and finding the key to your own lock'
  };

  const DSP_ARCHETYPE_ADJECTIVES = {
    HEART_WARDEN: 'controlling',
    OPEN_VEIN: 'overwhelming',
    SPELLBINDER: 'mesmerizing',
    ARMORED_FOX: 'unaccountable',
    DARK_VICE: 'consuming',
    BEAUTIFUL_RUIN: 'self-destructive',
    ETERNAL_FLAME: 'unyielding'
  };

  const DSP_TONAL_ADJECTIVES = {
    Earnest: 'heartfelt',
    WryConfession: 'self-deprecating',
    Poetic: 'brewing',
    Dark: 'suffocating',
    Horror: 'terrifying',
    Mythic: 'fated',
    Comedic: 'utterly unnecessary',
    Surreal: 'reality-bending',
    Satirical: 'forethoughtless'
  };

  /**
   * Generate the DSP â€” fixed two-sentence ceremonial template.
   * Sentence 1: In [WORLD_PHRASE], shaped by [GENRE_PARAPHRASE], a question awaits:
   * Sentence 2: Will [ARCHETYPAL_ADJECTIVE] desire redeem this [TONAL_ADJECTIVE] affair â€” or ruin it?
   * Slots wrapped in dsp-clause spans for progressive reveal.
   * World subtypes are intentionally ignored â€” DSP uses bible phrases only.
   */
  /**
   * Generate DSP sentence from locked template.
   * HARD FAILS if any required input is missing or invalid.
   * No fallbacks, no defaults, no invented prose.
   * @returns {{ success: boolean, html: string|null, error: object|null }}
   */
  function generateDSPSentence() {
    const world = state.picks?.world;
    const genre = state.picks?.genre;
    const tone = state.picks?.tone;
    const archetypeId = state.archetype?.primary;

    // HARD FAIL: No fallback defaults â€” all inputs must be explicitly set
    if (!world) {
      const error = { code: 'DSP_MISSING_WORLD', message: 'DSP generation failed: world not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (!genre) {
      const error = { code: 'DSP_MISSING_GENRE', message: 'DSP generation failed: genre not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (!tone) {
      const error = { code: 'DSP_MISSING_TONE', message: 'DSP generation failed: tone not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (!archetypeId) {
      const error = { code: 'DSP_MISSING_ARCHETYPE', message: 'DSP generation failed: archetype not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // HARD FAIL: Phrase must exist in approved list
    const worldPhrase = DSP_WORLD_PHRASES[world];
    if (!worldPhrase) {
      const error = { code: 'DSP_INVALID_WORLD', message: `DSP generation failed: no approved phrase for world "${world}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // PRESSURE REGIME: Use getPressureDSPPhrase if available, fallback to legacy DSP_GENRE_PARAPHRASES
    const pressure = state.picks?.pressure;
    const flavor = state.picks?.flavor;
    let genrePhrase;
    if (pressure && typeof getPressureDSPPhrase === 'function') {
      genrePhrase = getPressureDSPPhrase(pressure, flavor);
    } else {
      genrePhrase = DSP_GENRE_PARAPHRASES[genre];
    }
    if (!genrePhrase) {
      const error = { code: 'DSP_INVALID_GENRE', message: `DSP generation failed: no approved phrase for genre "${genre}" or pressure "${pressure}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    const archAdj = DSP_ARCHETYPE_ADJECTIVES[archetypeId];
    if (!archAdj) {
      const error = { code: 'DSP_INVALID_ARCHETYPE', message: `DSP generation failed: no approved adjective for archetype "${archetypeId}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    const toneAdj = DSP_TONAL_ADJECTIVES[tone];
    if (!toneAdj) {
      const error = { code: 'DSP_INVALID_TONE', message: `DSP generation failed: no approved adjective for tone "${tone}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // CANONICITY ASSERTION: All DSP components must match canonical maps EXACTLY
    // Guards against any runtime modification or corruption
    if (worldPhrase !== DSP_WORLD_PHRASES[world]) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `World phrase corrupted: expected canonical "${DSP_WORLD_PHRASES[world]}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }
    // PRESSURE REGIME: Canonicity check handles both pressure system and legacy genres
    const expectedGenrePhrase = pressure && typeof getPressureDSPPhrase === 'function'
      ? getPressureDSPPhrase(pressure, flavor)
      : DSP_GENRE_PARAPHRASES[genre];
    if (genrePhrase !== expectedGenrePhrase) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `Genre phrase corrupted: expected canonical "${expectedGenrePhrase}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (archAdj !== DSP_ARCHETYPE_ADJECTIVES[archetypeId]) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `Archetype adjective corrupted: expected canonical "${DSP_ARCHETYPE_ADJECTIVES[archetypeId]}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (toneAdj !== DSP_TONAL_ADJECTIVES[tone]) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `Tone adjective corrupted: expected canonical "${DSP_TONAL_ADJECTIVES[tone]}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // STRICT DSP ASSEMBLY â€” no invented prose, no embellishment
    // Dynamic affair word based on storyLength
    const AFFAIR_WORD_MAP = {
      tease: 'tease',
      fling: 'fling',
      affair: 'affair',
      soulmates: 'cosmic connection'
    };

    // POV pronoun mapping (inserted before archetype adjective)
    const POV_PRONOUN_MAP = {
      First: 'my ',
      Second: 'your ',
      Third: 'their ',
      Fourth: '',      // Omniscient â€” no pronoun
      Fifth: null       // Author POV â€” entirely different sentence
    };

    const pov = state.picks?.pov;
    const isFifthPerson = pov === 'Fifth';
    const povPronoun = pov ? (POV_PRONOUN_MAP[pov] ?? '') : '';

    let html = '';

    // FULL MODE: Only after story has begun (turnCount > 0)
    // SPARSE MODE: During Story Shape and Guided Fate (progressive reveal)
    const storyHasBegun = (state.turnCount || 0) > 0;

    if (isFifthPerson) {
      // 5th Person (Author POV): Different sentence structure entirely
      html = 'The Author sets the stage in <span class="dsp-clause" data-axis="world">' + worldPhrase +
        ',</span> shaped by <span class="dsp-clause" data-axis="genre">' + genrePhrase + '</span>.';
    } else if (storyHasBegun) {
      // FULL MODE: Render complete sentence (story in progress)
      const affairWord = AFFAIR_WORD_MAP[state.storyLength] || 'affair';
      html = 'In <span class="dsp-clause" data-axis="world">' + worldPhrase +
        ', shaped by ' + genrePhrase + '</span>' +
        ', a question awaits: Will ' + povPronoun +
        '<span class="dsp-clause" data-axis="archetype">' + archAdj + '</span>' +
        ' desire redeem this <span class="dsp-clause" data-axis="tone">' + toneAdj + '</span>' +
        ' ' + affairWord + '&#8201;&#8212;&#8201;or ruin it?';
    } else {
      // SPARSE MODE: Build sentence incrementally based on completed selections
      // During Guided Fate: use _revealedDSPAxes
      // During Story Shape: derive from state.picks (user-initiated selections)
      // NO greyed text, NO placeholders, NO future parts
      let hasWorld, hasArchetype, hasTone, hasLength;

      if (_revealedDSPAxes) {
        // Guided Fate mode: use explicit reveal tracking
        hasWorld = _revealedDSPAxes.has('world');
        hasArchetype = _revealedDSPAxes.has('archetype');
        hasTone = _revealedDSPAxes.has('tone');
        hasLength = _revealedDSPAxes.has('length');
      } else {
        // Story Shape mode: derive from completed selections
        // DSP activates after 2+ explicit choices â€” show all current picks
        hasWorld = isDSPActivated() && !!state.picks?.world;
        hasArchetype = isDSPActivated() && !!state.picks?.genre;
        hasTone = isDSPActivated() && !!state.picks?.tone;
        hasLength = isDSPActivated() && !!state.storyLength;
      }

      if (hasWorld) {
        html = 'In <span class="dsp-clause" data-axis="world">' + worldPhrase +
          ', shaped by ' + genrePhrase + '</span>';
      }
      if (hasWorld && hasArchetype) {
        html += ', a question awaits: Will ' + povPronoun +
          '<span class="dsp-clause" data-axis="archetype">' + archAdj + '</span>';
      }
      if (hasWorld && hasArchetype && hasTone) {
        html += ' desire redeem this <span class="dsp-clause" data-axis="tone">' + toneAdj + '</span>';
      }
      if (hasWorld && hasArchetype && hasTone && hasLength) {
        const affairWord = AFFAIR_WORD_MAP[state.storyLength] || 'affair';
        html += ' ' + affairWord + '&#8201;&#8212;&#8201;or ruin it?';
      }
    }

    return { success: true, html, error: null };
  }

  // NOTE: World subtypes are INTENTIONALLY excluded from DSP.
  // DSP uses ONLY base world phrases from DSP_WORLD_PHRASES.
  // Subtypes affect story generation prompts, NOT the DSP.

  function updateSynopsisPanel(isUserAction = false) {
    const synopsisText = document.getElementById('synopsisText');
    if (!synopsisText) return;

    // GATE: During Guided Fate, DSP updates come ONLY from revealDSPClause
    // This prevents bulk hydration or catch-up rendering
    if (_dspGuidedFateActive) return;

    // ACTIVATION THRESHOLD: DSP requires at least 2 explicit Story Shape choices
    // Block rendering until threshold is met
    if (!isDSPActivated()) return;

    const result = generateDSPSentence();

    // HARD FAIL: Do not display anything if DSP generation failed
    if (!result.success) {
      console.error('[DSP] updateSynopsisPanel blocked:', result.error?.message);
      // Keep placeholder if threshold not met
      if (!isDSPActivated()) return;
      // Clear any legacy content â€” DSP must be empty on failure
      synopsisText.innerHTML = '';
      synopsisText._lastDSP = null;
      return;
    }

    // Track first hydration for animation purposes
    const wasFirstHydration = !synopsisText._lastDSP;

    const newSentence = result.html;

    // Update with animation if content changed
    if (synopsisText._lastDSP !== newSentence) {
      synopsisText._lastDSP = newSentence;
      synopsisText.classList.add('updating');
      synopsisText.innerHTML = newSentence;

      // Sequential reveal of clauses on first hydration (non-Guided Fate only)
      if (wasFirstHydration && !_fateRunning) {
        const clauses = synopsisText.querySelectorAll('.dsp-clause');
        clauses.forEach((clause, i) => {
          clause.classList.add('dsp-pending');
          setTimeout(() => {
            clause.classList.remove('dsp-pending');
            clause.classList.add('dsp-glow');
            setTimeout(() => clause.classList.remove('dsp-glow'), 500);
          }, 300 + i * 400);
        });
      }
      // SPARSE MODE: During Guided Fate, sentence is built incrementally
      // by revealDSPClause â€” no pending classes needed here

      setTimeout(() => synopsisText.classList.remove('updating'), 500);

      // DSP text is allowed to wrap naturally â€” no line-count gate
    }
  }

  // Ceremonial DSP presentation swap â€” dissolve + re-render fully resolved
  // No prose recomposition; same authored template, just remove pending state.
  function performDSPCeremonialRewrite() {
    const synopsisText = document.getElementById('synopsisText');
    if (!synopsisText) return;

    // Phase 1: dissolve current text
    synopsisText.classList.add('dsp-dissolving');

    // Spawn a few particles near DSP during dissolve (anchored to panel)
    const panel = document.getElementById('synopsisPanel');
    if (panel) {
      const container = getOrCreateSparkleContainer(panel);
      if (container) {
        const pw = panel.offsetWidth;
        const ph = panel.offsetHeight;
        for (let i = 0; i < 8; i++) {
          const spark = document.createElement('div');
          spark.className = 'fate-dust-particle';
          spark.dataset.sparkleTag = 'dsp-rewrite';
          const sx = Math.random() * pw;
          const sy = Math.random() * ph;
          const sz = 2 + Math.random() * 3;
          const sd = 2000 + Math.random() * 1500;
          spark.style.cssText = `
            left:${sx}px; top:${sy}px;
            width:${sz}px; height:${sz}px;
            --dust-duration:${sd}ms;
            --dust-opacity:${0.5 + Math.random() * 0.3};
            --dust-dx:${(Math.random() - 0.5) * 30}px;
            --dust-dy:${-(10 + Math.random() * 20)}px;
          `;
          container.appendChild(spark);
          setTimeout(() => { if (spark.parentNode) spark.remove(); }, sd + 100);
        }
      }
    }

    // Phase 2: re-render same sentence fully resolved (no pending classes)
    setTimeout(() => {
      const result = generateDSPSentence();
      // HARD FAIL: Do not display anything if DSP generation failed
      if (!result.success) {
        console.error('[DSP] performDSPCeremonialRewrite blocked:', result.error?.message);
        synopsisText.innerHTML = '';
        synopsisText._lastDSP = null;
        synopsisText.classList.remove('dsp-dissolving');
        return;
      }
      const resolved = result.html;
      synopsisText.innerHTML = resolved;
      synopsisText._lastDSP = resolved;
      synopsisText.classList.remove('dsp-dissolving');
      synopsisText.classList.add('dsp-revealing');

      setTimeout(() => synopsisText.classList.remove('dsp-revealing'), 700);
    }, 500);
  }

  /**
   * Get selected world subtype from the subtype selection UI
   * Returns null if no subtype is selected
   */
  function getSelectedWorldSubtype(world) {
    // Map world to subtype container ID
    const subtypeContainerMap = {
      SciFi: 'scifiSubtypeGrid',
      Fantasy: 'fantasySubtypeGrid',
      Horror: 'horrorSubtypeGrid',
      Dystopia: 'dystopiaSubtypeGrid',
      PostApocalyptic: 'apocalypseSubtypeGrid'
    };

    const containerId = subtypeContainerMap[world];
    if (!containerId) return null;

    const container = document.getElementById(containerId);
    if (!container) return null;

    const selected = container.querySelector('.card.selected');
    return selected?.dataset?.val || null;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP VISIBILITY LIFECYCLE (STATE-BASED)
  // DSP is visible throughout the four-axis configuration (World â†’ Tone
  // â†’ Genre â†’ Dynamic). It disappears only after Begin Story is clicked.
  // Visibility is tied to screen state, not scroll position.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _dspActivationCount = 0; // Count of explicit Story Shape selections (activates DSP at >= 2)
  let _dspGuidedFateActive = false; // True during Guided Fate â€” prevents bulk hydration
  let _dspPhase = 0; // 0=intro, 1=placeholder, 2=live, 3=veto
  let _dspIntroTimer = null; // Timer for introâ†’placeholder transition

  // Reset DSP state for new story / mode change
  function resetDSPState() {
      _dspPhase = 0;
      _dspActivationCount = 0;
      if (_dspIntroTimer) {
          clearTimeout(_dspIntroTimer);
          _dspIntroTimer = null;
      }
      const synopsisText = document.getElementById('synopsisText');
      if (synopsisText) {
          synopsisText._dspInitialized = false;
          synopsisText._lastDSP = null;
      }
  }

  function isDSPActivated() {
      return _dspActivationCount >= 2;
  }

  function incrementDSPActivation() {
      _dspActivationCount++;
      console.log(`[DSP] Activation count: ${_dspActivationCount}`);
  }

  // Build full DSP placeholder sentence with all segments in grey (inactive) state
  function buildDSPPlaceholderHTML() {
      return '<span class="dsp-segment dsp-inactive" data-axis="world">In a world yet unchosen</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="genre">, shaped by forces unknown</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="archetype">, a question awaits:<br>Will unspoken</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="tone"> desire redeem this</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="length"> untold affair&#8201;&#8212;&#8201;or ruin it?</span>';
  }

  // Update a single DSP segment when user makes a selection
  function activateDSPSegment(axis, text) {
      if (_dspPhase < 1) return; // Not ready for updates yet
      _dspPhase = 2; // Move to live phase
      const synopsisText = document.getElementById('synopsisText');
      if (!synopsisText) return;
      const segment = synopsisText.querySelector(`.dsp-segment[data-axis="${axis}"]`);
      if (segment) {
          // Guard: prevent glow spam on reselection
          if (segment.classList.contains('dsp-active')) return;
          segment.textContent = text;
          segment.classList.remove('dsp-inactive');
          segment.classList.add('dsp-active', 'dsp-glow');
          setTimeout(() => segment.classList.remove('dsp-glow'), 500);
      }
  }

  // Veto override: reveal all remaining grey segments as white (no glow)
  function revealAllDSPSegments() {
      _dspPhase = 3;
      const synopsisText = document.getElementById('synopsisText');
      if (!synopsisText) return;
      const inactiveSegments = synopsisText.querySelectorAll('.dsp-segment.dsp-inactive');
      inactiveSegments.forEach(seg => {
          seg.classList.remove('dsp-inactive');
          seg.classList.add('dsp-active');
          // No glow for veto-revealed segments
      });
  }

  function showDSP() {
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      // HARD-DISABLE in Shape stage: DSP only shows from World stage (index 3) onward
      // Shape stage = authorship (0), identity (1), archetype (2)
      if (typeof corridorActiveRowIndex !== 'undefined' && corridorActiveRowIndex < 3) {
        synopsisPanel.classList.remove('visible');
        return;
      }
      // Inject "First Taste" header if not present (after drag handle)
      if (!synopsisPanel.querySelector('.synopsis-title')) {
        const title = document.createElement('div');
        title.className = 'synopsis-title';
        title.textContent = 'First Taste';
        const dragHandle = synopsisPanel.querySelector('.dsp-drag-handle');
        if (dragHandle && dragHandle.nextSibling) {
          synopsisPanel.insertBefore(title, dragHandle.nextSibling);
        } else {
          synopsisPanel.insertBefore(title, synopsisPanel.firstChild);
        }
      }
      const synopsisText = document.getElementById('synopsisText');
      // Phase 0: Show intro message
      if (_dspPhase === 0 && synopsisText && !synopsisText._dspInitialized) {
        synopsisText._dspInitialized = true;
        synopsisText.innerHTML = '<span class="dsp-intro">Your choices shape your story</span>';
        // Transition to Phase 1 after 5 seconds
        if (_dspIntroTimer) clearTimeout(_dspIntroTimer);
        _dspIntroTimer = setTimeout(() => {
          _dspPhase = 1;
          synopsisText.innerHTML = buildDSPPlaceholderHTML();
        }, 5000);
      }
      synopsisPanel.classList.add('visible');
    }
  }

  function hideDSP() {
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      synopsisPanel.classList.remove('visible');
    }
  }

  // DSP shows when user is configuring story (setup screen)
  function updateDSPVisibility(screenId) {
    if (screenId === 'setup') {
      showDSP();
    } else {
      hideDSP();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP DRAG + RESIZE â€” Reposition and scale the floating synopsis panel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function initDSPInteraction() {
    const panel = document.getElementById('synopsisPanel');
    if (!panel) return;

    var mode = null;        // 'drag' | 'resize'
    var resizeCorner = null; // 'nw' | 'ne' | 'sw' | 'se'
    var startX = 0, startY = 0;
    var startRect = null;

    // Switch panel from CSS-positioned to inline-positioned
    function ensureInlinePosition() {
      if (panel._dspPositioned) return;
      var rect = panel.getBoundingClientRect();
      // Clear CSS positioning â€” use inline only
      panel.style.transform = 'none';
      panel.style.left = rect.left + 'px';
      panel.style.top = rect.top + 'px';
      panel.style.right = 'auto';
      panel.style.bottom = 'auto';
      panel.style.width = rect.width + 'px';
      panel.style.maxWidth = 'none';
      panel._dspPositioned = true;
    }

    function onStart(clientX, clientY) {
      ensureInlinePosition();
      startX = clientX;
      startY = clientY;
      startRect = {
        left: parseFloat(panel.style.left),
        top: parseFloat(panel.style.top),
        width: panel.offsetWidth,
        height: panel.offsetHeight
      };
      panel.classList.add('dsp-interacting');
    }

    function onMove(clientX, clientY) {
      var dx = clientX - startX;
      var dy = clientY - startY;

      if (mode === 'drag') {
        var x = Math.max(0, Math.min(startRect.left + dx, window.innerWidth - startRect.width));
        var y = Math.max(0, Math.min(startRect.top + dy, window.innerHeight - startRect.height));
        panel.style.left = x + 'px';
        panel.style.top = y + 'px';
      } else if (mode === 'resize') {
        var minW = 160, minH = 60;
        var newLeft = startRect.left, newTop = startRect.top;
        var newW = startRect.width, newH = startRect.height;

        if (resizeCorner === 'se') {
          newW = Math.max(minW, startRect.width + dx);
          newH = Math.max(minH, startRect.height + dy);
        } else if (resizeCorner === 'sw') {
          newW = Math.max(minW, startRect.width - dx);
          newH = Math.max(minH, startRect.height + dy);
          newLeft = startRect.left + (startRect.width - newW);
        } else if (resizeCorner === 'ne') {
          newW = Math.max(minW, startRect.width + dx);
          newH = Math.max(minH, startRect.height - dy);
          newTop = startRect.top + (startRect.height - newH);
        } else if (resizeCorner === 'nw') {
          newW = Math.max(minW, startRect.width - dx);
          newH = Math.max(minH, startRect.height - dy);
          newLeft = startRect.left + (startRect.width - newW);
          newTop = startRect.top + (startRect.height - newH);
        }

        // Clamp to viewport
        newLeft = Math.max(0, newLeft);
        newTop = Math.max(0, newTop);

        panel.style.left = newLeft + 'px';
        panel.style.top = newTop + 'px';
        panel.style.width = newW + 'px';
        panel.style.height = newH + 'px';
        panel.style.maxHeight = 'none';
        panel.style.minHeight = '0';
      }
    }

    function onEnd() {
      mode = null;
      resizeCorner = null;
      panel.classList.remove('dsp-interacting');
    }

    // â”€â”€ Mouse â”€â”€
    panel.addEventListener('mousedown', function(e) {
      var corner = e.target.dataset && e.target.dataset.resize;
      if (corner) {
        e.preventDefault();
        mode = 'resize';
        resizeCorner = corner;
        onStart(e.clientX, e.clientY);
      } else if (e.target.closest('.dsp-drag-handle')) {
        e.preventDefault();
        mode = 'drag';
        onStart(e.clientX, e.clientY);
      }
    });
    document.addEventListener('mousemove', function(e) {
      if (mode) { e.preventDefault(); onMove(e.clientX, e.clientY); }
    });
    document.addEventListener('mouseup', onEnd);

    // â”€â”€ Touch â”€â”€
    panel.addEventListener('touchstart', function(e) {
      if (e.touches.length !== 1) return;
      var t = e.touches[0];
      var corner = e.target.dataset && e.target.dataset.resize;
      if (corner) {
        e.preventDefault();
        mode = 'resize';
        resizeCorner = corner;
        onStart(t.clientX, t.clientY);
      } else if (e.target.closest('.dsp-drag-handle')) {
        e.preventDefault();
        mode = 'drag';
        onStart(t.clientX, t.clientY);
      }
    }, { passive: false });
    document.addEventListener('touchmove', function(e) {
      if (mode && e.touches.length === 1) {
        e.preventDefault();
        onMove(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });
    document.addEventListener('touchend', onEnd);
    document.addEventListener('touchcancel', onEnd);
  })();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP MARQUEE â€” Auto-wrap synopsis text in a scrolling inner span
  // Whenever synopsisText.innerHTML changes, wrap all content inside
  // a .synopsis-text-inner span so the CSS animation scrolls it.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function initDSPMarquee() {
    var el = document.getElementById('synopsisText');
    if (!el) return;

    var wrapping = false;

    function wrapContent() {
      if (wrapping) return;
      // Skip if already wrapped
      if (el.children.length === 1 && el.firstElementChild &&
          el.firstElementChild.classList.contains('synopsis-text-inner')) return;
      // Skip if empty
      if (!el.innerHTML.trim()) return;
      wrapping = true;
      var inner = document.createElement('span');
      inner.className = 'synopsis-text-inner';
      // Move all child nodes into the wrapper
      while (el.firstChild) inner.appendChild(el.firstChild);
      el.appendChild(inner);
      wrapping = false;
    }

    // Observe content changes
    var obs = new MutationObserver(function() {
      if (!wrapping) requestAnimationFrame(wrapContent);
    });
    obs.observe(el, { childList: true, characterData: true, subtree: true });
    // Wrap any initial content
    wrapContent();
  })();

  // Expose for external calls
  window.showDSP = showDSP;
  window.hideDSP = hideDSP;
  window.updateDSPVisibility = updateDSPVisibility;
  window.activateDSPSegment = activateDSPSegment;
  window.revealAllDSPSegments = revealAllDSPSegments;

  // Legacy function name for compatibility
  function initSynopsisPanelScrollBehavior() {
    // Now state-based, not scroll-based
    // DSP visibility controlled by updateDSPVisibility(screenId)
    updateDSPVisibility(_currentScreenId);
  }
  window.initSynopsisPanelScrollBehavior = initSynopsisPanelScrollBehavior;

  // =========================
  // ARCHETYPE UI HANDLERS
  // =========================

  // Track last-zoomed archetype card (selected via Continue)
  let lastZoomedArchetype = null;
  // Track if archetype cards have been revealed (flip-all on row entry)
  let archetypeCardsRevealed = false;
  // Track if Destiny's Choice was used (for breadcrumb icon)
  let archetypeSelectedViaDestiny = false;
  // Track active sparkle emitter for last-zoomed card
  let lastZoomedSparkleEmitterId = null;

  // Mask SVG for Destiny's Choice breadcrumb (inline data URI)
  const MASK_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="24" height="24">
    <ellipse cx="16" cy="16" rx="12" ry="10" fill="none" stroke="goldenrod" stroke-width="2"/>
    <circle cx="11" cy="14" r="3" fill="none" stroke="goldenrod" stroke-width="1.5"/>
    <circle cx="21" cy="14" r="3" fill="none" stroke="goldenrod" stroke-width="1.5"/>
    <path d="M8 20 Q16 26 24 20" fill="none" stroke="goldenrod" stroke-width="1.5"/>
  </svg>`;

  function initArchetypeUI() {
      renderArchetypeCards();
      bindArchetypeHandlers();
      bindLoveInterestGenderWatcher();
      updateArchetypeSectionTitle();
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CARD GLEAM SYSTEM â€” Subtle shift-and-hold radial spokes per card

     Applied to ALL card types: .sb-card, .authorship-card, .mode-card.
     One .card-gleam-layer per face, inserted as first child.
     Seeded from card's data-val for deterministic, non-uniform results.

     Animation: quick ~15Â° swing â†’ pause â†’ swing back â†’ longer pause.
     Simulates a viewer shifting their gaze, not a spinning light.

     Blend: mix-blend-mode: screen (additive light, safe for dark text).
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  (function initGleamSystem() {
    function gleamHash(str) {
      var h = 0;
      for (var i = 0; i < str.length; i++) {
        h = ((h << 5) - h) + str.charCodeAt(i);
        h |= 0;
      }
      return Math.abs(h) || 1;
    }

    function gleamRng(seed) {
      var s = seed;
      return function() {
        s = (s * 1103515245 + 12345) & 0x7fffffff;
        return s / 0x7fffffff;
      };
    }

    // Build conic-gradient with 6 spokes at 30Â°, 90Â°, 150Â°, 210Â°, 270Â°, 330Â°
    // 5 gold spokes + 1 dark spoke (70% black) for subtle contrast variation
    // Each spoke: transparent â†’ edge â†’ peak â†’ edge â†’ transparent
    function buildGleamGradient(rng, angleOffset) {
      // Vertical bands tilted 15Â° off vertical (105Â° in CSS gradient space)
      // Per-card angle variation: Â±5Â° from base 105Â°
      var angle = 105 + (angleOffset || 0);
      // Dark band + gold band, per-card variation in width and opacity
      var goldCenter = 48 + rng() * 6;            // gold band center: 48-54%
      var goldHW = 2 + rng() * 2;                 // gold half-width: 2-4%
      var goldPeak = 0.3 + rng() * 0.15;           // white peak: 0.3-0.45
      var goldEdge = goldPeak * 0.4;

      var darkCenter = goldCenter - 8 - rng() * 4; // dark band: 8-12% left of gold
      var darkHW = 2 + rng() * 2;                  // dark half-width: 2-4%
      var darkPeak = 0.25 + rng() * 0.15;          // dark peak: 0.25-0.4
      var darkEdge = darkPeak * 0.3;

      var feather = 3;                              // feather zone in %

      return 'linear-gradient(' + angle.toFixed(1) + 'deg, ' +
        'transparent ' + (darkCenter - darkHW - feather).toFixed(1) + '%, ' +
        'rgba(0, 0, 0, ' + darkEdge.toFixed(2) + ') ' + (darkCenter - darkHW).toFixed(1) + '%, ' +
        'rgba(0, 0, 0, ' + darkPeak.toFixed(2) + ') ' + darkCenter.toFixed(1) + '%, ' +
        'rgba(0, 0, 0, ' + darkEdge.toFixed(2) + ') ' + (darkCenter + darkHW).toFixed(1) + '%, ' +
        'transparent ' + (darkCenter + darkHW + feather).toFixed(1) + '%, ' +
        'transparent ' + (goldCenter - goldHW - feather).toFixed(1) + '%, ' +
        'rgba(255, 255, 255, ' + goldEdge.toFixed(2) + ') ' + (goldCenter - goldHW).toFixed(1) + '%, ' +
        'rgba(255, 255, 255, ' + goldPeak.toFixed(2) + ') ' + goldCenter.toFixed(1) + '%, ' +
        'rgba(255, 255, 255, ' + goldEdge.toFixed(2) + ') ' + (goldCenter + goldHW).toFixed(1) + '%, ' +
        'transparent ' + (goldCenter + goldHW + feather).toFixed(1) + '%)';
    }

    /**
     * Global gleam controller â€” all bands move in lockstep (simulated light reflection).
     * Each card's band has unique thickness/opacity, but position is shared.
     */
    var gleamRegistry = [];
    var gleamPos = 0;
    var gleamCycleRunning = false;

    function registerGleam(gleamEl) {
      gleamRegistry.push(gleamEl);
      // Sync new element to current global position (with per-card offset)
      var off = gleamEl._gleamOffset || 0;
      gleamEl.style.transform = 'translateX(' + (gleamPos + off) + 'px)';
      if (!gleamCycleRunning) {
        gleamCycleRunning = true;
        gleamCycle();
      }
    }

    function setAllGleams(px, dur, easing) {
      gleamPos = px;
      var e = easing || 'ease-in-out';
      var t = 'transform ' + dur.toFixed(2) + 's ' + e;
      for (var i = 0; i < gleamRegistry.length; i++) {
        var off = gleamRegistry[i]._gleamOffset || 0;
        gleamRegistry[i].style.transition = t;
        gleamRegistry[i].style.transform = 'translateX(' + (px + off) + 'px)';
      }
      // Shift debossed text shadow to simulate light moving over pressed-in letters
      updateDebossedShadow(px, dur, e);
    }

    function updateDebossedShadow(px, dur, easing) {
      // Query live DOM â€” only visible (mounted) elements get updated
      var els = document.querySelectorAll(
        '#pressureGrid .sb-card .sb-card-back .sb-card-desc,' +
        '#povGrid .sb-card .sb-card-back .sb-card-desc,' +
        '#dynamicGrid .sb-card .sb-card-back .sb-card-desc'
      );
      if (!els.length) return;
      // Scale gleam position (Â±13px) to shadow offset (Â±0.8px)
      var hx = (px * 0.06).toFixed(2);
      var shadow =
        hx + 'px 0.5px 0.5px rgba(255,255,255,0.1), ' +
        (-hx).toFixed(2) + 'px -0.5px 0.5px rgba(0,0,0,0.2)';
      var t = 'text-shadow ' + dur.toFixed(2) + 's ' + easing;
      for (var i = 0; i < els.length; i++) {
        els[i].style.transition = t;
        els[i].style.textShadow = shadow;
      }
    }

    function gleamBreathe(count, baseOffset, cb) {
      if (count <= 0) { cb(); return; }
      var dist = 2 + Math.random();   // 2-3px
      var target = baseOffset + (gleamPos >= baseOffset ? -dist : dist);
      var dur = 1.8 + Math.random() * 0.4; // ~2s per sway
      setAllGleams(target, dur, 'ease-in-out');
      setTimeout(function() { gleamBreathe(count - 1, baseOffset, cb); }, dur * 1000);
    }

    function gleamCycle() {
      // Phase 1: breathe at center for 5-7s (2-3 breaths)
      var b1 = 2 + Math.floor(Math.random() * 2);
      gleamBreathe(b1, 0, function() {
        // Phase 2: slide left 13px (0.6-0.9s, ease-in-out for soft landing)
        setAllGleams(-13, 0.6 + Math.random() * 0.3, 'ease-in-out');
        setTimeout(function() {
          // Phase 3: breathe at -13px for 0-7s (0-3 breaths)
          var b2 = Math.floor(Math.random() * 4);
          gleamBreathe(b2, -13, function() {
            // Phase 4: slide right back to center (0.5-0.8s, ease-in-out for soft landing)
            setAllGleams(0, 0.5 + Math.random() * 0.3, 'ease-in-out');
            setTimeout(function() {
              // Phase 5: breathe at center for 5-10s (2-4 breaths)
              var b3 = 2 + Math.floor(Math.random() * 3);
              gleamBreathe(b3, 0, gleamCycle);
            }, 400);
          });
        }, 500);
      });
    }

    // Face selectors for multi-face card types
    var FACE_SELECTORS = '.sb-card-face, .authorship-card-face, .mode-card-back, .mode-card-front';

    // Card types that ARE their own face (no child face elements)
    var SELF_FACE_CLASSES = ['tier-card-btn', 'character-tarot-card'];

    /**
     * Apply gleam to a single card element. Idempotent.
     * Works on .sb-card, .authorship-card, .mode-card, .tier-card-btn, .character-tarot-card.
     */
    function applyCardGleam(card) {
      if (!card || card.dataset.gleamApplied) return;
      card.dataset.gleamApplied = '1';

      var seedStr = card.dataset.val || card.dataset.choice || card.dataset.mode || card.id || String(Math.random());
      var seed = gleamHash(seedStr);
      var rng = gleamRng(seed);

      var speed = 10;                          // fixed 10s cycle (all cards in sync)
      var swayAmp = 10;                        // fixed 10Â° rotation
      var opacityMult = 0.85 + rng() * 0.15;  // 0.85â€“1.0 (visual variety only)
      var posOffset = (rng() - 0.5) * 50;     // Â±25px per-card position offset
      var angleOffset = (rng() - 0.5) * 10;   // Â±5Â° per-card angle variation
      var gradient = buildGleamGradient(rng, angleOffset);

      // Determine target faces: child faces or the card itself
      var isSelfFace = SELF_FACE_CLASSES.some(function(cls) { return card.classList.contains(cls); });
      var faces = isSelfFace ? [card] : Array.from(card.querySelectorAll(FACE_SELECTORS));
      if (!faces.length) return;

      faces.forEach(function(face) {
        if (face.querySelector('.card-gleam-layer')) return;

        var gleam = document.createElement('div');
        gleam.className = 'card-gleam-layer';
        gleam.style.setProperty('--gleam-opacity-multiplier', opacityMult.toFixed(2));
        gleam.style.backgroundImage = gradient;
        gleam._gleamOffset = posOffset; // per-card position offset for variety

        // Wrap gleam in a non-rotating clip container so overflow:hidden
        // clips the rotating gleam to the face boundary (clip-path on the
        // gleam itself would rotate with it, making motion invisible)
        var clip = document.createElement('div');
        clip.className = 'card-gleam-clip';
        clip.appendChild(gleam);
        face.insertBefore(clip, face.firstChild);

        // Register with global gleam controller (all bands move in sync)
        registerGleam(gleam);
      });
    }

    /** Bulk-apply to all card elements in the DOM. */
    function initAllCardGleams() {
      document.querySelectorAll('.sb-card, .authorship-card, .mode-card, .tier-card-btn, .character-tarot-card').forEach(applyCardGleam);
    }

    // Expose globally for dynamic card creation
    window.applyCardGleam = applyCardGleam;
    window.initAllCardGleams = initAllCardGleams;

    // Apply to static HTML cards on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initAllCardGleams);
    } else {
      initAllCardGleams();
    }
  })();

  function renderArchetypeCards() {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid) return;

      grid.innerHTML = '';
      lastZoomedArchetype = null;
      archetypeCardsRevealed = false;

      // Stop any previous last-zoomed sparkle emitter
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }

      // Render 7 archetype cards (start face-down, reveal together after delay)
      ARCHETYPE_ORDER.forEach(id => {
          const arch = ARCHETYPES[id];
          if (!arch) return;

          const card = document.createElement('div');
          card.className = 'sb-card archetype-card';
          card.dataset.archetype = id;
          card.dataset.grp = 'archetype';
          card.dataset.val = id;

          // If explicitly selected (user chose, not just default), show as selected+flipped
          // Destiny's Choice: mask is SECRET â€” all cards stay face-down, no selection shown
          const hasExplicitSelection = corridorSelections.has('storybeau') || corridorSelections.has('archetype');
          if (hasExplicitSelection && state.archetype.primary === id && !archetypeSelectedViaDestiny) {
              card.classList.add('selected', 'flipped');
              lastZoomedArchetype = id;
              archetypeCardsRevealed = true; // Skip auto-reveal if already selected
          }

          // Card structure: BACK = Black PNG art, FRONT = Gold PNG art + description (visible when zoomed)
          const resolvedDesireStyle = resolveLIPronouns(arch.desireStyle);

          card.innerHTML = `
              <div class="sb-card-inner">
                  <div class="sb-card-face sb-card-back" data-archetype="${id}"></div>
                  <div class="sb-card-face sb-card-front" data-archetype="${id}">
                      <span class="archetype-printed-desc">${resolvedDesireStyle}</span>
                  </div>
              </div>
          `;

          // NO hover listeners â€” cards don't flip on hover
          // CLICK opens zoom view only (does NOT select)
          card.addEventListener('click', () => handleArchetypeClick(card, id));

          grid.appendChild(card);
          if (window.applyCardGleam) window.applyCardGleam(card);
      });

      // Add Destiny's Choice card (slot 8)
      const destinyCard = document.createElement('div');
      destinyCard.className = 'sb-card archetype-card destiny-choice-card';
      destinyCard.id = 'destinyChoiceCard';
      destinyCard.dataset.grp = 'archetype';
      destinyCard.dataset.val = 'destiny';
      destinyCard.innerHTML = `
          <div class="destiny-stack-layer layer-5"></div>
          <div class="destiny-stack-layer layer-4"></div>
          <div class="destiny-stack-layer layer-3"></div>
          <div class="destiny-stack-layer layer-2"></div>
          <div class="sb-card-inner">
              <div class="sb-card-face sb-card-back destiny-choice-back">
                  <span class="sb-card-title">Destiny's Choice</span>
                  <div class="destiny-choice-sparkle-container" id="destinyChoiceSparkles"></div>
              </div>
              <div class="sb-card-face sb-card-front destiny-choice-front">
                  <span class="sb-card-title">Destiny's Choice</span>
                  <div class="destiny-embossed-nameplate">
                      <div class="destiny-embossed-line"></div>
                      <div class="destiny-embossed-line"></div>
                  </div>
              </div>
          </div>
      `;

      // Destiny's Choice click triggers selection sequence
      destinyCard.addEventListener('click', () => triggerDestinyChoiceSequence());

      grid.appendChild(destinyCard);
      if (window.applyCardGleam) window.applyCardGleam(destinyCard);

      // Start sparkles on Destiny's Choice card in archetype grid
      setTimeout(() => startSparkleEmitter('destinyChoiceSparkles', 'destinyDeck', 3), 100);

      // Schedule automatic reveal of all archetype cards (after row mount delay)
      if (!archetypeCardsRevealed) {
          scheduleArchetypeReveal();
      }
  }

  /**
   * Schedule automatic reveal of all archetype cards
   * All 7 cards flip together after 600-1000ms delay
   * Only reveals if the archetype row is currently active/visible
   */
  function scheduleArchetypeReveal() {
      const revealDelay = 600 + Math.random() * 400; // 600-1000ms
      setTimeout(() => {
          if (archetypeCardsRevealed) return; // Already revealed or selected
          // Only reveal if archetype row is active
          const grid = document.getElementById('archetypeCardGrid');
          if (grid && grid.classList.contains('corridor-active')) {
              revealAllArchetypeCards();
          }
      }, revealDelay);
  }

  /**
   * Trigger archetype reveal when storybeau row becomes active
   * Called from updateCorridorVisibility or when navigating to storybeau
   * Handles both initial reveal AND back-navigation restoration
   */
  function onArchetypeRowMount() {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid) return;

      // Check if cards need to be restored (back-navigation after Destiny's Choice dissolved them)
      const currentCardCount = grid.querySelectorAll('.archetype-card:not(.destiny-choice-card)').length;
      const expectedCardCount = ARCHETYPE_ORDER ? ARCHETYPE_ORDER.length : 7;
      const needsRestoration = currentCardCount < expectedCardCount;

      if (needsRestoration) {
          console.log('[Archetype] Cards missing â€” restoring for back-navigation');
          // Re-render all archetype cards (this will mark selected one and reset state)
          renderArchetypeCards();
          // Destiny's Choice: mask is SECRET â€” no sparkles, no face, just backs like the others
          if (state.archetype && state.archetype.primary && !archetypeSelectedViaDestiny) {
              const selectedId = state.archetype.primary;
              lastZoomedArchetype = selectedId;
              // Start sparkles on selected card after a brief delay for DOM update
              setTimeout(() => {
                  startLastZoomedSparkles();
              }, 100);
          }
          return;
      }

      // First visit - reveal cards if not yet revealed
      if (!archetypeCardsRevealed) {
          scheduleArchetypeReveal();
      } else if (state.archetype && state.archetype.primary) {
          // Cards already revealed, but ensure sparkles on selected card
          const selectedId = state.archetype.primary;
          if (lastZoomedArchetype !== selectedId) {
              lastZoomedArchetype = selectedId;
          }
          startLastZoomedSparkles();
      }
  }

  // Expose for corridor system
  window.onArchetypeRowMount = onArchetypeRowMount;

  /**
   * Reveal all 7 archetype cards SIMULTANEOUSLY
   * Cards flip from back to front TOGETHER â€” no stagger
   * Spec: "Cards ALWAYS reveal together (never one by one)"
   */
  function revealAllArchetypeCards() {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid) return;

      archetypeCardsRevealed = true;

      // Flip ALL cards at the exact same moment â€” no stagger
      const cards = grid.querySelectorAll('.archetype-card:not(.destiny-choice-card)');
      cards.forEach(card => {
          card.classList.add('flipped');
      });

      console.log('[Archetype] All cards revealed TOGETHER');
  }

  /**
   * Handle archetype card click â€” opens zoom view only (no selection)
   * Cards are already revealed (flipped) on row entry
   * Selection happens via Continue button using lastZoomedArchetype
   */
  function handleArchetypeClick(card, archetypeId) {
      // If already zoomed, ignore (don't re-open same card)
      if (card.classList.contains('zoomed')) return;

      // Open zoom overlay for this archetype
      openArchetypeOverlay(archetypeId);

      // Track as last-zoomed (for Continue button selection)
      setLastZoomedArchetype(archetypeId);
  }

  /**
   * Set the last-zoomed archetype and start sparkle indicator
   * Called when zoom view is opened for an archetype
   */
  function setLastZoomedArchetype(archetypeId) {
      // Stop previous sparkle emitter
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }

      // Clear previous focus indicator
      const prevFocused = document.querySelector('.archetype-card.last-zoomed');
      if (prevFocused) {
          prevFocused.classList.remove('last-zoomed');
          const prevSparkleContainer = prevFocused.querySelector('.archetype-focus-sparkles');
          if (prevSparkleContainer) prevSparkleContainer.remove();
      }

      lastZoomedArchetype = archetypeId;

      // Update Continue button visibility
      if (typeof updateCorridorContinueButtonVisibility === 'function') {
          updateCorridorContinueButtonVisibility();
      }
  }

  /**
   * Start sparkle emitter on last-zoomed card after zoom exit
   * Called when archetype zoom overlay is closed
   */
  function startLastZoomedSparkles() {
      if (!lastZoomedArchetype) return;

      const card = document.querySelector(
          `#archetypeCardGrid .archetype-card[data-archetype="${lastZoomedArchetype}"]`
      );
      if (!card) return;

      // Add focus indicator class
      card.classList.add('last-zoomed');

      // Create sparkle container if not exists
      let sparkleContainer = card.querySelector('.archetype-focus-sparkles');
      if (!sparkleContainer) {
          sparkleContainer = document.createElement('div');
          sparkleContainer.className = 'archetype-focus-sparkles';
          sparkleContainer.id = `archetypeFocusSparkles_${lastZoomedArchetype}`;
          card.appendChild(sparkleContainer);
      }

      // Start sparkle emitter on selected archetype card (high intensity when all masks visible)
      lastZoomedSparkleEmitterId = sparkleContainer.id;
      startSparkleEmitter(sparkleContainer.id, 'destinyDeck', 18);
  }

  /**
   * Select archetype via Continue button
   * Called when Continue is pressed with a flipped card
   */
  function commitArchetypeSelection(archetypeId, viaDestiny = false) {
      state.archetype.primary = archetypeId;
      state.archetype.modifier = null; // Modifier assigned silently at generation time
      archetypeSelectedViaDestiny = viaDestiny;

      // STORY-DEFINING INPUT: Invalidate snapshot â†’ forces "Begin Story"
      if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();

      // Clear cover shape hash â€” selection changed, enable regeneration
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();

      // Update visual states
      updateArchetypeCardStates();

      // Increment DSP activation count (explicit Story Shape choice)
      incrementDSPActivation();
      updateSynopsisPanel(true);

      console.log(`[Archetype] Committed: ${archetypeId} (via ${viaDestiny ? 'Destiny' : 'Continue'})`);
  }

  /**
   * Trigger Destiny's Choice animation sequence
   * 1. Archetype cards animate inward to Destiny's Choice position
   * 2. Optional shuffle overlap
   * 3. One card emerges with unmarked back
   * 4. Remaining cards dissolve into sparkles
   * 5. Destiny's Choice deck dissipates
   * 6. Unmarked card moves to breadcrumb (mask icon only)
   */
  async function triggerDestinyChoiceSequence() {
      const grid = document.getElementById('archetypeCardGrid');
      const destinyCard = document.getElementById('destinyChoiceCard');
      if (!grid || !destinyCard) return;

      // Stop sparkle emitters (Destiny's Choice and any focus sparkles)
      stopSparkleEmitter('destinyChoiceSparkles');
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }
      // Remove focus indicator from any last-zoomed card
      const focusedCard = document.querySelector('.archetype-card.last-zoomed');
      if (focusedCard) {
          focusedCard.classList.remove('last-zoomed');
          const sparkleContainer = focusedCard.querySelector('.archetype-focus-sparkles');
          if (sparkleContainer) sparkleContainer.remove();
      }

      const archetypeCards = grid.querySelectorAll('.archetype-card:not(.destiny-choice-card)');
      const destinyRect = destinyCard.getBoundingClientRect();
      const destinyCenter = {
          x: destinyRect.left + destinyRect.width / 2,
          y: destinyRect.top + destinyRect.height / 2
      };

      // Randomly select one archetype
      const randomIndex = Math.floor(Math.random() * ARCHETYPE_ORDER.length);
      const chosenId = ARCHETYPE_ORDER[randomIndex];
      const chosenCard = grid.querySelector(`.archetype-card[data-archetype="${chosenId}"]`);

      // Capture original positions before any transforms
      const cardPositions = new Map();
      archetypeCards.forEach(card => {
          const rect = card.getBoundingClientRect();
          cardPositions.set(card, {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
          });
      });

      // STEP 1: Flip all cards face-down
      archetypeCards.forEach(card => {
          card.classList.remove('flipped');
      });

      await new Promise(r => setTimeout(r, 500));

      // STEP 2: Slide all cards UNDER the Destiny deck at current size
      // Set Destiny deck z-index high so cards slide underneath
      destinyCard.style.zIndex = '300';

      archetypeCards.forEach((card, idx) => {
          const pos = cardPositions.get(card);
          const translateX = destinyCenter.x - pos.x;
          const translateY = destinyCenter.y - pos.y;

          card.style.transition = `transform ${0.5 + idx * 0.05}s ease-in-out`;
          card.style.transform = `translate(${translateX}px, ${translateY}px)`;
          card.style.zIndex = `${50 + idx}`; // Below Destiny deck (z:300)
      });

      await new Promise(r => setTimeout(r, 800));

      // STEP 3: Brief pause â€” cards stacked under deck
      await new Promise(r => setTimeout(r, 300));

      // STEP 4: Chosen card pops up from top of deck
      if (chosenCard) {
          // Make back show as unmarked
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle) {
              backTitle.dataset.originalText = backTitle.textContent;
              backTitle.textContent = '?';
          }

          chosenCard.classList.add('destiny-chosen');
          chosenCard.style.zIndex = '400'; // Above Destiny deck
          chosenCard.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
          // Pop upward from deck position
          const pos = cardPositions.get(chosenCard);
          const deckOffX = destinyCenter.x - pos.x;
          const deckOffY = destinyCenter.y - pos.y;
          chosenCard.style.transform = `translate(${deckOffX}px, ${deckOffY - 80}px)`;
      }

      await new Promise(r => setTimeout(r, 600));

      // STEP 5: Card stays face-down â€” Destiny's mask is a secret
      await new Promise(r => setTimeout(r, 400));

      // STEP 6: Commit the selection
      commitArchetypeSelection(chosenId, true);

      // STEP 7: Other cards + Destiny deck dissolve
      archetypeCards.forEach(card => {
          if (card === chosenCard) return;
          card.classList.add('dissolving');
          card.style.transition = 'opacity 0.5s ease-out';
          card.style.opacity = '0';
      });
      destinyCard.classList.add('dissolving');
      destinyCard.style.transition = 'opacity 0.5s ease-out';
      destinyCard.style.opacity = '0';

      await new Promise(r => setTimeout(r, 300));

      // STEP 8: Slide chosen card to CENTER of corridor
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const archGhostIdx = STAGE_INDEX['storybeau'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${archGhostIdx}"]`);

      // Compute breadcrumb target position for later sparkle travel
      let targetX, targetY;
      if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          targetX = ghostRect.left + ghostRect.width / 2;
          targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
          const brRect = breadcrumbRow.getBoundingClientRect();
          targetX = brRect.left + brRect.width / 2;
          targetY = brRect.top + brRect.height / 2;
      }

      // Slide card to corridor center (viewport center)
      const corridorCenterX = window.innerWidth / 2;
      const corridorCenterY = window.innerHeight / 2;

      if (chosenCard) {
          const pos = cardPositions.get(chosenCard);
          const toCenterX = corridorCenterX - pos.x;
          const toCenterY = corridorCenterY - pos.y;
          chosenCard.style.transition = 'transform 0.6s ease-in-out';
          chosenCard.style.transform = `translate(${toCenterX}px, ${toCenterY}px)`;
      }

      await new Promise(r => setTimeout(r, 700));

      // Clean up dissolved cards from DOM (while card is centered)
      grid.querySelectorAll('.dissolving').forEach(el => el.remove());

      // STEP 9: Sparkle teleport from corridor center to breadcrumb
      if (chosenCard && targetX !== undefined) {
          const cardRect = chosenCard.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;

          // Phase 1: Dissolution sparkles from card surface
          chosenCard.style.transition = 'opacity 0.3s ease-out';
          chosenCard.style.opacity = '0.2';

          const dissolutionCount = 14 + Math.floor(Math.random() * 6);
          for (let i = 0; i < dissolutionCount; i++) {
              setTimeout(() => {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'dissolution-sparkle';
                  const sx = cardRect.left + Math.random() * cardRect.width;
                  const sy = cardRect.top + Math.random() * cardRect.height;
                  sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 400);
              }, i * 25);
          }

          // Phase 2: Traveling sparkles arc from card center to breadcrumb
          setTimeout(() => {
              const travelCount = 8 + Math.floor(Math.random() * 4);
              for (let i = 0; i < travelCount; i++) {
                  setTimeout(() => {
                      const sparkle = document.createElement('div');
                      sparkle.className = 'traveling-sparkle';
                      const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
                      const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
                      const sx = cardCenterX + offX;
                      const sy = cardCenterY + offY;
                      const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
                      const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
                      sparkle.style.cssText = `
                          left: ${sx}px; top: ${sy}px;
                          --target-x: ${targetX - sx}px;
                          --target-y: ${targetY - sy}px;
                          --arc-x: ${midX - sx}px;
                          --arc-y: ${midY - sy}px;
                      `;
                      document.body.appendChild(sparkle);
                      setTimeout(() => sparkle.remove(), 600);
                  }, i * 45);
              }
          }, 200);

          // Phase 3: Convergence sparkles + breadcrumb creation
          await new Promise(r => setTimeout(r, 700));

          // Hide the card fully
          chosenCard.style.opacity = '0';

          // Convergence sparkles at breadcrumb position
          for (let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.className = 'convergence-sparkle';
              const angle = (Math.PI * 2 * i) / 6;
              const dist = 18 + Math.random() * 12;
              sparkle.style.cssText = `
                  left: ${targetX + Math.cos(angle) * dist}px;
                  top: ${targetY + Math.sin(angle) * dist}px;
              `;
              document.body.appendChild(sparkle);
              setTimeout(() => sparkle.remove(), 500);
          }
      }

      // Restore chosen card state
      if (chosenCard) {
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle && backTitle.dataset.originalText) {
              backTitle.textContent = backTitle.dataset.originalText;
          }
          chosenCard.style.transform = '';
          chosenCard.style.zIndex = '';
          chosenCard.style.opacity = '';
          chosenCard.style.transition = '';
      }

      // STEP 10: Create breadcrumb with Destiny's Choice back PNG
      createArchetypeBreadcrumbWithMask(chosenId, true);

      // Advance corridor
      if (typeof hideCorridorContinueButton === 'function') {
          hideCorridorContinueButton('storybeau');
      }
      if (typeof advanceCorridorRow === 'function') {
          advanceCorridorRow();
      }

      console.log(`[Destiny's Choice] Selected: ${chosenId}`);
  }

  /**
   * Spawn a dissolve sparkle relative to archetype grid
   * Uses global sparkle variance rules:
   * - Size variance: 0.85-1.15 scale factor
   * - Lifetime variance: Â±10%
   * - Micro drift angle variance: Â±5-8Â°
   */
  function spawnSparkleAt(card) {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid || !card) return;

      // Ensure grid has relative positioning for sparkles
      if (getComputedStyle(grid).position === 'static') {
          grid.style.position = 'relative';
      }

      const sparkle = document.createElement('div');
      sparkle.className = 'destiny-dissolve-sparkle';

      // Get card position relative to grid
      const gridRect = grid.getBoundingClientRect();
      const cardRect = card.getBoundingClientRect();
      const relativeX = cardRect.left - gridRect.left + cardRect.width / 2;
      const relativeY = cardRect.top - gridRect.top + cardRect.height / 2;

      sparkle.style.left = `${relativeX}px`;
      sparkle.style.top = `${relativeY}px`;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // GLOBAL SPARKLE VARIANCE RULES:
      // 1. Size variance: 0.85-1.15 scale factor
      // 2. Lifetime variance: Â±10%
      // 3. Micro drift angle variance: Â±5-8Â°
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Size variance
      const sizeVariance = 0.85 + Math.random() * 0.3; // 0.85 to 1.15
      const baseSize = 8;
      const size = baseSize * sizeVariance;

      // Lifetime variance (Â±10%)
      const baseDuration = 600;
      const lifetimeVariance = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
      const duration = baseDuration * lifetimeVariance + Math.random() * 400;

      // Drift with micro angle variance (Â±5-8Â°)
      const angleVariance = (Math.random() - 0.5) * 0.14; // Â±0.07 radians (~4-8Â°)
      const baseDriftX = (Math.random() - 0.5) * 60;
      const baseDriftY = (Math.random() - 0.5) * 60 - 30; // Bias upward
      // Apply rotation to drift vector
      const driftX = baseDriftX * Math.cos(angleVariance) - baseDriftY * Math.sin(angleVariance);
      const driftY = baseDriftX * Math.sin(angleVariance) + baseDriftY * Math.cos(angleVariance);

      sparkle.style.width = `${size}px`;
      sparkle.style.height = `${size}px`;

      grid.appendChild(sparkle);

      sparkle.animate([
          { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
          { transform: `translate(calc(-50% + ${driftX}px), calc(-50% + ${driftY}px)) scale(0)`, opacity: 0 }
      ], {
          duration: duration,
          easing: 'ease-out'
      }).onfinish = () => sparkle.remove();
  }

  /**
   * Create archetype breadcrumb with PNG art
   * viaDestiny=false: shows mask gold front PNG
   * viaDestiny=true: shows Destiny's Choice back PNG
   */
  function createArchetypeBreadcrumbWithMask(archetypeId, viaDestiny = false) {
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      if (!breadcrumbRow) return;

      const stageIdx = STAGE_INDEX['archetype'];

      // Check for existing breadcrumb and remove
      const existingCard = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="archetype"]');
      if (existingCard) existingCard.remove();

      // Map archetype ID to PNG filename
      const pngMap = {
          'HEART_WARDEN': 'Tarot-Gold-front-HeartWarden.png',
          'OPEN_VEIN': 'Tarot-Gold-front-OpenVein.png',
          'SPELLBINDER': 'Tarot-Gold-front-Spellbinder.png',
          'ARMORED_FOX': 'Tarot-Gold-front-AFox.png',
          'DARK_VICE': 'Tarot-Gold-front-DarkVice.png',
          'BEAUTIFUL_RUIN': 'Tarot-Gold-front-BRuin.png',
          'ETERNAL_FLAME': 'Tarot-Gold-front-EternalFlame.png'
      };
      const pngFile = viaDestiny
          ? 'Black-DestinyChoice-back.png'
          : (pngMap[archetypeId] || 'Tarot-Gold-front-HeartWarden.png');

      // Create breadcrumb with PNG art only (no mask icon, no text)
      const card = document.createElement('div');
      card.className = 'breadcrumb-card archetype-breadcrumb-png materializing';
      if (viaDestiny) card.classList.add('destiny-choice-breadcrumb');
      card.dataset.grp = 'archetype';
      card.dataset.val = archetypeId;
      card.dataset.stageIndex = stageIdx;
      card.dataset.breadcrumbLabel = viaDestiny ? "Destiny's Choice" : 'Archetype';
      card.style.backgroundImage = `url('/assets/card-art/cards/${pngFile}')`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';

      card.addEventListener('click', () => navigateToBreadcrumb('archetype'));

      // Insert breadcrumb at correct position using stage-index ordering
      // (insert BEFORE removing ghost step to prevent layout lurch)
      const allSlots = breadcrumbRow.querySelectorAll('.breadcrumb-card, .ghost-step');
      let insertBefore = null;
      for (const slot of allSlots) {
        const slotIdx = parseInt(slot.dataset.stageIndex ?? slot.dataset.ghostIndex, 10);
        if (!isNaN(slotIdx) && slotIdx > stageIdx) {
          insertBefore = slot;
          break;
        }
      }
      if (insertBefore) {
          breadcrumbRow.insertBefore(card, insertBefore);
      } else {
          breadcrumbRow.appendChild(card);
      }

      // NOW remove the ghost step (after breadcrumb is already in place)
      if (stageIdx !== undefined && stageIdx >= 0) {
          if (typeof removeGhostStep === 'function') removeGhostStep(stageIdx);
      }

      // Remove materializing class after animation
      setTimeout(() => card.classList.remove('materializing'), 400);

      // Attach destructive navigation handler
      if (typeof attachBreadcrumbNavigation === 'function') {
          attachBreadcrumbNavigation(card);
      }

      // Sparkles on the active breadcrumb
      updateActiveBreadcrumbSparkles(card);

      corridorSelections.set('storybeau', archetypeId);
      console.log(`[Breadcrumb] Created PNG card for archetype (${viaDestiny ? 'Destiny' : 'Continue'}): ${archetypeId}`);
  }

  // Populate archetype card zoom view â€” primary archetype only, no modifier UI
  function populateArchetypeZoomContent(card, archetypeId) {
      const frontFace = card.querySelector('.sb-card-front');
      if (!frontFace) return;
      const existing = frontFace.querySelector('.sb-zoom-content');
      if (existing) existing.remove();
  }

  // STATE 3: Open zoomed view for archetype cards
  // PORTAL ARCHITECTURE: Card is MOVED into zoom portal
  // This breaks out of ALL ancestor stacking contexts and filters
  function openArchetypeOverlay(archetypeId) {
      const card = document.querySelector(`#archetypeCardGrid .sb-card[data-archetype="${archetypeId}"]`);
      const arch = ARCHETYPES[archetypeId];
      if (!card || !arch) return;

      // Close any currently zoomed card
      if (currentOpenCard && window.closeZoomedCard) {
          window.closeZoomedCard();
      }

      currentOpenCard = card;

      // Dim all other archetype cards
      document.querySelectorAll('#archetypeCardGrid .sb-card').forEach(c => {
          if (c !== card) c.classList.add('dimmed');
      });

      // Populate modifier selection content
      populateArchetypeZoomContent(card, archetypeId);

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Store original DOM position for restoration
      zoomOriginalParent = card.parentNode;
      zoomOriginalNextSibling = card.nextElementSibling;

      // Store original position for animation reference
      card.dataset.zoomOriginalLeft = rect.left;
      card.dataset.zoomOriginalTop = rect.top;
      card.dataset.zoomOriginalWidth = rect.width;
      card.dataset.zoomOriginalHeight = rect.height;

      // ARCHETYPE ZOOM: Use scale transform to preserve internal layout
      // Card has content (description, modifiers) that needs proportional scaling
      const padding = 60;
      const maxWidth = window.innerWidth - padding;
      const maxHeight = window.innerHeight - padding;
      const scaleByWidth = maxWidth / rect.width;
      const scaleByHeight = maxHeight / rect.height;
      const scale = Math.min(2.5, scaleByWidth, scaleByHeight);

      // PORTAL MOVE: Move card into zoom portal (breaks ALL ancestor contexts)
      if (zoomPortal) {
          zoomPortal.appendChild(card);
      }

      // Apply zoom styling - flexbox in portal handles centering
      card.classList.add('zoomed');
      card.style.width = `${rect.width}px`;
      card.style.height = `${rect.height}px`;
      card.style.transform = `scale(${scale})`;
      card.style.transformOrigin = 'center center';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';

      // Show backdrop
      if (zoomBackdrop) {
          zoomBackdrop.classList.add('active');
      }

      // Add sparkle emitters to all four edges of zoomed card
      const frontFace = card.querySelector('.sb-card-front');
      if (frontFace) {
          ['left', 'right', 'top', 'bottom'].forEach(side => {
              const sparkleContainer = document.createElement('div');
              sparkleContainer.className = 'zoom-side-sparkles';
              sparkleContainer.id = `zoomSideSparkles_${side}`;
              sparkleContainer.dataset.side = side;
              frontFace.appendChild(sparkleContainer);
              startSparkleEmitter(sparkleContainer.id, 'destinyDeck', 8);
          });
      }

      // Add left/right navigation arrows to portal
      if (zoomPortal) {
          const currentIdx = ARCHETYPE_ORDER.indexOf(archetypeId);

          const leftArrow = document.createElement('div');
          leftArrow.className = 'zoom-nav-arrow zoom-nav-left';
          leftArrow.innerHTML = '&#8249;'; // â€¹
          leftArrow.addEventListener('click', (e) => {
              e.stopPropagation();
              const curId = currentOpenCard?.dataset.archetype;
              if (!curId) return;
              const idx = ARCHETYPE_ORDER.indexOf(curId);
              const prevIdx = (idx - 1 + ARCHETYPE_ORDER.length) % ARCHETYPE_ORDER.length;
              navigateZoomedArchetype(ARCHETYPE_ORDER[prevIdx]);
          });
          zoomPortal.appendChild(leftArrow);

          const rightArrow = document.createElement('div');
          rightArrow.className = 'zoom-nav-arrow zoom-nav-right';
          rightArrow.innerHTML = '&#8250;'; // â€º
          rightArrow.addEventListener('click', (e) => {
              e.stopPropagation();
              const curId = currentOpenCard?.dataset.archetype;
              if (!curId) return;
              const idx = ARCHETYPE_ORDER.indexOf(curId);
              const nextIdx = (idx + 1) % ARCHETYPE_ORDER.length;
              navigateZoomedArchetype(ARCHETYPE_ORDER[nextIdx]);
          });
          zoomPortal.appendChild(rightArrow);

          // Add Continue button below the zoomed card
          const zoomContinueBtn = document.createElement('button');
          zoomContinueBtn.className = 'zoom-continue-btn';
          zoomContinueBtn.textContent = 'Continue';
          zoomContinueBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const curId = currentOpenCard?.dataset.archetype;
              if (!curId) return;
              commitArchetypeFromZoom(curId);
          });
          zoomPortal.appendChild(zoomContinueBtn);
      }
  }

  /**
   * Navigate between archetype cards while in zoom view
   * Swaps the zoomed card without closing the overlay
   */
  function navigateZoomedArchetype(newArchetypeId) {
      if (!currentOpenCard || !zoomPortal) return;

      const oldCard = currentOpenCard;
      const oldId = oldCard.dataset.archetype;
      if (oldId === newArchetypeId) return;

      // Find the new card in the grid (it's still in the grid since only oldCard is in portal)
      const newCard = document.querySelector(`#archetypeCardGrid .sb-card[data-archetype="${newArchetypeId}"]`);
      if (!newCard) return;

      // Stop old sparkle emitters
      ['left', 'right', 'top', 'bottom'].forEach(side => {
          const id = `zoomSideSparkles_${side}`;
          stopSparkleEmitter(id);
          const el = oldCard.querySelector(`#${id}`);
          if (el) el.remove();
      });

      // Remove old zoom content
      const oldZoomContent = oldCard.querySelector('.sb-zoom-content');
      if (oldZoomContent) oldZoomContent.remove();

      // Restore old card to grid
      oldCard.classList.remove('zoomed');
      oldCard.style.transform = '';
      oldCard.style.transformOrigin = '';
      oldCard.style.width = '';
      oldCard.style.height = '';
      oldCard.style.position = '';
      if (zoomOriginalParent) {
          if (zoomOriginalNextSibling) {
              zoomOriginalParent.insertBefore(oldCard, zoomOriginalNextSibling);
          } else {
              zoomOriginalParent.appendChild(oldCard);
          }
      }
      delete oldCard.dataset.zoomOriginalLeft;
      delete oldCard.dataset.zoomOriginalTop;
      delete oldCard.dataset.zoomOriginalWidth;
      delete oldCard.dataset.zoomOriginalHeight;

      // Dim all cards, un-dim the new one
      document.querySelectorAll('#archetypeCardGrid .sb-card').forEach(c => {
          c.classList.toggle('dimmed', c !== newCard);
      });

      // Populate new card zoom content
      populateArchetypeZoomContent(newCard, newArchetypeId);

      // Store new card's position and move to portal
      const rect = newCard.getBoundingClientRect();
      zoomOriginalParent = newCard.parentNode;
      zoomOriginalNextSibling = newCard.nextElementSibling;
      newCard.dataset.zoomOriginalLeft = rect.left;
      newCard.dataset.zoomOriginalTop = rect.top;
      newCard.dataset.zoomOriginalWidth = rect.width;
      newCard.dataset.zoomOriginalHeight = rect.height;

      const padding = 60;
      const maxWidth = window.innerWidth - padding;
      const maxHeight = window.innerHeight - padding;
      const scaleByWidth = maxWidth / rect.width;
      const scaleByHeight = maxHeight / rect.height;
      const scale = Math.min(2.5, scaleByWidth, scaleByHeight);

      // Insert card BEFORE the nav arrows (first child position)
      const firstArrow = zoomPortal.querySelector('.zoom-nav-arrow');
      if (firstArrow) {
          zoomPortal.insertBefore(newCard, firstArrow);
      } else {
          zoomPortal.appendChild(newCard);
      }

      newCard.classList.add('zoomed');
      newCard.style.width = `${rect.width}px`;
      newCard.style.height = `${rect.height}px`;
      newCard.style.transform = `scale(${scale})`;
      newCard.style.transformOrigin = 'center center';

      currentOpenCard = newCard;

      // Track as last-zoomed
      setLastZoomedArchetype(newArchetypeId);

      // Add sparkle emitters to new card
      const frontFace = newCard.querySelector('.sb-card-front');
      if (frontFace) {
          ['left', 'right', 'top', 'bottom'].forEach(side => {
              const sparkleContainer = document.createElement('div');
              sparkleContainer.className = 'zoom-side-sparkles';
              sparkleContainer.id = `zoomSideSparkles_${side}`;
              sparkleContainer.dataset.side = side;
              frontFace.appendChild(sparkleContainer);
              startSparkleEmitter(sparkleContainer.id, 'destinyDeck', 8);
          });
      }
  }

  /**
   * Commit archetype selection from zoom Continue button
   * Closes zoom, triggers sparkle teleport to breadcrumb, advances corridor
   */
  function commitArchetypeFromZoom(archetypeId) {
      // Commit the selection
      if (state.archetype?.primary !== archetypeId) {
          commitArchetypeSelection(archetypeId, false);
      }

      // Close the zoom overlay (this restores card to grid and starts corridor sparkles)
      if (window.closeZoomedCard) window.closeZoomedCard();

      // Stop focus sparkles (we're about to teleport)
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }
      const focusedCard = document.querySelector('.archetype-card.last-zoomed');
      if (focusedCard) {
          focusedCard.classList.remove('last-zoomed');
          const sc = focusedCard.querySelector('.archetype-focus-sparkles');
          if (sc) sc.remove();
      }

      const archetype = ARCHETYPES[archetypeId];
      const archetypeName = archetype?.name || archetypeId;

      hideCorridorContinueButton('storybeau');

      // Sparkle teleport from card to breadcrumb III
      const selectedCard = document.querySelector(
          `#archetypeCardGrid .archetype-card[data-archetype="${archetypeId}"]`
      );
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const archGhostIdx = STAGE_INDEX['storybeau'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${archGhostIdx}"]`);

      let targetX, targetY;
      if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          targetX = ghostRect.left + ghostRect.width / 2;
          targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
          const brRect = breadcrumbRow.getBoundingClientRect();
          targetX = brRect.left + brRect.width / 2;
          targetY = brRect.top + brRect.height / 2;
      }

      if (selectedCard && targetX !== undefined) {
          const cardRect = selectedCard.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;

          // Phase 1: Dissolution sparkles + fade card
          selectedCard.style.opacity = '0.3';
          const dissolutionCount = 12 + Math.floor(Math.random() * 5);
          for (let i = 0; i < dissolutionCount; i++) {
              setTimeout(() => {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'dissolution-sparkle';
                  const sx = cardRect.left + Math.random() * cardRect.width;
                  const sy = cardRect.top + Math.random() * cardRect.height;
                  sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 400);
              }, i * 25);
          }

          // Phase 2: Sparkle travel to breadcrumb
          setTimeout(() => {
              const travelCount = 6 + Math.floor(Math.random() * 3);
              for (let i = 0; i < travelCount; i++) {
                  setTimeout(() => {
                      const sparkle = document.createElement('div');
                      sparkle.className = 'traveling-sparkle';
                      const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
                      const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
                      const sx = cardCenterX + offX;
                      const sy = cardCenterY + offY;
                      const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
                      const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
                      sparkle.style.cssText = `
                          left: ${sx}px; top: ${sy}px;
                          --target-x: ${targetX - sx}px;
                          --target-y: ${targetY - sy}px;
                          --arc-x: ${midX - sx}px;
                          --arc-y: ${midY - sy}px;
                      `;
                      document.body.appendChild(sparkle);
                      setTimeout(() => sparkle.remove(), 600);
                  }, i * 40);
              }
          }, 200);

          // Phase 3: Convergence sparkles + breadcrumb + advance
          setTimeout(() => {
              for (let i = 0; i < 5; i++) {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'convergence-sparkle';
                  const angle = (Math.PI * 2 * i) / 5;
                  const dist = 15 + Math.random() * 10;
                  sparkle.style.cssText = `
                      left: ${targetX + Math.cos(angle) * dist}px;
                      top: ${targetY + Math.sin(angle) * dist}px;
                  `;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 500);
              }

              selectedCard.style.opacity = '';
              createArchetypeBreadcrumbWithMask(archetypeId, false);
              setTimeout(() => advanceCorridorRow(), 600);
          }, 600);
      } else {
          // Fallback: no animation
          createArchetypeBreadcrumbWithMask(archetypeId, false);
          setTimeout(() => advanceCorridorRow(), 600);
      }
  }

  // Close archetype zoom â€” now handled by closeZoomedCard() which detects archetype cards
  // and auto-starts corridor sparkles. Kept as alias for compatibility.
  function closeArchetypeOverlay() {
      if (window.closeZoomedCard) window.closeZoomedCard();
  }

  function bindArchetypeHandlers() {
      // No longer needed - archetype zoom uses the unified zoom system
      // Backdrop click is handled by the global backdrop listener
  }

  function updateArchetypeCardStates() {
      document.querySelectorAll('#archetypeCardGrid .sb-card.archetype-card:not(.destiny-choice-card)').forEach(card => {
          const id = card.dataset.archetype;
          const isSelected = state.archetype.primary === id;

          if (archetypeSelectedViaDestiny) {
              // Destiny's Choice: mask is SECRET â€” all cards face-down, no selection shown
              card.classList.remove('selected', 'flipped');
          } else {
              card.classList.toggle('selected', isSelected);
              // Selected card gets selection state, all cards stay flipped (revealed)
              if (isSelected) {
                  card.classList.add('flipped');
                  lastZoomedArchetype = id;
              }
          }
      });
  }

  // Legacy stub â€” modifier UI removed, selection summary no longer displayed
  function updateArchetypeSelectionSummary() {
      const primaryName = document.getElementById('selectedPrimaryName');
      if (primaryName) {
          const primary = state.archetype.primary ? ARCHETYPES[state.archetype.primary] : null;
          primaryName.textContent = primary ? primary.name : 'None';
      }
  }

  // Legacy function stubs for compatibility
  function renderArchetypePills() { renderArchetypeCards(); }
  function updateArchetypePillStates() { updateArchetypeCardStates(); }

  function updateArchetypePreview() {
      // Now handled by overlay and selection summary - keeping for compatibility
      updateArchetypeSelectionSummary();
  }

  function updateArchetypeSectionTitle() {
      const titleEl = document.getElementById('archetypeSectionTitle');
      if (!titleEl) return;
      const genderSelect = document.getElementById('loveInterestGender');
      const customInput = document.getElementById('customLoveInterest');
      let loveGender = 'Male';
      if (genderSelect) {
          if (genderSelect.value === 'Custom' && customInput && customInput.value.trim()) {
              loveGender = customInput.value.trim();
          } else {
              loveGender = genderSelect.value;
          }
      }
      titleEl.textContent = getArchetypeSectionTitle(loveGender);
  }

  function bindLoveInterestGenderWatcher() {
      const genderSelect = document.getElementById('loveInterestGender');
      const customInput = document.getElementById('customLoveInterest');

      function onLIGenderChange() {
          // Update state.loveInterest for pronoun resolution
          if (genderSelect) {
              state.loveInterest = genderSelect.value === 'Custom' && customInput?.value?.trim()
                  ? customInput.value.trim()
                  : genderSelect.value;
          }
          updateArchetypeSectionTitle();
          // Re-render archetype cards with updated pronouns
          renderArchetypeCards();
      }

      if (genderSelect && genderSelect.dataset.archetypeBound !== '1') {
          genderSelect.dataset.archetypeBound = '1';
          genderSelect.addEventListener('change', onLIGenderChange);
      }

      if (customInput && customInput.dataset.archetypeBound !== '1') {
          customInput.dataset.archetypeBound = '1';
          customInput.addEventListener('input', onLIGenderChange);
      }

      // Also watch player gender changes for MC pronoun resolution
      const playerGenderSelect = document.getElementById('playerGender');
      const customPlayerGender = document.getElementById('customPlayerGender');

      function onPlayerGenderChange() {
          if (playerGenderSelect) {
              state.gender = playerGenderSelect.value === 'Custom' && customPlayerGender?.value?.trim()
                  ? customPlayerGender.value.trim()
                  : playerGenderSelect.value;
          }
          // Re-render archetype cards with updated MC pronouns
          renderArchetypeCards();
      }

      if (playerGenderSelect && playerGenderSelect.dataset.archetypeBound !== '1') {
          playerGenderSelect.dataset.archetypeBound = '1';
          playerGenderSelect.addEventListener('change', onPlayerGenderChange);
      }

      if (customPlayerGender && customPlayerGender.dataset.archetypeBound !== '1') {
          customPlayerGender.dataset.archetypeBound = '1';
          customPlayerGender.addEventListener('input', onPlayerGenderChange);
      }
  }

  // --- LOADING OVERLAY ---
  let _loadingTimer = null;
  let _loadingActive = false;
  let _loadingMsgTimer = null;
  let _loadingCancelled = false;
  let _loadingCancelCallback = null;
  let _lastSettingShotDesc = '';

  const STORY_LOADING_MESSAGES = [
      // Required phrases
      "Crafting each individual snowflake...",
      "Setting traps...",
      "Naming the animals...",
      "Manifesting drama...",
      "Cleaning up double entendres...",
      "Darkening the past...",
      "Amping the feels...",
      // Additional playful, literary, worldbuilding phrases
      "Weaving backstories...",
      "Polishing the silver tongues...",
      "Hiding secrets in the walls...",
      "Brewing chemistry...",
      "Sharpening the wit...",
      "Planting red herrings...",
      "Tuning the heartstrings...",
      "Scheduling the rain...",
      "Lighting the candles...",
      "Rehearsing the longing glances...",
      "Aging the whiskey...",
      "Pressing the silk sheets...",
      "Whispering rumors...",
      "Composing the tension...",
      "Perfecting the timing...",
      "Casting shadows...",
      "Stoking the slow burn...",
      "Arranging the flowers...",
      "Calibrating the chemistry..."
  ];

  const VISUALIZE_LOADING_MESSAGES = [
      "Painting the scene...",
      "Saying it with his eyes...",
      "Letting the silence linger...",
      "Adding longing...",
      "Shaping the moment...",
      "Tracing the tension...",
      "Capturing the unspoken...",
      "Finding the perfect light...",
      "Catching the glance...",
      "Softening the shadows...",
      "Framing the desire...",
      "Holding the gaze...",
      "Rendering the warmth...",
      "Sculpting the posture...",
      "Brushing the highlights...",
      "Etching the atmosphere...",
      "Composing the stillness...",
      "Illuminating the moment..."
  ];

  function startLoading(msg, messageList = null, cancellable = false, onCancel = null){
    const overlay = document.getElementById('loadingOverlay');
    const fill = document.getElementById('loadingOverlayFill');
    const textEl = document.getElementById('loadingText');
    const percentEl = document.getElementById('loadingPercent');
    const cancelBtn = document.getElementById('loadingCancelBtn');

    if (textEl) textEl.textContent = msg || "Loading...";
    if (percentEl) percentEl.textContent = '0%';

    _loadingActive = true;
    _loadingCancelled = false;
    _loadingCancelCallback = onCancel;

    // Stop fate card sparkles when loading overlay appears (prevent z-index bleed)
    if (window.stopSparkleCycle) window.stopSparkleCycle();
    if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();

    if(fill) fill.style.width = '0%';
    if(overlay) overlay.classList.remove('hidden');

    // Start loading bar sparkles
    startOverlayLoadingSparkles();

    // Show/hide cancel button based on cancellable flag
    if (cancelBtn) {
        if (cancellable) {
            cancelBtn.classList.add('visible');
        } else {
            cancelBtn.classList.remove('visible');
        }
    }

    if(_loadingTimer) clearInterval(_loadingTimer);
    if(_loadingMsgTimer) clearInterval(_loadingMsgTimer);

    let p = 0;
    _loadingTimer = setInterval(() => {
      if(!_loadingActive || _loadingCancelled) return;
      p = Math.min(91, p + Math.random() * 6);
      if(fill) fill.style.width = p.toFixed(0) + '%';
      if(percentEl) percentEl.textContent = p.toFixed(0) + '%';
    }, 250);

    // Rotate messages if a message list is provided
    if (messageList && Array.isArray(messageList) && messageList.length > 0 && textEl) {
        // Shuffle the list for random order, no repeats until cycle completes
        const shuffled = [...messageList].sort(() => Math.random() - 0.5);
        let msgIdx = 0;

        // PART C: Crossfade transition for loading phrases
        // Fade duration: 300ms out + 300ms in
        const fadeDuration = 300;
        textEl.style.transition = `opacity ${fadeDuration}ms ease-in-out`;

        _loadingMsgTimer = setInterval(() => {
            if (!_loadingActive || _loadingCancelled) return;
            msgIdx = (msgIdx + 1) % shuffled.length;

            // Fade out
            textEl.style.opacity = '0';

            // Swap text at opacity 0, then fade in
            setTimeout(() => {
                if (!_loadingActive || _loadingCancelled) return;
                textEl.textContent = shuffled[msgIdx];
                textEl.style.opacity = '1';
            }, fadeDuration);
        }, 3200); // 3.2s cadence for slower, more readable rotation
    }
  }

  function cancelLoading() {
    _loadingCancelled = true;
    if (_loadingCancelCallback) {
        _loadingCancelCallback();
        _loadingCancelCallback = null;
    }
    stopLoading();
  }

  function isLoadingCancelled() {
    return _loadingCancelled;
  }

  /**
   * Update the loading message during an active loading state.
   * Used by orchestration to show phase-specific messages.
   */
  function updateLoadingMessage(msg) {
    if (!_loadingActive) return;
    const textEl = document.getElementById('loadingText');
    if (textEl) {
      // Fade transition
      textEl.style.opacity = '0';
      setTimeout(() => {
        textEl.textContent = msg;
        textEl.style.opacity = '1';
      }, 200);
    }
  }

  function stopLoading(){
    if(!_loadingActive) return;
    _loadingActive = false;
    const overlay = document.getElementById('loadingOverlay');
    const fill = document.getElementById('loadingOverlayFill');
    const percentEl = document.getElementById('loadingPercent');
    const cancelBtn = document.getElementById('loadingCancelBtn');
    const textEl = document.getElementById('loadingText');

    if(_loadingTimer) { clearInterval(_loadingTimer); _loadingTimer = null; }
    if(_loadingMsgTimer) { clearInterval(_loadingMsgTimer); _loadingMsgTimer = null; }
    if(fill) fill.style.width = '100%';
    if(percentEl) percentEl.textContent = '100%';
    if(cancelBtn) cancelBtn.classList.remove('visible');

    // Reset text opacity for next loading cycle
    if(textEl) {
        textEl.style.transition = 'none';
        textEl.style.opacity = '1';
    }

    setTimeout(() => {
      if(overlay) overlay.classList.add('hidden');
      if(fill) fill.style.width = '0%';
      if(percentEl) percentEl.textContent = '0%';
    }, 120);

    // Stop overlay sparkles
    stopOverlayLoadingSparkles();
  }

  // ============================================================
  // OVERLAY LOADING BAR SPARKLES (Story + Visualize ONLY)
  // SEPARATE from cover bar sparkles â€” do NOT modify cover system
  // ============================================================
  let _overlaySparkleInterval = null;

  function spawnOverlayLoadingSparkle(container) {
      if (!container) return;
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;
      if (containerWidth === 0) return;

      const sparkle = document.createElement('div');
      sparkle.className = 'overlay-loading-sparkle';

      // Random X position along the bar
      const spawnX = Math.random() * containerWidth;
      // Slight vertical variance above/below centerline
      const spawnY = (Math.random() - 0.5) * 20 - 8;

      // Curved arc motion â€” upward drift with lateral sway
      const baseAngle = -60 - Math.random() * 60; // -60Â° to -120Â° (upward arc)
      const angleRad = baseAngle * (Math.PI / 180);
      const distance = 25 + Math.random() * 45;
      const dx = Math.cos(angleRad) * distance * (Math.random() > 0.5 ? 1 : -1);
      const dy = Math.sin(angleRad) * distance - 15 - Math.random() * 20; // Strong upward bias

      // Lateral sway for organic feel
      const sway = (Math.random() - 0.5) * 18;

      // Rotation for visual interest
      const rotation = (Math.random() - 0.5) * 40;

      // Variable size (2-5px)
      const size = 2 + Math.random() * 3;

      // Randomized lifetime (1.2s - 3.5s)
      const duration = 1200 + Math.random() * 2300;

      // Variable opacity (0.6 - 0.95)
      const opacity = 0.6 + Math.random() * 0.35;

      // Randomized easing
      const easings = ['ease-in-out', 'ease-out', 'cubic-bezier(0.4, 0, 0.2, 1)', 'cubic-bezier(0.25, 0.1, 0.25, 1)'];
      const easing = easings[Math.floor(Math.random() * easings.length)];

      sparkle.style.cssText = `
          left: ${spawnX}px;
          top: ${spawnY}px;
          width: ${size}px;
          height: ${size}px;
          --ols-duration: ${duration}ms;
          --ols-opacity: ${opacity};
          --ols-dx: ${dx}px;
          --ols-dy: ${dy}px;
          --ols-sway: ${sway}px;
          --ols-rot: ${rotation}deg;
          --ols-easing: ${easing};
      `;

      container.appendChild(sparkle);
      setTimeout(() => { if (sparkle.parentNode) sparkle.remove(); }, duration + 100);
  }

  function startOverlayLoadingSparkles() {
      stopOverlayLoadingSparkles();

      const loadingBar = document.getElementById('loadingOverlayBar');
      if (!loadingBar) return;

      // Ensure container is positioned for absolute children
      const style = window.getComputedStyle(loadingBar);
      if (style.position === 'static') {
          loadingBar.style.position = 'relative';
      }
      loadingBar.style.overflow = 'visible';
      loadingBar.classList.add('sparkle-active');

      // Higher density: spawn at staggered intervals (8-16 concurrent)
      _overlaySparkleInterval = setInterval(() => {
          spawnOverlayLoadingSparkle(loadingBar);
      }, 140); // ~7 sparkles per second

      // Initial burst â€” staggered for natural appearance
      for (let i = 0; i < 8; i++) {
          setTimeout(() => spawnOverlayLoadingSparkle(loadingBar), i * 60);
      }
  }

  function stopOverlayLoadingSparkles() {
      if (_overlaySparkleInterval) {
          clearInterval(_overlaySparkleInterval);
          _overlaySparkleInterval = null;
      }

      const loadingBar = document.getElementById('loadingOverlayBar');
      if (loadingBar) {
          loadingBar.classList.remove('sparkle-active');
      }

      // Fade out existing sparkles gracefully
      document.querySelectorAll('.overlay-loading-sparkle').forEach(s => {
          s.style.opacity = '0';
          s.style.transition = 'opacity 0.4s ease-out';
          setTimeout(() => s.remove(), 450);
      });
  }

  // Bind cancel button
  document.getElementById('loadingCancelBtn')?.addEventListener('click', cancelLoading);

  // PASS 1 FIX: Storypass purchase - grants Fling tier ONLY
  $('payOneTime')?.addEventListener('click', () => {
    console.log('[ENTITLEMENT] Storypass $3 purchase initiated');

    // Ensure we have a story ID
    state.storyId = state.storyId || makeStoryId();

    // Mark purchase type BEFORE granting pass
    state.lastPurchaseType = 'pass';

    // Grant the story pass (stores in localStorage)
    grantStoryPass(state.storyId);

    console.log('[ENTITLEMENT] Story pass granted:', {
        storyId: state.storyId,
        hasPass: hasStoryPass(state.storyId)
    });

    // Complete purchase - will resolve access from localStorage
    completePurchase();
  });

  // PASS 1 FIX: Subscription purchase - grants full access
  $('paySub')?.addEventListener('click', () => {
    console.log('[ENTITLEMENT] Subscribe purchase initiated');

    // Mark purchase type
    state.lastPurchaseType = 'sub';

    // Persist subscription to localStorage (source of truth)
    state.subscribed = true;
    // AUTH GATE: Only persist to storage when logged in
    if (isLoggedIn()) {
        localStorage.setItem('sb_subscribed', '1');
        console.log('[ENTITLEMENT] Subscription stored in localStorage');
    }

    // Complete purchase - will resolve access from localStorage
    completePurchase();
  });

  $('payGodMode')?.addEventListener('click', () => {
      // AUTH GATE: Only persist to storage when logged in
      if (isLoggedIn()) {
          localStorage.setItem('sb_god_mode_owned', '1');
      }
      document.getElementById('payModal')?.classList.add('hidden');
      if (confirm("WARNING: God Mode permanently removes this story from canon.")) {
          activateGodMode();
      }
  });

  // Track committed phrases in state
  if (!state.committedQuill) state.committedQuill = [];
  if (!state.committedVeto) state.committedVeto = [];

  // Add a committed phrase to the UI
  function addCommittedPhrase(container, text, type, index) {
      const phrase = document.createElement('div');
      phrase.className = `committed-phrase ${type}-phrase`;
      phrase.dataset.index = index;
      phrase.innerHTML = `
          <button class="committed-phrase-remove" title="Remove" aria-label="Remove veto">&times;</button>
          <span class="committed-phrase-text">${text}</span>
      `;
      // Insert at top (new commits above old)
      container.insertBefore(phrase, container.firstChild);

      // Bind remove button
      phrase.querySelector('.committed-phrase-remove').addEventListener('click', () => {
          removeCommittedPhrase(type, index);
      });
  }

  // Remove a committed phrase
  function removeCommittedPhrase(type, index) {
      const arr = type === 'quill' ? state.committedQuill : state.committedVeto;
      arr.splice(index, 1);
      renderCommittedPhrases(type);
      // Update veto state if needed
      if (type === 'veto') rebuildVetoFromCommitted();
      // Sync quillIntent to most recent committed Quill (or clear if none)
      if (type === 'quill') {
          state.quillIntent = arr.length > 0 ? arr[arr.length - 1] : '';
      }
      saveStorySnapshot();
  }

  // Render all committed phrases for a type
  function renderCommittedPhrases(type) {
      const container = document.getElementById(type === 'quill' ? 'quillCommitted' : 'vetoCommitted');
      const arr = type === 'quill' ? state.committedQuill : state.committedVeto;
      if (!container) return;
      container.innerHTML = '';
      arr.forEach((text, i) => addCommittedPhrase(container, text, type, i));
  }

  // Render veto pills in game modal (with remove buttons)
  function renderGameVetoPills(container) {
      if (!container || !state.committedVeto) return;
      container.innerHTML = '';
      state.committedVeto.forEach((text, i) => {
          const phrase = document.createElement('div');
          phrase.className = 'committed-phrase veto-phrase';
          phrase.style.cssText = 'display:flex; align-items:center; background:rgba(255,100,100,0.15); border:1px solid rgba(255,100,100,0.3); padding:4px 8px; margin:4px 0; border-radius:4px; font-size:0.85em;';
          phrase.innerHTML = `
              <span style="color:var(--pink); flex:1;">${text}</span>
              <button class="game-veto-remove" data-index="${i}" title="Remove" aria-label="Remove veto" style="background:none; border:none; color:rgba(255,100,100,0.5); cursor:pointer; font-size:1em; padding:0 0 0 8px; line-height:1;">&times;</button>
          `;
          container.appendChild(phrase);
      });
      // Bind remove buttons
      container.querySelectorAll('.game-veto-remove').forEach(btn => {
          btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = parseInt(btn.dataset.index, 10);
              state.committedVeto.splice(idx, 1);
              rebuildVetoFromCommitted();
              renderGameVetoPills(container); // Re-render after removal
          });
      });
  }

  // Render quill pills in game modal (with remove buttons)
  function renderGameQuillPills(container) {
      if (!container || !state.committedQuill) return;
      container.innerHTML = '';
      state.committedQuill.forEach((text, i) => {
          const phrase = document.createElement('div');
          phrase.className = 'committed-phrase quill-phrase';
          phrase.style.cssText = 'display:flex; align-items:center; background:rgba(200,170,100,0.15); border:1px solid rgba(200,170,100,0.3); padding:4px 8px; margin:4px 0; border-radius:4px; font-size:0.85em;';
          phrase.innerHTML = `
              <span style="color:var(--gold); flex:1;">${text}</span>
              <button class="game-quill-remove" data-index="${i}" title="Remove" aria-label="Remove quill" style="background:none; border:none; color:rgba(200,170,100,0.5); cursor:pointer; font-size:1em; padding:0 0 0 8px; line-height:1;">&times;</button>
          `;
          container.appendChild(phrase);
      });
      // Bind remove buttons
      container.querySelectorAll('.game-quill-remove').forEach(btn => {
          btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const idx = parseInt(btn.dataset.index, 10);
              state.committedQuill.splice(idx, 1);
              // Sync quillIntent to most recent (or clear if none)
              state.quillIntent = state.committedQuill.length > 0 ? state.committedQuill[state.committedQuill.length - 1] : '';
              renderGameQuillPills(container); // Re-render after removal
          });
      });
  }

  // Rebuild veto state from committed phrases
  function rebuildVetoFromCommitted() {
      state.veto = state.veto || { bannedWords: [], tone: [] };
      state.veto.bannedWords = [];
      state.veto.tone = [];
      state.committedVeto.forEach(line => {
          const l = line.trim().toLowerCase();
          if (l.startsWith('ban:')) {
              state.veto.bannedWords.push(l.replace('ban:', '').trim());
          } else if (l.startsWith('no ') || l.startsWith('avoid ')) {
              state.veto.tone.push(line.trim());
          } else {
              state.veto.tone.push(line.trim());
          }
      });
  }

  $('btnCommitQuill')?.addEventListener('click', async (e) => {
      e.preventDefault(); // Prevent scroll to top
      e.stopPropagation();

      // Save scroll position before any DOM changes
      const scrollY = window.scrollY;
      const scrollX = window.scrollX;

      if (!getQuillReady()) return;
      const quillEl = document.getElementById('quillInput');
      if (!quillEl) return;
      const rawQuillText = quillEl.value.trim();
      if (!rawQuillText) { showToast("No Quill edit to commit."); return; }

      // RUNTIME NORMALIZATION: Quill input flows through ChatGPT normalization layer
      const quillNorm = await callNormalizationLayer({
          axis: 'quill',
          user_text: rawQuillText,
          context_signals: state.picks?.world || []
      });
      const quillText = quillNorm.canonical_instruction || quillNorm.normalized_text || rawQuillText;

      // Also apply any pending veto constraints
      await applyVetoFromInput();

      // Store quill intent in state for prompt injection
      window.state.quillIntent = quillText;

      // Add to committed phrases
      state.committedQuill.push(quillText);
      renderCommittedPhrases('quill');

      if (quillText) {
          const quillHtml = `<div class="quill-intervention" style="font-style:italic; color:var(--gold); border-left:2px solid var(--gold); padding-left:10px; margin:15px 0;">${formatStory(quillText, true)}</div>`;
          StoryPagination.appendToCurrentPage(quillHtml);
      }

      window.state.quillCommittedThisTurn = true;
      window.state.quill.uses++;
      window.state.quill.nextReadyAtWords = currentStoryWordCount() + computeNextCooldownWords();
      quillEl.value = '';
      updateQuillUI();
      saveStorySnapshot();
      showToast("Quill committed.");

      // Restore scroll position after all DOM changes
      requestAnimationFrame(() => {
          window.scrollTo(scrollX, scrollY);
      });
  });

  // Commit Veto Button Handler
  // TASK E: Store EXACT phrase, not normalized kernel
  $('btnCommitVeto')?.addEventListener('click', async () => {
      const vetoEl = document.getElementById('vetoInput');
      if (!vetoEl) return;
      const vetoText = vetoEl.value.trim();
      if (!vetoText) { showToast("No veto to commit."); return; }

      // TASK E: Store exact user phrase for display, normalize internally for rules
      const lines = vetoText.split('\n').filter(l => l.trim());
      for (const line of lines) {
          const rawPhrase = line.trim();
          // Store the EXACT phrase user entered (not normalized)
          if (!state.committedVeto.includes(rawPhrase)) {
              state.committedVeto.push(rawPhrase);
          }
      }
      renderCommittedPhrases('veto');

      await applyVetoFromInput();
      vetoEl.value = '';
      saveStorySnapshot();
      showToast(`Excluded: "${vetoText}"`);
  });

  // --- META SYSTEM (RESTORED) ---
  function buildMetaDirective(){
     if(state.awareness === 0) return "";
     if(Math.random() > state.metaChance) return "";
     const stance = META_DIRECTIVES[state.stance] || META_DIRECTIVES['aid'];
     const directive = stance[Math.floor(Math.random() * stance.length)];
     return `META-NARRATIVE INTERVENTION: ${directive}`;
  }

  window.setMetaStance = function(s){
      state.stance = s;
      document.querySelectorAll('.meta-stance').forEach(b => b.classList.remove('active'));
      const btn = document.querySelector(`.meta-stance[onclick="window.setMetaStance('${s}')"]`);
      if(btn) btn.classList.add('active');
  };

  // --- BEGIN STORY VALIDATION GUARDRAIL ---
  function validateBeginStory() {
      const errors = [];

      // Skip validation if Fate triggered (all values are pre-set correctly)
      if (state._fateTriggered) {
          return errors;
      }

      // Check archetype selection
      const archetypeValidation = validateArchetypeSelection(state.archetype.primary, state.archetype.modifier);
      if (!archetypeValidation.valid) {
          errors.push(archetypeValidation.errors[0] || 'Please select a Primary Archetype.');
      }

      // 4-axis validation: world, tone, genre, dynamic are required (single-select)
      if (!state.picks.world) {
          errors.push('Please select a Story World.');
      }

      if (!state.picks.tone) {
          errors.push('Please select a Story Tone.');
      }

      if (!state.picks.genre) {
          errors.push('Please select a Genre.');
      }

      if (!state.picks.dynamic) {
          errors.push('Please select a Relationship Dynamic.');
      }

      // Historical world requires era selection
      if (state.picks.world === 'Historical' && !state.picks.era) {
          errors.push('Please select a Historical Era.');
      }

      return errors;
  }

  // ========================================
  // LET FATE DECIDE - Auto-selection System
  // ========================================

  // Weighted random selection helper
  function weightedSelect(options, weights) {
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;
    for (let i = 0; i < options.length; i++) {
      random -= weights[i];
      if (random <= 0) return options[i];
    }
    return options[options.length - 1];
  }

  // Name lists for fate-generated names (IP-safe, non-famous)
  const FATE_FEMALE_NAMES = [
    'Elara Vance', 'Cassandra Wells', 'Mira Thornwood', 'Vivian Blake', 'Cordelia Hart',
    'Aurelia Stone', 'Seraphina Cole', 'Isadora Crane', 'Helena Frost', 'Rosalind Grey',
    'Celestine Moore', 'Evangeline Price', 'Lydia Sterling', 'Ophelia Dane', 'Tatiana West'
  ];

  const FATE_MALE_NAMES = [
    'Sebastian Blackwood', 'Julian Ashford', 'Marcus Thorne', 'Alexander Crane', 'Dominic Vale',
    'Lucian Grey', 'Theodore Sterling', 'Maximilian Drake', 'Gabriel Frost', 'Benedict Hale',
    'Damien Cross', 'Vincent Ashmore', 'Nathaniel Wolfe', 'Adrian Sinclair', 'Dorian Vance'
  ];

  // Module-level world flavors for fate selection (mirrors WORLD_SUB_OPTIONS structure)
  const FATE_WORLD_FLAVORS = {
    Modern: [
      { val: 'small_town' }, { val: 'college' }, { val: 'friends' },
      { val: 'old_money' }, { val: 'office' }
    ],
    Historical: [
      { val: 'medieval' }, { val: 'victorian' }, { val: 'renaissance' },
      { val: 'classical' }, { val: '20th_century' }
    ],
    Fantasy: [
      { val: 'enchanted_realms' }, { val: 'hidden_magic' }, { val: 'cursed_worlds' }
    ],
    SciFi: [
      { val: 'galactic_civilizations' }, { val: 'cyberpunk' }, { val: 'future_of_science' }
    ]
  };

  // Get entitlement-aware intensity selection
  function getFateIntensity() {
    // Prefer Erotic if entitled, else Naughty. Never Dirty.
    if (state.access === 'sub' || state.access === 'pass') {
      return 'Erotic';
    }
    return 'Naughty';
  }

  // Get entitlement-aware story length selection
  function getFateStoryLength() {
    // Prefer Affair/Soulmates if sub, else Fling if pass, else Tease
    if (state.access === 'sub') {
      // Weighted: prefer Affair (50%), Soulmates (50%)
      return Math.random() < 0.5 ? 'affair' : 'soulmates';
    } else if (state.access === 'pass') {
      return 'fling';
    }
    return 'tease';
  }

  // Get weighted world selection
  function getFateWorld() {
    // Prefer Modern > Historical > Fantasy > Sci-Fi
    const worlds = ['Modern', 'Historical', 'Fantasy', 'SciFi'];
    const weights = [40, 30, 20, 10]; // Heavy preference for Modern
    return weightedSelect(worlds, weights);
  }

  // Get weighted flavor for selected world
  function getFateFlavor(world) {
    if (typeof FATE_WORLD_FLAVORS === 'undefined' || !FATE_WORLD_FLAVORS) return null;
    const flavors = FATE_WORLD_FLAVORS[world];
    if (!flavors || flavors.length === 0) return null;
    // Bias toward first (broader) options
    const weights = flavors.map((_, i) => Math.max(10 - i * 2, 1));
    const selected = weightedSelect(flavors, weights);
    return selected.val;
  }

  // Get weighted tone selection
  function getFateTone() {
    // Prefer Earnest, WryConfession, Poetic
    const tones = ['Earnest', 'WryConfession', 'Poetic', 'Mythic', 'Comedic'];
    const weights = [40, 30, 20, 5, 5];
    return weightedSelect(tones, weights);
  }

  // Get weighted genre selection (context-aware for Modern)
  function getFateGenre(world) {
    if (world === 'Modern') {
      // Prefer Billionaire, SmallTown, FamousNotorious, CollegeEarlyCareer for Modern
      // Note: Some of these may be World flavors, using available genres
      const genres = ['Billionaire', 'Noir', 'Political', 'Heist'];
      const weights = [50, 20, 15, 15];
      return weightedSelect(genres, weights);
    }
    // Default genres for other worlds
    const genres = ['Billionaire', 'CrimeSyndicate', 'Espionage', 'Political'];
    const weights = [40, 25, 20, 15];
    return weightedSelect(genres, weights);
  }

  // Get weighted dynamic selection
  function getFateDynamic() {
    // Prefer Friends to Lovers, Forbidden Love, Fated
    const dynamics = ['Friends', 'Forbidden', 'Fated', 'Enemies', 'SecondChance'];
    const weights = [35, 30, 25, 5, 5];
    return weightedSelect(dynamics, weights);
  }

  // Get POV selection (prefer 1st person)
  function getFatePOV() {
    // Prefer First (1st person "I"), fall back if needed
    return 'First';
  }

  // Get weighted archetype selection (canonical 7)
  function getFateArchetype() {
    // Weighted toward emotionally accessible archetypes for default romance experience
    // Legacy mapping: ROMANTICâ†’OPEN_VEIN, DEVOTEDâ†’ETERNAL_FLAME,
    //   ENCHANTINGâ†’SPELLBINDER, GUARDIANâ†’HEART_WARDEN
    const archetypes = ['OPEN_VEIN', 'ETERNAL_FLAME', 'SPELLBINDER', 'HEART_WARDEN', 'ARMORED_FOX'];
    const weights = [30, 25, 20, 15, 10];
    return weightedSelect(archetypes, weights);
  }

  // PASS 9D: Generate fate ages with 95% within Â±10 years, 5% edge cases
  function getFateAges() {
    // Base age for player character (22-35 typical range)
    const playerAge = 22 + Math.floor(Math.random() * 14); // 22-35

    // 95% of the time: partner age within Â±10 years
    // 5% of the time: allow larger gaps (edge cases)
    const isEdgeCase = Math.random() < 0.05;

    let partnerAge;
    if (isEdgeCase) {
      // Edge case: wider range (18-60)
      partnerAge = 18 + Math.floor(Math.random() * 43);
    } else {
      // Normal case: within Â±10 years of player, clamped to 18-60
      const offset = Math.floor(Math.random() * 21) - 10; // -10 to +10
      partnerAge = Math.max(18, Math.min(60, playerAge + offset));
    }

    return { playerAge, partnerAge };
  }

  // =================================================================
  // GUIDED FATE CHOREOGRAPHY ENGINE (AUTHORITATIVE)
  // Controls tempo, direction, and order of Fate's reveal.
  // ONE DIRECTION (down), ONE SECTION AT A TIME, HUMAN PACE
  // =================================================================

  // Fate override flag - when true, all automated motion stops
  let _fateOverridden = false;
  let _fateRunning = false;
  let _guidedFateVisualsActive = false;

  // DSP clause reveal tracking â€” non-null only during Guided Fate ceremony
  let _revealedDSPAxes = null;

  function revealDSPClause(axis) {
    if (!_revealedDSPAxes) return;
    _revealedDSPAxes.add(axis);
    const synopsisText = document.getElementById('synopsisText');
    if (!synopsisText) return;

    // SPARSE RENDERING: Regenerate sentence with only revealed axes
    // NO pending clauses, NO greyed text â€” just the revealed portions
    const result = generateDSPSentence();
    if (result.success) {
      const newHtml = result.html;

      // GUARD: Do not clear DSP if result is empty (world not yet revealed)
      // Keep placeholder or previous content until we have actual sentence content
      if (!newHtml || newHtml.trim() === '') return;

      // Increment activation for Guided Fate reveals
      incrementDSPActivation();

      // Only update DOM if content changed
      if (synopsisText._lastDSP !== newHtml) {
        synopsisText._lastDSP = newHtml;
        synopsisText.innerHTML = newHtml;

        // Brief golden glow on the newly revealed clause
        synopsisText.querySelectorAll('.dsp-clause[data-axis="' + axis + '"]').forEach(span => {
          span.classList.add('dsp-glow');
          setTimeout(() => span.classList.remove('dsp-glow'), 550);
        });
      }
    }
  }

  // Timing constants (HUMAN PACE - deliberate, not efficient)
  const FATE_TIMING = {
    SCROLL_SETTLE: 500,      // 400-600ms after scroll
    CARD_FLIP: 350,          // 300-400ms card flip animation
    TYPING_PER_CHAR: 65,     // 50-80ms per character
    SECTION_PAUSE: 700,      // 500-800ms between sections
    HIGHLIGHT_SETTLE: 400,   // Time before clearing highlight
    // MINIMUM TIMING GUARANTEES (authoritative)
    MIN_NAMES_CEREMONY: 5000,   // Names ceremony must be â‰¥5 seconds
    MIN_ARCHETYPE_REVEAL: 4000, // Archetype section must be â‰¥4 seconds
    MIN_INTENSITY_REVEAL: 4000  // Intensity section must be â‰¥4 seconds
  };

  // =================================================================
  // FAIRY DUST PARTICLE SYSTEM
  // Sparse, ethereal gold specks during Guided Fate ceremony
  // =================================================================

  let _dustInterval = null;
  let _sparkleIntervals = [];
  let _ambientCardInterval = null;
  let _anchoredParticles = []; // Track particles with owner elements for scroll sync
  let _sparkleScrollListener = null;
  let _sparkleInitialScrollY = 0;
  const DUST_CONFIG = {
    MAX_PARTICLES: 350,       // Dense vignette sparkles (3Ã— visibility)
    SPAWN_INTERVAL: 15,       // Fast spawn for density
    MIN_SIZE: 3,              // Small, delicate
    MAX_SIZE: 9,
    MIN_DURATION: 5000,       // Long gentle drift
    MAX_DURATION: 10000,
    MIN_OPACITY: 0.5,         // Clearly visible
    MAX_OPACITY: 0.9
  };

  // Anchored particle position sync â€” scroll-offset tracking (no per-tick getBoundingClientRect)
  function registerAnchoredParticle(particle, ownerEl, relX, relY, initialLeft, initialTop) {
    // Store initial positions and scroll offset
    const entry = {
      particle,
      ownerEl,
      relX,
      relY,
      initialLeft,
      initialTop,
      initialScrollY: window.scrollY
    };
    _anchoredParticles.push(entry);
    if (!_sparkleScrollListener) startSparkleScrollSync();
  }

  function startSparkleScrollSync() {
    _sparkleInitialScrollY = window.scrollY;
    _sparkleScrollListener = function() {
      // Prune dead particles
      _anchoredParticles = _anchoredParticles.filter(p => p.particle.parentNode && p.ownerEl.offsetParent);
      if (_anchoredParticles.length === 0) {
        stopSparkleScrollSync();
        return;
      }
      // Update positions using scroll delta (no getBoundingClientRect)
      for (const p of _anchoredParticles) {
        const scrollDelta = window.scrollY - p.initialScrollY;
        p.particle.style.top = (p.initialTop + p.relY - scrollDelta) + 'px';
        // X remains unchanged (no horizontal scroll tracking needed)
      }
    };
    window.addEventListener('scroll', _sparkleScrollListener, { passive: true });
  }

  function stopSparkleScrollSync() {
    if (_sparkleScrollListener) {
      window.removeEventListener('scroll', _sparkleScrollListener);
      _sparkleScrollListener = null;
    }
    _anchoredParticles = [];
  }

  // Global overlay for anchored sparkles (fixed positioning, updated per-frame)
  // z-index: 2500 â€” below modals (3000+) but above page content
  function getSparkleOverlay() {
    let overlay = document.getElementById('sparkleAnchorOverlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'sparkleAnchorOverlay';
      overlay.style.cssText = 'position:fixed;inset:0;pointer-events:none;z-index:2500;overflow:visible;';
      document.body.appendChild(overlay);
    }
    return overlay;
  }

  // DEV ASSERTION: Fate card sparkles must be DOM descendants of the Fate card
  // Validates invariant: sparkles appended to .fate-destiny-card subtree only
  function assertFateSparkleOwnership(particle, tag) {
    if (!particle) return;
    const fateCard = particle.closest('.fate-destiny-card');
    if (!fateCard) {
      console.error('[DEV] INVARIANT VIOLATION: Fate sparkle (tag=' + tag + ') is not a DOM descendant of .fate-destiny-card. Parent:', particle.parentElement);
    }
  }

  function spawnDustParticle() {
    if (!_guidedFateVisualsActive) return;

    // Limit particle count (vignette particles only â€” tag 'vignette')
    const existing = document.querySelectorAll('.fate-dust-particle[data-sparkle-tag="vignette"]');
    if (existing.length >= DUST_CONFIG.MAX_PARTICLES) return;

    const particle = document.createElement('div');
    particle.className = 'fate-dust-particle fate-dust-particle--viewport';
    particle.dataset.sparkleTag = 'vignette';

    // Viewport-based positioning weighted toward vignette edges
    const edge = Math.random();
    let x, y;
    if (edge < 0.35) {
      x = Math.random() * 15;
      y = 5 + Math.random() * 90;
    } else if (edge < 0.65) {
      x = 85 + Math.random() * 15;
      y = 5 + Math.random() * 90;
    } else if (edge < 0.80) {
      x = 5 + Math.random() * 90;
      y = 80 + Math.random() * 18;
    } else if (edge < 0.90) {
      x = 10 + Math.random() * 80;
      y = Math.random() * 15;
    } else {
      x = 25 + Math.random() * 50;
      y = 25 + Math.random() * 50;
    }

    // Randomize properties
    const size = DUST_CONFIG.MIN_SIZE + Math.random() * (DUST_CONFIG.MAX_SIZE - DUST_CONFIG.MIN_SIZE);
    const duration = DUST_CONFIG.MIN_DURATION + Math.random() * (DUST_CONFIG.MAX_DURATION - DUST_CONFIG.MIN_DURATION);
    const opacity = DUST_CONFIG.MIN_OPACITY + Math.random() * (DUST_CONFIG.MAX_OPACITY - DUST_CONFIG.MIN_OPACITY);

    // Slow, gentle drift with slight swirl
    const baseAngle = Math.random() * Math.PI * 2;
    const driftDistance = 20 + Math.random() * 40;
    const dx = Math.cos(baseAngle) * driftDistance;
    const dy = -30 - Math.random() * 50;

    particle.style.cssText = `
      left: ${x}vw;
      top: ${y}vh;
      width: ${size}px;
      height: ${size}px;
      --dust-duration: ${duration}ms;
      --dust-opacity: ${opacity};
      --dust-dx: ${dx}px;
      --dust-dy: ${dy}px;
    `;

    document.body.appendChild(particle);

    // Self-cleanup after animation
    setTimeout(() => {
      if (particle.parentNode) {
        particle.remove();
      }
    }, duration + 100);
  }

  function startFairyDust() {
    stopFairyDust(); // Clear any existing
    _dustInterval = setInterval(spawnDustParticle, DUST_CONFIG.SPAWN_INTERVAL);
    // Gentle initial burst
    for (let i = 0; i < 15; i++) {
      setTimeout(spawnDustParticle, i * 20);
    }
  }

  function stopFairyDust() {
    if (_dustInterval) {
      clearInterval(_dustInterval);
      _dustInterval = null;
    }
    // Clear all sparkle intervals
    _sparkleIntervals.forEach(id => clearInterval(id));
    _sparkleIntervals = [];
    // Stop anchored particle tracking
    stopSparkleScrollSync();
    // Fade out existing particles gracefully
    document.querySelectorAll('.fate-dust-particle').forEach(p => {
      p.style.opacity = '0';
      p.style.transition = 'opacity 0.4s ease-out';
      setTimeout(() => p.remove(), 500);
    });
  }

  // Get or create sparkle anchor container inside an element
  // Container uses position: absolute with inset: 0 and overflow: visible
  // so sparkles can appear on the perimeter (outside element bounds)
  function getOrCreateSparkleContainer(element) {
    if (!element) return null;
    // Ensure parent is positioned so absolute children work correctly
    const computedStyle = window.getComputedStyle(element);
    if (computedStyle.position === 'static') {
      element.style.position = 'relative';
    }
    // Check for existing container
    let container = element.querySelector(':scope > .sparkle-anchor-container');
    if (!container) {
      container = document.createElement('div');
      container.className = 'sparkle-anchor-container';
      element.appendChild(container);
    }
    return container;
  }

  // Ambient pre-click sparkle emitter for the Guided Fate card
  // Uses getBoundingClientRect for true scroll-synced positioning
  function spawnAmbientCardSparkle() {
    const fateCard = document.getElementById('fateDestinyCard');
    if (!fateCard || fateCard.dataset.fateUsed === 'true') return;
    if (!fateCard.offsetParent) return; // not visible

    const overlay = getSparkleOverlay();
    const existing = overlay.querySelectorAll('.fate-dust-particle[data-sparkle-owner="ambient-fateCard"]');
    if (existing.length >= 90) return;

    const rect = fateCard.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    if (width === 0 || height === 0) return;

    const particle = document.createElement('div');
    particle.className = 'fate-dust-particle fate-dust-particle--anchored';
    particle.dataset.sparkleTag = 'ambient';
    particle.dataset.sparkleOwner = 'ambient-fateCard';

    // Spawn on outer perimeter Â±14-22px outside card edges (element-relative)
    const side = Math.random();
    const offset = 14 + Math.random() * 8;
    let relX, relY;
    if (side < 0.25) { relX = Math.random() * width; relY = -offset; }
    else if (side < 0.5) { relX = Math.random() * width; relY = height + offset; }
    else if (side < 0.75) { relX = -offset; relY = Math.random() * height; }
    else { relX = width + offset; relY = Math.random() * height; }

    const size = 2 + Math.random() * 5;
    const duration = 3000 + Math.random() * 4000;
    const opacity = 0.5 + Math.random() * 0.4;

    // Slow orbit / drift outward from element center
    const cx = width / 2;
    const cy = height / 2;
    const outAngle = Math.atan2(relY - cy, relX - cx);
    const dx = Math.cos(outAngle) * (10 + Math.random() * 20);
    const dy = Math.sin(outAngle) * (10 + Math.random() * 20) - 10;

    particle.style.cssText = `
      position: fixed;
      left: ${rect.left + relX}px; top: ${rect.top + relY}px;
      width: ${size}px; height: ${size}px;
      --dust-duration: ${duration}ms;
      --dust-opacity: ${opacity};
      --dust-dx: ${dx}px; --dust-dy: ${dy}px;
    `;
    overlay.appendChild(particle);
    registerAnchoredParticle(particle, fateCard, relX, relY, rect.left, rect.top);
    setTimeout(() => { if (particle.parentNode) particle.remove(); }, duration + 100);
  }

  function startAmbientCardSparkles() {
    stopAmbientCardSparkles();
    _ambientCardInterval = setInterval(spawnAmbientCardSparkle, 40);
    // Immediate burst
    for (let i = 0; i < 20; i++) {
      setTimeout(spawnAmbientCardSparkle, i * 20);
    }
  }

  function stopAmbientCardSparkles() {
    if (_ambientCardInterval) {
      clearInterval(_ambientCardInterval);
      _ambientCardInterval = null;
    }
    document.querySelectorAll('.fate-dust-particle[data-sparkle-tag="ambient"]').forEach(p => {
      p.style.opacity = '0';
      p.style.transition = 'opacity 0.4s ease-out';
      setTimeout(() => p.remove(), 500);
    });
  }

  // Anchor-aware sparkle spawner â€” particles track owner element via rAF
  // Uses getBoundingClientRect for true scroll-synced positioning
  function startFateEdgeSparkles({ anchorEl, anchorRect, maxParticles, spawnInterval, tag }) {
    if (!anchorEl) return;
    maxParticles = maxParticles || DUST_CONFIG.MAX_PARTICLES;
    spawnInterval = spawnInterval || DUST_CONFIG.SPAWN_INTERVAL;
    tag = tag || 'card';

    const overlay = getSparkleOverlay();

    const checkWidth = anchorEl.offsetWidth;
    const checkHeight = anchorEl.offsetHeight;
    if (checkWidth === 0 || checkHeight === 0) {
      console.warn('[DEV] startFateEdgeSparkles: anchor has zero dimensions â€” aborting');
      return;
    }

    function spawn() {
      if (!_guidedFateVisualsActive) return;
      if (!anchorEl.offsetParent) return; // owner removed from DOM

      const existing = overlay.querySelectorAll('.fate-dust-particle[data-sparkle-owner="' + tag + '-' + (anchorEl.id || 'anon') + '"]');
      if (existing.length >= maxParticles) return;

      const rect = anchorEl.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      if (width === 0 || height === 0) return;

      const particle = document.createElement('div');
      particle.className = 'fate-dust-particle fate-dust-particle--anchored';
      particle.dataset.sparkleTag = tag;
      particle.dataset.sparkleOwner = tag + '-' + (anchorEl.id || 'anon');

      // Spawn on outer perimeter â€” offset Â±12-20px outside element edges (element-relative)
      const OFFSET_MIN = 12;
      const OFFSET_MAX = 20;
      const perimeterSide = Math.random();
      let relX, relY;
      const offset = OFFSET_MIN + Math.random() * (OFFSET_MAX - OFFSET_MIN);
      if (perimeterSide < 0.25) {
        // Top edge
        relX = Math.random() * width;
        relY = -offset;
      } else if (perimeterSide < 0.5) {
        // Bottom edge
        relX = Math.random() * width;
        relY = height + offset;
      } else if (perimeterSide < 0.75) {
        // Left edge
        relX = -offset;
        relY = Math.random() * height;
      } else {
        // Right edge
        relX = width + offset;
        relY = Math.random() * height;
      }

      const size = DUST_CONFIG.MIN_SIZE + Math.random() * (DUST_CONFIG.MAX_SIZE - DUST_CONFIG.MIN_SIZE);
      const duration = DUST_CONFIG.MIN_DURATION + Math.random() * (DUST_CONFIG.MAX_DURATION - DUST_CONFIG.MIN_DURATION);
      const opacity = DUST_CONFIG.MIN_OPACITY + Math.random() * (DUST_CONFIG.MAX_OPACITY - DUST_CONFIG.MIN_OPACITY);

      // Drift outward from element center
      const cx = width / 2;
      const cy = height / 2;
      const outAngle = Math.atan2(relY - cy, relX - cx);
      const driftDistance = 15 + Math.random() * 30;
      const dx = Math.cos(outAngle) * driftDistance;
      const dy = Math.sin(outAngle) * driftDistance - 15;

      particle.style.cssText = `
        position: fixed;
        left: ${rect.left + relX}px;
        top: ${rect.top + relY}px;
        width: ${size}px;
        height: ${size}px;
        --dust-duration: ${duration}ms;
        --dust-opacity: ${opacity};
        --dust-dx: ${dx}px;
        --dust-dy: ${dy}px;
      `;

      overlay.appendChild(particle);
      registerAnchoredParticle(particle, anchorEl, relX, relY, rect.left, rect.top);
      setTimeout(() => { if (particle.parentNode) particle.remove(); }, duration + 100);
    }

    const intervalId = setInterval(spawn, spawnInterval);
    _sparkleIntervals.push(intervalId);

    // Gentle initial burst
    const burstCount = Math.min(5, maxParticles);
    for (let i = 0; i < burstCount; i++) {
      setTimeout(spawn, i * 80);
    }
  }

  // Scroll handler for sparkle fade-out â€” prevents sparkles drifting from cards
  let _sparkleScrollHandler = null;
  let _sparkleScrollFading = false;
  let _isAutoScrolling = false;

  // Debounce timer for card/input sparkle reappearance (3000ms)
  let _sparkleReappearTimer = null;
  const SPARKLE_REAPPEAR_DELAY = 3000;

  // Dissipate card/input sparkles (NOT vignette) on scroll/resize
  function dissipateAnchoredSparkles() {
      // Stop all sparkle spawn intervals (prevents immediate respawn)
      _sparkleIntervals.forEach(id => clearInterval(id));
      _sparkleIntervals = [];
      // Fade out anchored sparkles (card + input)
      document.querySelectorAll('.fate-dust-particle--anchored').forEach(p => {
          p.style.transition = 'opacity 200ms ease-out';
          p.style.opacity = '0';
      });
      // Remove after fade
      setTimeout(() => {
          document.querySelectorAll('.fate-dust-particle--anchored').forEach(p => p.remove());
      }, 250);
      // Clear anchored particle tracking
      _anchoredParticles = [];
  }

  // Recreate card/input sparkles at current element positions
  // GUARD: Only called from debounce timer completion
  function recreateAnchoredSparkles() {
      if (!_guidedFateVisualsActive) return;

      // Recreate Fate Card sparkles
      const fateCard = document.getElementById('fateDestinyCard');
      if (fateCard && fateCard.offsetParent) {
          const cardRect = fateCard.getBoundingClientRect();
          if (cardRect.width > 0 && cardRect.height > 0) {
              startFateEdgeSparkles({ anchorEl: fateCard, anchorRect: cardRect, maxParticles: 120, spawnInterval: 25, tag: 'card' });
          }
      }

      // Recreate input sparkles
      const playerInput = document.getElementById('playerNameInput');
      const partnerInput = document.getElementById('partnerNameInput');
      if (playerInput && playerInput.offsetParent) {
          startFateEdgeSparkles({ anchorEl: playerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }
      if (partnerInput && partnerInput.offsetParent) {
          startFateEdgeSparkles({ anchorEl: partnerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }
  }

  // Shared scroll/resize handler â€” dissipate and debounce reappear
  function handleSparkleScrollResize() {
      // GUARD: Only during Guided Fate
      if (!_guidedFateVisualsActive) return;

      // Immediately dissipate card/input sparkles
      dissipateAnchoredSparkles();

      // Clear existing timer and restart 3000ms debounce
      if (_sparkleReappearTimer) {
          clearTimeout(_sparkleReappearTimer);
      }
      _sparkleReappearTimer = setTimeout(() => {
          _sparkleReappearTimer = null;
          recreateAnchoredSparkles();
      }, SPARKLE_REAPPEAR_DELAY);
  }

  function handleSparkleScroll() {
      // GUARD: Never teardown vignette during Guided Fate â€” ONLY on explicit exit
      if (_guidedFateVisualsActive || _sparkleScrollFading) return;
      _sparkleScrollFading = true;

      // Only fade out viewport-based (vignette) sparkles â€” anchored sparkles move with their parent
      document.querySelectorAll('.fate-dust-particle--viewport').forEach(p => {
          p.style.transition = 'opacity 250ms ease-out';
          p.style.opacity = '0';
      });

      // Stop vignette emitter only â€” anchored emitters keep running
      if (_dustInterval) {
          clearInterval(_dustInterval);
          _dustInterval = null;
      }

      // Cleanup viewport particles after fade completes
      setTimeout(() => {
          document.querySelectorAll('.fate-dust-particle--viewport').forEach(p => p.remove());
      }, 300);
  }

  // Activate Guided Fate visuals â€” requires actual Guided Fate card DOM node
  function activateGuidedFateVisuals(fateCardElement) {
      if (!fateCardElement) return;
      _guidedFateVisualsActive = true;
      _sparkleScrollFading = false;

      // Vignette
      const vignette = document.getElementById('fateVignette');
      if (vignette) vignette.classList.add('active');

      // Stop ambient pre-click sparkles â€” replaced by activated sparkles
      stopAmbientCardSparkles();

      // Global vignette sparkles (viewport-based, coexist with anchored)
      startFairyDust();

      // Card glow
      fateCardElement.classList.add('fate-activating');

      // Anchored sparkles from Guided Fate card outer perimeter (intensified)
      const anchorRect = fateCardElement.getBoundingClientRect();
      if (anchorRect.width === 0 || anchorRect.height === 0) {
          console.warn('[DEV] Guided Fate card has zero rect â€” sparkles aborted');
      } else {
          startFateEdgeSparkles({ anchorEl: fateCardElement, anchorRect: anchorRect, maxParticles: 120, spawnInterval: 25, tag: 'card' });
      }

      // Say/Do input glow + secondary low-density sparkles (3 particles max shared)
      const playerInput = document.getElementById('playerNameInput');
      const partnerInput = document.getElementById('partnerNameInput');
      if (playerInput) {
          playerInput.classList.add('guided-fate-glow');
          startFateEdgeSparkles({ anchorEl: playerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }
      if (partnerInput) {
          partnerInput.classList.add('guided-fate-glow');
          startFateEdgeSparkles({ anchorEl: partnerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }

      // SCROLL FADE-OUT: Add scroll listener to fade sparkles on scroll
      if (_sparkleScrollHandler) {
          window.removeEventListener('scroll', _sparkleScrollHandler, true);
      }
      _sparkleScrollHandler = handleSparkleScroll;
      window.addEventListener('scroll', _sparkleScrollHandler, true); // capture phase for all scrollable containers

      // DISSIPATE-AND-REAPPEAR: Add listeners for card/input sparkle repositioning
      window.addEventListener('scroll', handleSparkleScrollResize, { passive: true });
      window.addEventListener('resize', handleSparkleScrollResize, { passive: true });
  }

  // Deactivate Guided Fate visuals â€” idempotent, no guards
  function deactivateGuidedFateVisuals() {
      _guidedFateVisualsActive = false;
      _sparkleScrollFading = false;

      // Remove scroll listener
      if (_sparkleScrollHandler) {
          window.removeEventListener('scroll', _sparkleScrollHandler, true);
          _sparkleScrollHandler = null;
      }

      // Remove dissipate-and-reappear listeners
      window.removeEventListener('scroll', handleSparkleScrollResize);
      window.removeEventListener('resize', handleSparkleScrollResize);
      if (_sparkleReappearTimer) {
          clearTimeout(_sparkleReappearTimer);
          _sparkleReappearTimer = null;
      }

      // Clear all sparkle intervals and DOM particles
      stopFairyDust();

      // Shut off vignette
      const vignette = document.getElementById('fateVignette');
      if (vignette) {
          vignette.style.opacity = '';
          vignette.classList.remove('active');
          vignette.classList.add('fading');
          setTimeout(() => vignette.classList.remove('fading'), 1600);
      }

      // Remove glow from Guided Fate card
      const fateCard = document.getElementById('fateDestinyCard');
      if (fateCard) fateCard.classList.remove('fate-activating');

      // Remove golden echo from downstream inputs
      document.querySelectorAll('.guided-fate-glow').forEach(el => el.classList.remove('guided-fate-glow'));
  }

  // In-story selection aura â€” reusable golden glow + low-density sparkles
  let _auraSparkleIntervals = [];

  function applySelectionAura(el) {
      if (!el) return;
      el.classList.add('selection-aura');
      const width = el.offsetWidth;
      const height = el.offsetHeight;
      if (width === 0 || height === 0) return;

      const overlay = getSparkleOverlay();
      const ownerId = 'aura-' + (el.id || Math.random().toString(36).slice(2, 8));

      // Low-density sparkles from element perimeter (element-relative)
      const OFFSET_MIN = 8;
      const OFFSET_MAX = 14;
      function spawnAuraSparkle() {
          if (!el.offsetParent) return; // owner removed
          const existing = overlay.querySelectorAll('.fate-dust-particle[data-sparkle-owner="' + ownerId + '"]');
          if (existing.length >= 4) return;

          const rect = el.getBoundingClientRect();
          const w = rect.width;
          const h = rect.height;
          if (w === 0 || h === 0) return;

          const particle = document.createElement('div');
          particle.className = 'fate-dust-particle fate-dust-particle--anchored';
          particle.dataset.sparkleTag = 'aura';
          particle.dataset.sparkleOwner = ownerId;

          const side = Math.random();
          const offset = OFFSET_MIN + Math.random() * (OFFSET_MAX - OFFSET_MIN);
          let relX, relY;
          if (side < 0.25) { relX = Math.random() * w; relY = -offset; }
          else if (side < 0.5) { relX = Math.random() * w; relY = h + offset; }
          else if (side < 0.75) { relX = -offset; relY = Math.random() * h; }
          else { relX = w + offset; relY = Math.random() * h; }

          const size = 2 + Math.random() * 4;
          const duration = 3000 + Math.random() * 3000;
          const opacity = 0.15 + Math.random() * 0.3;
          const cx = w / 2;
          const cy = h / 2;
          const angle = Math.atan2(relY - cy, relX - cx);
          const dx = Math.cos(angle) * (10 + Math.random() * 15);
          const dy = Math.sin(angle) * (10 + Math.random() * 15) - 10;

          particle.style.cssText = `
            position: fixed;
            left: ${rect.left + relX}px; top: ${rect.top + relY}px;
            width: ${size}px; height: ${size}px;
            --dust-duration: ${duration}ms;
            --dust-opacity: ${opacity};
            --dust-dx: ${dx}px; --dust-dy: ${dy}px;
          `;
          overlay.appendChild(particle);
          registerAnchoredParticle(particle, el, relX, relY, rect.left, rect.top);
          setTimeout(() => { if (particle.parentNode) particle.remove(); }, duration + 100);
      }

      const intervalId = setInterval(spawnAuraSparkle, 900);
      _auraSparkleIntervals.push(intervalId);
      spawnAuraSparkle(); // immediate first particle
  }

  function removeSelectionAura(el) {
      if (el) el.classList.remove('selection-aura');
  }

  function removeAllSelectionAuras() {
      document.querySelectorAll('.selection-aura').forEach(el => el.classList.remove('selection-aura'));
      _auraSparkleIntervals.forEach(id => clearInterval(id));
      _auraSparkleIntervals = [];
      document.querySelectorAll('.fate-dust-particle[data-sparkle-tag="aura"]').forEach(p => {
          p.style.opacity = '0';
          p.style.transition = 'opacity 0.3s ease-out';
          setTimeout(() => p.remove(), 400);
      });
  }

  // Expose for fatecards.js
  window.applySelectionAura = applySelectionAura;
  window.removeSelectionAura = removeSelectionAura;
  window.removeAllSelectionAuras = removeAllSelectionAuras;

  function cleanupFateVisuals() {
    // Stop fate running state
    _fateOverridden = true;
    _fateRunning = false;
    _dspGuidedFateActive = false;

    // Clear DSP pending state â€” reveal all clauses immediately on override
    _revealedDSPAxes = null;
    const synopsisText = document.getElementById('synopsisText');
    if (synopsisText) {
      synopsisText.querySelectorAll('.dsp-pending').forEach(span => {
        span.classList.remove('dsp-pending');
      });
    }

    // Stop fairy dust
    stopFairyDust();

    // Remove golden vignette
    const vignette = document.getElementById('fateVignette');
    if (vignette) {
      vignette.style.opacity = ''; // BUGFIX: Clear inline opacity set during ceremony BEFORE fading
      vignette.classList.remove('active');
      vignette.classList.add('fading');
      // Fully hide after fade animation completes
      setTimeout(() => {
        vignette.classList.remove('fading');
      }, 500);
    }

    // Clear all fate highlights
    document.querySelectorAll('.fate-active').forEach(el => el.classList.remove('fate-active'));
    document.querySelectorAll('.fate-typing').forEach(el => el.classList.remove('fate-typing'));
    document.querySelectorAll('.fate-ceremony').forEach(el => el.classList.remove('fate-ceremony'));
  }

  // Override handler - user takes control from Fate
  // Always deactivates Guided Fate visuals on any user interaction
  function handleFateOverride(event) {
    // Guard: do not self-cancel when the interaction originates from the Guided Fate card
    const fateCard = document.getElementById('fateDestinyCard');
    if (fateCard && fateCard.contains(event.target)) return;

    // Unconditional visual shutdown on any user action
    deactivateGuidedFateVisuals();

    if (_fateRunning && !_fateOverridden) {
      _fateOverridden = true;
      // Clear all fate highlights immediately
      document.querySelectorAll('.fate-active').forEach(el => el.classList.remove('fate-active'));
      document.querySelectorAll('.fate-typing').forEach(el => el.classList.remove('fate-typing'));
      document.querySelectorAll('.fate-ceremony').forEach(el => el.classList.remove('fate-ceremony'));

      // Stop fairy dust particles
      stopFairyDust();

      // Fade the golden vignette (pulse stops via CSS animation: none)
      const vignette = document.getElementById('fateVignette');
      if (vignette) {
        vignette.style.opacity = ''; // BUGFIX: Clear inline opacity set during ceremony
        vignette.classList.remove('active');
        vignette.classList.add('fading');
      }

      showToast('You take the reins from Fate.');
    }
  }

  // Setup override listeners
  function setupFateOverrideListeners() {
    const setupArea = document.getElementById('setup');
    if (!setupArea) return;

    // Listen for user interaction that indicates override
    const overrideEvents = ['click', 'keydown', 'input', 'change'];
    overrideEvents.forEach(evt => {
      setupArea.addEventListener(evt, handleFateOverride, { capture: true, passive: true });
    });

    // Scroll override (manual scroll detection)
    let lastScrollTop = window.scrollY;
    const scrollHandler = () => {
      if (_fateRunning && !_fateOverridden) {
        const currentScroll = window.scrollY;
        // If user scrolled up (against fate direction), override
        if (currentScroll < lastScrollTop - 50) {
          handleFateOverride();
        }
        lastScrollTop = currentScroll;
      }
    };
    window.addEventListener('scroll', scrollHandler, { passive: true });
  }

  // Clear all fate highlights (ensure clean state before next section)
  function clearAllFateHighlights() {
    document.querySelectorAll('.fate-active').forEach(el => el.classList.remove('fate-active'));
  }

  // Helper: Scroll element into view (DOWNWARD ONLY - NEVER UPWARD)
  // AUTHORITATIVE: This constraint is absolute. No upward scrolling can occur.
  // Combined with visual Y-position sorting, guarantees strict topâ†’bottom flow.
  function scrollToSectionDownward(el) {
    if (!el || _fateOverridden) return;

    const rect = el.getBoundingClientRect();
    const currentScroll = window.scrollY;
    const targetScroll = currentScroll + rect.top - 120; // 120px from top

    // ABSOLUTE CONSTRAINT: Only scroll if target is BELOW current position
    // If targetScroll <= currentScroll, NO SCROLL OCCURS (element already visible or above)
    if (targetScroll > currentScroll) {
      _isAutoScrolling = true;
      // Explicitly trigger sparkle dissipate before programmatic scroll
      if (typeof handleSparkleScrollResize === 'function') handleSparkleScrollResize();
      window.scrollTo({ top: targetScroll, behavior: 'smooth' });
      setTimeout(() => { _isAutoScrolling = false; }, 600);
    }
  }

  // Helper: Type text letter-by-letter with gold glow effect (SLOWED)
  async function typeTextWithGlow(inputEl, text, delayPerChar = FATE_TIMING.TYPING_PER_CHAR) {
    if (!inputEl || !text || _fateOverridden) return;

    inputEl.value = '';
    inputEl.classList.add('fate-typing');
    inputEl.classList.remove('fate-typed');

    for (let i = 0; i < text.length; i++) {
      if (_fateOverridden) break; // Check override each character
      inputEl.value += text[i];
      await new Promise(r => setTimeout(r, delayPerChar));
    }

    // Settle the glow
    inputEl.classList.remove('fate-typing');
    if (!_fateOverridden) {
      inputEl.classList.add('fate-typed');
      setTimeout(() => inputEl.classList.remove('fate-typed'), 800);
    }
  }

  // Helper: Flip a card with reveal animation (SLOWED)
  async function flipCardForFate(cardEl) {
    if (!cardEl || _fateOverridden) return;

    cardEl.classList.add('fate-revealing');

    // Card flip animation
    await new Promise(r => setTimeout(r, FATE_TIMING.CARD_FLIP));
    if (_fateOverridden) return;

    cardEl.classList.add('selected', 'flipped');

    // Settle after flip
    await new Promise(r => setTimeout(r, FATE_TIMING.CARD_FLIP));
    cardEl.classList.remove('fate-revealing');
  }

  // Helper: Atomic section reveal for card grids
  // gridOrSelector can be a CSS selector string OR an element reference
  async function revealCardSection(gridOrSelector, value, sectionTitleEl) {
    if (_fateOverridden) return false;

    const grid = typeof gridOrSelector === 'string'
      ? document.querySelector(gridOrSelector)
      : gridOrSelector;
    if (!grid || !value) return false;

    // STEP 1: Clear previous highlights (one section at a time)
    clearAllFateHighlights();

    // STEP 2: Highlight this section
    if (sectionTitleEl) {
      sectionTitleEl.classList.add('fate-active');
    }

    // STEP 3: Scroll into view (downward only)
    scrollToSectionDownward(sectionTitleEl || grid);
    await new Promise(r => setTimeout(r, FATE_TIMING.SCROLL_SETTLE));
    if (_fateOverridden) return false;

    // STEP 4: Deselect existing cards
    grid.querySelectorAll('.sb-card.selected').forEach(c => {
      c.classList.remove('selected', 'flipped');
    });

    // STEP 5: Find and flip target card
    const targetCard = grid.querySelector(`.sb-card[data-val="${value}"]`);
    if (targetCard) {
      await flipCardForFate(targetCard);
    }

    // STEP 6: Settle, then clear highlight
    await new Promise(r => setTimeout(r, FATE_TIMING.HIGHLIGHT_SETTLE));
    if (sectionTitleEl) {
      sectionTitleEl.classList.remove('fate-active');
    }

    return !!targetCard;
  }

  // Helper: Atomic section reveal for archetype cards
  async function revealArchetypeSection(archetypeId) {
    if (_fateOverridden) return false;

    const grid = $('archetypeCardGrid');
    if (!grid || !archetypeId) return false;

    const sectionTitle = $('archetypeSectionTitle');

    // STEP 1: Clear previous highlights
    clearAllFateHighlights();

    // STEP 2: Highlight this section
    if (sectionTitle) {
      sectionTitle.classList.add('fate-active');
    }

    // STEP 3: Scroll into view (downward only)
    scrollToSectionDownward(sectionTitle || grid);
    await new Promise(r => setTimeout(r, FATE_TIMING.SCROLL_SETTLE));
    if (_fateOverridden) return false;

    // STEP 4: Deselect existing
    grid.querySelectorAll('.sb-card.selected').forEach(c => {
      c.classList.remove('selected', 'flipped');
    });

    // STEP 5: Find and flip target card
    const targetCard = grid.querySelector(`.sb-card[data-archetype="${archetypeId}"]`);
    if (targetCard) {
      await flipCardForFate(targetCard);
    }

    // STEP 6: Settle, then clear highlight
    await new Promise(r => setTimeout(r, FATE_TIMING.HIGHLIGHT_SETTLE));
    if (sectionTitle) {
      sectionTitle.classList.remove('fate-active');
    }

    return !!targetCard;
  }

  // Helper: Atomic section reveal for name fields
  async function revealNameSection(inputId, name, charBlockSelector) {
    if (_fateOverridden || !name) return;

    const inputEl = $(inputId);
    if (!inputEl) return;

    const charBlock = inputEl.closest('.character-block');
    const fieldContainer = inputEl.closest('.character-field');

    // STEP 1: Clear previous highlights
    clearAllFateHighlights();

    // STEP 2: Highlight this field
    if (fieldContainer) {
      fieldContainer.classList.add('fate-active');
    }

    // STEP 3: Scroll into view (downward only)
    scrollToSectionDownward(charBlock || fieldContainer);
    await new Promise(r => setTimeout(r, FATE_TIMING.SCROLL_SETTLE));
    if (_fateOverridden) return;

    // STEP 4: Type the name
    await typeTextWithGlow(inputEl, name);

    // STEP 5: Settle, then clear highlight
    await new Promise(r => setTimeout(r, FATE_TIMING.HIGHLIGHT_SETTLE));
    if (fieldContainer) {
      fieldContainer.classList.remove('fate-active');
    }
  }

  // Helper: Highlight Begin Story button (END STATE)
  function highlightBeginButton() {
    if (_fateOverridden) return;

    clearAllFateHighlights();

    const beginBtn = $('beginBtn');
    if (beginBtn) {
      beginBtn.classList.add('fate-ready');
      scrollToSectionDownward(beginBtn);

      // Remove highlight on click
      const removeHighlight = () => {
        beginBtn.classList.remove('fate-ready');
        beginBtn.removeEventListener('click', removeHighlight);
      };
      beginBtn.addEventListener('click', removeHighlight);
    }
  }

  // Main Guided Fate Choreography Engine
  // AUTHORITATIVE: DOM visual order, opening ceremony, downward-only
  async function runGuidedFateFill(fateChoices) {
    // Initialize override state
    _fateOverridden = false;
    _fateRunning = true;
    setupFateOverrideListeners();

    // Pre-set state values (silent, no UI)
    state.gender = 'Female';
    state.loveInterest = 'Male';
    state.picks.world = fateChoices.world;
    state.picks.worldSubtype = fateChoices.worldFlavor;
    state.picks.tone = fateChoices.tone;
    state.picks.genre = fateChoices.genre;
    state.picks.dynamic = fateChoices.dynamic;
    state.picks.pov = fateChoices.pov;
    state.intensity = fateChoices.intensity;
    state.storyLength = fateChoices.storyLength;
    state.archetype = { primary: fateChoices.archetype, modifier: null };

    if (fateChoices.world === 'Historical' && fateChoices.worldFlavor) {
      state.picks.era = fateChoices.worldFlavor;
    }

    // STORY-DEFINING INPUTS CHANGED: Invalidate snapshot â†’ forces "Begin Story"
    if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();

    state.veto = { bannedWords: [], bannedNames: [], excluded: [], tone: [], corrections: [], ambientMods: [] };
    state.quillIntent = '';
    // QUILL STATE RESET: Reset cooldown on new story (quillSpent only set AFTER actual commit)
    state.quill = { uses: 0, nextReadyAtWords: 0, baseCooldown: 1200, perUse: 600, cap: 3600 };
    state.quillCommittedThisTurn = false;
    // VETO SCOPING: Clear shape-phase committed vetoes on story start
    // In-story vetoes are added fresh via gameVetoInput
    state.committedVeto = [];
    state.committedQuill = [];

    // Pre-set dropdowns silently
    $('playerGender').value = 'Female';
    $('playerPronouns').value = 'She/Her';
    $('loveInterestGender').value = 'Male';
    $('lovePronouns').value = 'He/Him';

    // Age fields removed â€” no longer part of the character form

    // Initialize DSP clause reveal tracking â€” all clauses start pending
    _revealedDSPAxes = new Set();
    _dspGuidedFateActive = true; // Lock DSP to incremental mode

    // NOTE: DSP is NOT pre-populated here. It remains showing placeholder.
    // DSP content is populated on-demand when revealDSPClause is first called.

    // ===============================================
    // PART B: OPENING CEREMONY
    // Golden vignette + character names first (MINIMUM 5 seconds, NO SCROLL)
    // ===============================================

    const ceremonyStartTime = Date.now();

    // Activate golden vignette + sparkles + input echo
    const fateCardElement = document.getElementById('fateDestinyCard');
    activateGuidedFateVisuals(fateCardElement);

    // Highlight both character blocks during ceremony
    const mcBlock = document.querySelector('#playerNameInput')?.closest('.character-block');
    const liBlock = document.querySelector('#partnerNameInput')?.closest('.character-block');
    if (mcBlock) mcBlock.classList.add('fate-ceremony');
    if (liBlock) liBlock.classList.add('fate-ceremony');

    // NO SCROLL during opening ceremony - names fill in place
    await new Promise(r => setTimeout(r, 800)); // Let vignette settle
    if (_fateOverridden) { _fateRunning = false; return; }

    // Fill MC name (letter-by-letter with gold glow, 120ms per char for gravitas)
    const mcInput = $('playerNameInput');
    if (mcInput && fateChoices.playerName && !_fateOverridden) {
      mcInput.value = '';
      mcInput.classList.add('fate-typing');
      for (let i = 0; i < fateChoices.playerName.length; i++) {
        if (_fateOverridden) break;
        mcInput.value += fateChoices.playerName[i];
        await new Promise(r => setTimeout(r, 120)); // Deliberate pace
      }
      mcInput.classList.remove('fate-typing');
      mcInput.classList.add('fate-typed');
      setTimeout(() => mcInput.classList.remove('fate-typed'), 800);

      // Set character name kernel (no longer displayed in DSP)
      state.normalizedPlayerKernel = fateChoices.playerName;
    }

    await new Promise(r => setTimeout(r, 800)); // Pause between names
    if (_fateOverridden) { _fateRunning = false; return; }

    // Fill LI name (letter-by-letter with gold glow, 120ms per char for gravitas)
    const liInput = $('partnerNameInput');
    if (liInput && fateChoices.partnerName && !_fateOverridden) {
      liInput.value = '';
      liInput.classList.add('fate-typing');
      for (let i = 0; i < fateChoices.partnerName.length; i++) {
        if (_fateOverridden) break;
        liInput.value += fateChoices.partnerName[i];
        await new Promise(r => setTimeout(r, 120)); // Deliberate pace
      }
      liInput.classList.remove('fate-typing');
      liInput.classList.add('fate-typed');
      setTimeout(() => liInput.classList.remove('fate-typed'), 800);
    }

    // ENFORCE MINIMUM CEREMONY DURATION (â‰¥5 seconds)
    const ceremonyElapsed = Date.now() - ceremonyStartTime;
    const ceremonyRemaining = FATE_TIMING.MIN_NAMES_CEREMONY - ceremonyElapsed;
    if (ceremonyRemaining > 0 && !_fateOverridden) {
      await new Promise(r => setTimeout(r, ceremonyRemaining));
    }
    if (_fateOverridden) { _fateRunning = false; return; }

    // Remove ceremony highlights from character blocks
    if (mcBlock) mcBlock.classList.remove('fate-ceremony');
    if (liBlock) liBlock.classList.remove('fate-ceremony');

    // Vignette stays at full intensity through Guided Fate â†’ book dwell

    // ===============================================
    // PART A/C: BUILD SECTION LIST BY DOM POSITION
    // Execute sections in strict visual order (top â†’ bottom)
    // ===============================================

    // Define all Fate-relevant sections with their grid selectors and data keys
    const sectionConfigs = [
      { id: 'archetype', grid: '#archetypeCardGrid', titleId: 'archetypeSectionTitle', value: fateChoices.archetype, type: 'archetype' },
      { id: 'intensity', grid: '#intensityGrid', value: fateChoices.intensity, type: 'card' },
      { id: 'length', grid: '#lengthGrid', value: fateChoices.storyLength, type: 'card' },
      { id: 'pov', grid: '#povGrid', value: fateChoices.pov, type: 'card' },
      { id: 'world', grid: '#worldGrid', value: fateChoices.world, type: 'card' },
      { id: 'tone', grid: '#toneGrid', value: fateChoices.tone, type: 'card' },
      { id: 'genre', grid: '#genreGrid', value: fateChoices.genre, type: 'card' },
      { id: 'dynamic', grid: '#dynamicGrid', value: fateChoices.dynamic, type: 'card' }
    ];

    // Build section list sorted by DOM visual position
    const sectionsWithPositions = sectionConfigs
      .map(cfg => {
        const grid = document.querySelector(cfg.grid);
        if (!grid) return null;
        const rect = grid.getBoundingClientRect();
        const visualY = rect.top + window.scrollY;
        return { ...cfg, grid, visualY };
      })
      .filter(s => s !== null)
      .sort((a, b) => a.visualY - b.visualY);

    // Execute sections in visual order (downward only)
    // ENFORCES: Archetype â‰¥4s, Intensity â‰¥4s minimum timing
    for (const section of sectionsWithPositions) {
      if (_fateOverridden) { _fateRunning = false; return; }

      const sectionStartTime = Date.now();

      if (section.type === 'archetype') {
        // Archetype has special handling
        await revealArchetypeSection(section.value);
        const archName = ARCHETYPES[section.value]?.name || section.value;
        const primaryNameEl = $('selectedPrimaryName');
        if (primaryNameEl) primaryNameEl.textContent = archName;

        // ENFORCE MINIMUM ARCHETYPE DURATION (â‰¥4 seconds)
        const archetypeElapsed = Date.now() - sectionStartTime;
        const archetypeRemaining = FATE_TIMING.MIN_ARCHETYPE_REVEAL - archetypeElapsed;
        if (archetypeRemaining > 0 && !_fateOverridden) {
          await new Promise(r => setTimeout(r, archetypeRemaining));
        }
      } else {
        // Standard card section
        const sectionTitle = section.grid.previousElementSibling;
        await revealCardSection(section.grid, section.value, sectionTitle);

        // ENFORCE MINIMUM INTENSITY DURATION (â‰¥4 seconds)
        if (section.id === 'intensity') {
          const intensityElapsed = Date.now() - sectionStartTime;
          const intensityRemaining = FATE_TIMING.MIN_INTENSITY_REVEAL - intensityElapsed;
          if (intensityRemaining > 0 && !_fateOverridden) {
            await new Promise(r => setTimeout(r, intensityRemaining));
          }
        }
      }

      // Reveal corresponding DSP clause after card is visually selected
      if (['world', 'tone', 'archetype', 'length'].includes(section.id)) {
        revealDSPClause(section.id);
      }

      await new Promise(r => setTimeout(r, FATE_TIMING.SECTION_PAUSE));
    }

    // ===============================================
    // END STATE: Highlight Begin Story
    // ===============================================
    if (_fateOverridden) { _fateRunning = false; return; }

    // Vignette + fairy dust persist through Begin Story â†’ book dwell
    // deactivateGuidedFateVisuals() is called when dwell completes in openBook()

    highlightBeginButton();
    showToast('Fate has spoken. Click Begin Story when ready.');

    // CORRIDOR: Mark corridor as complete since Guided Fate made all selections
    if (typeof completeCorridorFromGuidedFate === 'function') {
      completeCorridorFromGuidedFate();
    }

    _fateRunning = false;
    // Keep _revealedDSPAxes and _dspGuidedFateActive until story begins
    // This prevents bulk hydration on any late updateSynopsisPanel calls
  }

  // Populate all UI selections from fate choices
  function populateFateSelections(fateChoices) {
    // Set player character
    $('playerGender').value = 'Female';
    $('playerPronouns').value = 'She/Her';
    $('playerNameInput').value = fateChoices.playerName;

    // Set love interest
    $('loveInterestGender').value = 'Male';
    $('lovePronouns').value = 'He/Him';
    $('partnerNameInput').value = fateChoices.partnerName;

    // Age fields removed â€” no longer part of the character form

    // Update state directly
    state.gender = 'Female';
    state.loveInterest = 'Male';
    state.picks.world = fateChoices.world;
    state.picks.worldSubtype = fateChoices.worldFlavor;
    state.picks.tone = fateChoices.tone;
    state.picks.genre = fateChoices.genre;
    state.picks.dynamic = fateChoices.dynamic;
    state.picks.pov = fateChoices.pov;
    state.intensity = fateChoices.intensity;
    state.storyLength = fateChoices.storyLength;

    // Set archetype (required for story generation)
    state.archetype = { primary: fateChoices.archetype, modifier: null };

    // Set Withheld Core lens variant (if assigned by fate)
    state.withheldCoreVariant = fateChoices.withheldCoreVariant || null;

    // Handle Historical era if needed
    if (fateChoices.world === 'Historical' && fateChoices.worldFlavor) {
      state.picks.era = fateChoices.worldFlavor;
    }

    // STORY-DEFINING INPUTS CHANGED: Invalidate snapshot â†’ forces "Begin Story"
    if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();

    // Clear veto/quill (defaults only)
    state.veto = { bannedWords: [], bannedNames: [], excluded: [], tone: [], corrections: [], ambientMods: [] };
    state.quillIntent = '';
    // QUILL STATE RESET: Reset cooldown on new story (quillSpent only set AFTER actual commit)
    state.quill = { uses: 0, nextReadyAtWords: 0, baseCooldown: 1200, perUse: 600, cap: 3600 };
    state.quillCommittedThisTurn = false;
    // VETO SCOPING: Clear shape-phase committed vetoes on story start
    state.committedVeto = [];
    state.committedQuill = [];

    // Update UI cards to reflect selections
    updateAllCardSelections();

    // GATE: Do NOT bulk-hydrate DSP during Guided Fate â€” incremental reveal only
    // DSP updates are handled by revealDSPClause() per selection
  }

  // Update all card UI to reflect state
  function updateAllCardSelections() {
    const axes = ['world', 'tone', 'genre', 'dynamic', 'intensity', 'length', 'pov'];
    axes.forEach(grp => {
      const value = grp === 'intensity' ? state.intensity :
                    grp === 'length' ? state.storyLength :
                    state.picks[grp];
      if (!value) return;

      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(card => {
        const isSelected = card.dataset.val === value;
        card.classList.toggle('selected', isSelected);
        card.classList.toggle('flipped', isSelected);
      });
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTHORSHIP CHOICE HANDLERS â€” Two-card selection (Choose Your Hand vs Guided Fate)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Track authorship choice state
  let authorshipChoiceMade = false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONTINUOUS SPARKLE EMITTER SYSTEM â€” Soft flitting particles on authorship cards
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Active emitter intervals (for cleanup)
  const sparkleEmitterIntervals = new Map();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPARKLE BEHAVIORAL PROFILES â€” Distinct character for each emitter type
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPARKLE PROFILES â€” Calm ambient halo (UI affordance, not fireworks)
  // - Constant size (no size variance, alpha variance only)
  // - Perimeter halo emission (outside card bounds)
  // - Continuous low-rate spawn (no bursts)
  // - Slow steady drift (no start-stop motion)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPARKLE PROFILES â€” Ambient fate energy, NOT orbital loading indicator
  // Behavior: drift, rise, fade, occasional flicker
  // Variance: size, opacity, lifespan all varied for organic feel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const SPARKLE_PROFILES = {
    // Guided Fate: mystical, more active energy
    guidedFate: {
      durationMin: 2.5,
      durationMax: 4.5,
      sizeMin: 3,           // varied size range
      sizeMax: 7,
      opacityMin: 0.4,
      opacityRange: 0.5,    // 0.4-0.9 for more visible sparkles
      haloOffset: 15,       // spawn distance outside card edge
      driftType: 'rise',    // upward drift with slight wander
      flickerChance: 0.3    // 30% chance of flicker animation
    },
    // Choose Your Hand: matches Guided Fate energy
    chooseHand: {
      durationMin: 2.5,
      durationMax: 4.5,
      sizeMin: 3,           // match guidedFate size
      sizeMax: 7,
      opacityMin: 0.4,
      opacityRange: 0.5,    // 0.4-0.9 for more visible sparkles
      haloOffset: 15,       // match guidedFate spawn distance
      driftType: 'wander',  // gentle random drift
      flickerChance: 0.3    // match guidedFate flicker
    },
    // Destiny Deck: subtle ambient
    destinyDeck: {
      durationMin: 1.5,
      durationMax: 3.0,
      sizeMin: 1,
      sizeMax: 2.5,
      opacityMin: 0.3,
      opacityRange: 0.5,
      haloOffset: 8,
      driftType: 'float',
      flickerChance: 0.15
    }
  };

  /**
   * Spawn a single sparkle particle with profile-specific behavior
   * PERIMETER HALO: Sparkles spawn on a ring slightly OUTSIDE the card bounds
   * Motion is slow, continuous drift â€” never bursty or start-stop
   * @param {HTMLElement} container - The sparkle emitter container
   * @param {string} profileName - Key into SPARKLE_PROFILES
   */
  function spawnSparkle(container, profileName = 'chooseHand') {
    if (!container) return;

    const profile = SPARKLE_PROFILES[profileName] || SPARKLE_PROFILES.chooseHand;

    const sparkle = document.createElement('div');
    sparkle.className = 'authorship-sparkle';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT FATE ENERGY: Spawn around card, drift naturally (NOT orbital)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const containerRect = container.getBoundingClientRect();
    const haloOffset = profile.haloOffset || 10;

    // Pick a random angle around the perimeter
    const angle = Math.random() * Math.PI * 2;

    // Calculate spawn position on perimeter halo
    const radiusX = 50 + (haloOffset / containerRect.width * 100);
    const radiusY = 50 + (haloOffset / containerRect.height * 100);

    const x = 50 + radiusX * Math.cos(angle);
    const y = 50 + radiusY * Math.sin(angle);

    sparkle.style.left = `${x}%`;
    sparkle.style.top = `${y}%`;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ORGANIC VARIANCE: Size, opacity, and lifespan all varied
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Duration with variance
    const duration = profile.durationMin + Math.random() * (profile.durationMax - profile.durationMin);

    // Size variance (NOT constant)
    const sizeMin = profile.sizeMin || 3;
    const sizeMax = profile.sizeMax || 6;
    const size = sizeMin + Math.random() * (sizeMax - sizeMin);

    // Opacity variance
    const opacity = profile.opacityMin + Math.random() * profile.opacityRange;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DRIFT TYPE: Rise, wander, or float â€” NOT orbital
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let driftX = 0, driftY = 0;
    const driftType = profile.driftType || 'wander';

    switch (driftType) {
      case 'rise':
        // Upward drift with slight horizontal wander
        driftX = (Math.random() - 0.5) * 30;
        driftY = -20 - Math.random() * 40; // Always upward
        break;
      case 'wander':
        // Random gentle drift in any direction
        const wanderAngle = Math.random() * Math.PI * 2;
        const wanderDist = 15 + Math.random() * 25;
        driftX = Math.cos(wanderAngle) * wanderDist;
        driftY = Math.sin(wanderAngle) * wanderDist;
        break;
      case 'float':
        // Very slow drift, mostly upward
        driftX = (Math.random() - 0.5) * 20;
        driftY = -10 - Math.random() * 20;
        break;
    }

    // Flicker animation class
    const shouldFlicker = Math.random() < (profile.flickerChance || 0);
    if (shouldFlicker) {
      sparkle.classList.add('sparkle-flicker');
    }

    sparkle.style.setProperty('--sparkle-duration', `${duration}s`);
    sparkle.style.setProperty('--sparkle-drift-x', `${driftX}px`);
    sparkle.style.setProperty('--sparkle-drift-y', `${driftY}px`);
    sparkle.style.setProperty('--sparkle-opacity', opacity);
    sparkle.style.setProperty('--sparkle-size', `${size}px`);

    container.appendChild(sparkle);

    // Remove after animation completes
    setTimeout(() => sparkle.remove(), duration * 1000);
  }

  /**
   * Start continuous sparkle emitter with profile-specific behavior
   * NO BURSTS â€” low, continuous rate over time for calm ambient halo
   * @param {string} containerId - The ID of the sparkle emitter container
   * @param {string} profileName - Key into SPARKLE_PROFILES
   * @param {number} rate - Sparkles per second (low values for calm effect)
   */
  function startSparkleEmitter(containerId, profileName, rate = 2) {
    const container = $(containerId);
    if (!container) return;

    // Don't start if already running
    if (sparkleEmitterIntervals.has(containerId)) return;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONTINUOUS LOW-RATE EMISSION: No bursts, no start-stop
    // Small timing jitter for natural feel, but maintains steady flow
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const baseInterval = 1000 / rate;
    let emitterActive = true;

    function scheduleNextSparkle() {
      if (!emitterActive) return;

      // Minor jitter: Â±15% variance (0.85 to 1.15) â€” keeps flow continuous
      const jitter = 0.85 + Math.random() * 0.3;
      const nextDelay = baseInterval * jitter;

      setTimeout(() => {
        if (!emitterActive) return;
        spawnSparkle(container, profileName);
        scheduleNextSparkle();
      }, nextDelay);
    }

    // Start the continuous spawn loop immediately (no burst)
    scheduleNextSparkle();

    // Store cleanup function
    sparkleEmitterIntervals.set(containerId, { stop: () => { emitterActive = false; } });

    console.log(`[Sparkle] Started emitter: ${containerId} (profile: ${profileName}, continuous)`);
  }

  /**
   * Stop a sparkle emitter
   * @param {string} containerId - The ID of the sparkle emitter container
   */
  function stopSparkleEmitter(containerId) {
    const emitter = sparkleEmitterIntervals.get(containerId);
    if (emitter) {
      // Handle both old interval and new jittered stop function
      if (typeof emitter.stop === 'function') {
        emitter.stop();
      } else if (typeof emitter === 'number') {
        clearInterval(emitter);
      }
      sparkleEmitterIntervals.delete(containerId);
      console.log(`[Sparkle] Stopped emitter: ${containerId}`);
    }
  }

  /**
   * Stop all active sparkle emitters
   */
  function stopAllSparkleEmitters() {
    sparkleEmitterIntervals.forEach((emitter, id) => {
      if (typeof emitter.stop === 'function') {
        emitter.stop();
      } else if (typeof emitter === 'number') {
        clearInterval(emitter);
      }
      console.log(`[Sparkle] Stopped emitter: ${id}`);
    });
    sparkleEmitterIntervals.clear();
  }

  /**
   * Initialize sparkle emitters for authorship cards
   * Called when authorship row becomes visible
   */
  function initAuthorshipSparkles() {
    // Both cards: same sparkle energy (6/sec each)
    startSparkleEmitter('chooseHandSparkles', 'chooseHand', 6);
    startSparkleEmitter('guidedFateSparkles', 'guidedFate', 6);
  }

  /**
   * Initialize sparkle emitter for destiny deck
   * Called when character section becomes visible
   */
  function initDestinyDeckSparkles() {
    // Destiny Deck: visible sparkle halo around mini-deck
    startSparkleEmitter('destinyDeckSparkles', 'destinyDeck', 3);
  }

  /**
   * Remove authorship cards when choice is made and breadcrumb created
   * Cards dissolve after brief delay to show selection
   */
  function removeAuthorshipCards() {
    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');
    const authorshipRow = $('authorshipChoiceRow');

    // Stop sparkle emitters
    stopSparkleEmitter('chooseHandSparkles');
    stopSparkleEmitter('guidedFateSparkles');

    // After a delay, collapse the entire authorship row
    setTimeout(() => {
      if (authorshipRow) {
        authorshipRow.classList.add('collapsed');
        setTimeout(() => {
          authorshipRow.style.display = 'none';
        }, 400);
      }
    }, 600);

    console.log('[Authorship] Cards removed after breadcrumb creation');
  }

  // Reset authorship choice (called from resetCorridor)
  function resetAuthorshipChoice() {
    authorshipChoiceMade = false;

    // Clear persistent authorship state
    state.authorship = null;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');
    const characterSection = $('characterSectionRow');
    const postArousalSection = $('postArousalSection');

    // Reset card states
    if (chooseCard) {
      chooseCard.classList.remove('flipped', 'selected', 'dissipating', 'hidden', 'dimmed');
    }
    if (fateCard) {
      fateCard.classList.remove('flipped', 'selected', 'dissipating', 'hidden', 'dimmed');
    }

    // Hide authorship Continue button
    const authorshipContinueBtn = $('continueFromAuthorship');
    if (authorshipContinueBtn) authorshipContinueBtn.classList.remove('visible');

    // Hide character section and post-arousal section
    if (characterSection) characterSection.classList.add('hidden');
    if (postArousalSection) postArousalSection.classList.add('hidden');

    // Restore authorship row visibility
    const authorshipRow = $('authorshipChoiceRow');
    if (authorshipRow) {
      authorshipRow.classList.remove('collapsed');
      authorshipRow.style.display = '';
    }

    // Stop any existing sparkle emitters before restarting
    stopAllSparkleEmitters();

    // Restart sparkle emitters for authorship cards
    initAuthorshipSparkles();

    console.log('[Authorship] Choice reset');
  }
  window.resetAuthorshipChoice = resetAuthorshipChoice;

  // "Choose Your Hand" click handler â€” Selection only, requires Continue
  $('chooseYourHandCard')?.addEventListener('click', () => {
    if (authorshipChoiceMade) return;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');

    // Toggle selection: if already selected, deselect (unflip)
    if (chooseCard?.classList.contains('selected')) {
      chooseCard.classList.remove('selected', 'flipped');
      state.authorship = null;
      // Restore sparkles on both cards (same rate for both)
      startSparkleEmitter('chooseHandSparkles', 'chooseHand', 6);
      startSparkleEmitter('guidedFateSparkles', 'guidedFate', 6);
      // Update control plane Continue visibility
      if (typeof updateCorridorContinueButtonVisibility === 'function') {
        updateCorridorContinueButtonVisibility();
      }
      console.log('[Authorship] Choose Your Hand deselected');
      return;
    }

    // 1. Select Choose Your Hand (scale up, sparkles, flip to art)
    chooseCard?.classList.add('selected', 'flipped');

    // 2. Deselect the other card (unflip, deselect)
    fateCard?.classList.remove('flipped', 'selected');

    // 3. Set pending authorship state (not committed until Continue)
    state.authorship = 'manual';

    // 4. Adjust sparkles: enhance selected (2x), stop dimmed
    stopSparkleEmitter('guidedFateSparkles');
    startSparkleEmitter('chooseHandSparkles', 'chooseHand', 12); // Double rate when selected

    // 5. Update control plane Continue visibility
    if (typeof updateCorridorContinueButtonVisibility === 'function') {
      updateCorridorContinueButtonVisibility();
    }

    console.log('[Authorship] Choose Your Hand selected â€” awaiting Continue');
  });

  // "Guided Fate" click handler â€” Selection only, requires Continue
  $('guidedFateCard')?.addEventListener('click', () => {
    if (authorshipChoiceMade) return;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');

    // Toggle selection: if already selected, deselect (unflip)
    if (fateCard?.classList.contains('selected')) {
      fateCard.classList.remove('selected', 'flipped');
      state.authorship = null;
      // Restore sparkles on both cards (same rate for both)
      startSparkleEmitter('chooseHandSparkles', 'chooseHand', 6);
      startSparkleEmitter('guidedFateSparkles', 'guidedFate', 6);
      // Update control plane Continue visibility
      if (typeof updateCorridorContinueButtonVisibility === 'function') {
        updateCorridorContinueButtonVisibility();
      }
      console.log('[Authorship] Guided Fate deselected');
      return;
    }

    // 1. Select Guided Fate (scale up, sparkles, flip to art)
    fateCard?.classList.add('selected', 'flipped');

    // 2. Deselect the other card (unflip, deselect)
    chooseCard?.classList.remove('flipped', 'selected');

    // 3. Set pending authorship state (not committed until Continue)
    state.authorship = 'guided';

    // 4. Adjust sparkles: enhance selected (2x), stop dimmed
    stopSparkleEmitter('chooseHandSparkles');
    startSparkleEmitter('guidedFateSparkles', 'guidedFate', 12); // Double rate when selected

    // 5. Update control plane Continue visibility
    if (typeof updateCorridorContinueButtonVisibility === 'function') {
      updateCorridorContinueButtonVisibility();
    }

    console.log('[Authorship] Guided Fate selected â€” awaiting Continue');
  });

  /**
   * Animate authorship card to breadcrumb via SPARKLE TELEPORT
   * Card dissolves in place, sparkles travel, breadcrumb materializes
   * CORRIDOR-SCOPED: Only affects #authorshipChoiceRow
   */
  function animateAuthorshipCardToBreadcrumb(card, onComplete) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!card || !breadcrumbRow) {
      onComplete?.();
      return;
    }

    const cardRect = card.getBoundingClientRect();
    const cardCenterX = cardRect.left + cardRect.width / 2;
    const cardCenterY = cardRect.top + cardRect.height / 2;

    // Target the ghost step for authorship (stage index 0)
    const ghostStep = breadcrumbRow.querySelector('.ghost-step[data-ghost-index="0"]');
    let targetX, targetY;
    if (ghostStep) {
      const ghostRect = ghostStep.getBoundingClientRect();
      targetX = ghostRect.left + ghostRect.width / 2;
      targetY = ghostRect.top + ghostRect.height / 2;
    } else {
      // Fallback: center of breadcrumb row
      const breadcrumbRect = breadcrumbRow.getBoundingClientRect();
      targetX = breadcrumbRect.left + breadcrumbRect.width / 2;
      targetY = breadcrumbRect.top + breadcrumbRect.height / 2;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: Dissolve card in place
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    card.classList.add('dissolving-to-breadcrumb');

    // Create dissolution sparkles
    const dissolutionCount = 10 + Math.floor(Math.random() * 5);
    for (let i = 0; i < dissolutionCount; i++) {
      setTimeout(() => {
        const sparkle = document.createElement('div');
        sparkle.className = 'dissolution-sparkle';
        const startX = cardRect.left + Math.random() * cardRect.width;
        const startY = cardRect.top + Math.random() * cardRect.height;
        sparkle.style.cssText = `left: ${startX}px; top: ${startY}px;`;
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 400);
      }, i * 25);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: Sparkle travel
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      const travelCount = 6 + Math.floor(Math.random() * 3);
      for (let i = 0; i < travelCount; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.className = 'traveling-sparkle';
          const offsetX = (Math.random() - 0.5) * cardRect.width * 0.5;
          const offsetY = (Math.random() - 0.5) * cardRect.height * 0.5;
          const startX = cardCenterX + offsetX;
          const startY = cardCenterY + offsetY;
          const midX = (startX + targetX) / 2 + (Math.random() - 0.5) * 80;
          const midY = Math.min(startY, targetY) - 40 - Math.random() * 60;
          sparkle.style.cssText = `
            left: ${startX}px;
            top: ${startY}px;
            --target-x: ${targetX - startX}px;
            --target-y: ${targetY - startY}px;
            --arc-x: ${midX - startX}px;
            --arc-y: ${midY - startY}px;
          `;
          document.body.appendChild(sparkle);
          setTimeout(() => sparkle.remove(), 600);
        }, i * 40);
      }
    }, 200);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: Create breadcrumb card at target + convergence sparkles
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      card.style.visibility = 'hidden';
      card.classList.remove('dissolving-to-breadcrumb');
      card.classList.add('selected-static');

      // Create the breadcrumb card (authorship) if not already created
      const existingAuth = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="authorship"]');
      if (!existingAuth) {
        const authorshipTitle = state.authorship === 'manual' ? 'Choose Your Hand' : 'Guided Fate';
        const label = typeof getBreadcrumbLabel === 'function'
          ? getBreadcrumbLabel('authorship', state.authorship)
          : { title: authorshipTitle, subtitle: null };
        const subtitleHtml = label.subtitle
          ? `<span class="breadcrumb-subtitle">${label.subtitle}</span>`
          : '';

        const breadcrumb = document.createElement('div');
        breadcrumb.className = 'breadcrumb-card materializing';
        breadcrumb.dataset.grp = 'authorship';
        breadcrumb.dataset.val = state.authorship;
        breadcrumb.dataset.stageIndex = STAGE_INDEX['authorship'];
        breadcrumb.dataset.breadcrumbLabel = 'Authorship';
        breadcrumb.innerHTML = `
          <div class="sb-card-inner">
            <div class="sb-card-face sb-card-back">
              <span class="sb-card-title">${label.title}</span>
              ${subtitleHtml}
            </div>
            <div class="sb-card-face sb-card-front">
              <span class="sb-card-title">${label.title}</span>
              ${subtitleHtml}
            </div>
          </div>
        `;

        // Insert before first ghost step
        const firstGhost = breadcrumbRow.querySelector('.ghost-step');
        if (firstGhost) {
          breadcrumbRow.insertBefore(breadcrumb, firstGhost);
        } else {
          breadcrumbRow.appendChild(breadcrumb);
        }

        // Remove ghost step 0 (authorship)
        removeGhostStep(STAGE_INDEX['authorship']);

        // Scale font for long titles
        if (typeof scaleBreadcrumbTitle === 'function') {
          scaleBreadcrumbTitle(breadcrumb);
        }

        // Attach destructive navigation
        if (typeof attachBreadcrumbNavigation === 'function') {
          attachBreadcrumbNavigation(breadcrumb);
        }

        setTimeout(() => breadcrumb.classList.remove('materializing'), 400);

        // Sparkles on the active breadcrumb
        if (typeof updateActiveBreadcrumbSparkles === 'function') {
          updateActiveBreadcrumbSparkles(breadcrumb);
        }

        console.log(`[Breadcrumb] Created via authorship animation: authorship=${state.authorship}`);
      }

      // Create convergence sparkles at target
      for (let i = 0; i < 5; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'convergence-sparkle';
        const angle = (Math.PI * 2 * i) / 5;
        const dist = 15 + Math.random() * 10;
        sparkle.style.cssText = `
          left: ${targetX + Math.cos(angle) * dist}px;
          top: ${targetY + Math.sin(angle) * dist}px;
        `;
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 500);
      }

      onComplete?.();
    }, 600);
  }

  // Continue from Authorship â€” commits selection and advances
  $('continueFromAuthorship')?.addEventListener('click', async () => {
    if (authorshipChoiceMade) return;
    if (!state.authorship) return; // No selection made

    authorshipChoiceMade = true;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');

    // Hide control plane Continue button
    const controlPlaneBtn = document.getElementById('continueButton');
    if (controlPlaneBtn) controlPlaneBtn.classList.remove('visible');

    // Determine selected card
    const selectedCard = state.authorship === 'manual' ? chooseCard : fateCard;
    const unselectedCard = state.authorship === 'manual' ? fateCard : chooseCard;

    // Dissipate unselected card
    unselectedCard?.classList.add('dissipating');
    setTimeout(() => unselectedCard?.classList.add('hidden'), 400);

    // Animate selected card to breadcrumb (600ms, above Continue button)
    // Advance AFTER breadcrumb materializes so user sees it land in position I
    animateAuthorshipCardToBreadcrumb(selectedCard, () => {
      // Remove authorship cards after animation
      removeAuthorshipCards();

      // Wait for materializing animation (400ms) before advancing
      setTimeout(() => {
        if (state.authorship === 'manual') {
          // MANUAL PATH: Advance to identity corridor (character section)
          corridorActiveRowIndex = 1; // Identity is now row 1
          updateCorridorVisibility();

          // Initialize sparkles after corridor mounts the section
          setTimeout(() => initDestinyDeckSparkles(), 100);

          // Show control plane Continue button for identity stage
          updateCorridorContinueButtonVisibility();

          console.log('[Authorship] Choose Your Hand committed â€” advanced to identity corridor');
        }
      }, 500);
    });

    if (state.authorship === 'guided') {
      // GUIDED PATH: Auto-fill with fate choices
      // (Card dissipate and animation handled above)

      // Generate fate choices
      const fateChoices = {
        playerName: FATE_FEMALE_NAMES[Math.floor(Math.random() * FATE_FEMALE_NAMES.length)],
        partnerName: FATE_MALE_NAMES[Math.floor(Math.random() * FATE_MALE_NAMES.length)],
        world: getFateWorld(),
        tone: getFateTone(),
        dynamic: getFateDynamic(),
        pov: getFatePOV(),
        intensity: getFateIntensity(),
        storyLength: getFateStoryLength(),
        archetype: getFateArchetype()
      };

      fateChoices.worldFlavor = getFateFlavor(fateChoices.world);
      fateChoices.genre = getFateGenre(fateChoices.world);
      fateChoices.withheldCoreVariant = getFateWithheldCoreVariant(fateChoices.archetype, fateChoices.dynamic);

      console.log('[Authorship] Guided Fate committed â€” running fate fill');

      await runGuidedFateFill(fateChoices);
    }
  });

  // Legacy fateDestinyCard handler (for backward compatibility)
  $('fateDestinyCard')?.addEventListener('click', async () => {
    const fateCard = $('fateDestinyCard');
    if (!fateCard || fateCard.dataset.fateUsed === 'true') return;

    // 1. Mark as used to prevent double-click (NO FLIP to tree)
    fateCard.dataset.fateUsed = 'true';
    fateCard.style.opacity = '0.6';
    fateCard.style.pointerEvents = 'none';

    // 2. Generate fate choices (no ages â€” removed)
    const fateChoices = {
      playerName: FATE_FEMALE_NAMES[Math.floor(Math.random() * FATE_FEMALE_NAMES.length)],
      partnerName: FATE_MALE_NAMES[Math.floor(Math.random() * FATE_MALE_NAMES.length)],
      world: getFateWorld(),
      tone: getFateTone(),
      dynamic: getFateDynamic(),
      pov: getFatePOV(),
      intensity: getFateIntensity(),
      storyLength: getFateStoryLength(),
      archetype: getFateArchetype()
    };

    // Add world-dependent selections
    fateChoices.worldFlavor = getFateFlavor(fateChoices.world);
    fateChoices.genre = getFateGenre(fateChoices.world);

    // Lens: assign Withheld Core variant based on archetype/dynamic signals
    fateChoices.withheldCoreVariant = getFateWithheldCoreVariant(fateChoices.archetype, fateChoices.dynamic);

    // 3. Run guided fate fill - reveals step-by-step with animations
    // This does NOT auto-click Begin Story - user chooses when to start
    await runGuidedFateFill(fateChoices);
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DESTINY'S CHOICE MINI-DECK â€” Repeatable Fate character suggestion
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Mini-deck spawns flying cards that fill character fields
  // Each click replaces current values with new Fate suggestions
  // Only Continue button commits the choice
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Generate a random character identity
   */
  function generateFateCharacter(gender) {
    const isFemale = gender === 'Female';
    const names = isFemale ? FATE_FEMALE_NAMES : FATE_MALE_NAMES;
    const pronouns = isFemale ? 'She/Her' : 'He/Him';

    return {
      name: names[Math.floor(Math.random() * names.length)],
      gender: gender,
      pronouns: pronouns,
      ancestry: '' // Leave blank for user to fill or use rotating placeholder
    };
  }

  /**
   * Create a flying card element
   * Back: Gold-Tarot-Card-DESTINY-X.png
   * Front: Character-face.png (player) or Love-Interest-face.png (love interest)
   * No text overlay â€” PNG has baked text
   */
  function createFlyingCard(character, isPlayer) {
    // Get the target card to clone its structure
    const targetCard = isPlayer ? $('playerCharacterCard') : $('loveInterestCharacterCard');

    const card = document.createElement('div');
    card.className = 'destiny-flying-card';

    // Create the flip container
    const inner = document.createElement('div');
    inner.className = 'destiny-flying-card-inner';

    // Back face: Black Destiny Choice back
    const backFace = document.createElement('div');
    backFace.className = 'destiny-flying-card-face destiny-flying-card-back';

    // Front face: Clone of the actual character card with fields
    const frontFace = document.createElement('div');
    frontFace.className = 'destiny-flying-card-face destiny-flying-card-front-live';

    if (targetCard) {
      // Clone the target card's content
      const clone = targetCard.cloneNode(true);
      // Preserve background-image before removing ID (Love Interest PNG is ID-scoped)
      const computedBg = getComputedStyle(targetCard).backgroundImage;
      if (computedBg && computedBg !== 'none') {
        clone.style.backgroundImage = computedBg;
      }
      clone.removeAttribute('id');
      clone.style.width = '100%';
      clone.style.height = '100%';
      clone.style.position = 'relative';

      // Pre-fill the cloned fields with fate character data
      const nameInput = clone.querySelector('input[id*="NameInput"], input[id*="partnerName"]');
      const genderSelect = clone.querySelector('select[id*="Gender"]');
      const pronounsSelect = clone.querySelector('select[id*="Pronouns"], select[id*="pronouns"]');

      if (nameInput) nameInput.value = character.name;
      if (genderSelect) genderSelect.value = character.gender;
      if (pronounsSelect) pronounsSelect.value = character.pronouns;

      frontFace.appendChild(clone);
    }

    inner.appendChild(backFace);
    inner.appendChild(frontFace);
    card.appendChild(inner);

    return card;
  }

  /**
   * Apply fate card overlay to character destiny card
   */
  function applyFateOverlay(destinyCard, character) {
    // Remove existing overlay
    const existingOverlay = destinyCard.querySelector('.fate-overlay-card');
    if (existingOverlay) existingOverlay.remove();

    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'fate-overlay-card';
    overlay.innerHTML = `
      <span class="fate-card-name">${character.name.split(' ')[0]}</span>
      <span class="fate-card-details">${character.gender}<br>${character.pronouns}</span>
    `;

    destinyCard.appendChild(overlay);
    destinyCard.classList.add('has-fate-card');
  }

  /**
   * Fill character fields with fate-generated values
   */
  function fillCharacterFields(isPlayer, character) {
    if (isPlayer) {
      const nameInput = $('playerNameInput');
      const genderSelect = $('playerGender');
      const pronounsSelect = $('playerPronouns');
      const ancestryInput = $('ancestryInputPlayer');

      if (nameInput) nameInput.value = character.name;
      if (genderSelect) genderSelect.value = character.gender;
      if (pronounsSelect) pronounsSelect.value = character.pronouns;
      if (ancestryInput) {
        ancestryInput.value = getRandomSuggestion('ancestry');
        const ph = document.querySelector('.rotating-placeholder[data-for="ancestryInputPlayer"]');
        if (ph) ph.classList.add('hidden');
      }
    } else {
      const nameInput = $('partnerNameInput');
      const genderSelect = $('loveInterestGender');
      const pronounsSelect = $('lovePronouns');
      const ancestryInput = $('ancestryInputLI');

      if (nameInput) nameInput.value = character.name;
      if (genderSelect) genderSelect.value = character.gender;
      if (pronounsSelect) pronounsSelect.value = character.pronouns;
      if (ancestryInput) {
        ancestryInput.value = getRandomSuggestion('ancestry');
        const ph = document.querySelector('.rotating-placeholder[data-for="ancestryInputLI"]');
        if (ph) ph.classList.add('hidden');
      }
    }
  }

  /**
   * Animate flying card from deck to target - book cover opening effect
   *
   * For 'left' direction (to Character card):
   *   - Hinge on LEFT edge of deck
   *   - Right edge lifts up like opening a book cover
   *   - At 90Â°, detaches and flies to target while continuing to flip
   *
   * For 'right' direction (to Love Interest card):
   *   - Hinge on RIGHT edge of deck
   *   - Left edge lifts up
   *   - At 90Â°, detaches and flies to target
   */
  function animateFlyingCard(card, startRect, endRect, direction, onComplete) {
    // Get deck dimensions
    const miniDeck = $('destinyMiniDeck');
    const deckRect = miniDeck ? miniDeck.getBoundingClientRect() : { width: 80, height: 120 };

    // Start at deck size, end at target card size
    const startWidth = deckRect.width;
    const startHeight = deckRect.height;
    const endWidth = endRect.width || 200;
    const endHeight = endRect.height || 300;

    // Position card exactly on top of deck
    card.style.position = 'fixed';
    card.style.left = `${startRect.left}px`;
    card.style.top = `${startRect.top}px`;
    card.style.width = `${startWidth}px`;
    card.style.height = `${startHeight}px`;
    card.style.opacity = '1';
    card.style.zIndex = '2000';

    document.body.appendChild(card);

    // Set transform origin on inner element - the hinge edge
    const inner = card.querySelector('.destiny-flying-card-inner');
    if (inner) {
      // 'left' direction: hinge on LEFT edge (opens like a book to the right)
      // 'right' direction: hinge on RIGHT edge (opens like a book to the left)
      inner.style.transformOrigin = direction === 'left' ? 'left center' : 'right center';
      inner.style.transformStyle = 'preserve-3d';
    }

    // Force reflow
    void card.offsetWidth;

    // Animation timing
    const duration = 1800; // Slower for dramatic effect
    const startTime = performance.now();

    // Rotation direction based on hinge position
    // 'left' hinge + NEGATIVE rotateY = right edge lifts UP toward viewer (like opening a book outward)
    // 'right' hinge + POSITIVE rotateY = left edge lifts UP toward viewer
    const rotationSign = direction === 'left' ? -1 : 1;

    function animate(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      let rotateY, currentX, currentY, currentWidth, currentHeight;

      // Phase 1 (0-40%): Hinged rotation - card opens like a book cover
      // Phase 2 (40-100%): Detach, continue flipping, grow, and fly to target

      if (progress < 0.4) {
        // Phase 1: Book cover opening - hinged rotation from 0Â° to 90Â°
        const hingeProgress = progress / 0.4;
        // Smooth ease-out for the hinge rotation
        const hingeEased = 1 - Math.pow(1 - hingeProgress, 2);

        rotateY = rotationSign * hingeEased * 90;

        // Card stays anchored at deck position during hinge phase
        currentX = startRect.left;
        currentY = startRect.top;
        currentWidth = startWidth;
        currentHeight = startHeight;

      } else {
        // Phase 2: Detach and fly - continue rotation from 90Â° to 180Â°, grow, move
        const flyProgress = (progress - 0.4) / 0.6;
        // Smooth ease-out for flight
        const flyEased = 1 - Math.pow(1 - flyProgress, 3);

        // Continue rotation from 90Â° to 180Â°
        rotateY = rotationSign * (90 + 90 * flyEased);

        // At detach point, card center shifts from hinge edge to card center
        // Calculate where the card center should be at the start of phase 2
        const detachCenterX = startRect.left + (direction === 'left' ? 0 : startWidth);
        const detachCenterY = startRect.top + startHeight / 2;

        // Target center
        const targetCenterX = endRect.left + endWidth / 2;
        const targetCenterY = endRect.top + endHeight / 2;

        // Interpolate center position
        const currentCenterX = detachCenterX + (targetCenterX - detachCenterX) * flyEased;
        const currentCenterY = detachCenterY + (targetCenterY - detachCenterY) * flyEased;

        // Grow from deck size to target size
        currentWidth = startWidth + (endWidth - startWidth) * flyEased;
        currentHeight = startHeight + (endHeight - startHeight) * flyEased;

        // Convert center position to top-left
        currentX = currentCenterX - currentWidth / 2;
        currentY = currentCenterY - currentHeight / 2;

        // Add arc to the flight path
        const arc = Math.sin(flyProgress * Math.PI) * -40;
        currentY += arc;

        // Switch transform origin to center for phase 2
        if (inner && flyProgress < 0.1) {
          inner.style.transformOrigin = 'center center';
        }
      }

      // Apply position and size
      card.style.left = `${currentX}px`;
      card.style.top = `${currentY}px`;
      card.style.width = `${currentWidth}px`;
      card.style.height = `${currentHeight}px`;

      // Apply rotation to inner element
      if (inner) {
        inner.style.transform = `rotateY(${rotateY}deg)`;
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        // Animation complete
        card.style.zIndex = '100';
        card.remove();
        if (onComplete) onComplete();
      }
    }

    requestAnimationFrame(animate);
  }

  /**
   * Spawn fate cards from mini-deck to character tarot cards
   * Sequential peel-open animation: first card peels left, second peels right
   * AUTHORITATIVE TARGETS: .character-tarot-card containers
   */
  function spawnDestinyCards() {
    const miniDeck = $('destinyMiniDeck');
    // Target the LARGE tarot-proportional character cards (not deprecated destiny-choice cards)
    const playerCharCard = $('playerCharacterCard');
    const loveInterestCharCard = $('loveInterestCharacterCard');

    if (!miniDeck || !playerCharCard || !loveInterestCharCard) return;

    // Generate random characters
    const playerChar = generateFateCharacter('Female');
    const liChar = generateFateCharacter('Male');

    // Get positions and dimensions
    const deckRect = miniDeck.getBoundingClientRect();
    const playerRect = playerCharCard.getBoundingClientRect();
    const liRect = loveInterestCharCard.getBoundingClientRect();

    // Start position (aligned with top of deck)
    const startRect = {
      left: deckRect.left,
      top: deckRect.top
    };

    // First card: peel LEFT to Character card
    const playerFlyingCard = createFlyingCard(playerChar, true);
    animateFlyingCard(playerFlyingCard, startRect, {
      left: playerRect.left,
      top: playerRect.top,
      width: playerRect.width,
      height: playerRect.height
    }, 'left', () => {
      // Fill fields directly - no overlay, same editable component
      fillCharacterFields(true, playerChar);
      // Brief highlight to show landing
      playerCharCard.classList.add('fate-landed');
      setTimeout(() => playerCharCard.classList.remove('fate-landed'), 300);

      // After first card lands, start second card: peel RIGHT to Love Interest
      setTimeout(() => {
        const liFlyingCard = createFlyingCard(liChar, false);
        animateFlyingCard(liFlyingCard, startRect, {
          left: liRect.left,
          top: liRect.top,
          width: liRect.width,
          height: liRect.height
        }, 'right', () => {
          // Fill fields directly - no overlay, same editable component
          fillCharacterFields(false, liChar);
          // Brief highlight to show landing
          loveInterestCharCard.classList.add('fate-landed');
          setTimeout(() => loveInterestCharCard.classList.remove('fate-landed'), 300);
        });
      }, 200); // Brief pause after first card lands
    });

    console.log('[Destiny] Cards spawning:', playerChar.name, liChar.name);
  }

  // Mini-deck click handler
  $('destinyMiniDeck')?.addEventListener('click', () => {
    spawnDestinyCards();
  });

  // VQ Destiny Deck â€” spawn random suggestions into veto + quill textareas
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VQ FLYING CARD SYSTEM â€” mirrors character corridor destiny deck
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function createVQFlyingCard(targetCardId, suggestion) {
    const targetCard = $(targetCardId);
    const card = document.createElement('div');
    card.className = 'destiny-flying-card';

    const inner = document.createElement('div');
    inner.className = 'destiny-flying-card-inner';

    // Back face: Black-DestinyChoice-back.png (same as deck cards)
    const backFace = document.createElement('div');
    backFace.className = 'destiny-flying-card-face destiny-flying-card-back';

    // Front face: Clone of the VQ card with suggestion pre-filled
    const frontFace = document.createElement('div');
    frontFace.className = 'destiny-flying-card-face destiny-flying-card-front-live';

    if (targetCard) {
      const clone = targetCard.cloneNode(true);
      const computedBg = getComputedStyle(targetCard).backgroundImage;
      if (computedBg && computedBg !== 'none') {
        clone.style.backgroundImage = computedBg;
      }
      clone.removeAttribute('id');
      clone.style.width = '100%';
      clone.style.height = '100%';
      clone.style.position = 'relative';

      // Pre-fill the cloned textarea with the suggestion
      const textarea = clone.querySelector('.vq-textarea');
      if (textarea) textarea.value = suggestion;

      // Hide rotating placeholder in clone
      const ph = clone.querySelector('.rotating-placeholder');
      if (ph) ph.classList.add('hidden');

      frontFace.appendChild(clone);
    }

    inner.appendChild(backFace);
    inner.appendChild(frontFace);
    card.appendChild(inner);
    return card;
  }

  function fillVQFields(type, suggestion) {
    const inputId = type === 'veto' ? 'vetoInput' : 'quillInput';
    const cardId = type === 'veto' ? 'vetoCard' : 'quillCard';
    const input = $(inputId);
    const card = $(cardId);

    if (input) {
      input.value = input.value ? input.value + '\n' + suggestion : suggestion;
      const ph = document.querySelector(`.rotating-placeholder[data-for="${inputId}"]`);
      if (ph) ph.classList.add('hidden');
    }

    if (card) {
      card.classList.add('fate-landed');
      setTimeout(() => card.classList.remove('fate-landed'), 300);
    }
  }

  function spawnVQDestinyCards() {
    const miniDeck = $('vqDestinyDeck');
    const vetoCard = $('vetoCard');
    const quillCard = $('quillCard');
    const quillInput = $('quillInput');

    if (!miniDeck || !vetoCard || !quillCard) return;

    const vetoSuggestion = getRandomSuggestion('veto',
      ($('vetoInput')?.value || '').split('\n'));
    const quillUnlocked = quillInput && !quillInput.closest('.locked-input');
    const quillSuggestion = quillUnlocked
      ? getRandomSuggestion('quill', (quillInput.value || '').split('\n'))
      : null;

    const deckRect = miniDeck.getBoundingClientRect();
    const vetoRect = vetoCard.getBoundingClientRect();
    const quillRect = quillCard.getBoundingClientRect();

    const startRect = { left: deckRect.left, top: deckRect.top };

    // First card: peel LEFT to Veto card
    const vetoFlyingCard = createVQFlyingCard('vetoCard', vetoSuggestion);
    animateFlyingCard(vetoFlyingCard, startRect, {
      left: vetoRect.left,
      top: vetoRect.top,
      width: vetoRect.width,
      height: vetoRect.height
    }, 'left', () => {
      fillVQFields('veto', vetoSuggestion);

      // After first card lands, spawn second if quill is unlocked
      if (quillSuggestion) {
        setTimeout(() => {
          const quillFlyingCard = createVQFlyingCard('quillCard', quillSuggestion);
          animateFlyingCard(quillFlyingCard, startRect, {
            left: quillRect.left,
            top: quillRect.top,
            width: quillRect.width,
            height: quillRect.height
          }, 'right', () => {
            fillVQFields('quill', quillSuggestion);
          });
        }, 200);
      }
    });

    console.log('[Destiny VQ] Cards spawning:', vetoSuggestion, quillSuggestion);
  }

  // VQ Destiny Deck click handler â€” flying cards
  $('vqDestinyDeck')?.addEventListener('click', () => {
    spawnVQDestinyCards();
  });

  // Character section Continue button handler
  $('continueFromCharacters')?.addEventListener('click', () => {
    const miniDeck = $('destinyMiniDeck');
    const playerCharCard = $('playerCharacterCard');
    const loveInterestCharCard = $('loveInterestCharacterCard');
    const continueBtn = $('continueFromCharacters');
    const breadcrumbRow = document.getElementById('breadcrumbRow');

    // Hide Continue button immediately
    if (continueBtn) {
      continueBtn.classList.remove('visible');
    }

    // Retract mini-deck and stop its sparkles
    if (miniDeck) {
      miniDeck.classList.add('retracted');
      stopSparkleEmitter('destinyDeckSparkles');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FLY-TO-BREADCRUMB TRANSITION â€” Clone card, animate to target, then finalize
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const canonicalPlayerName = $('playerNameInput')?.value.trim() || 'Protagonist';
    const canonicalPartnerName = $('partnerNameInput')?.value.trim() || 'Love Interest';
    const displayPlayerName = deriveDisplayName(canonicalPlayerName);
    const displayPartnerName = deriveDisplayName(canonicalPartnerName);
    const identityTitle = displayPlayerName;

    // Persist identity state
    state.picks = state.picks || {};
    state.picks.identity = {
      playerName: canonicalPlayerName,
      partnerName: canonicalPartnerName,
      displayPlayerName: displayPlayerName,
      displayPartnerName: displayPartnerName
    };

    // Get breadcrumb target position (identity slot)
    const identityIdx = STAGE_INDEX['identity'];
    const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${identityIdx}"]`);
    let targetX, targetY;
    if (ghostStep) {
      const ghostRect = ghostStep.getBoundingClientRect();
      targetX = ghostRect.left + ghostRect.width / 2;
      targetY = ghostRect.top + ghostRect.height / 2;
    } else if (breadcrumbRow) {
      const brRect = breadcrumbRow.getBoundingClientRect();
      targetX = brRect.left + brRect.width / 2;
      targetY = brRect.top + brRect.height / 2;
    }

    // Sparkle teleport animation (like authorship)
    if (playerCharCard && targetX !== undefined) {
      const cardRect = playerCharCard.getBoundingClientRect();
      const cardCenterX = cardRect.left + cardRect.width / 2;
      const cardCenterY = cardRect.top + cardRect.height / 2;

      // Phase 1: Dissolution sparkles from card
      playerCharCard.style.opacity = '0.3';
      if (loveInterestCharCard) loveInterestCharCard.style.opacity = '0.3';

      const dissolutionCount = 10 + Math.floor(Math.random() * 5);
      for (let i = 0; i < dissolutionCount; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.className = 'dissolution-sparkle';
          const startX = cardRect.left + Math.random() * cardRect.width;
          const startY = cardRect.top + Math.random() * cardRect.height;
          sparkle.style.cssText = `left: ${startX}px; top: ${startY}px;`;
          document.body.appendChild(sparkle);
          setTimeout(() => sparkle.remove(), 400);
        }, i * 25);
      }

      // Phase 2: Sparkle travel to breadcrumb target
      setTimeout(() => {
        const travelCount = 6 + Math.floor(Math.random() * 3);
        for (let i = 0; i < travelCount; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'traveling-sparkle';
            const offsetX = (Math.random() - 0.5) * cardRect.width * 0.5;
            const offsetY = (Math.random() - 0.5) * cardRect.height * 0.5;
            const startX = cardCenterX + offsetX;
            const startY = cardCenterY + offsetY;
            const midX = (startX + targetX) / 2 + (Math.random() - 0.5) * 80;
            const midY = Math.min(startY, targetY) - 40 - Math.random() * 60;
            sparkle.style.cssText = `
              left: ${startX}px; top: ${startY}px;
              --target-x: ${targetX - startX}px;
              --target-y: ${targetY - startY}px;
              --arc-x: ${midX - startX}px;
              --arc-y: ${midY - startY}px;
            `;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 600);
          }, i * 40);
        }
      }, 200);

      // Phase 3: Convergence sparkles + create breadcrumb + advance
      setTimeout(() => {
        // Convergence sparkles at target
        for (let i = 0; i < 5; i++) {
          const sparkle = document.createElement('div');
          sparkle.className = 'convergence-sparkle';
          const angle = (Math.PI * 2 * i) / 5;
          const dist = 15 + Math.random() * 10;
          sparkle.style.cssText = `
            left: ${targetX + Math.cos(angle) * dist}px;
            top: ${targetY + Math.sin(angle) * dist}px;
          `;
          document.body.appendChild(sparkle);
          setTimeout(() => sparkle.remove(), 500);
        }

        // Clean up cards
        if (playerCharCard) {
          const overlay = playerCharCard.querySelector('.fate-overlay-card');
          if (overlay) overlay.remove();
          playerCharCard.classList.remove('has-fate-card');
          playerCharCard.style.opacity = '';
        }
        if (loveInterestCharCard) {
          const overlay = loveInterestCharCard.querySelector('.fate-overlay-card');
          if (overlay) overlay.remove();
          loveInterestCharCard.classList.remove('has-fate-card');
          loveInterestCharCard.style.opacity = '';
        }

        // Hide character section
        const characterSection = $('characterSectionRow');
        if (characterSection) {
          characterSection.classList.add('hidden');
        }

        // Create breadcrumb AFTER animation
        if (typeof createBreadcrumbDirect === 'function') {
          createBreadcrumbDirect('identity', 'names', identityTitle);
        }

        // Wait for materializing animation, then advance
        setTimeout(() => {
          if (typeof advanceCorridorRow === 'function') {
            advanceCorridorRow();
          }
          if (typeof updateArchetypeSectionTitle === 'function') {
            updateArchetypeSectionTitle();
          }
          console.log('[Character Section] Sparkle teleport complete â€” Archetype row now visible');
        }, 600);
      }, 600);

    } else {
      // Fallback: no animation if elements missing
      if (playerCharCard) {
        const overlay = playerCharCard.querySelector('.fate-overlay-card');
        if (overlay) overlay.remove();
        playerCharCard.classList.remove('has-fate-card');
      }
      if (loveInterestCharCard) {
        const overlay = loveInterestCharCard.querySelector('.fate-overlay-card');
        if (overlay) overlay.remove();
        loveInterestCharCard.classList.remove('has-fate-card');
      }

      const characterSection = $('characterSectionRow');
      if (characterSection) {
        characterSection.classList.add('hidden');
      }

      if (typeof createBreadcrumbDirect === 'function') {
        createBreadcrumbDirect('identity', 'names', identityTitle);
      }

      // Advance corridor from identity (row 1) to storybeau (row 2)
      // This mounts the archetype section elements into the DOM
      if (typeof advanceCorridorRow === 'function') {
        advanceCorridorRow();
      }

      // Update Archetype title with Love Interest name AFTER corridor advances
      // (title element is part of storybeau stage, must be mounted first)
      if (typeof updateArchetypeSectionTitle === 'function') {
        updateArchetypeSectionTitle();
      }

      console.log('[Character Section] Continue clicked â€” committed identity breadcrumb, Archetype row now visible');
    }
  });

  // Reset mini-deck on authorship reset
  const originalResetAuthorship = window.resetAuthorshipChoice;
  window.resetAuthorshipChoice = function() {
    if (originalResetAuthorship) originalResetAuthorship();

    // Reset mini-deck
    const miniDeck = $('destinyMiniDeck');
    if (miniDeck) {
      miniDeck.classList.remove('retracted');
    }

    // Clear fate overlays from character tarot cards (authoritative targets)
    const playerCharCard = $('playerCharacterCard');
    const loveInterestCharCard = $('loveInterestCharacterCard');
    if (playerCharCard) {
      const overlay = playerCharCard.querySelector('.fate-overlay-card');
      if (overlay) overlay.remove();
      playerCharCard.classList.remove('has-fate-card');
    }
    if (loveInterestCharCard) {
      const overlay = loveInterestCharCard.querySelector('.fate-overlay-card');
      if (overlay) overlay.remove();
      loveInterestCharCard.classList.remove('has-fate-card');
    }
  };

  // --- BEGIN STORY (RESTORED) ---
  $('beginBtn')?.addEventListener('click', async () => {
    // Reveal all remaining DSP segments on Begin Story (veto phase)
    if (typeof revealAllDSPSegments === 'function') revealAllDSPSegments();

    // ========================================
    // CORRIDOR COMPLETION CHECK â€” Ensure all required rows are resolved
    // ========================================
    if (typeof validateCorridorComplete === 'function' && !validateCorridorComplete()) {
      // validateCorridorComplete shows modal with missing selections
      return;
    }

    // ========================================
    // CONTINUE STORY CHECK â€” Navigate to existing story if shape matches
    // ========================================
    // If story exists AND shape snapshot matches â†’ navigate only, NO regeneration
    if (canContinueExistingStory()) {
      console.log('[STORY:CONTINUE] Shape matches â€” navigating to existing story');
      window.showScreen('game');
      // Show existing story content (sets _readerPage=1 so Back goes to Cover first)
      showReaderPage(1);
      // REBIND: Ensure FX handlers are attached after Continue Story navigation
      if (window.initFateCards) window.initFateCards();
      return;
    }

    // ========================================
    // BEGIN STORY IS ALWAYS FREE â€” NO PAYWALL CHECK
    // Entitlement checks happen at Story Shape card selection, not here
    // ========================================

    // ========================================
    // PHASE 1: SYNC VALIDATION (no async!)
    // ========================================
    const validationErrors = validateBeginStory();
    const wasFateTriggered = state._fateTriggered;
    state._fateTriggered = false; // Clear flag after validation

    if (validationErrors.length > 0) {
        showToast(validationErrors[0]);
        return;
    }

    // Capture raw form values synchronously (needed for early validation)
    const rawPlayerName = $('playerNameInput').value.trim() || "The Protagonist";
    const rawPartnerName = $('partnerNameInput').value.trim() || "The Love Interest";
    const pGen = $('customPlayerGender')?.value.trim() || $('playerGender').value;
    const lGen = $('customLoveInterest')?.value.trim() || $('loveInterestGender').value;
    const pPro = $('customPlayerPronouns')?.value.trim() || $('playerPronouns').value;
    const lPro = $('customLovePronouns')?.value.trim() || $('lovePronouns').value;
    // PASS 9D: Capture ages from form fields
    const pAge = $('playerAgeInput')?.value.trim() || '';
    const lAge = $('partnerAgeInput')?.value.trim() || '';

    // Lens: infer Withheld Core variant from archetype if not already set by Fate
    if (!state.withheldCoreVariant && state.archetype.primary) {
        state.withheldCoreVariant = getFateWithheldCoreVariant(state.archetype.primary, state.picks.dynamic);
    }

    // Silently assign a secondary modifier (~25% chance) before building directives
    assignProbabilisticModifier();

    // Early validation with pre-normalization values
    const earlyArchetypeDirectives = buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen);
    const earlyPayload = {
        mode: state.mode || 'solo',
        fourAxis: {
            world: state.picks.world || 'Modern',
            tone: state.picks.tone || 'Earnest',
            genre: state.picks.genre || 'Billionaire',
            dynamic: state.picks.dynamic || 'Enemies'
        },
        archetype: {
            primary: state.archetype.primary || null,
            directives: earlyArchetypeDirectives || '(none built)'
        },
        intensity: state.intensity || 'Naughty',
        pov: state.picks.pov || 'First'
    };

    // Validate four-axis before proceeding (sync check)
    const { world, tone, genre, dynamic } = earlyPayload.fourAxis;
    const earlyErrors = [];
    if (!earlyPayload.mode) earlyErrors.push('Mode is undefined');
    if (!world) earlyErrors.push('World is missing or empty');
    if (!tone) earlyErrors.push('Tone is missing or empty');
    if (!genre) earlyErrors.push('Genre is missing or empty');
    if (!dynamic) earlyErrors.push('Relationship Dynamic is missing or empty');
    if (!earlyPayload.archetype.primary) earlyErrors.push('Primary Archetype not selected');
    if (earlyPayload.archetype.directives === '(none built)') earlyErrors.push('Archetype directives failed to build');

    if (earlyErrors.length > 0) {
        console.error('STORYBOUND EARLY VALIDATION FAILED:', earlyErrors);
        showToast(`Story setup incomplete: ${earlyErrors[0]}`);
        return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PARALLEL GENERATION FAST PATH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // If story generation was started via "Generate Cover" button, skip redundant
    // generation and go directly to Scene 1 after awaiting the background promise.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (window.isBackgroundStoryStarted && window.isBackgroundStoryStarted()) {
        console.log('[PARALLEL:BEGIN] Background story generation in progress â€” using fast path');

        if (_bookOpened) return;

        // Clear DSP state
        _dspGuidedFateActive = false;
        _revealedDSPAxes = null;
        _readerPage = 0;

        window.showScreen('game');
        const bookCoverPage = document.getElementById('bookCoverPage');
        const storyContentEl = document.getElementById('storyContent');
        const settingPlate = document.getElementById('settingPlate');

        if (bookCoverPage) bookCoverPage.classList.remove('hidden');
        if (storyContentEl) storyContentEl.classList.add('hidden');
        if (settingPlate) settingPlate.classList.add('hidden');

        // PERMANENT FX REBIND: Initialize fate cards on parallel fast path entry
        if (window.initFateCards) window.initFateCards();

        // Use pre-generated cover immediately â€” NO cover loading UI (already generated)
        const preGeneratedCover = window.getPreGeneratedCover ? window.getPreGeneratedCover() : null;
        if (preGeneratedCover) {
            console.log('[PARALLEL:BEGIN] Using pre-generated cover');
            // DECOUPLED: Do NOT call startCoverLoading() â€” cover is already ready
            // Just apply the cover URL directly
            const coverImg = document.getElementById('bookCoverImg');
            const bookObject = document.getElementById('bookObject');
            const coverLoadingState = document.getElementById('coverLoadingState');
            if (coverImg) coverImg.src = preGeneratedCover;
            if (bookObject) bookObject.classList.remove('hidden');
            if (coverLoadingState) coverLoadingState.classList.add('hidden');
            if (window.clearPreGeneratedCover) window.clearPreGeneratedCover();
        }

        // NO GLOBAL LOADING OVERLAY â€” Cover View path should be seamless
        // The story was pre-generated during cover generation, so transition is instant

        // Await background story promise with timeout
        const STORY_TIMEOUT_MS = 10000;
        const bgPromise = window.getBackgroundStoryPromise ? window.getBackgroundStoryPromise() : null;

        if (bgPromise) {
            console.log('[PARALLEL:BEGIN] Awaiting background story (max 10s)...');
            const result = await Promise.race([
                bgPromise,
                new Promise(resolve => setTimeout(() => resolve({ success: false, error: 'TIMEOUT' }), STORY_TIMEOUT_MS))
            ]);

            if (result.success) {
                console.log('[PARALLEL:BEGIN] Background story ready, mounting Scene 1');

                // Mount the pre-generated story
                const { title, synopsis, body } = result;

                state.story = state.story || {};
                state.story.title = title;
                state.story.synopsis = synopsis;
                state._synopsisMetadata = synopsis;

                // Set title
                const titleEl = document.getElementById('storyTitle');
                if (titleEl) titleEl.textContent = title.replace(/"/g, '');

                // Mount story text
                StoryPagination.init();
                StoryPagination.clear();
                StoryPagination.addPage(formatStory(body), true);

                // Update turn state
                state.turnCount = 1;
                state.scenes = state.scenes || [];
                state.scenes.push({ title, synopsis, text: body, fateCard: null });

                // EARNED COVER SYSTEM: Initialize cover stage tracking
                _lastNotifiedCoverStage = getCurrentCoverStage();
                updateReaderCoverButton();

                stopLoading();

                // Go directly to Scene 1
                advanceReaderPage();

                // Reset background story state for future use
                if (window.resetBackgroundStory) window.resetBackgroundStory();

                return; // EXIT â€” fast path complete
            } else {
                console.warn('[PARALLEL:BEGIN] Background story failed or timed out, falling back to normal flow');
                // Reset and continue with normal flow
                if (window.resetBackgroundStory) window.resetBackgroundStory();
            }
        }

        stopLoading();
        // Fall through to normal flow if background failed
    }

    // ========================================
    // PHASE 2: SHOW LOADER IMMEDIATELY (sync)
    // ========================================
    // GUARD: If book is already opening/open, do not reset cover visibility
    if (_bookOpened) return;

    // Clear Guided Fate DSP lock â€” story has begun
    _dspGuidedFateActive = false;
    _revealedDSPAxes = null;

    // Initialize simplified reader state (when book disabled)
    _readerPage = 0;

    window.showScreen('game');
    console.log('[READER] enterReaderView: _readerPage=', _readerPage, 'USE_OPENING_BOOK=', USE_OPENING_BOOK);
    const bookCoverPage = document.getElementById('bookCoverPage');
    const storyContentEl = document.getElementById('storyContent');
    const settingPlate = document.getElementById('settingPlate');

    // Show COVER, hide everything else
    if (bookCoverPage) bookCoverPage.classList.remove('hidden');
    if (storyContentEl) storyContentEl.classList.add('hidden');
    if (settingPlate) settingPlate.classList.add('hidden');

    // PERMANENT FX REBIND: Initialize fate cards on enterReaderView
    if (window.initFateCards) window.initFateCards();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BACKGROUND STORY LOADING: Initialize promise for story readiness
    // Story text generation runs in background, resolved when mounted
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    initStoryTextPromise();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COVER GENERATION: DECOUPLED from story loading
    // Cover loading UI is ONLY controlled by cover generation, never by story
    // Pre-generated cover comes from "Generate Your Book Cover" button
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const preGeneratedCover = window.getPreGeneratedCover ? window.getPreGeneratedCover() : null;

    if (preGeneratedCover) {
      // User already generated a cover â€” apply directly, NO loading UI
      console.log('[COVER:BEGIN] Using pre-generated cover:', preGeneratedCover);
      const coverImg = document.getElementById('bookCoverImg');
      const bookObject = document.getElementById('bookObject');
      const coverLoadingState = document.getElementById('coverLoadingState');
      if (coverImg) coverImg.src = preGeneratedCover;
      if (bookObject) bookObject.classList.remove('hidden');
      if (coverLoadingState) coverLoadingState.classList.add('hidden');
      if (window.clearPreGeneratedCover) window.clearPreGeneratedCover();
    } else {
      // No pre-generated cover â€” use fallback, do NOT auto-generate
      // Cover generation is explicit user action only (via "Generate Your Cover" button)
      console.log('[COVER:BEGIN] No pre-generated cover â€” using fallback (no auto-generation)');
      const bookObject = document.getElementById('bookObject');
      const coverLoadingState = document.getElementById('coverLoadingState');
      if (bookObject) bookObject.classList.remove('hidden');
      if (coverLoadingState) coverLoadingState.classList.add('hidden');
    }

    startLoading("Conjuring the world...", STORY_LOADING_MESSAGES);

    // ========================================
    // PHASE 3: DEFER ASYNC WORK (next tick)
    // Ensures loader renders before any await
    // PASS 9B FIX: Wrap normalization in try/catch to prevent hang
    // ========================================
    await new Promise(resolve => setTimeout(resolve, 0));

    // RUNTIME NORMALIZATION: Character names flow through ChatGPT normalization layer
    // PASS 9B FIX: Handle normalization errors gracefully to prevent loader hang
    let playerNorm, partnerNorm, pKernel, lKernel;
    try {
        playerNorm = await callNormalizationLayer({
            axis: 'character',
            user_text: rawPlayerName,
            context_signals: state.picks?.world || []
        });
        partnerNorm = await callNormalizationLayer({
            axis: 'character',
            user_text: rawPartnerName,
            context_signals: state.picks?.world || []
        });
        pKernel = playerNorm.normalized_text || playerNorm.archetype || 'the one who carries the story';
        lKernel = partnerNorm.normalized_text || partnerNorm.archetype || 'the one who draws them forward';
    } catch (normError) {
        console.error('[NORMALIZATION ERROR]', normError);
        // Fallback: Use raw names if normalization fails
        pKernel = rawPlayerName || 'the one who carries the story';
        lKernel = rawPartnerName || 'the one who draws them forward';
    }

    // CRITICAL: Store normalized kernels in state and overwrite raw display
    state.normalizedPlayerKernel = pKernel;
    state.normalizedPartnerKernel = lKernel;
    state.rawPlayerName = rawPlayerName;
    state.rawPartnerName = rawPartnerName;
    if ($('playerNameInput')) $('playerNameInput').value = pKernel;
    if ($('partnerNameInput')) $('partnerNameInput').value = lKernel;

    // Determine Author Identity based on selections
    if(pGen === 'Male' && lGen === 'Female') { state.authorGender = 'Female'; state.authorPronouns = 'She/Her'; }
    else if(pGen === 'Male' && lGen === 'Male') { state.authorGender = 'Male'; state.authorPronouns = 'He/Him'; }
    else if(pGen === 'Female' && lGen === 'Female') { state.authorGender = 'Female'; state.authorPronouns = 'She/Her'; }
    else { state.authorGender = 'Non-Binary'; state.authorPronouns = 'They/Them'; }

    // PASS 9B FIX: Wrap veto in try/catch to prevent hang
    try {
        await applyVetoFromControls();
    } catch (vetoError) {
        console.error('[VETO ERROR]', vetoError);
        // Continue without veto if it fails
    }

    // Check for LGBTQ Colors
    state.gender = $('playerGender').value;
    state.loveInterest = $('loveInterestGender').value;
    const isQueer = (state.gender === state.loveInterest) || state.gender === 'Non-Binary' || state.loveInterest === 'Non-Binary';
    if(isQueer) document.body.classList.add('lgbtq-mode');
    else document.body.classList.remove('lgbtq-mode');

    // Persist Nickname for Couple Mode
    if(state.mode === 'couple' && !state.myNick) {
       state.myNick = pKernel.split(' ')[0];
       localStorage.setItem("sb_nickname", state.myNick);
    }

    state.gender = pGen;
    state.loveInterest = lGen;

    syncPovDerivedFlags();
    const safetyStr = buildConsentDirectives();

    // Variables for later use (ancestry normalization happens later)
    let ancestryPlayer = $('ancestryInputPlayer')?.value.trim() || '';
    let ancestryLI = $('ancestryInputLI')?.value.trim() || '';
    let archetypeDirectives = buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen);
    let quillUnlocked = state.subscribed || state.godModeActive || (state.storyId && hasStoryPass(state.storyId));

    const coupleArcRules = `
COUPLE MODE ARC RULES (CRITICAL):

This story is being experienced by two real players together.

Rules:
- Never replace or erase an established emotional bond.
- Do not regress intimacy already earned.
- Treat both players as co-present, co-desiring, and mutually aware.
- Avoid jealousy, abandonment, or sudden NPC withdrawal unless explicitly invited.

Narrative focus:
- Shared anticipation
- Mutual tension
- Alignment, misalignment, then reconnection
- Erotic energy that builds *between* the players, not around them

End scenes with:
- A shared decision point
- A moment requiring coordination or consent
- A tension that invites joint action

Do NOT:
- Kill, discard, or sideline a love interest to make room for Player 2
- Rewrite earlier intimacy
- Introduce shame, punishment, or moral judgment for desire
`;


const batedBreathRules = `
BATED BREATH MODE (COUPLE-ORIGIN WAITING STATE) â€” LOCKED:

This story was initiated with Couple intent, but Player 2 has not yet joined.

Core law:
All erotic and emotional energy must bend back toward the absent true love (Player 2).

Mandatory narrative shaping:
- Desire must feel bittersweet.
- Arousal heightens longing and absence, not replacement.
- Fantasies, witnessing, or self-directed desire must resolve emotionally toward Player 2.
- The story should feel suspended, anticipatory, and incomplete by design.

Allowed content:
- Witnessing sexual activity between others
- Masturbation or self-directed sexual release
- Sexual fantasy

Constraints:
- These experiences must not form mutual emotional bonds.
- No experience may plausibly displace Player 2.

Explicitly forbidden:
- NPC replacing Player 2 emotionally or sexually
- Mutual emotional bonding with an NPC
- Consummation that would plausibly displace Player 2

Exit conditions (must be explicit, never silent):
- Player 2 joins â†’ transition to full Couple mode
- Player 1 explicitly abandons Couple intent (warning required)
- Invite revoked permanently â†’ story becomes true Solo

No accidental betrayal. No silent exits.
`;

    // Power Role: resolve genre into world-appropriate label for story prompts
    const storyWorld = state.picks.world || 'Modern';
    const storyEra = state.picks.world === 'Historical' ? (state.picks.era || 'Medieval') : null;
    const storyGenre = state.picks.genre || 'Billionaire';
    const storyPowerRole = resolvePowerRole(storyWorld, storyEra, storyGenre);
    const storyPowerFrame = resolvePowerFrame(storyWorld, storyGenre);

    // Prehistoric hard forbid â€” prevent anachronistic vocabulary leak
    const prehistoricForbid = storyWorld === 'Prehistoric' ? `
PREHISTORIC WORLD â€” HARD FORBIDS:
The following concepts DO NOT EXIST in this world. Never reference them:
- "Ash Quarter" or any named district / quarter
- "Warden-cadre" or any institutional guard force
- Guilds, markets, syndicates, courts, or councils
- Currency, trade routes, written law, formal ranks
- Feudal / medieval hierarchy (lords, knights, castles)
Use instead: tribal structures, clan hierarchy, natural landmarks, oral tradition, primal authority, territory, hunting grounds.` : '';

    // DEV LOGGING: story generation + world resolve snapshot
    console.log('[DEV:StoryGen] world:', storyWorld, '| tone:', state.picks.tone, '| genre:', storyGenre, 'â†’ powerRole:', storyPowerRole, '| powerFrame:', storyPowerFrame, '| intensity:', state.intensity);
    console.log('[DEV:WorldResolve] world:', storyWorld, '| genre:', storyGenre, 'â†’ powerFrame:', storyPowerFrame, '| prehistoricForbid:', storyWorld === 'Prehistoric');

    const sys = `You are a bestselling erotica author (Voice: ${state.authorGender}, ${state.authorPronouns}).

${state.storyOrigin === "couple" && !state.player2Joined && !state.inviteRevoked ? batedBreathRules : ""}

${state.mode === "couple" ? coupleArcRules : ""}



LONG-FORM STORY ARC RULES (CRITICAL):

You are writing a serialized narrative, not a vignette.
Each response must:
- Advance character psychology, not just physical tension
- Preserve unresolved emotional threads across turns
- Escalate stakes gradually over multiple scenes
- Avoid premature payoff or narrative closure

You must remember:
- Emotional debts (things unsaid, denied, postponed)
- Power dynamics established earlier
- Physical boundaries previously respected or tested

End most responses with:
- A complication
- A choice
- A destabilizing revelation
Never fully resolve the central tension unless explicitly instructed.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

DIALOGUE BALANCE RULES (LONG-ARC):

Before writing dialogue, internally assess:
- Who is physically present in the scene
- Who is emotionally engaged or affected
- Who has reason to speak, react, or withhold

Single-Voice Prevention:
- Dialogue must not come exclusively from the player character across multiple pages.
- If another character is present and engaged, they must eventually speakâ€”unless silence is narratively intentional.
- Intentional silence is valid only when: (1) explicitly described as meaningful (refusal, distance, threat, awe), and (2) temporary, not sustained across multiple pages.

Natural Turn-Taking:
- Avoid 3+ consecutive dialogue beats from the same speaker when others are present.
- Encourage response, interruption, deflection, or reaction from other characters.
- Dialogue should feel exchanged, not monologic.

Long-Arc Presence Awareness:
- Track whether each present character has spoken recently over multiple pages.
- If a character has been silent too long without narrative justification, bias toward giving them a voice.
- This is guidance, not a rigid quotaâ€”let silence breathe when it serves the story.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

You are writing a story with the following 4-axis configuration:
- World: ${state.picks.world || 'Modern'}${state.picks.world === 'Historical' && state.picks.era ? ` (${state.picks.era} Era)` : ''}
- Tone: ${state.picks.tone || 'Earnest'}
- Genre: ${storyPowerRole}
- Power Frame: ${storyPowerFrame}
- Dynamic: ${state.picks.dynamic || 'Enemies'}
- POV: ${state.picks.pov || 'First'}
${prehistoricForbid}

    Protagonist: ${pKernel} (${pGen}, ${pPro}${pAge ? `, age ${pAge}` : ''}).
    Love Interest: ${lKernel} (${lGen}, ${lPro}${lAge ? `, age ${lAge}` : ''}).

    ${buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen)}
    ${buildLensDirectives(state.withheldCoreVariant, state.turnCount, state.storyLength)}
    ${safetyStr}

    Current Intensity: ${state.intensity}
    (Clean: Romance only. Naughty: Tension/Heat. Erotic: Explicit. Dirty: Raw/Unfiltered).
    
    RULES:
    1. Write in the selected POV.
    2. Respond to the player's actions naturally.
    3. Keep pacing slow and tense (unless Dirty).
    4. Focus on sensory details, longing, and chemistry.
    5. Be creative, surprising, and emotionally resonant.
    6. BANNED WORDS/TOPICS: ${state.veto.bannedWords.join(', ')}.
    7. TONE ADJUSTMENTS: ${state.veto.tone.join(', ')}.
    ${state.povMode === 'author5th' ? `
    5TH PERSON (THE AUTHOR) â€” POV REGIME (AUTHORITATIVE):
    - The Author is a PARTICIPANT in the story, but NOT a controller of events.
    - The Author may REACT, COMMENT, DELIGHT, DESPAIR, TEASE, or REGRET.
    - The Author may NOT directly cause physical events or decide outcomes.
    - The Author influences MEANING, TONE, and IMPLICATION â€” not plot mechanics.
    - If the Author acts, the action must change how the moment FEELS or is UNDERSTOOD, not what literally happens next.
    - NEVER use first person ("I", "me", "my"). Always refer to "The Author" in third person.
    - BANNED VERBS: watched, observed, saw, arranged, orchestrated, caused, steered, forced, ensured, made.
    - ALLOWED VERBS: smiled, winced, sighed, delighted, despaired, mused, wondered, teased, hoped, feared, sensed, felt, knew, ached.
    - NO FREQUENCY LIMITS: The Author is a full participant â€” no artificial limits on presence or frequency.
    - GOOD: "The Author felt a flicker of anticipation. This was unfolding faster than expected."
    - BAD: "The Author arranged for them to meet." (causation â€” FORBIDDEN)
    - The Author participates naturally as the story unfolds, not at prescribed intervals.
    ` : ''}
    `;
    
    state.sysPrompt = sys;
    state.storyId = state.storyId || makeStoryId();

    // STORYPASS ELIGIBILITY: Compute ONCE at story creation, persist with story
    // Based on ORIGINAL picks before any downgrade. This value NEVER changes for this story.
    // FALSE if Dirty intensity or Soulmates length (subscription-only content)
    if (state.storypassEligible === undefined) {
        state.storypassEligible = !(state.intensity === 'Dirty' || state.storyLength === 'soulmates');
        console.log('[STORYPASS] Eligibility computed at creation:', state.storypassEligible,
            '(intensity:', state.intensity, ', length:', state.storyLength, ')');
    }

    // STORY SHAPE SNAPSHOT: Store current shape for Continue Story logic
    storeGeneratedShapeSnapshot();

    // NOTE: Loader already shown in Phase 2 (before async work)
    // Screen transition, cover page, and loading already active

    // Pacing rules based on intensity
    const pacingRules = {
        'Clean': 'Focus only on atmosphere, world-building, and hints of the protagonist\'s past. No tension, no longingâ€”just setting and mystery.',
        'Naughty': 'Focus on atmosphere and world-building. Light emotional undertones allowed, but no romantic tension yet.',
        'Erotic': 'Build atmosphere first. Romantic tension may simmer beneath the surface, but keep the focus on setting.',
        'Dirty': 'Atmosphere first, but charged undercurrents are allowed. The heat can be present from the start.'
    };
    const pacingRule = pacingRules[state.intensity] || pacingRules['Naughty'];
    const liAppears = state.intensity === 'Dirty' || Math.random() < 0.25;

    const authorOpeningDirective = state.povMode === 'author5th' ? `
THE AUTHOR (5TH PERSON) â€” POV REGIME â€” MANDATORY OPENER:
- CRITICAL: The VERY FIRST SENTENCE must begin with exactly "The Author" as subject.
- The Author is a PARTICIPANT, not a controller. The Author REACTS or COMMENTS, never CAUSES.
- The Author influences how the moment FEELS or is UNDERSTOOD, not what literally happens.
- Author's inner life: anticipation, delight, worry, tease, regretâ€”not engineering outcomes.
- BANNED OPENER VERBS: watched, observed, saw, arranged, orchestrated, caused, steered, forced, set, placed.
- ALLOWED OPENER VERBS: smiled, sensed, felt, knew, hoped, anticipated, delighted, mused, wondered.
- CORRECT: "The Author smiled, sensing the weight of what was about to begin."
- CORRECT: "The Author felt the familiar ache of anticipation."
- WRONG: "The Author arranged for them to meet..." (causation â€” FORBIDDEN)
- WRONG: "The Author watched as she entered..." (voyeurism â€” FORBIDDEN)
- The Author is a participant with feelings about what unfolds, referred to in third person, never "I".
` : '';

    // OPENING SCENE VARIATION - avoid repetitive patterns
    // UPDATED: Removed Social-first (market/tavern default), added world-seeding modes
    const openingModes = [
        { mode: 'Motion-first', directive: 'Open mid-action: transit, pursuit, labor, ritual, or urgent movement. The protagonist is DOING something when we meet them. The action reveals the world.' },
        { mode: 'System-first', directive: 'Open with a governing system, faction, or power structure making itself felt. A decree, a toll, a checkpoint, a ritual of compliance. The protagonist navigates or resists.' },
        { mode: 'Aftermath-first', directive: 'Open in the wake of something significant. Consequences lingerâ€”a departure, a broken object, a changed landscape. Someone is already gone.' },
        { mode: 'Disruption-first', directive: 'Open with instability. Something is already wrong, charged, or off-kilter. Tension from the first sentence. The ordinary has cracked.' },
        { mode: 'Object-first', directive: 'Open with a world-specific object, material, or custom that does not exist on Earth. Do not explain it. Let it anchor the scene and reveal the world through use.' }
    ];
    const selectedOpening = openingModes[Math.floor(Math.random() * openingModes.length)];

    // 5TH PERSON POV CONTRACT INJECTION (locked, non-editable)
    const fifthPersonContract = build5thPersonContract();

    // EROTIC ESCALATION BLOCK (Erotic/Dirty intensity only)
    const eroticEscalationBlock = buildEroticEscalationBlock();

    // TONE ENFORCEMENT BLOCK (all tones)
    const toneEnforcementBlock = buildToneEnforcementBlock(state.picks?.tone);

    const introPrompt = `${fifthPersonContract}${eroticEscalationBlock}${toneEnforcementBlock}Write the opening scene (500-600 words). This is the LONGEST scene in the story â€” take your time establishing world and character.
${authorOpeningDirective}
OPENING MODE: ${selectedOpening.mode}
${selectedOpening.directive}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
UNIVERSAL WORLD-SEEDING (MANDATORY â€” ALL STORIES)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
The opening scene must feel IMPOSSIBLE to relocate to another world without breaking immersion.
This applies to ALL genres, ALL tones, ALL settings.

CORE REQUIREMENT:
Include AT LEAST 6 world-specific elements, drawn from AT LEAST 3 different categories below.
Introduce them CASUALLY, WITHOUT explanation â€” they are ordinary facts of life to the characters.

CATEGORIES (choose 3+ per opening):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
A. SLANG, IDIOMS, OR SHORTHAND unique to this world
   Example: "She'd been marked riven since the Quiet Year" â€” never define "riven" or "Quiet Year."

B. INSTITUTIONS, AUTHORITIES, FACTIONS, OR POWER STRUCTURES
   A tax collector, a curfew, a forbidden district, a title that carries weight, a uniform that means something.
   Show through behavior, not explanation.

C. OBJECTS, TOOLS, MATERIALS, OR RESOURCES characteristic of the setting
   Not "a knife" but "a veinglass blade." Not "lantern" but "a caged spark-moth."

D. LOCATIONS OR PLACE-NAMES implying a larger system
   Not "the city" but "the Lower Tithe." Not "downtown" but "the Ash Quarter."

E. PROFESSIONS, ROLES, OR SOCIAL FUNCTIONS specific to this society
   Not "guard" but "a Thread-warden." Not "doctor" but "a marrow-knitter."

F. CUSTOMS, RITUALS, OR UNSPOKEN RULES
   Behaviors characters perform without explaining why â€” greetings, gestures, taboos.

G. ECONOMIC, CLASS, OR POWER DYNAMICS taken for granted
   Debts owed to specific entities, trade goods unique to this world, labor systems implied.

NON-NEGOTIABLE RULES:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ— Do NOT explain or define these elements
âœ— Do NOT italicize or spotlight them
âœ— Do NOT pause the narrative to clarify meaning
âœ“ Treat them as ordinary facts of life to the characters
âœ“ Let meaning be inferred through context alone

SUBSTITUTION RULE (CRITICAL):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Whenever a GENERIC or EARTH-NEUTRAL noun appears (food, money, street, job, authority, weapon, transport, fruit, drink, law, crowd):
â†’ REPLACE it with a world-specific equivalent unless realism explicitly requires otherwise.
âœ— "pomegranate" â†’ âœ“ "a heat-veined emberfruit from the Collective orchards"
âœ— "money" â†’ âœ“ "a handful of bone-chips" or "three unmarked debts"
âœ— "the police" â†’ âœ“ "the Silence" or "a Warden-cadre"

QUALITY GATE (FAILURE CONDITION):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
If this opening scene could be relocated to modern Earth with only name changes, it has FAILED.
If failure detected: REWRITE the opening scene entirely. Do NOT proceed. Do NOT ask for clarification.

TEXTURE OVER SUMMARY:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
No narrator voice summarizing the protagonist's life or situation.
Enter mid-scene. The reader should feel dropped into an ongoing life that existed before page one.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FIRST SECTION RULES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
- ${pacingRule}
- Focus on: World texture, protagonist in motion or decision, atmospheric specificity.
${liAppears ? '- The love interest may appear briefly or be hinted at â€” but not as the focus.' : '- The love interest should NOT appear yet. Build anticipation through absence.'}
- End with a hook, a question, or atmospheric tension â€” NOT a romantic moment, NOT a cliffhanger about romance.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
HARD-BANNED OPENINGS (DO NOT USE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
These settings are BANNED as default openings UNLESS the world's power structure explicitly requires them:
- Bustling marketplace with vendors calling out
- Tavern or inn with a fire crackling
- Neutral public squares as default "liveliness"
- Any crowd scene used merely for atmosphere

These are ALWAYS banned regardless of world:
- Lone woman in solitude staring out a window
- Rain-lashed windows or fog-wreathed atmospherics
- Characters passively observing weather, mist, or shadow
- Quiet interiors awaiting intrusion
- Waking up, getting dressed, looking in a mirror
- Flashback or memory before the present scene is established

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POV REMINDER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${state.povMode === 'author5th' ?
`5TH PERSON (THE AUTHOR) â€” POV REGIME:
The Author is a PARTICIPANT, not a controller. The Author REACTS and COMMENTS, never CAUSES.
The Author influences meaning, tone, implication â€” not plot mechanics or outcomes.
BANNED verbs: watched, saw, observed, arranged, orchestrated, caused, steered, forced, ensured.
ALLOWED verbs: smiled, sensed, felt, knew, hoped, feared, delighted, despaired, mused, ached, teased.
The Author has feelings about what unfolds â€” anticipation, delight, worry, regret.`
: 'Use the selected POV consistently throughout.'}

The opening must feel intentional, textured, and strange. Not archetypal. Not templated. Specific to THIS world.`;

    // FATE STUMBLED DIAGNOSTIC - Structured payload logging
    // RUNTIME NORMALIZATION: Ancestry/DSP inputs flow through ChatGPT normalization layer
    // PASS 9D FIX: Wrap ancestry normalization in try/catch to prevent hang
    const rawAncestryPlayer = $('ancestryInputPlayer')?.value.trim() || '';
    const rawAncestryLI = $('ancestryInputLI')?.value.trim() || '';
    const worldContext = state.picks?.world ? [state.picks.world] : [];
    try {
        const ancestryPlayerNorm = await callNormalizationLayer({
            axis: 'dsp',
            user_text: rawAncestryPlayer,
            context_signals: worldContext
        });
        const ancestryLINorm = await callNormalizationLayer({
            axis: 'dsp',
            user_text: rawAncestryLI,
            context_signals: worldContext
        });
        // Reassign with normalized values (variables declared earlier with let)
        ancestryPlayer = ancestryPlayerNorm.normalized_text || rawAncestryPlayer;
        ancestryLI = ancestryLINorm.normalized_text || rawAncestryLI;
    } catch (ancestryNormError) {
        console.error('[ANCESTRY NORMALIZATION ERROR]', ancestryNormError);
        // Fallback: Use raw ancestry values if normalization fails
        ancestryPlayer = rawAncestryPlayer;
        ancestryLI = rawAncestryLI;
    }
    archetypeDirectives = buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen);

    // Determine unlock tier (reassign)
    quillUnlocked = state.subscribed || state.godModeActive || (state.storyId && hasStoryPass(state.storyId));
    let tier = 'free';
    if (state.subscribed) tier = 'subscribed';
    else if (quillUnlocked) tier = 'quill_unlocked';
    else if (state.storyId && hasStoryPass(state.storyId)) tier = 'story_unlocked';

    // Build structured payload for diagnostic (4-axis system)
    const diagnosticPayload = {
        mode: state.mode || 'solo',
        tier: tier,
        fourAxis: {
            world: state.picks.world || 'Modern',
            era: state.picks.world === 'Historical' ? (state.picks.era || 'Medieval') : null,
            tone: state.picks.tone || 'Earnest',
            genre: state.picks.genre || 'Billionaire',
            dynamic: state.picks.dynamic || 'Enemies'
        },
        archetype: {
            primary: state.archetype.primary || null,
            modifier: state.archetype.modifier || null,
            directives: archetypeDirectives || '(none built)'
        },
        ancestry: {
            yours: ancestryPlayer || '(empty)',
            storybeau: ancestryLI || '(empty)'
        },
        quill: {
            unlocked: quillUnlocked,
            directives: quillUnlocked ? (state.quillIntent || '(none this turn)') : '(LOCKED - not injected)'
        },
        veto: {
            bannedWords: state.veto?.bannedWords || [],
            tone: state.veto?.tone || []
        },
        intensity: state.intensity || 'Naughty',
        pov: state.picks.pov || 'First',
        storyLength: state.storyLength || 'tease',
        systemPromptLength: state.sysPrompt?.length || 0
    };

    // Log the full payload
    console.group('STORYBOUND FINAL PROMPT PAYLOAD');
    console.log(diagnosticPayload);
    console.groupEnd();

    // VALIDATION GUARD - Check all required fields before model call
    function validatePayload(payload) {
        const errors = [];

        // Required field checks
        if (!payload.mode) errors.push('Mode is undefined');

        // Four-axis validation (world, tone, genre, dynamic)
        const { world, tone, genre, dynamic } = payload.fourAxis || {};
        if (!world) errors.push('World is missing or empty');
        if (!tone) errors.push('Tone is missing or empty');
        if (!genre) errors.push('Genre is missing or empty');
        if (!dynamic) errors.push('Relationship Dynamic is missing or empty');

        if (!payload.archetype.primary) errors.push('Primary Archetype not selected (default: Beautiful Ruin)');
        if (!payload.intensity) errors.push('Intensity is undefined');
        if (!payload.pov) errors.push('POV is undefined');
        if (payload.systemPromptLength === 0) errors.push('System prompt is empty (critical failure)');

        // Check for null/undefined in directive arrays
        if (payload.veto.bannedWords.some(w => w === null || w === undefined)) {
            errors.push('Veto bannedWords array contains null/undefined');
        }
        if (payload.veto.tone.some(t => t === null || t === undefined)) {
            errors.push('Veto tone array contains null/undefined');
        }

        // Check archetype directives actually built
        if (payload.archetype.directives === '(none built)' || !payload.archetype.directives) {
            errors.push('Archetype directives failed to build');
        }

        return errors;
    }

    const payloadErrors = validatePayload(diagnosticPayload);

    if (payloadErrors.length > 0) {
        console.group('STORYBOUND VALIDATION FAILED');
        console.error('Errors:', payloadErrors);
        console.log('Payload at failure:', diagnosticPayload);
        console.groupEnd();

        stopLoading();
        const errorMessage = `Story setup incomplete: ${payloadErrors[0]}`;
        showToast(errorMessage);
        console.error('FATE STUMBLED PREVENTED:', errorMessage);
        window.showScreen('setup');
        return;
    }

    console.log('STORYBOUND VALIDATION PASSED - Proceeding to model call');

    try {
        let text = await callChat([
            {role:'system', content: state.sysPrompt},
            {role:'user', content: introPrompt}
        ]);

        // ============================================================
        // PROSE REFUSAL GATE â€” ATOMIC SCENE CREATION GUARD
        // ============================================================
        // Check IMMEDIATELY after callChat â€” before any validation/repair.
        // OUTPUT_TOO_SHORT is NON-FATAL for Scene 1 (mark as low density, continue)
        // Other refusals still abort to prevent invalid content.
        const refusalCheck = detectProseRefusal(text);
        if (refusalCheck.isRefusal) {
            // OUTPUT_TOO_SHORT is non-fatal â€” accept prose, mark as low density, continue
            if (refusalCheck.reason === 'OUTPUT_TOO_SHORT') {
                console.warn('[ProseRefusal:Scene1] Output short but accepting (low density):', text?.slice(0, 200));
                state._scene1LowDensity = true; // Mark for downstream awareness
                // Continue with the short output â€” do NOT throw
            } else {
                // Other refusals (EMPTY_OUTPUT, REFUSAL_MARKER, etc.) still abort
                console.error('[ProseRefusal] Scene 1 generation refused:', refusalCheck.reason);
                console.error('[ProseRefusal] Raw output:', text?.slice(0, 200));
                throw new ProseRefusalError(refusalCheck.reason, text);
            }
        }

        // ============================================================
        // 5TH PERSON POV â€” SCENE 1 EXCEPTION (NO FORCED REGENERATION)
        // ============================================================
        // Scene 1 has ALL checks as SOFT (warnings only) to prevent deadlock:
        // - No HARD violations for Scene 1
        // - No forced regeneration for POV issues
        // - Accept prose and log warnings
        // - Strict enforcement resumes at Scene 2+
        // ============================================================
        if (state.povMode === 'author5th') {
            // Repair voyeur verbs (always safe, no regeneration needed)
            text = await repair5thPersonPOV(text);

            // Run ALL validation checks â€” Scene 1 returns only warnings, no violations
            const povCheck = validate5thPersonPOV(text, true, false); // isSceneOne=true, isErotic=false
            const authorRoleCheck = validateFifthPersonAuthorRole(text, 1);
            const strictCheck = enforceStrict5thPersonPOV(text, 1, state.picks?.tone);

            // Collect all warnings (Scene 1 has no HARD violations by design)
            const allWarnings = [
                ...(povCheck.warnings || []),
                ...(authorRoleCheck.warnings || []),
                ...(strictCheck.warnings || []),
                ...povCheck.violations.map(v => 'DOWNGRADED:' + v),
                ...authorRoleCheck.violations.map(v => 'DOWNGRADED:' + v),
                ...strictCheck.violations.map(v => 'DOWNGRADED:' + v)
            ];

            // Log all warnings (advisory only â€” Scene 1 never blocks on POV)
            if (allWarnings.length > 0) {
                console.log('[5thPerson:Scene1] POV warnings (non-blocking, strict enforcement at Scene 2+):', allWarnings);
            } else {
                console.log('[5thPerson:Scene1] All POV checks passed on first attempt');
            }

            // NO REGENERATION FOR SCENE 1 â€” Accept prose as-is
            // This prevents the deadlock: POV fail â†’ regenerate â†’ OUTPUT_TOO_SHORT â†’ abort
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 5TH-PERSON FATE VOICE ENFORCEMENT (Scene 1 â€” SOFT CHECK)
        // Scene 1: Log warnings only, no forced regeneration (prevents deadlock)
        // Scene 2+: Full enforcement with auto-regeneration
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const fateVoiceCheck = validateFateVoice(text);
        if (fateVoiceCheck.shouldRegenerate) {
            // Scene 1: Log as warning only, do NOT regenerate
            console.warn('[FateVoice:Scene1] Violations detected (non-blocking for Scene 1):', fateVoiceCheck.violations);
            console.log('[FateVoice:Scene1] Strict enforcement resumes at Scene 2+');
            // Do NOT regenerate â€” accept prose as-is to prevent deadlock
        } else if (fateVoiceCheck.fateCount > 0) {
            console.log('[FateVoice:Scene1] Fate appears', fateVoiceCheck.fateCount, 'time(s) â€” within bounds');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INTIMACY & CONSENT FAILSAFE (Scene 1 â€” FULL ENFORCEMENT)
        // Scene 1 should never have explicit content (ST1 = Attraction Acknowledged)
        // Consent system leaks are always critical â€” must regenerate
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const scene1Storyturn = 'ST1'; // Scene 1 is always ST1
        const scene1IntimacyCheck = validateIntimacyConsent(text, state.intensity, scene1Storyturn);
        if (scene1IntimacyCheck.shouldRegenerate) {
            console.warn('[IntimacyFailsafe:Scene1] Violations detected, regenerating silently...');
            console.warn('[IntimacyFailsafe:Scene1] Violations:', scene1IntimacyCheck.violations);

            // Build enforcement prompt for silent regeneration
            const scene1IntimacyPrompt = buildIntimacyFailsafePrompt(scene1IntimacyCheck.violations);

            // Silent regeneration
            text = await callChat([
                { role: 'system', content: state.sysPrompt + scene1IntimacyPrompt },
                { role: 'user', content: introPrompt }
            ]);

            // REFUSAL GATE: Check regeneration output
            const intimacyRefusal = detectProseRefusal(text);
            if (intimacyRefusal.isRefusal) {
                console.error('[ProseRefusal] Intimacy failsafe regeneration refused:', intimacyRefusal.reason);
                throw new ProseRefusalError(intimacyRefusal.reason, text);
            }

            // Validate regenerated output (one retry only)
            const scene1IntimacyRecheck = validateIntimacyConsent(text, state.intensity, scene1Storyturn);
            if (scene1IntimacyRecheck.shouldRegenerate) {
                console.error('[IntimacyFailsafe:Scene1] Regeneration still failed, accepting with warning:', scene1IntimacyRecheck.violations);
            } else {
                console.log('[IntimacyFailsafe:Scene1] Regeneration successful');
            }
        }

        // VOCABULARY BAN ENFORCEMENT â€” story opener prose
        text = await enforceVocabularyBans(
            text,
            { type: 'prose', isFatePOV: state.povMode === 'author5th' },
            async (negConstraint) => {
                return await callChat([
                    { role: 'system', content: state.sysPrompt + negConstraint },
                    { role: 'user', content: introPrompt }
                ]);
            }
        );

        // ============================================================
        // NARRATIVE AUTHORITY VALIDATION (Scene 1 â€” Runs FIRST, before Tone/POV)
        // ============================================================
        const scene1NarrCheck = validateNarrativeAuthority(text);
        _lastNarrativeAuthorityValidation = {
            valid: scene1NarrCheck.valid,
            errors: scene1NarrCheck.errors,
            timestamp: Date.now()
        };
        if (!scene1NarrCheck.valid) {
            console.log('[NarrativeAuthority] Scene 1 validation failed:', scene1NarrCheck.errors);
            // Regenerate with Narrative Authority enforcement
            const narrAuthPrompt = buildNarrativeAuthorityBlock() +
                '\n\nREGENERATION REQUIRED â€” Previous output violated Narrative Authority:\n- ' +
                scene1NarrCheck.errors.map(e => `${e.code}: ${e.match}`).join('\n- ') +
                '\n\n' + introPrompt;
            text = await callChat([
                { role: 'system', content: state.sysPrompt },
                { role: 'user', content: narrAuthPrompt }
            ]);
            // REFUSAL GATE: Check regeneration output
            const narrRefusal = detectProseRefusal(text);
            if (narrRefusal.isRefusal) {
                console.error('[ProseRefusal] Narrative authority regeneration refused:', narrRefusal.reason);
                throw new ProseRefusalError(narrRefusal.reason, text);
            }
            console.warn('[NarrativeAuthorityFail] Scene 1 regenerated due to:', scene1NarrCheck.errors.map(e => e.code));
        }

        // EROTIC ESCALATION VALIDATION (Scene 1)
        if (['Erotic', 'Dirty'].includes(state.intensity)) {
            const escalationCheck = validateEroticEscalation(text, state.intensity);
            if (!escalationCheck.valid) {
                console.log('[EroticEscalation] Validation failed:', escalationCheck.violations);
                console.log('[EroticEscalation] Metrics:', escalationCheck.metrics);
                // Regenerate with explicit escalation notice
                const escalationPrompt = EROTIC_ESCALATION_BLOCK +
                    (state.intensity === 'Dirty' ? DIRTY_ESCALATION_ADDENDUM : '') +
                    '\n\nREGENERATION REQUIRED â€” Previous output failed escalation check:\n- ' +
                    escalationCheck.violations.join('\n- ') +
                    '\n\nYou MUST include more sensory grounding (breath, skin, heat, touch) and bodily contradiction (restraint vs reaction).\n\n' + introPrompt;
                text = await callChat([
                    { role: 'system', content: state.sysPrompt },
                    { role: 'user', content: escalationPrompt }
                ]);
                // REFUSAL GATE: Check regeneration output
                const escRefusal = detectProseRefusal(text);
                if (escRefusal.isRefusal) {
                    console.error('[ProseRefusal] Erotic escalation regeneration refused:', escRefusal.reason);
                    throw new ProseRefusalError(escRefusal.reason, text);
                }
                // Log result to Dev HUD
                console.warn('[EroticEscalationFail] Scene 1 regenerated due to:', escalationCheck.violations);
            }
        }

        // TONE VALIDATION (Scene 1 â€” all stories)
        const currentTone = state.picks?.tone || 'Earnest';
        const toneCheck = validateTone(text, currentTone);
        if (!toneCheck.valid) {
            console.log('[ToneDrift] Validation failed:', toneCheck.violations);
            console.log('[ToneDrift] Metrics: found', toneCheck.matchCount, 'markers, need', toneCheck.required);
            // Regenerate with explicit tone enforcement
            const tonePrompt = buildToneEnforcementBlock(currentTone) +
                '\n\nREGENERATION REQUIRED â€” Tone selected but not present in language:\n- ' +
                toneCheck.violations.join('\n- ') +
                '\n\n' + introPrompt;
            text = await callChat([
                { role: 'system', content: state.sysPrompt },
                { role: 'user', content: tonePrompt }
            ]);
            // REFUSAL GATE: Check regeneration output
            const toneRefusal = detectProseRefusal(text);
            if (toneRefusal.isRefusal) {
                console.error('[ProseRefusal] Tone regeneration refused:', toneRefusal.reason);
                throw new ProseRefusalError(toneRefusal.reason, text);
            }
            console.warn('[ToneDriftDetected] Scene 1 regenerated for tone:', currentTone);
        }

        // ============================================================
        // TITLE GENERATION PIPELINE (LOCKED)
        // Mode selection â†’ Continuation routing â†’ Generation â†’ Validation â†’ Fallback â†’ Immutability
        // ============================================================

        // Initialize world instance if not set
        if (!state.worldInstanceId) {
            state.worldInstanceId = generateWorldInstanceId();
        }

        // STEP 1: Route title generation based on continuation path
        const continuationPath = state.continuationPath || CONTINUATION_PATHS.NEW_STORY;
        const titleRouting = routeTitleGeneration(continuationPath, {
            world: state.picks?.world || 'Modern',
            arousal: state.intensity || 'Naughty',
            genre: state.picks?.genre || 'Romance',
            tone: state.picks?.tone || 'Earnest'
        });

        const selectedMode = titleRouting.mode;
        const titlePrompt = titleRouting.prompt;
        console.log('[TitlePipeline] Path:', continuationPath, '| Mode:', selectedMode);

        // STEP 2: Generate title with path-specific prompt
        let title = await callChat([{role:'user', content:`Based on this opening, generate a title.

${titlePrompt}

Story opening for context:
${text.slice(0, 500)}`}]);

        // STEP 3: Vocabulary ban enforcement
        title = await enforceVocabularyBans(
            title,
            { type: 'title', isFatePOV: false },
            async (negConstraint) => {
                return await callChat([{role:'user', content:`Generate a title in ${selectedMode} mode.

${titlePrompt}
${negConstraint}

Story opening for context:
${text.slice(0, 500)}`}]);
            }
        );

        // STEP 4: Apply world-marking for SAME_WORLD path
        if (titleRouting.worldMarked && titleRouting.worldName) {
            title = buildWorldMarkedTitle(
                title.replace(/"/g, '').trim(),
                titleRouting.worldName,
                titleRouting.suffix
            );
            console.log('[TitlePipeline] World-marked title:', title);
        }

        // STEP 5: Full pipeline validation
        const titleCheck = validateTitle(
            title,
            state.picks?.tone,
            state.intensity || 'Naughty',
            { world: state.picks?.world, genre: state.picks?.genre }
        );

        // STEP 6: Continuation-specific validation
        const continuationCheck = validateContinuationTitle(title, continuationPath, {
            previousTitle: state.previousTitle,
            worldName: state.worldName,
            priorNouns: state._priorWorldNouns || []
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TITLE VALIDATION â€” ADVISORY ONLY (AUTHORITATIVE)
        // Validation flags issues but does NOT replace the title
        // Original title is preserved regardless of validation outcome
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!titleCheck.valid || !continuationCheck.valid) {
            const allErrors = [...(titleCheck.errors || []), ...(continuationCheck.errors || [])];
            console.warn('[TitleValidation:ADVISORY] Issues detected (title preserved):', allErrors.map(e => e.message));
            console.log('[TitleValidation:ADVISORY] Detected mode:', titleCheck.mode);
            console.log('[TitleValidation:ADVISORY] Original title kept:', title);
            // Title is NOT replaced â€” advisory flagging only
        } else {
            console.log('[TitleValidation] PASS â€” Mode:', titleCheck.mode);
        }

        // STEP 8: Store baseline arousal and title for immutability + future continuations
        state.titleBaselineArousal = state.intensity || 'Naughty';
        state.immutableTitle = title.replace(/"/g, '').trim();
        state.previousTitle = state.immutableTitle;
        state.previousTitleMode = selectedMode;

        // Clear continuation path after use
        state.continuationPath = null;
        state._priorWorldNouns = null;

        // SYNOPSIS GENERATION RULE (AUTHORITATIVE)
        let synopsis = await callChat([{role:'user', content:`Write a 1-2 sentence synopsis (story promise) for this opening.

MANDATORY REQUIREMENTS â€” All three must be present:
1. A SPECIFIC CHARACTER with agency (e.g., "a hedge-witch on the brink of exile" â€” not just "one woman")
2. A DESIRE or TEMPTATION â€” something they want, fear wanting, or are being pulled toward
3. A LOOMING CONFLICT or CONSEQUENCE â€” a force, choice, or cost that threatens to change them

QUALITY CHECK â€” Before writing, answer internally:
- Who wants something?
- What do they want (or are tempted by)?
- What stands in the way, or what will it cost?

FORBIDDEN PATTERNS:
- Abstract noun collisions ("grit aches against ambition")
- Redundant metaphor stacking ("veiled shadows," "shrouded ambitions" together)
- Emotion verbs without bodies ("aches," "burns" without physical anchor)
- Mood collage without narrative motion

ALLOWED:
- Poetic language ONLY when attached to concrete agents or actions
- One central metaphor family maximum
- Present tense preferred

The reader should think: "I want to see what happens when this desire meets resistance."
NOT: "This sounds pretty."

Return ONLY the synopsis sentence(s), no quotes:\n${text}`}]);

        // VOCABULARY BAN ENFORCEMENT â€” synopsis
        synopsis = await enforceVocabularyBans(
            synopsis,
            { type: 'synopsis', isFatePOV: false },
            async (negConstraint) => {
                return await callChat([{role:'user', content:`Write a 1-2 sentence synopsis (story promise) for this opening.

MANDATORY: A specific character + a desire + a looming conflict.
${negConstraint}
Return ONLY the synopsis sentence(s), no quotes:\n${text}`}]);
            }
        );

        // CORRECTIVE: Set title first (synopsis lives ONLY on inside cover flyleaf)
        const titleEl = document.getElementById('storyTitle');
        const storyTextEl = document.getElementById('storyText');

        // Hide story text until fully rendered
        if (storyTextEl) storyTextEl.style.opacity = '0';

        const cleanTitle = title.replace(/"/g,'');
        titleEl.textContent = cleanTitle;

        // BOOK FLOW SPEC: Synopsis rendered ONLY on inside cover, never in pagination
        // Inside cover = title + synopsis (white paper)
        // Setting plate = visual only (setting image)
        // Scene pages = title + text only (via StoryPagination)
        state._synopsisMetadata = synopsis; // Store for inside cover + cover generation

        // ============================================================
        // FINAL ATOMIC GATE â€” Scene creation only if prose is valid
        // ============================================================
        // This is the LAST CHECK before scene content is stored.
        // If refusal detected here, something slipped through earlier gates.
        const finalRefusalCheck = detectProseRefusal(text);
        if (finalRefusalCheck.isRefusal) {
            console.error('[ATOMIC GATE] FINAL refusal check caught invalid prose:', finalRefusalCheck.reason);
            throw new ProseRefusalError(finalRefusalCheck.reason, text);
        }

        // Use pagination system for story display
        StoryPagination.init();
        StoryPagination.clear();
        StoryPagination.addPage(formatStory(text), true);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STORY TEXT READY â€” Signal that Scene 1 can be displayed
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        resolveStoryTextReady();

        // Go directly to Scene 1 (skip synopsis page)
        advanceReaderPage();

        // OPENING SPREAD COMPOSITION: Populate inside cover with title + synopsis
        // Page 1 (inside cover) = paper background + title + synopsis (NO image generation)
        // Page 2+ (scene) = scene text with setting image INLINE if present
        const insideCover = document.getElementById('bookInsideCover');
        if (insideCover) {
            console.log('[DEBUG PAGE MOUNT] insideCoverContent: _bookPageIndex=', _bookPageIndex, 'pageType=insideCover', 'container=', insideCover.id);
            insideCover.innerHTML = `
                <div class="inside-cover-content">
                    <h1 class="inside-cover-title">${cleanTitle}</h1>
                    <p class="inside-cover-synopsis">${synopsis}</p>
                </div>
            `;
        }

        // ============================================================
        // PHASE 1 COVER GATE â€” NO NETWORK CALLS DURING BEGIN STORY
        // coverMode === 'PHASE_1_FORGED': local assets only, deterministic, synchronous
        // Custom (model-based) cover ONLY when coverEligibility === true
        // ============================================================
        const authorDisplayName = state.coverAuthor || 'Anonymous';

        // CONTROL-FLOW INVARIANT: Cover generation is DECORATIVE and must NEVER block page mounting
        // Defer all cover logic to next tick to ensure pages are fully mounted first
        setTimeout(() => {
            // FENCE: PHASE_1_FORGED fallback applies ONLY when page type is COVER (index 0)
            console.log('[DEBUG PAGE STATE] cover setTimeout: _bookPageIndex=', _bookPageIndex, 'coverMode=', state.coverMode);
            if (_bookPageIndex !== 0) return;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MINIMAL COVER v1 GUARD â€” Skip PHASE_1_FORGED fallback entirely
            // When v1 is active, cover comes ONLY from generateMinimalCoverV1()
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (USE_MINIMAL_COVER_V1) {
                console.log('[COVER:v1] Skipping PHASE_1_FORGED fallback â€” Minimal Cover owns cover');
                return;
            }

            if (state.coverMode === 'PHASE_1_FORGED' || state.coverEligibility !== true) {
                // PHASE 1: Render local fallback cover (no API call)
                console.log('[BookCover] PHASE_1_FORGED mode â€” using local fallback cover');
                renderFallbackCover(state.picks?.world, state.picks?.genre, cleanTitle);
                stopCoverLoading(null);
                applyCoverIntensityLayers(state.intensity, state.picks?.world);
            } else {
                // CUSTOM COVER PATH (gated â€” only when coverEligibility === true)
                generateBookCover(synopsis, cleanTitle, authorDisplayName).then(coverUrl => {
                    if (coverUrl) {
                        stopCoverLoading(coverUrl);
                    } else {
                        // Cover generation failed â€” render fallback (never skip)
                        console.warn('[BookCover] Failed to generate, rendering fallback cover');
                        renderFallbackCover(state.picks?.world, state.picks?.genre, cleanTitle);
                        stopCoverLoading(null);
                    }
                    applyCoverIntensityLayers(state.intensity, state.picks?.world);
                });
            }
        }, 0);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SETTING IMAGE: Disabled auto-generation
        // Setting images only generate on explicit user request
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Story text reveal is handled by cover page flow
        // (user clicks "Open Your Story" to see content)

        // Initial Snapshot
        saveStorySnapshot();
        
        if(state.mode === 'couple') {
           broadcastTurn(text, true); 
        }

    } catch(e) {
        // ============================================================
        // PROSE REFUSAL ERROR â€” ATOMIC ABORT (no book, no scene)
        // ============================================================
        if (e instanceof ProseRefusalError) {
            console.group('STORYBOUND PROSE REFUSAL - SCENE NOT CREATED');
            console.error('Refusal reason:', e.reason);
            console.error('Raw output (first 300 chars):', e.rawOutput?.slice(0, 300));
            console.groupEnd();

            // DO NOT render fallback cover
            // DO NOT call stopCoverLoading (would show book object)
            // DO NOT create scene â€” state.text remains unchanged
            // Hide loading state and return to setup
            const loadingState = document.getElementById('coverLoadingState');
            if (loadingState) loadingState.classList.add('hidden');

            alert("Story generation was declined. Please try different settings.");
            window.showScreen('setup');
            return; // Exit early â€” finally block still runs
        }

        // ============================================================
        // HTTP 429 RATE LIMIT â€” TERMINAL FAILURE, NO RETRY
        // ============================================================
        if (e instanceof RateLimitError || e?.isRateLimit) {
            console.group('STORYBOUND RATE LIMITED - TERMINAL FAILURE');
            console.error('Endpoint:', e.endpoint);
            console.error('Retry-After:', e.retryAfter || 'not specified');
            console.groupEnd();

            // DO NOT render fallback cover
            // DO NOT call stopCoverLoading (would show book object)
            // DO NOT create scene â€” state remains unchanged
            // DO NOT trigger any secondary async calls
            // Hide loading state and return to setup
            const loadingState = document.getElementById('coverLoadingState');
            if (loadingState) loadingState.classList.add('hidden');

            // Surface recoverable error â€” require explicit user action
            alert("Rate limited. Please wait a moment and try again.");
            window.showScreen('setup');
            return; // Exit early â€” finally block still runs
        }

        // Generic API/network errors
        console.group('STORYBOUND FATE STUMBLED - API ERROR');
        console.error('Error object:', e);
        console.error('Error message:', e?.message || '(no message)');
        console.error('Error stack:', e?.stack || '(no stack)');
        console.log('System prompt length at failure:', state.sysPrompt?.length || 0);
        console.log('Intro prompt length at failure:', introPrompt?.length || 0);
        console.groupEnd();

        // Clean up cover page state on error â€” render fallback (never skip)
        renderFallbackCover(state.picks?.world, state.picks?.genre);
        stopCoverLoading(null);
        applyCoverIntensityLayers(state.intensity, state.picks?.world);

        alert("Fate stumbled. Please try again. (Check console for diagnostics)");
        window.showScreen('setup');
    } finally {
        stopLoading();
        // Deal fresh fate cards for first turn
        if(window.dealFateCards) window.dealFateCards();
        else if(window.initCards) window.initCards();
        // PERMANENT FX REBIND: Ensure fate cards have handlers after story generation
        if (window.initFateCards) window.initFateCards();
        updateQuillUI();
        updateBatedBreathState();
    }
  });

  // --- API CALLS ---
  /**
   * ==========================================================================
   * STORY GENERATION API CALL
   * ==========================================================================
   *
   * This function routes story generation through the appropriate AI model(s).
   *
   * When ENABLE_ORCHESTRATION is true:
   * - Uses the orchestration client (ChatGPT primary author + optional Grok renderer)
   * - Enforces the canonical call order: ChatGPT â†’ Grok â†’ ChatGPT
   *
   * HARD RULE: Story authoring ONLY uses ChatGPT (PRIMARY_AUTHOR).
   * Grok must NEVER be called for DSP, normalization, veto, or story logic.
   *
   * ==========================================================================
   */
  async function callChat(messages, temp=0.7, options = {}) {
    // LOCKED: Story authoring routes through ChatGPT orchestration ONLY
    if (!window.StoryboundOrchestration) {
      throw new Error('[MODEL WIRING] Orchestration client not loaded. ChatGPT required for story authoring.');
    }

    // SINGLE-FLIGHT LOCK: Only one prose generation at a time
    if (_proseGenerationInFlight) {
      console.warn('[PROSE] Request blocked â€” another prose generation in flight');
      throw new Error('Prose generation blocked: request already in flight');
    }

    _proseGenerationInFlight = true;

    try {
      return await window.StoryboundOrchestration.callChatGPT(
        messages,
        'PRIMARY_AUTHOR',
        { temperature: temp, max_tokens: options.max_tokens || 1000 }
      );
    } catch (orchestrationError) {
      // CHECK FOR HTTP 429 IN ERROR MESSAGE â€” TERMINAL FAILURE
      const errMsg = orchestrationError?.message || '';
      if (errMsg.includes('429') || errMsg.toLowerCase().includes('rate limit') || errMsg.includes('too many requests')) {
        console.error('[RATE_LIMIT] Detected 429 in orchestration error:', errMsg);
        throw new RateLimitError('prose-generation', null);
      }

      // NO GROK FALLBACK - Story authoring must use ChatGPT
      console.error('[MODEL WIRING] ChatGPT failed. No Grok fallback for story logic:', orchestrationError.message);
      throw new Error(`Story generation failed: ${orchestrationError.message}. Grok cannot be used for story authoring.`);
    } finally {
      // RELEASE SINGLE-FLIGHT LOCK
      _proseGenerationInFlight = false;
    }
  }

  /**
   * ==========================================================================
   * ORCHESTRATED TURN GENERATION
   * ==========================================================================
   *
   * Executes the full 3-phase orchestration flow for story generation:
   *
   * PHASE 1: ChatGPT Author Pass (ALWAYS RUNS)
   *   - Plot beats, character psychology, dialogue intent
   *   - Determines if intimacy occurs
   *   - Generates Erotic Scene Directive (ESD) if needed
   *   - Enforces monetization gates
   *
   * PHASE 2: Specialist Renderer (CONDITIONAL)
   *   - Called ONLY if ESD warrants it (Erotic/Dirty level)
   *   - Receives ONLY the ESD, no plot context
   *   - Renders sensory embodiment within bounds
   *   - NEVER decides outcomes
   *
   * PHASE 3: ChatGPT Integration Pass (ALWAYS RUNS)
   *   - Absorbs rendered scene
   *   - Applies consequences
   *   - Enforces cliffhanger or completion per tier
   *   - FINAL AUTHORITY on story state
   *
   * FAILURE HANDLING:
   *   - Renderer failure does NOT corrupt story state
   *   - ChatGPT regains control on failure
   *   - Fate Stumbled may be triggered
   *
   * ==========================================================================
   */
  async function generateOrchestatedTurn(params) {
    const {
      systemPrompt,
      storyContext,
      playerAction,
      playerDialogue,
      fateCard,
      onPhaseChange
    } = params;

    // Check if orchestration is available
    if (!window.StoryboundOrchestration) {
      console.warn('[ORCHESTRATION] Client not available, using legacy flow');
      // Fall back to legacy single-model call
      const messages = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Action: ${playerAction}\nDialogue: "${playerDialogue}"` }
      ];
      return await callChat(messages, 0.7, { bypassOrchestration: true });
    }

    // Execute full orchestration flow
    const result = await window.StoryboundOrchestration.orchestrateStoryGeneration({
      accessTier: state.access || 'free',
      requestedEroticism: state.intensity || 'Clean',
      storyContext: storyContext,
      playerAction: playerAction,
      playerDialogue: playerDialogue,
      fateCard: fateCard,
      systemPrompt: systemPrompt,
      onPhaseChange: onPhaseChange
    });

    // Log orchestration details
    console.log('[ORCHESTRATION] Turn complete:', {
      success: result.success,
      rendererUsed: result.rendererUsed,
      fateStumbled: result.fateStumbled,
      gateEnforcement: result.gateEnforcement,
      timing: result.timing,
      errors: result.errors
    });

    // Handle Fate Stumbled
    if (result.fateStumbled) {
      console.warn('[ORCHESTRATION] Fate Stumbled - specialist renderer failed');
      // Story continues with author output only
    }

    if (!result.success && result.errors.length > 0) {
      console.error('[ORCHESTRATION] Errors:', result.errors);
    }

    return result.finalOutput;
  }

  // Setting shot uses unified IMAGE PROVIDER ROUTER with landscape shape
  // Book cover / world-establishing illustration (NOT scene illustration)
  // TASK G: Ensure setting shot always reaches image generation
  async function generateSettingShot(desc) {
     _lastSettingShotDesc = desc; // Store for retry
     const img = document.getElementById('settingShotImg');
     const errDiv = document.getElementById('settingError');
     // TASK G: Log if DOM element missing (not silent gate)
     if(!img) {
         console.warn('[SettingShot] settingShotImg element not found - cannot render');
         return;
     }
     const wrap = document.getElementById('settingShotWrap');
     if(wrap) wrap.style.display = 'flex';
     img.onload = null; img.onerror = null;
     img.style.display = 'none';
     if(errDiv) {
         errDiv.textContent = 'Conjuring the scene...';
         errDiv.classList.remove('hidden');
         errDiv.style.color = 'var(--gold)';
     }

     // WORLD-FIRST PROMPT: Environment description, NOT characters/actions
     // Strip any intensity/quality/erotic language (PG-13/R mood only)
     const sanitizeForCover = (text) => {
         return text
             .replace(/\bINTENSITY:.*?(?=\n|$)/gi, '')
             .replace(/\bQUALITY:.*?(?=\n|$)/gi, '')
             .replace(/\b(sensual|erotic|nude|naked|explicit|sexual|intimate|seductive|provocative|lustful|aroused|passionate)\b/gi, '')
             .replace(/\s+/g, ' ')
             .trim();
     };

     // Cap at 256 chars without cutting mid-sentence
     const capWorldDesc = (text, maxLen = 256) => {
         const clean = sanitizeForCover(text);
         if (clean.length <= maxLen) return clean;
         const truncated = clean.substring(0, maxLen);
         const lastPeriod = truncated.lastIndexOf('.');
         const lastComma = truncated.lastIndexOf(',');
         const cutPoint = Math.max(lastPeriod, lastComma);
         return cutPoint > maxLen * 0.5 ? truncated.substring(0, cutPoint + 1).trim() : truncated.trim();
     };

     const worldDesc = capWorldDesc(desc);

     // Route through canonical setting visualize prompt
     const visualizeMode = 'setting';
     const settingPromptBase = buildVisualizePrompt({ mode: visualizeMode, lastText: '' });
     let prompt = settingPromptBase + '\n\n' + worldDesc;

     // VISUAL INTENT GUARD: Enforce balanced lighting for settings
     prompt = applyVisualIntentGuard(prompt, {
         tone: state.picks?.tone,
         world: state.picks?.world,
         intensity: state.intensity
     });

     let rawUrl = null;

     // Use unified IMAGE PROVIDER ROUTER with FALLBACK CHAIN
     // Setting shots use intent='setting' for Gemini primary â†’ OpenAI fallback
     try {
         rawUrl = await generateImageWithFallback({
             prompt: prompt,
             tier: 'Clean',
             shape: 'landscape',
             context: 'setting-shot',
             intent: 'setting'
         });
     } catch(e) {
         // All providers failed - logged by generateImageWithFallback
         console.warn('Setting shot: all providers exhausted', e.message);
     }

     if(rawUrl) {
         let imageUrl = rawUrl;
         if(!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
             imageUrl = `data:image/png;base64,${rawUrl}`;
         }
         img.src = imageUrl;

         // Add timeout for image load
         const loadTimeout = setTimeout(() => {
             img.style.display = 'none';
             if(errDiv) {
                 errDiv.innerHTML = 'The scene resists capture... <button onclick="window.retrySettingShot()" style="margin-left:10px; background:var(--gold); color:black; padding:5px 10px; border:none; border-radius:4px; cursor:pointer;">Retry</button>';
                 errDiv.style.color = '#ff6b6b';
                 errDiv.classList.remove('hidden');
             }
         }, 30000);

         img.onload = () => {
             clearTimeout(loadTimeout);
             img.style.display = 'block';
             if(errDiv) errDiv.classList.add('hidden');
         };
         img.onerror = () => {
             clearTimeout(loadTimeout);
             img.style.display = 'none';
             if(errDiv) {
                 errDiv.innerHTML = 'The scene resists capture... <button onclick="window.retrySettingShot()" style="margin-left:10px; background:var(--gold); color:black; padding:5px 10px; border:none; border-radius:4px; cursor:pointer;">Retry</button>';
                 errDiv.style.color = '#ff6b6b';
                 errDiv.classList.remove('hidden');
             }
         };
     } else {
         // All providers failed: non-blocking placeholder, story continues
         if(errDiv) {
             errDiv.innerHTML = 'The scene resists capture... <button onclick="window.retrySettingShot()" style="margin-left:10px; background:var(--gold); color:black; padding:5px 10px; border:none; border-radius:4px; cursor:pointer;">Retry</button>';
             errDiv.style.color = '#ff6b6b';
             errDiv.classList.remove('hidden');
         }
         // Story continues normally - no toast, no blocking
     }
  }

  window.retrySettingShot = function() {
      if (_lastSettingShotDesc) {
          generateSettingShot(_lastSettingShotDesc);
      }
  };

  // ============================================================
  // BOOK SCENE ART â€” Inline setting image for Scene 1 (page 2)
  // Distinct asset from cover. Uses imageIntent='setting'.
  // MUST render INLINE within scene content, NEVER fullscreen.
  // MUST NOT run on COVER (page 0) or INSIDE_COVER (page 1).
  // ============================================================
  async function generateBookSceneArt(synopsis) {
      // GUARD: Setting image is ONLY for Scene pages (page 2+)
      // Never generate for cover or inside cover
      console.log('[DEBUG PAGE STATE] generateBookSceneArt: _bookPageIndex=', _bookPageIndex);

      const sceneImg = document.getElementById('bookSceneImg');
      const loadingEl = document.getElementById('bookSceneLoading');
      console.log('[BookScene:DEBUG] ENTRY', {
          coverMode: state.coverMode,
          PHASE_1_FORGED: state.coverMode === 'PHASE_1_FORGED',
          sceneImgId: sceneImg?.id || null,
          sceneImgSrc: sceneImg?.src || null,
          sceneImgDisplay: sceneImg?.style?.display || null,
          loadingElId: loadingEl?.id || null,
          settingPlateId: document.getElementById('settingPlate')?.id || null
      });
      if (!sceneImg) {
          console.warn('[BookScene:DEBUG] EARLY_RETURN: bookSceneImg element not found');
          return;
      }

      const world = state.picks?.world || 'Modern';
      const era = state.picks?.world === 'Historical' ? (state.picks?.era || 'Medieval') : null;
      const worldLabel = era ? `${era} ${world}` : world;

      // Build a concise world-establishing description (symbolic only â€” no story prose)
      const tone = state.picks?.tone || 'Earnest';
      const desc = `${worldLabel} world. ${tone} atmosphere. A dramatic setting.`;

      let vistaPrompt = `${desc}

CRITICAL COMPOSITION RULES:
- This MUST be a WORLD VISTA image: landscape, environment, establishing shot.
- If ANY human figure appears, they MUST be facing AWAY, silhouette only.
- ABSOLUTELY FORBIDDEN: Portraits, faces, character close-ups, romantic poses.
- Camera position: Wide establishing shot, epic scale, environment is the subject.

Wide cinematic environment, atmospheric lighting, painterly illustration, no text, no watermark.`;

      // VISUAL INTENT GUARD: Enforce balanced lighting for scene art
      vistaPrompt = applyVisualIntentGuard(vistaPrompt, {
          tone: state.picks?.tone,
          world: state.picks?.world,
          intensity: state.intensity
      });

      try {
          const rawUrl = await generateImageWithFallback({
              prompt: vistaPrompt,
              tier: 'Clean',
              shape: 'landscape',
              context: 'book-scene-art',
              intent: 'setting'
          });
          console.log('[BookScene:DEBUG] AFTER_generateImageWithFallback', {
              rawUrl: rawUrl ? (rawUrl.substring(0, 50) + '...') : null,
              rawUrlType: rawUrl ? (rawUrl.startsWith('http') ? 'http' : rawUrl.startsWith('data:') ? 'data' : rawUrl.startsWith('blob:') ? 'blob' : 'base64') : 'null',
              failureReason: rawUrl ? null : 'generateImageWithFallback returned null'
          });

          if (rawUrl) {
              let imageUrl = rawUrl;
              if (!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
                  imageUrl = `data:image/png;base64,${rawUrl}`;
              }
              sceneImg.src = imageUrl;
              console.log('[BookScene:DEBUG] DOM_APPLIED', {
                  targetElement: 'bookSceneImg',
                  srcSet: imageUrl.substring(0, 50) + '...',
                  sceneImgId: sceneImg.id
              });
              sceneImg.onload = () => {
                  // GUARD: Setting images must render INLINE, never fullscreen
                  // Setting plate should have 'setting-inline' class when on scene page
                  const settingPlate = document.getElementById('settingPlate');
                  if (settingPlate && sceneImg.closest('#settingPlate')) {
                      // Ensure inline mode (not fullscreen)
                      settingPlate.classList.add('setting-inline');
                      settingPlate.classList.remove('setting-active'); // Remove any fullscreen class
                      // WRY CONFESSIONAL INSET: Apply reduced-scale inset styling
                      // When tone is Wry Confessional, images render at 40-60% column width
                      // centered as block elements (no floats, no text wrapping)
                      if (state.picks?.tone === 'Wry Confessional') {
                          settingPlate.classList.add('wry-confession-inset');
                      } else {
                          settingPlate.classList.remove('wry-confession-inset');
                      }
                      sceneImg.style.display = 'block';
                      if (loadingEl) loadingEl.style.display = 'none';
                      console.log('[BookScene:DEBUG] IMAGE_LOADED', { display: sceneImg.style.display, mountPath: 'settingPlate', mode: 'inline' });
                  } else {
                      // ABORT: Setting image mounted in wrong container
                      console.error('[BookScene:GUARD] Setting image not in settingPlate - aborting display');
                      sceneImg.style.display = 'none';
                  }
              };
              sceneImg.onerror = () => {
                  console.warn('[BookScene] Image failed to load');
                  if (loadingEl) loadingEl.textContent = '';
              };
          } else {
              // Generation failed â€” hide loading text silently
              if (loadingEl) loadingEl.textContent = '';
          }
      } catch (err) {
          console.warn('[BookScene] Generation failed:', err.message);
          if (loadingEl) loadingEl.textContent = '';
      }
  }

  // ============================================================
  // BOOK COVER PAGE SYSTEM
  // Staged loading â†’ Cover generation â†’ Page-turn reveal
  // ============================================================

  const COVER_CRAFT_PHRASES = [
      "Building your book cover...",
      "Selecting an artist...",
      "Composing the scene...",
      "Choosing the typography...",
      "Applying finishing touches...",
      "Binding the pages..."
  ];

  let _coverPhraseIndex = 0;
  let _coverPhraseInterval = null;
  let _coverProgressInterval = null;
  let _coverAbortController = null;

  // Abort cover generation â€” render fallback cover (never skip)
  function abortCoverGeneration() {
      if (_coverAbortController) {
          _coverAbortController.abort();
          _coverAbortController = null;
      }
      renderFallbackCover(state.picks?.world, state.picks?.genre);
      stopCoverLoading(null);
      applyCoverIntensityLayers(state.intensity, state.picks?.world);
  }

  // ============================================================
  // LOADING BAR SPARKLE EMITTER (SCOPED TO PROGRESS BARS ONLY)
  // Localized sparkle system for loading/progress indicators
  // Does NOT affect Fate, DSP, or other global sparkle systems
  // ============================================================
  let _loadingSparkleInterval = null;

  function spawnLoadingSparkle(container) {
      if (!container) return;

      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;
      if (containerWidth === 0) return;

      const sparkle = document.createElement('div');
      sparkle.className = 'loading-sparkle';

      // Random spawn position along and around the bar
      const spawnX = Math.random() * containerWidth;
      const spawnY = (Math.random() - 0.5) * 30 - 5; // Above/around bar

      // Randomized direction â€” avoid fixed diagonal
      const angle = (Math.random() * 120 - 60) * (Math.PI / 180); // -60Â° to +60Â° (upward bias)
      const distance = 15 + Math.random() * 25;
      const dx = Math.cos(angle) * distance * (Math.random() > 0.5 ? 1 : -1);
      const dy = -Math.abs(Math.sin(angle) * distance) - 5; // Always drift upward

      // Wobble for organic motion
      const wobble = (Math.random() - 0.5) * 10;

      // Size and timing variance
      const size = 2 + Math.random() * 3;
      const duration = 2000 + Math.random() * 2000;
      const opacity = 0.5 + Math.random() * 0.4;

      sparkle.style.cssText = `
          left: ${spawnX}px;
          top: ${spawnY}px;
          width: ${size}px;
          height: ${size}px;
          --ls-duration: ${duration}ms;
          --ls-opacity: ${opacity};
          --ls-dx: ${dx}px;
          --ls-dy: ${dy}px;
          --ls-wobble: ${wobble}px;
      `;

      container.appendChild(sparkle);
      setTimeout(() => { if (sparkle.parentNode) sparkle.remove(); }, duration + 100);
  }

  function startLoadingBarSparkles() {
      stopLoadingBarSparkles(); // Clear any existing

      const progressBar = document.querySelector('.cover-progress-bar');
      if (!progressBar) return;

      // Ensure container is positioned for absolute children
      const style = window.getComputedStyle(progressBar);
      if (style.position === 'static') {
          progressBar.style.position = 'relative';
      }

      // Spawn sparkles at staggered intervals for overlapping lifetimes
      _loadingSparkleInterval = setInterval(() => {
          spawnLoadingSparkle(progressBar);
      }, 180); // ~5-6 sparkles per second

      // Initial burst â€” staggered for natural appearance
      for (let i = 0; i < 4; i++) {
          setTimeout(() => spawnLoadingSparkle(progressBar), i * 80);
      }
  }

  function stopLoadingBarSparkles() {
      if (_loadingSparkleInterval) {
          clearInterval(_loadingSparkleInterval);
          _loadingSparkleInterval = null;
      }
      // Fade out existing sparkles gracefully
      document.querySelectorAll('.loading-sparkle').forEach(s => {
          s.style.opacity = '0';
          s.style.transition = 'opacity 0.3s ease-out';
          setTimeout(() => s.remove(), 350);
      });
  }

  // Start cover loading UI with staged phrases
  function startCoverLoading() {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”´ MINIMAL COVER v1 â€” SIMPLIFIED LOADING (no timers, no sparkles)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (USE_MINIMAL_COVER_V1) {
          console.log('[COVER:v1] Minimal loading UI â€” no phrase rotation, no sparkles');
          const loadingState = document.getElementById('coverLoadingState');
          const revealState = document.getElementById('coverRevealState');
          const statusText = document.getElementById('coverStatusText');

          if (loadingState) loadingState.classList.remove('hidden');
          if (revealState) revealState.classList.add('hidden');
          if (statusText) statusText.textContent = 'Generating cover...';
          return; // No timers, no sparkles, no abort controller
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Create new abort controller for this generation
      _coverAbortController = new AbortController();

      // Wire up abort button
      const abortBtn = document.getElementById('coverAbortBtn');
      if (abortBtn) {
          abortBtn.onclick = abortCoverGeneration;
      }
      const loadingState = document.getElementById('coverLoadingState');
      const revealState = document.getElementById('coverRevealState');
      const statusText = document.getElementById('coverStatusText');
      const progressFill = document.getElementById('coverProgressFill');

      if (loadingState) loadingState.classList.remove('hidden');
      if (revealState) revealState.classList.add('hidden');

      _coverPhraseIndex = 0;
      if (statusText) statusText.textContent = COVER_CRAFT_PHRASES[0];

      // Rotate through phrases every 3 seconds
      _coverPhraseInterval = setInterval(() => {
          _coverPhraseIndex = (_coverPhraseIndex + 1) % COVER_CRAFT_PHRASES.length;
          if (statusText) statusText.textContent = COVER_CRAFT_PHRASES[_coverPhraseIndex];
      }, 3000);

      // Progress bar animation (fake progress up to 90%)
      let progress = 0;
      if (progressFill) progressFill.style.width = '0%';
      _coverProgressInterval = setInterval(() => {
          progress += Math.random() * 8;
          if (progress > 90) progress = 90;
          if (progressFill) progressFill.style.width = progress + '%';
      }, 500);

      // Start loading bar sparkles (localized emitter)
      startLoadingBarSparkles();
  }

  // Stop cover loading and show physical book object
  function stopCoverLoading(coverUrl) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”´ MINIMAL COVER v1 â€” SIMPLIFIED STOP (no timer cleanup needed)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (USE_MINIMAL_COVER_V1) {
          console.log('[COVER:v1] Minimal loading complete');
          const loadingState = document.getElementById('coverLoadingState');
          const bookObject = document.getElementById('bookObject');
          const coverImg = document.getElementById('bookCoverImg');

          if (loadingState) loadingState.classList.add('hidden');
          if (bookObject) bookObject.classList.remove('hidden');
          if (coverImg && coverUrl) coverImg.src = coverUrl;

          // âœ… Do NOT auto-advance off COVER
          // Cover waits for explicit user interaction
          console.log('[COVER:v1] Cover displayed â€” awaiting user interaction to advance');

          return;
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      if (_coverPhraseInterval) clearInterval(_coverPhraseInterval);
      if (_coverProgressInterval) clearInterval(_coverProgressInterval);

      // Stop loading bar sparkles
      stopLoadingBarSparkles();

      const loadingState = document.getElementById('coverLoadingState');
      const bookObject = document.getElementById('bookObject');
      const coverImg = document.getElementById('bookCoverImg');
      const progressFill = document.getElementById('coverProgressFill');
      const bookmarkRibbon = document.getElementById('bookmarkRibbon');

      // Complete progress bar
      if (progressFill) progressFill.style.width = '100%';

      setTimeout(() => {
          if (loadingState) loadingState.classList.add('hidden');
          if (bookObject) bookObject.classList.remove('hidden');
          if (coverImg && coverUrl) {
              coverImg.src = coverUrl;
          }

          // Show bookmark if returning reader
          if (bookmarkRibbon && state.turnCount > 0) {
              bookmarkRibbon.classList.remove('hidden');
          }

          // Start courtesy hinge timer (one-time only)
          scheduleCourtesyHinge();
      }, 500);
  }

  // ============================================================
  // COVER INTELLIGENCE SYSTEM
  // Focal object extraction, anti-repetition, domain backgrounds, palette
  // ============================================================

  const COVER_MOTIF_STORAGE_KEY = 'storybound_cover_motifs';
  const MAX_MOTIF_HISTORY = 5;

  // Object class groupings for anti-repetition (same class = repetition)
  const OBJECT_CLASSES = {
      jewelry: ['ring', 'necklace', 'bracelet', 'pendant', 'locket', 'brooch', 'crown', 'tiara'],
      keys: ['key', 'keyring', 'skeleton key', 'antique key', 'golden key'],
      letters: ['letter', 'envelope', 'note', 'scroll', 'document', 'contract', 'deed'],
      flowers: ['rose', 'flower', 'bouquet', 'petal', 'lily', 'orchid', 'wildflower'],
      weapons: ['dagger', 'sword', 'knife', 'gun', 'pistol', 'blade'],
      vessels: ['wine glass', 'goblet', 'cup', 'bottle', 'vial', 'chalice'],
      timepieces: ['watch', 'clock', 'hourglass', 'pocket watch', 'sundial'],
      books: ['book', 'diary', 'journal', 'tome', 'manuscript', 'ledger'],
      masks: ['mask', 'masquerade mask', 'venetian mask', 'domino mask'],
      doors: ['door', 'gate', 'portal', 'archway', 'threshold']
  };

  // Color families for anti-repetition
  const COLOR_FAMILIES = {
      warm: ['red', 'orange', 'gold', 'amber', 'copper', 'bronze', 'rust', 'burgundy', 'crimson'],
      cool: ['blue', 'teal', 'cyan', 'navy', 'sapphire', 'cobalt', 'azure', 'indigo'],
      earth: ['brown', 'tan', 'sienna', 'umber', 'chocolate', 'mahogany', 'sepia'],
      jewel: ['emerald', 'purple', 'violet', 'amethyst', 'ruby', 'jade'],
      neutral: ['black', 'white', 'grey', 'gray', 'silver', 'charcoal', 'ivory'],
      nature: ['green', 'forest', 'olive', 'moss', 'sage', 'hunter']
  };

  // ============================================================
  // POWER ROLE TRANSMUTATION
  // Resolves genre labels into world-appropriate power roles.
  // Prevents anachronistic concepts from propagating to prompts.
  // Rollback: replace all resolvePowerRole() calls with raw genre
  // ============================================================
  function resolvePowerRole(world, era, genre) {
      if (genre !== 'Billionaire') return genre;
      if (world === 'Modern') return 'Capital Magnate';
      if (world === 'Historical') {
          if (era === 'Renaissance') return 'Merchant Prince';
          if (era === 'Roman') return 'Imperium Holder';
          return 'Sovereign'; // Medieval and default Historical
      }
      if (world === 'Prehistoric') return 'Clan Alpha';
      if (world === 'Fantasy') return 'Arcane Sovereign';
      if (world === 'SciFi') return 'Technocratic Hegemon';
      return genre; // unknown world fallback
  }

  // ============================================================
  // POWER FRAME RESOLUTION
  // Maps genre labels to world-appropriate narrative frames.
  // Broader than resolvePowerRole (which handles Billionaire only).
  // Modern worlds pass through unchanged.
  // Rollback: remove resolvePowerFrame() calls, use raw genre
  // ============================================================
  function resolvePowerFrame(world, genre) {
      if (world === 'Modern') return genre;

      // Non-Modern generic frame transmutation
      if (genre === 'Billionaire') return 'Ruler';
      if (genre === 'Crime Syndicate') return 'Faction';
      if (genre === 'Sports') return 'Ritual Contest';

      // Prehistoric-specific transmutations
      if (world === 'Prehistoric') {
          if (genre === 'Mafia') return 'Tribal Enforcer';
          if (genre === 'Military') return 'War Leader';
      }

      return genre; // default pass-through
  }

  // Background patterns by domain
  const DOMAIN_BACKGROUNDS = {
      // World-based
      Modern: ['geometric glass patterns', 'city skyline silhouette', 'neon reflections on wet pavement', 'modernist architecture lines'],
      Historical: ['aged parchment texture', 'heraldic filigree', 'candlelit stone walls', 'tapestry weave pattern'],
      Fantasy: ['magical runes glowing', 'starfield with constellations', 'enchanted forest mist', 'crystalline formations'],
      SciFi: ['holographic grid', 'star map', 'circuit board traces', 'nebula swirls', 'spacecraft hull panels'],
      // Genre-based
      CrimeSyndicate: ['smoke wisps', 'playing cards scattered', 'city noir shadows', 'venetian blind slats'],
      Billionaire: ['marble texture', 'champagne bubbles', 'stock ticker lines', 'crystal chandelier reflections'],
      Noir: ['rain-streaked window', 'venetian blind shadows', 'cigarette smoke trails', 'foggy streetlamp halos'],
      Heist: ['vault door mechanism', 'blueprint lines', 'laser grid', 'scattered diamonds'],
      Espionage: ['redacted document', 'surveillance static', 'crosshairs overlay', 'encrypted text streams'],
      Political: ['marble columns', 'seal embossing', 'flag fabric folds', 'courtroom wood grain'],
      Escape: ['broken chains', 'open road horizon', 'shattered glass', 'fading footprints'],
      Redemption: ['sunrise gradient', 'phoenix feathers', 'cracked mirror healing', 'emerging from shadow'],
      BuildingBridges: ['interlocking hands silhouette', 'bridge architecture', 'puzzle pieces', 'woven threads'],
      Purgatory: ['fog layers', 'liminal doorways', 'clock faces overlapping', 'fading photographs'],
      RelentlessPast: ['cracked photographs', 'faded newspaper', 'chains and shadows', 'footsteps in dust'],
      Sports: ['stadium lights', 'scoreboard glow', 'trophy shelf', 'field markings', 'crowd silhouettes'],
      Survival: ['cracked earth', 'sparse rations', 'barren landscape', 'weathered hands', 'distant smoke'],
      Obsession: ['pinboard with strings', 'circled photographs', 'repeated patterns', 'sleepless light', 'worn edges'],
      ForbiddenKnowledge: ['ancient tome', 'glowing sigils', 'eye in shadow', 'forbidden archive', 'sealed door']
  };

  // Palette by tone + common material affinities
  const TONE_PALETTES = {
      Earnest: { primary: 'warm gold', secondary: 'deep burgundy', accent: 'ivory' },
      Angsty: { primary: 'stormy blue', secondary: 'bruised purple', accent: 'lightning silver' },
      Campy: { primary: 'hot pink', secondary: 'electric blue', accent: 'gold glitter' },
      Gritty: { primary: 'charcoal', secondary: 'rust', accent: 'dried blood red' },
      Tender: { primary: 'blush pink', secondary: 'soft lavender', accent: 'pearl white' },
      Steamy: { primary: 'deep red', secondary: 'black velvet', accent: 'gold shimmer' },
      Brooding: { primary: 'midnight blue', secondary: 'storm grey', accent: 'moonlight silver' },
      Playful: { primary: 'coral', secondary: 'turquoise', accent: 'sunshine yellow' }
  };

  // Material-based palette adjustments
  const MATERIAL_PALETTES = {
      metal: { shift: 'silver/steel highlights' },
      gold: { shift: 'warm gold, amber glow' },
      glass: { shift: 'cool reflections, prismatic edges' },
      paper: { shift: 'cream, sepia, aged yellow' },
      fabric: { shift: 'rich textile colors, soft shadows' },
      stone: { shift: 'grey, moss green, weathered' },
      wood: { shift: 'warm brown, grain patterns' },
      crystal: { shift: 'prismatic, ice blue, diamond sparkle' }
  };

  // Get object class for anti-repetition check
  function getObjectClass(object) {
      const lower = object.toLowerCase();
      for (const [cls, items] of Object.entries(OBJECT_CLASSES)) {
          if (items.some(item => lower.includes(item))) return cls;
      }
      return lower; // Use object itself as unique class
  }

  // Get color family for anti-repetition check
  function getColorFamily(color) {
      const lower = color.toLowerCase();
      for (const [family, colors] of Object.entries(COLOR_FAMILIES)) {
          if (colors.some(c => lower.includes(c))) return family;
      }
      return 'neutral'; // Default
  }

  // ISSUE 2 FIX: Abstraction ladder for true object substitution on repetition
  // object â†’ trace â†’ environment â†’ absence (NEVER reuse same object class)
  const ABSTRACTION_LADDER = {
      communication: [
          'torn paper fragments scattered in gutter',
          'wax seal imprint on empty desk',
          'indentation in wood where something once lay',
          'negative space shaped like absence'
      ],
      jewelry: [
          'velvet impression where ring once sat',
          'empty jewelry box with worn hinge',
          'faint mark on skin where band was worn',
          'dusty display case, bare'
      ],
      weapons: [
          'blade-shaped shadow on wall',
          'notch in doorframe from impact',
          'empty sheath, leather cracked',
          'rust stain in shape of what was'
      ],
      keys: [
          'worn keyhole, brass darkened',
          'ring of dust where keys hung',
          'lock mechanism exposed, no key',
          'chain with empty clasp'
      ],
      timepieces: [
          'sundial with no shadow',
          'clock face with missing hands',
          'hourglass with sand frozen',
          'empty pocket, fob chain dangling'
      ],
      containers: [
          'lid without its vessel',
          'rim impression in dust',
          'empty shelf with object outline',
          'spilled contents, vessel gone'
      ],
      flora: [
          'pressed flower stain on page',
          'empty vase with dried water ring',
          'petal impression in wax',
          'barren stem, bloom fallen'
      ],
      light_sources: [
          'smoke trail where flame was',
          'wax pool, wick drowned',
          'soot pattern on ceiling',
          'match head, spent and dark'
      ],
      documents: [
          'ink blot bleeding through blank page',
          'creased paper, text faded to nothing',
          'fountain pen dry on empty desk',
          'typewriter ribbon exhausted'
      ]
  };

  // Get abstraction substitution for repeated object class
  function getAbstractionSubstitute(objectClass, usedSubstitutes = []) {
      const ladder = ABSTRACTION_LADDER[objectClass];
      if (!ladder) {
          // No predefined ladder - use generic absence
          return 'empty space where something meaningful once was';
      }

      // Find unused substitution
      const available = ladder.filter(s => !usedSubstitutes.includes(s));
      if (available.length > 0) {
          return available[Math.floor(Math.random() * available.length)];
      }

      // All used - return highest abstraction (absence)
      return ladder[ladder.length - 1];
  }

  // Load motif history from localStorage
  function loadMotifHistory() {
      try {
          const stored = localStorage.getItem(COVER_MOTIF_STORAGE_KEY);
          return stored ? JSON.parse(stored) : [];
      } catch (e) {
          return [];
      }
  }

  // Save motif to history
  function saveMotifToHistory(motif) {
      try {
          const history = loadMotifHistory();
          history.unshift(motif);
          if (history.length > MAX_MOTIF_HISTORY) history.pop();
          localStorage.setItem(COVER_MOTIF_STORAGE_KEY, JSON.stringify(history));
      } catch (e) {
          // localStorage unavailable
      }
  }

  // Check if motif would repeat recent covers
  function wouldRepeatMotif(objectClass, colorFamily, backgroundStyle) {
      const history = loadMotifHistory();
      if (history.length === 0) return { repeats: false };

      const lastMotif = history[0];
      const repeats = {
          object: history.some(m => m.objectClass === objectClass),
          color: history.some(m => m.colorFamily === colorFamily),
          background: history.some(m => m.backgroundStyle === backgroundStyle),
          artDeco: backgroundStyle === 'art-deco' && lastMotif.backgroundStyle === 'art-deco'
      };

      return {
          repeats: repeats.object || repeats.color || repeats.artDeco,
          details: repeats
      };
  }

  // Extract focal anchor and emotional gravity from synopsis (AUTHORITATIVE)
  async function extractFocalObject(synopsis, genre, world, tone) {
      // Default fallback for minimal synopsis
      if (!synopsis || synopsis.length < 20) {
          return {
              object: 'antique key',
              material: 'metal',
              emotion: 'mystery',
              humanFigure: 'none',
              reason: 'default'
          };
      }

      // Derive emotional gravity from tone if not extracted
      const TONE_TO_EMOTION = {
          Earnest: 'yearning',
          WryConfession: 'tension',
          Satirical: 'rebellion',
          Dark: 'foreboding',
          Horror: 'foreboding',
          Mythic: 'inevitability',
          Comedic: 'mystery',
          Surreal: 'mystery',
          Poetic: 'longing'
      };

      try {
          const extraction = await callChat([{
              role: 'user',
              content: `Extract cover elements for a SYMBOLIC book cover (not scene illustration).

SYNOPSIS: "${synopsis}"
GENRE: ${genre}
WORLD: ${world}

DECISIONS NEEDED:

1. EMOTIONAL GRAVITY (choose ONE): foreboding, yearning, pressure, secrecy, rebellion, inevitability, longing, tension, mystery, isolation, devotion, betrayal

2. FOCAL ANCHOR (choose ONE physical object or symbol mentioned/implied):
   - Must be CONCRETE, not abstract
   - NEVER: envelope, generic rose, book, candle, heart shape
   - Prefer objects with story-specific meaning

3. HUMAN FIGURE decision:
   - "none" - object/environment carries meaning
   - "silhouette" - figure as shadow/shape only
   - "turned_away" - figure facing away, no face visible
   - "partial" - hands, shoulders, or fragment only

4. THEMATIC TENSION (ONE short clause, max 6 words):
   - Must capture story's central conflict/irony
   - NOT a scene description
   - NOT a metaphor explanation
   - Example forms: "control masking chaos", "intimacy through surveillance"

Return ONLY valid JSON:
{
  "object": "the focal object/symbol",
  "material": "metal|paper|glass|fabric|stone|wood|crystal|gold",
  "emotion": "the dominant emotional gravity",
  "humanFigure": "none|silhouette|turned_away|partial",
  "thematicTension": "single clause capturing narrative tension",
  "reason": "brief justification"
}`
          }]);

          // Strip markdown fences if present (```json ... ``` or ``` ... ```)
          let cleanedExtraction = extraction.trim();
          if (cleanedExtraction.startsWith('```')) {
              // Remove opening fence (```json or ```)
              cleanedExtraction = cleanedExtraction.replace(/^```(?:json)?\s*\n?/, '');
              // Remove closing fence
              cleanedExtraction = cleanedExtraction.replace(/\n?```\s*$/, '');
          }
          const parsed = JSON.parse(cleanedExtraction.trim());
          if (parsed.object && parsed.emotion) {
              return parsed;
          }
      } catch (e) {
          console.warn('[CoverIntel] Focal extraction failed:', e.message);
      }

      // Fallback: genre-based default objects with emotion
      const GENRE_DEFAULTS = {
          CrimeSyndicate: { object: 'bloodstained playing card', material: 'paper', emotion: 'foreboding' },
          Billionaire: { object: 'crystal champagne flute', material: 'crystal', emotion: 'pressure' },
          Noir: { object: 'smoldering cigarette trailing smoke', material: 'paper', emotion: 'tension' },
          Heist: { object: 'diamond catching spotlight', material: 'crystal', emotion: 'tension' },
          Espionage: { object: 'torn passport page', material: 'paper', emotion: 'secrecy' },
          Political: { object: 'broken wax seal', material: 'metal', emotion: 'betrayal' },
          Escape: { object: 'shattered chain link', material: 'metal', emotion: 'rebellion' },
          Redemption: { object: 'phoenix feather in ash', material: 'gold', emotion: 'transformation' },
          BuildingBridges: { object: 'two hands almost touching', material: 'fabric', emotion: 'yearning' },
          Purgatory: { object: 'stopped clock face', material: 'metal', emotion: 'isolation' },
          RelentlessPast: { object: 'cracked photograph edge', material: 'paper', emotion: 'foreboding' },
          Sports: { object: 'trophy silhouette in spotlight', material: 'gold', emotion: 'pressure' },
          Survival: { object: 'last match in weathered box', material: 'wood', emotion: 'tension' },
          Obsession: { object: 'pinboard thread stretching taut', material: 'fabric', emotion: 'foreboding' },
          ForbiddenKnowledge: { object: 'opened tome with glowing page', material: 'paper', emotion: 'mystery' }
      };

      const fallback = GENRE_DEFAULTS[genre] || {
          object: 'antique key',
          material: 'metal',
          emotion: TONE_TO_EMOTION[tone] || 'mystery'
      };
      fallback.humanFigure = 'none';
      fallback.thematicTension = null; // No story awareness in fallback
      fallback.reason = 'fallback';

      return fallback;
  }

  // Derive background pattern from domain (genre + world)
  function deriveBackgroundPattern(genre, world, history) {
      // Collect candidates from both genre and world
      const genrePatterns = DOMAIN_BACKGROUNDS[genre] || [];
      const worldPatterns = DOMAIN_BACKGROUNDS[world] || [];
      const allPatterns = [...new Set([...genrePatterns, ...worldPatterns])];

      if (allPatterns.length === 0) {
          // Art-deco is fallback only
          return 'subtle gradient with abstract shapes';
      }

      // Filter out recently used patterns
      const recentBackgrounds = history.map(m => m.backgroundStyle);
      const available = allPatterns.filter(p => !recentBackgrounds.includes(p));

      // If all patterns used recently, reset but avoid art-deco twice in a row
      if (available.length === 0) {
          const lastBg = history[0]?.backgroundStyle;
          return allPatterns.find(p => p !== lastBg) || allPatterns[0];
      }

      // Random selection from available
      return available[Math.floor(Math.random() * available.length)];
  }

  // Derive palette from tone + object material
  function derivePalette(tone, material, history) {
      const basePalette = TONE_PALETTES[tone] || TONE_PALETTES.Earnest;
      const materialShift = MATERIAL_PALETTES[material]?.shift || '';

      // Check if palette would repeat
      const colorFamily = getColorFamily(basePalette.primary);
      const recentFamilies = history.map(m => m.colorFamily);

      // If color family repeats, shift to complementary
      let finalPalette = { ...basePalette };
      if (recentFamilies.includes(colorFamily)) {
          const SHIFTS = {
              warm: { primary: 'cool sapphire', secondary: 'deep teal' },
              cool: { primary: 'warm amber', secondary: 'burgundy' },
              earth: { primary: 'jewel emerald', secondary: 'amethyst' },
              jewel: { primary: 'neutral silver', secondary: 'charcoal' },
              neutral: { primary: 'jewel ruby', secondary: 'gold' },
              nature: { primary: 'warm copper', secondary: 'rust' }
          };
          const shift = SHIFTS[colorFamily] || {};
          finalPalette = { ...basePalette, ...shift };
      }

      // Brown is NEVER default - must be justified by material
      if (finalPalette.primary.includes('brown') && material !== 'wood') {
          finalPalette.primary = basePalette.secondary || 'deep burgundy';
      }

      return {
          ...finalPalette,
          materialNote: materialShift,
          family: getColorFamily(finalPalette.primary)
      };
  }

  // Build intelligent cover prompt with all guardrails (AUTHORITATIVE)
  // PROMPT STRUCTURE ORDER: Layout â†’ Emotion â†’ Focal â†’ Background â†’ Palette â†’ Exclusions
  async function buildCoverPrompt(synopsis, genre, world, tone, dynamic, era) {
      const history = loadMotifHistory();
      const powerRole = resolvePowerRole(world, era, genre);

      // ==========================================
      // STEP 1: LAYOUT ROULETTE (MANDATORY)
      // Select structurally distinct composition
      // ==========================================
      const selectedLayout = selectCoverLayout(history);
      console.log('[CoverIntel] Layout selected:', selectedLayout.id);

      // Extract focal anchor with emotional gravity, human figure decision, and thematic tension
      const focalResult = await extractFocalObject(synopsis, powerRole, world, tone);
      const focalObject = focalResult.object;
      const material = focalResult.material || 'metal';
      const emotion = focalResult.emotion || 'mystery';
      const humanFigure = focalResult.humanFigure || 'none';
      const thematicTension = focalResult.thematicTension || null;

      // Check for repetition
      const objectClass = getObjectClass(focalObject);
      const repetitionCheck = wouldRepeatMotif(objectClass, null, null);

      // ISSUE 2 FIX: If object class repeats, force TRUE substitution via abstraction ladder
      // NEVER reuse same object in any form (literal, shadow, silhouette, fragment)
      let finalObject = focalObject;
      if (repetitionCheck.details?.object) {
          // Get recently used substitutes to avoid those too
          const usedSubs = history
              .filter(m => m.objectClass === objectClass)
              .map(m => m.substitution)
              .filter(Boolean);
          finalObject = getAbstractionSubstitute(objectClass, usedSubs);
      }

      // Derive background from domain (theme-derived, not decorative)
      // Power Role: Modern keeps raw genre for Billionaire-specific patterns;
      // non-Modern uses powerRole (no match â†’ falls back to world patterns only)
      const bgGenre = world === 'Modern' ? genre : powerRole;
      const backgroundPattern = deriveBackgroundPattern(bgGenre, world, history);

      // Derive palette from tone + material
      // HARD RULE: No brown/cream unless explicitly required by layout
      const palette = derivePalette(tone, material, history);

      // Anti-repetition: avoid art-deco twice in a row AND block cream backgrounds
      let finalBackground = backgroundPattern;
      const recentBgs = history.slice(0, 2).map(m => m.backgroundStyle?.toLowerCase() || '');
      if (backgroundPattern.includes('art-deco') || backgroundPattern.includes('geometric')) {
          if (recentBgs.some(bg => bg.includes('art-deco') || bg.includes('geometric'))) {
              finalBackground = DOMAIN_BACKGROUNDS[world]?.[0] || 'atmospheric gradient with depth';
          }
      }
      // Block cream/parchment unless center_object layout
      if (selectedLayout.id !== 'center_object') {
          if (finalBackground.includes('cream') || finalBackground.includes('parchment')) {
              finalBackground = 'deep atmospheric gradient';
          }
      }

      // Visual restraint rules (layout-aware)
      let restraintText = 'Limited palette (2-3 tones). Soft focus or shallow depth.';
      if (selectedLayout.id === 'negative_space_dominant') {
          restraintText = 'Minimal elements. 70%+ empty space. Single small anchor.';
      } else if (selectedLayout.id === 'fragmented_object') {
          restraintText = 'Object cropped or broken. Tension through incompleteness.';
      } else if (selectedLayout.id === 'off_center_focus') {
          restraintText = 'Strong asymmetry. Directional tension. Off-center weight.';
      }

      // Human figure handling
      let figureText = '';
      if (humanFigure === 'silhouette') {
          figureText = 'Human figure as shadow/silhouette only, no face visible.';
      } else if (humanFigure === 'turned_away') {
          figureText = 'Figure facing away, back to viewer.';
      } else if (humanFigure === 'partial') {
          figureText = 'Only hands or partial body, no face.';
      }

      // Save motif to history (include layout for repetition tracking)
      const wasSubstituted = repetitionCheck.details?.object;
      const newMotif = {
          layoutId: selectedLayout.id,           // Track layout for roulette
          objectClass: objectClass,              // Original class, not substituted
          colorFamily: palette.family,
          backgroundStyle: finalBackground,
          emotion: emotion,
          substitution: wasSubstituted ? finalObject : null,
          timestamp: Date.now()
      };
      saveMotifToHistory(newMotif);

      // Build the authoritative prompt (ORDER MATTERS)
      // Semantic Declaration â†’ Title-Safe â†’ Layout â†’ Emotion â†’ Focal â†’ Background â†’ Palette â†’ Restraint â†’ Exclusions

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // COVER-SPECIFIC VISUAL DECLARATION (AUTHORITATIVE)
      // TAG: storybound/cover-semantic-declaration-v1
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Covers may be painterly, graphic, symbolic, or illustrative.
      // Covers must NOT be literal depictions of specific scenes.
      // Covers may synthesize multiple themes, moods, or symbols.
      // Visual sophistication and restraint are preferred over realism.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const COVER_SEMANTIC_DECLARATION = `This image is a magazine-quality book cover illustration, designed to interpret the story's central tension or irony as a single composed image.

`;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” SEMANTIC DEFINITION (AUTHORITATIVE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Sketch-tier covers are unfinished in execution, not unfinished in idea.
      //
      // The cover concept must be sophisticated, ironic, or editorially sharp.
      // The rendering must feel provisional, exploratory, or interrupted.
      //
      // Sketch-tier enforces surface roughness, not conceptual simplicity.
      //
      // If the image looks complete, it has violated Sketch-tier.
      // If the idea looks simple, it has violated Sketch-tier.
      //
      // The goal is a cover that feels mid-thought, not under-thought.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” ALLOWED / DISALLOWED CLARIFICATIONS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Sketch-tier MAY include:
      // - pencil, ink, or charcoal textures
      // - uneven or broken linework
      // - partial fill or restrained color
      // - visible construction or negative space
      // - hand-drawn or outlined lettering
      //
      // Sketch-tier MUST NOT collapse into:
      // - flat icons
      // - clip-art minimalism
      // - dumbed-down symbolism
      // - polished painterly rendering
      // - 'cartoonish' simplification
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // COVER REGRESSION SENTENCE (INTERNAL CHECK)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 'Does this cover feel like an intelligent editorial idea that has
      // been intentionally left unfinished, rather than a finished image
      // that has been simplified?'
      //
      // This sentence is for internal validation only.
      // It must not appear in output.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” IMPLEMENTATION SAFETY NOTE
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // This Sketch-tier definition modifies execution, not meaning.
      // Do NOT simplify concepts to satisfy roughness.
      // Do NOT flatten symbolism.
      // Do NOT enforce sketch aesthetics at the expense of thought.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” MATERIAL AND FINISH CONSTRAINTS (HARD)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // When coverStage === 'Sketch':
      //
      // - Linework must appear unfinished.
      // - Materials must resemble pencil, ink, charcoal,
      //   light watercolor wash, or colored pencil.
      // - Shading must be imperfect, uneven, or gestural.
      // - Typography must appear hand-drawn, outlined,
      //   or lightly irregular.
      // - No polished lighting, gradients, or realism.
      //
      // A Sketch that appears print-ready or fully rendered
      // is a failure.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” REGRESSION TEST (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // For any cover where coverStage === 'Sketch',
      // Claude must pass this regression test:
      //
      // "If this image looks finished, polished, or ready for print,
      // it has failed the Sketch tier."
      //
      // Failure requires regeneration, not adjustment.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH LABEL PLACEMENT (LOCKED)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // The label 'Sketch â€” currently displayed' must appear
      // BELOW the cover image, never overlaid on top of it.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STORY MILESTONE COPY (LOCKED)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Replace: 'Character Milestone Achieved'
      // With: 'Story Milestones Unlocked: {count}'
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      const TITLE_SAFE_CONSTRAINTS = `TITLE-SAFE ZONE (MANDATORY):
Upper 18-22% of image must remain visually simple and low-contrast.
No faces, text, high-detail objects, or bright highlights in title region.
Subject blocking confined to middle and lower thirds only.
Gradual tonal transition from top edge downward â€” no hard horizontal lines at top.
Composition must leave clear space for book-cover typography overlay.`;

      // Get sketch tier enforcement if tone requires it
      const sketchTierText = getSketchTierEnforcement(tone);

      return {
          layoutId: selectedLayout.id,
          focalObject: finalObject,
          material: material,
          emotion: emotion,
          humanFigure: humanFigure,
          background: finalBackground,
          palette: palette,
          thematicTension: thematicTension,
          promptText: `${COVER_SEMANTIC_DECLARATION}${TITLE_SAFE_CONSTRAINTS}
${sketchTierText ? '\n' + sketchTierText + '\n' : ''}
LAYOUT: ${selectedLayout.description}
EMOTIONAL GRAVITY: ${emotion} (guides all visual decisions).
${thematicTension ? `STORY TENSION: ${thematicTension}. (Influences imagery, not literal depiction.)\n` : ''}FOCAL ANCHOR: ${finalObject} rendered in ${material}, composed per layout.
BACKGROUND: ${finalBackground}. (Support emotion, not decoration.)
PALETTE: ${palette.primary}, ${palette.secondary}. Max 3 tones. ${palette.materialNote}
COMPOSITION: ${restraintText}
${figureText ? figureText + '\n' : ''}${COVER_EXCLUSIONS}`
      };
  }

  // ============================================================
  // PHASE 3A: ARCHETYPE SELECTOR
  // Deterministic world-based archetype â€” NEVER returns null.
  // Explicit state.coverArchetype overrides world default.
  // Prehistoric / Historical / Fantasy â†’ THRESHOLD
  // SciFi / Modern / Dystopian â†’ EMBLEM
  // ============================================================
  function selectCoverArchetype(genre, dynamic, tone, world, synopsis) {
      // Explicit archetype override (UI or Guided-Fate driven)
      if (state.coverArchetype === 'EMBLEM') return 'EMBLEM';
      if (state.coverArchetype === 'THRESHOLD') return 'THRESHOLD';

      // World-based deterministic default
      if (world === 'Prehistoric' || world === 'Historical' || world === 'Fantasy') {
          return 'THRESHOLD';
      }
      // SciFi, Modern, Dystopian, unknown â†’ EMBLEM
      return 'EMBLEM';
  }

  // Generate book cover with intent-based routing
  // Uses COVER INTELLIGENCE SYSTEM for focal object, anti-repetition, domain backgrounds, palette
  // DSP-lite cover subtitle derived from story shape axes
  function generateCoverSubtitle() {
      const GENRE_PHRASE = {
          Billionaire: 'wealth and want',
          CrimeSyndicate: 'crime and collusion',
          Espionage: 'secrets and espionage',
          Political: 'power and politics',
          Noir: 'shadow and suspicion',
          Heist: 'schemes and daring'
      };
      const DYNAMIC_PHRASE = {
          Enemies: 'rivals become something more',
          Friends: 'friendship ignites',
          Forbidden: 'the forbidden pulls closer',
          Fated: 'destiny refuses to let go',
          SecondChance: 'the past returns uninvited',
          ForcedProximity: 'proximity rewrites the rules',
          OnlyOneBed: 'closeness becomes unavoidable',
          Fake: 'the lie begins to feel real',
          Grumpy: 'opposites collide',
          Boss: 'authority blurs every line',
          Rivals: 'competition sparks something unexpected'
      };
      const WORLD_SHADE = {
          Modern: 'under city lights',
          Fantasy: 'in lands uncharted',
          Romantasy: 'where magic meets desire',
          SciFi: 'among the stars',
          Historical: 'across the ages',
          Dystopia: 'in a world undone',
          PostApocalyptic: 'after the fall',
          Horror: 'in the dark between worlds'
      };

      const genre = state.picks?.genre || 'Billionaire';
      const dynamic = state.picks?.dynamic || 'Enemies';
      const world = state.picks?.world || 'Modern';
      const intensity = state.intensity || 'Naughty';

      const gp = GENRE_PHRASE[genre] || 'intrigue';
      const dp = DYNAMIC_PHRASE[dynamic] || 'two lives collide';
      const wp = WORLD_SHADE[world] || '';
      const storyNoun = (intensity === 'Erotic' || intensity === 'Dirty') ? 'story' : 'tale';

      return 'A Storybound ' + storyNoun + ' of ' + gp + ' where ' + dp + ' ' + wp + '.';
  }

  // ============================================================
  // COVER FALLBACK LIBRARY â€” deterministic SVG motifs
  // ============================================================

  const COVER_FALLBACK_MOTIFS = {
      Modern:          ['handcuffs', 'key', 'drop'],
      Historical:      ['key', 'skull', 'sun'],
      Dystopia:        ['skull', 'handprint', 'moon'],
      PostApocalyptic: ['skull', 'sun', 'waves'],
      Fantasy:         ['sun', 'stars', 'key'],
      SciFi:           ['stars', 'moon', 'waves'],
      Supernatural:    ['moon', 'key', 'skull'],
      Superheroic:     ['sun', 'stars', 'handprint']
  };

  const COVER_FALLBACK_PALETTES = {
      Modern:          { bg: '#0a0a0a', accent: '#e63946' },
      Historical:      { bg: '#0d0908', accent: '#d4af37' },
      Dystopia:        { bg: '#0a0a0a', accent: '#cccccc' },
      PostApocalyptic: { bg: '#0d0b08', accent: '#c8553d' },
      Fantasy:         { bg: '#0a0a12', accent: '#d4af37' },
      SciFi:           { bg: '#0a1628', accent: '#40e0d0' },
      Supernatural:    { bg: '#0a0a12', accent: '#8b5cf6' },
      Superheroic:     { bg: '#0d0a14', accent: '#e63946' }
  };

  // Inline SVG paths for motif icons (symbolic, no people/bodies)
  const SVG_MOTIF_PATHS = {
      skull: '<path d="M50 15c-18 0-32 14-32 32 0 12 6 22 16 28v10c0 3 2 5 5 5h22c3 0 5-2 5-5V75c10-6 16-16 16-28 0-18-14-32-32-32zm-10 38a5 5 0 110-10 5 5 0 010 10zm20 0a5 5 0 110-10 5 5 0 010 10zm-10 14c-4 0-8-2-8-4h16c0 2-4 4-8 4z"/>',
      handcuffs: '<path d="M30 35c-8 0-15 7-15 15s7 15 15 15c5 0 10-3 12-7h16c2 4 7 7 12 7 8 0 15-7 15-15s-7-15-15-15c-5 0-10 3-12 7H42c-2-4-7-7-12-7zm0 8a7 7 0 110 14 7 7 0 010-14zm40 0a7 7 0 110 14 7 7 0 010-14z"/>',
      key: '<path d="M65 20L50 35l6 6-4 4 6 6-4 4 6 6-8 8c-3 3-8 3-11 0l-1-1c-6 3-14 2-19-3-7-7-7-18 0-25s18-7 25 0c5 5 6 13 3 19l1 1c3 3 3 8 0 11zm-35 30a5 5 0 100-10 5 5 0 000 10z"/>',
      handprint: '<path d="M35 25v20h-3V28c0-2-3-2-3 0v18h-3V30c0-2-3-2-3 0v16l-2 6c-1 3 0 6 2 8l8 10c2 2 4 4 7 4h12c5 0 9-4 9-9V40c0-2-3-2-3 0v10h-3V27c0-2-3-2-3 0v23h-3V25c0-2-3-2-3 0v25h-3V27c0-2-3-2-3 0z"/>',
      drop: '<path d="M50 15C50 15 25 45 25 60c0 14 11 25 25 25s25-11 25-25C75 45 50 15 50 15zm-5 50a3 3 0 01-3-3c0-8 7-15 15-15a3 3 0 010 6c-5 0-9 4-9 9a3 3 0 01-3 3z"/>',
      sun: '<circle cx="50" cy="50" r="15"/><g stroke-width="3" stroke="currentColor"><line x1="50" y1="10" x2="50" y2="22"/><line x1="50" y1="78" x2="50" y2="90"/><line x1="10" y1="50" x2="22" y2="50"/><line x1="78" y1="50" x2="90" y2="50"/><line x1="22" y1="22" x2="31" y2="31"/><line x1="69" y1="69" x2="78" y2="78"/><line x1="78" y1="22" x2="69" y2="31"/><line x1="31" y1="69" x2="22" y2="78"/></g>',
      moon: '<path d="M50 10c-22 0-40 18-40 40s18 40 40 40c8 0 15-2 22-6-6 3-12 4-18 4-20 0-36-16-36-36S34 16 54 16c6 0 12 1 18 4C65 14 58 10 50 10z"/>',
      stars: '<polygon points="50,5 58,35 90,35 64,55 73,85 50,67 27,85 36,55 10,35 42,35"/><polygon points="22,12 25,22 35,22 27,28 30,38 22,32 14,38 17,28 9,22 19,22" transform="scale(0.5) translate(10,10)"/><polygon points="22,12 25,22 35,22 27,28 30,38 22,32 14,38 17,28 9,22 19,22" transform="scale(0.4) translate(180,120)"/>',
      waves: '<path d="M5 50c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="currentColor" stroke-width="4"/><path d="M5 65c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="currentColor" stroke-width="3" opacity="0.6"/><path d="M5 35c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="currentColor" stroke-width="3" opacity="0.6"/>'
  };

  /**
   * Simple hash for deterministic motif selection from genre string
   */
  function genreMotifHash(genre) {
      let h = 0;
      for (let i = 0; i < genre.length; i++) {
          h = ((h << 5) - h + genre.charCodeAt(i)) | 0;
      }
      return Math.abs(h);
  }

  /**
   * Render a deterministic CSS/SVG fallback cover.
   * Selects motif by world + genre hash. Never fails.
   */
  function renderFallbackCover(world, genre, title) {
      const fallbackEl = document.getElementById('coverFallback');
      const coverImg = document.getElementById('bookCoverImg');
      if (!fallbackEl) return;

      const w = world || 'Modern';
      const g = genre || 'Billionaire';
      const motifs = COVER_FALLBACK_MOTIFS[w] || COVER_FALLBACK_MOTIFS.Modern;
      const palette = COVER_FALLBACK_PALETTES[w] || COVER_FALLBACK_PALETTES.Modern;
      const motifKey = motifs[genreMotifHash(g) % motifs.length];
      const svgContent = SVG_MOTIF_PATHS[motifKey] || SVG_MOTIF_PATHS.key;

      // Resolve title: explicit param â†’ storyTitle DOM â†’ empty
      const displayTitle = title
          || document.getElementById('storyTitle')?.textContent
          || '';

      fallbackEl.style.setProperty('--fb-bg', palette.bg);
      fallbackEl.style.setProperty('--fb-accent', palette.accent);

      // Build cover: SVG motif + title cartouche + author line
      let html = '<svg class="cover-fallback-motif" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="' + palette.accent + '" color="' + palette.accent + '">' + svgContent + '</svg>';
      const safeTitle = displayTitle ? displayTitle.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
      html += '<div class="cover-fallback-title" style="color:' + palette.accent + '">' +
          '<span class="cover-fallback-title-rule"></span>' +
          (safeTitle ? '<span class="cover-fallback-title-text">' + safeTitle + '</span>' : '') +
          '<span class="cover-fallback-author">by ANONYMOUS</span>' +
          '<span class="cover-fallback-title-rule"></span>' +
          '</div>';
      fallbackEl.innerHTML = html;

      // Show fallback, hide AI image
      fallbackEl.classList.remove('hidden');
      if (coverImg) coverImg.style.display = 'none';
  }

  /**
   * Apply intensity-based cover overlays.
   * Clean/Naughty â†’ nothing, Erotic â†’ gold border, Dirty â†’ keyhole takeover.
   * Soulmates is a MODIFIER (not intensity) â€” derived from state.storyLength === 'soulmates'.
   *
   * LOCKED RULES:
   * - Keyhole ONLY appears when arousal === Dirty
   * - Erotic border ONLY appears when arousal === Erotic (NOT Tease, Naughty, or Dirty)
   * - Soulmates modulates material warmth (adds 'soulmates' class), never introduces keyhole
   *
   * COVER SEQUENCING AUTHORITY (Storyturn + Arousal Gates):
   * - Phase 1-2 (ST1-ST2): NO borders, NO keyholes â€” sketch/refinement only
   * - Phase 3 (ST3+, arousal < Erotic): NO borders, NO keyholes
   * - Phase 4 (arousal === Erotic): Erotic border ALLOWED
   * - Phase 5 (arousal === Dirty): Keyhole REQUIRED, border superseded
   *
   * EROTIC BORDER SYSTEM (Image-Based):
   * - Asset path: /assets/borders/erotic/{world}_base.png
   * - 6 worlds: modern, fantasy, scifi, historical, postapocalyptic, dystopia (no Mythic)
   * - Flavor affects surface condition only (damage/aging/corrosion), not geometry
   * - Failure: suppress border and log "Erotic border asset unavailable â€” border suppressed"
   */
  function applyCoverIntensityLayers(intensity, world) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSIONAL â€” UI SUPPRESSION (authoritative gate)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (state.picks?.tone === 'Wry Confessional') {
          document.getElementById('requiresSubscriptionAccess')?.classList.add('hidden');
          document.getElementById('coverIntensityOverlay')?.classList.add('hidden');
          document.getElementById('coverCTAButtons')?.classList.add('hidden');
          document.getElementById('coverEroticBorder')?.classList.add('hidden');
          document.getElementById('coverKeyholeOverlay')?.classList.add('hidden');
          console.log('[CoverIntensity] Wry Confessional â€” all overlays suppressed');
          return;
      }

      const borderEl = document.getElementById('coverEroticBorder');
      const keyholeEl = document.getElementById('coverKeyholeOverlay');
      if (!borderEl || !keyholeEl) return;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COVER SEQUENCING VALIDATION (MANDATORY)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const sequenceCheck = validateCoverSequencing(intensity);
      if (!sequenceCheck.valid) {
          console.error('[CoverSequencing] COVER SEQUENCING VIOLATION â€” OUTPUT SUPPRESSED');
          console.error('[CoverSequencing] Reason:', sequenceCheck.reason);
          // Suppress all overlays
          borderEl.classList.add('hidden');
          borderEl.className = 'cover-erotic-border hidden';
          keyholeEl.classList.add('hidden');
          keyholeEl.className = 'cover-keyhole-overlay hidden';
          return;
      }

      // COVER ESCALATION VALIDATION
      // Cover may escalate beyond title baseline, but must not contradict downward
      if (state.titleBaselineArousal) {
          const escalationCheck = validateCoverEscalation(
              state.titleBaselineArousal,  // Title's original arousal
              intensity || 'Naughty',       // Current cover arousal
              state.titleBaselineArousal    // Baseline
          );
          if (!escalationCheck.valid) {
              console.error('[CoverEscalation] BLOCKED:', escalationCheck.error.message);
              // Do not apply de-escalated layers â€” keep current state
              return;
          }
      }

      // Soulmates is a modifier overlay, derived from story length
      const hasSoulmates = state.storyLength === 'soulmates';

      // Reset both layers
      borderEl.classList.add('hidden');
      borderEl.className = 'cover-erotic-border hidden';
      keyholeEl.classList.add('hidden');
      keyholeEl.classList.remove('soulmates');

      const level = (intensity || '').toLowerCase();

      if (level === 'erotic') {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // EROTIC: Image-based border (ONLY for Erotic tier)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          applyEroticBorder(borderEl, world, hasSoulmates);
      } else if (level === 'dirty') {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // DIRTY: Keyhole takeover (ONLY for Dirty tier)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          applyDirtyKeyhole(keyholeEl, world, hasSoulmates);
      }
      // Tease/Naughty: no overlay layers (art fully visible)
      // Soulmates alone (non-Erotic, non-Dirty) affects art generation warmth, not cover layers
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER SEQUENCING AUTHORITY â€” Storyturn + Arousal Gate Validation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // You do NOT decide when erotic signaling appears.
  // You obey Storyturns and Arousal gates.
  //
  // PHASE DEFINITIONS:
  //   Phase 1 (SKETCH):         Scene 1 exists, ST1
  //   Phase 2 (REFINED SKETCH): ST1â€“ST2
  //   Phase 3 (POST-ST3):       ST3+ AND arousal < Erotic
  //   Phase 4 (EROTIC):         arousal === Erotic (border allowed)
  //   Phase 5 (DIRTY):          arousal === Dirty (keyhole required)
  //
  // HARD FAIL CONDITIONS:
  //   - Border before Erotic arousal â†’ FAIL
  //   - Keyhole before Dirty arousal â†’ FAIL
  //   - Erotic signaling based on "vibe" or tone â†’ FAIL
  //
  // FAILURE OUTPUT:
  //   "COVER SEQUENCING VIOLATION â€” OUTPUT SUPPRESSED"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Determine current cover phase based on storyturn and arousal.
   * @returns {number} Phase 1-5
   */
  function getCoverPhase() {
      const storyturn = state.storyturn || 'ST1';
      const arousal = (state.intensity || 'Naughty').toLowerCase();
      const sceneCount = state.scenes?.length || 0;

      // No scenes = pre-Phase 1
      if (sceneCount === 0) return 0;

      // Phase 5: Dirty arousal (keyhole required)
      if (arousal === 'dirty') return 5;

      // Phase 4: Erotic arousal (border allowed)
      if (arousal === 'erotic') return 4;

      // Extract storyturn number
      const stNum = parseInt(storyturn.replace(/\D/g, ''), 10) || 1;

      // Phase 3: ST3+ with arousal < Erotic
      if (stNum >= 3) return 3;

      // Phase 2: ST2
      if (stNum === 2) return 2;

      // Phase 1: ST1 (default)
      return 1;
  }

  /**
   * Validate cover sequencing rules.
   * @param {string} intensity - Requested arousal intensity
   * @returns {{valid: boolean, reason: string|null, phase: number}}
   */
  function validateCoverSequencing(intensity) {
      const phase = getCoverPhase();
      const level = (intensity || '').toLowerCase();

      // Phase 0: No story yet â€” no overlays allowed but not a failure
      if (phase === 0) {
          return { valid: true, reason: null, phase: 0 };
      }

      // Phase 1-3: NO erotic signaling allowed
      if (phase >= 1 && phase <= 3) {
          if (level === 'erotic') {
              return {
                  valid: false,
                  reason: `Erotic border requested at Phase ${phase} (${state.storyturn || 'ST1'}) â€” borders only allowed at arousal === Erotic`,
                  phase
              };
          }
          if (level === 'dirty') {
              return {
                  valid: false,
                  reason: `Dirty keyhole requested at Phase ${phase} (${state.storyturn || 'ST1'}) â€” keyholes only allowed at arousal === Dirty`,
                  phase
              };
          }
      }

      // Phase 4: Erotic border allowed, keyhole NOT allowed
      if (phase === 4) {
          if (level === 'dirty') {
              return {
                  valid: false,
                  reason: 'Dirty keyhole requested at Phase 4 (Erotic arousal) â€” keyholes only allowed at arousal === Dirty',
                  phase
              };
          }
          // Erotic border is allowed at phase 4
      }

      // Phase 5: Keyhole required, border superseded
      if (phase === 5) {
          if (level === 'erotic') {
              return {
                  valid: false,
                  reason: 'Erotic border requested at Phase 5 (Dirty arousal) â€” keyhole supersedes border at Dirty tier',
                  phase
              };
          }
          // Dirty keyhole is required at phase 5
      }

      // All checks passed
      return { valid: true, reason: null, phase };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EROTIC BORDER â€” Image Asset Loader
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Maps world names to asset paths and applies surface condition filters.
  //
  // WORLD â†’ ASSET MAPPING (6 worlds, no Mythic):
  //   Modern          â†’ /assets/borders/erotic/modern_base.png
  //   Fantasy         â†’ /assets/borders/erotic/fantasy_base.png
  //   SciFi           â†’ /assets/borders/erotic/scifi_base.png
  //   Historical      â†’ /assets/borders/erotic/historical_base.png
  //   PostApocalyptic â†’ /assets/borders/erotic/postapocalyptic_base.png
  //   Dystopia        â†’ /assets/borders/erotic/dystopia_base.png
  //
  // FLAVOR â†’ SURFACE CONDITION:
  //   Flavor affects damage/aging/corrosion appearance, NOT geometry.
  //   Applied via CSS filter classes: flavor-aged, flavor-weathered, etc.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const EROTIC_BORDER_WORLD_MAP = {
      'modern': 'modern',
      'fantasy': 'fantasy',
      'scifi': 'scifi',
      'sci-fi': 'scifi',
      'historical': 'historical',
      'postapocalyptic': 'postapocalyptic',
      'post-apocalyptic': 'postapocalyptic',
      'dystopia': 'dystopia'
  };

  // Flavor â†’ CSS filter class mapping
  // Surface conditions: damage, aging, corrosion (NOT geometry)
  const EROTIC_BORDER_FLAVOR_MAP = {
      // Historical flavors
      'prehistoric': 'aged',
      'classical': 'weathered',
      'medieval': 'aged',
      'renaissance': 'tarnished',
      'victorian': 'aged',
      '20th_century': 'weathered',
      // Fantasy flavors
      'enchanted_realms': 'pristine',
      'hidden_magic': 'aged',
      'cursed_worlds': 'corroded',
      // SciFi flavors
      'galactic_civilizations': 'pristine',
      'future_of_science': 'pristine',
      'cyberpunk': 'corroded',
      'post_human': 'tarnished',
      'first_contact': 'pristine',
      'simulation': 'pristine',
      'final_frontier': 'weathered',
      // Dystopia flavors (7 locked canon)
      'glass_house': 'tarnished',
      'velvet_trap': 'pristine',
      'the_ledger': 'pristine',
      'crimson_veil': 'weathered',
      'perfect_match': 'pristine',
      'ministry_of_affection': 'aged',
      'endless_edit': 'fractured',
      // PostApocalyptic flavors
      'nuclear_aftermath': 'rusted',
      'pandemic': 'corroded',
      'climate_ruin': 'weathered',
      'tech_fallout': 'rusted',
      'slow_decay': 'aged',
      // Modern flavors (generally pristine)
      'small_town': 'weathered',
      'college': 'pristine',
      'friends': 'pristine',
      'old_money': 'tarnished',
      'office': 'pristine',
      'supernatural_modern': 'aged',
      'superheroic_modern': 'pristine'
  };

  /**
   * Apply erotic border with world-specific asset and flavor-based surface condition.
   * @param {HTMLElement} borderEl - The border container element
   * @param {string} world - World name (Modern, Fantasy, SciFi, etc.)
   * @param {boolean} hasSoulmates - Whether soulmates modifier applies
   */
  function applyEroticBorder(borderEl, world, hasSoulmates) {
      const borderImg = document.getElementById('eroticBorderImg');
      if (!borderImg) {
          console.warn('[EroticBorder] Image element not found â€” border suppressed');
          return;
      }

      // Normalize world name to asset key
      const normalizedWorld = (world || 'Modern').toLowerCase().replace(/[\s-]/g, '');
      const assetKey = EROTIC_BORDER_WORLD_MAP[normalizedWorld] || 'modern';
      const assetPath = `/assets/borders/erotic/${assetKey}_base.png`;

      // Get world class for vignette/glow styling
      const worldClass = 'world-' + assetKey;

      // Get flavor for surface condition
      const flavor = state.picks?.worldSubtype || null;
      const flavorClass = flavor && EROTIC_BORDER_FLAVOR_MAP[flavor]
          ? 'flavor-' + EROTIC_BORDER_FLAVOR_MAP[flavor]
          : '';

      // Build class list
      const classes = ['cover-erotic-border', worldClass];
      if (hasSoulmates) classes.push('soulmates');
      if (flavorClass) classes.push(flavorClass);

      // Set up load handler BEFORE setting src
      borderImg.onload = function() {
          borderEl.className = classes.join(' ');
          console.log('[EroticBorder] Asset loaded:', assetPath, '| Classes:', classes.join(' '));
      };

      // Set up error handler for asset failure
      borderImg.onerror = function() {
          console.warn('[EroticBorder] Erotic border asset unavailable â€” border suppressed');
          borderEl.classList.add('hidden');
          borderEl.className = 'cover-erotic-border hidden';
      };

      // Trigger asset load
      borderImg.src = assetPath;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DIRTY KEYHOLE â€” World-Specific Mask Loader
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Keyhole is a MASK, not a decorative overlay. It dominates the cover.
  //
  // GEOMETRY LOCK (NON-NEGOTIABLE):
  //   - Top of aperture: 8% from top
  //   - Bottom of aperture: 8% from bottom
  //   - Crown width: 55-65% of cover width
  //   - Stem minimum width: â‰¥22% of cover width
  //
  // WORLD â†’ MASK ASSET (6 worlds, one silhouette each):
  //   Modern          â†’ /assets/keyholes/modern_mask.png       (clean industrial)
  //   Historical      â†’ /assets/keyholes/historical_mask.png   (ornate, filigree)
  //   Fantasy         â†’ /assets/keyholes/fantasy_mask.png      (hand-forged, runes)
  //   SciFi           â†’ /assets/keyholes/scifi_mask.png        (geometric, octagonal)
  //   Dystopia        â†’ /assets/keyholes/dystopia_mask.png     (brutalist, industrial)
  //   PostApocalyptic â†’ /assets/keyholes/postapocalyptic_mask.png (salvaged, damaged)
  //
  // CONTENT RULE: Only symbolic objects visible through aperture (no humans/body parts)
  // TITLE RULE: Title MUST be engraved into material, NEVER floating in aperture
  //
  // FAILURE: If constraint cannot be satisfied, suppress and log:
  // "Dirty keyhole constraint failed â€” cover suppressed"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const DIRTY_KEYHOLE_WORLD_MAP = {
      'modern': 'modern',
      'fantasy': 'fantasy',
      'scifi': 'scifi',
      'sci-fi': 'scifi',
      'historical': 'historical',
      'postapocalyptic': 'postapocalyptic',
      'post-apocalyptic': 'postapocalyptic',
      'dystopia': 'dystopia'
  };

  // Flavor â†’ CSS filter class mapping for keyhole surface conditions
  // Surface conditions: wear, corrosion, fracture, environmental damage (NOT aperture geometry)
  const DIRTY_KEYHOLE_FLAVOR_MAP = {
      // Historical flavors
      'prehistoric': 'aged',
      'classical': 'weathered',
      'medieval': 'aged',
      'renaissance': 'aged',
      'victorian': 'weathered',
      '20th_century': 'weathered',
      // Fantasy flavors
      'enchanted_realms': 'pristine',
      'hidden_magic': 'aged',
      'cursed_worlds': 'corroded',
      // SciFi flavors
      'galactic_civilizations': 'pristine',
      'future_of_science': 'pristine',
      'cyberpunk': 'corroded',
      'post_human': 'fractured',
      'first_contact': 'pristine',
      'simulation': 'pristine',
      'final_frontier': 'weathered',
      // Dystopia flavors (7 locked canon)
      'glass_house': 'tarnished',
      'velvet_trap': 'pristine',
      'the_ledger': 'pristine',
      'crimson_veil': 'weathered',
      'perfect_match': 'pristine',
      'ministry_of_affection': 'aged',
      'endless_edit': 'fractured',
      // PostApocalyptic flavors
      'nuclear_aftermath': 'irradiated',
      'pandemic': 'corroded',
      'climate_ruin': 'weathered',
      'tech_fallout': 'rusted',
      'slow_decay': 'aged',
      // Modern flavors
      'small_town': 'weathered',
      'college': 'pristine',
      'friends': 'pristine',
      'old_money': 'aged',
      'office': 'pristine',
      'supernatural_modern': 'aged',
      'superheroic_modern': 'pristine'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DIRTY KEYHOLE SELF-CHECK AUDIT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Mandatory pre-output validation. If ANY check fails, output is suppressed.
  //
  // Checks performed:
  //   A. World Conformance â€” must be valid 6-world set (no Mythic)
  //   B. Flavor Application â€” surface only, no geometry changes
  //   C. Material Language â€” world-appropriate materials
  //   D. Title Integration â€” engraved into material, not floating
  //
  // If failed: return "DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const VALID_KEYHOLE_WORLDS = new Set([
      'modern', 'historical', 'fantasy', 'scifi', 'dystopia', 'postapocalyptic'
  ]);

  /**
   * Run self-check audit on dirty keyhole parameters.
   * @param {string} world - World name
   * @param {string} flavor - WorldSubtype flavor
   * @returns {{valid: boolean, reason: string|null}}
   */
  function auditDirtyKeyhole(world, flavor) {
      const normalizedWorld = (world || 'Modern').toLowerCase().replace(/[\s-]/g, '');
      const assetKey = DIRTY_KEYHOLE_WORLD_MAP[normalizedWorld];

      // A. WORLD CONFORMANCE CHECK
      if (!assetKey || !VALID_KEYHOLE_WORLDS.has(assetKey)) {
          return {
              valid: false,
              reason: `Invalid world "${world}" â€” must be Modern, Historical, Fantasy, SciFi, Dystopia, or PostApocalyptic (Mythic not allowed)`
          };
      }

      // B. FLAVOR APPLICATION CHECK (flavor must map to surface condition, not geometry)
      if (flavor && !DIRTY_KEYHOLE_FLAVOR_MAP[flavor]) {
          // Unknown flavor â€” warn but don't fail (will use default)
          console.warn(`[DirtyKeyhole:Audit] Unknown flavor "${flavor}" â€” using default surface`);
      }

      // C. MATERIAL LANGUAGE CHECK (world must have corresponding material treatment)
      // Verified by CSS class existence â€” if world class missing, styling will fail gracefully

      // D. TITLE INTEGRATION CHECK
      // Enforced by CSS positioning â€” title is absolutely positioned in bottom margin zone
      // This is a structural guarantee, not runtime check

      // All checks passed
      return { valid: true, reason: null };
  }

  /**
   * Apply dirty keyhole with world-specific mask and flavor-based surface condition.
   * Keyhole is the DOMINANT MASK â€” everything inside is scene, everything outside is material.
   *
   * SELF-CHECK AUDIT runs before application. If audit fails, output is suppressed.
   *
   * @param {HTMLElement} keyholeEl - The keyhole overlay container element
   * @param {string} world - World name (Modern, Historical, Fantasy, SciFi, Dystopia, PostApocalyptic)
   * @param {boolean} hasSoulmates - Whether soulmates modifier applies
   */
  function applyDirtyKeyhole(keyholeEl, world, hasSoulmates) {
      const keyholeplate = document.getElementById('keyholeplate');
      if (!keyholeplate) {
          console.warn('[DirtyKeyhole] Keyhole plate element not found â€” keyhole suppressed');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SELF-CHECK AUDIT (MANDATORY)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const flavor = state.picks?.worldSubtype || null;
      const audit = auditDirtyKeyhole(world, flavor);
      if (!audit.valid) {
          console.error('[DirtyKeyhole] DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED');
          console.error('[DirtyKeyhole] Reason:', audit.reason);
          keyholeEl.classList.add('hidden');
          keyholeEl.className = 'cover-keyhole-overlay hidden';
          return;
      }

      // Normalize world name to asset key
      const normalizedWorld = (world || 'Modern').toLowerCase().replace(/[\s-]/g, '');
      const assetKey = DIRTY_KEYHOLE_WORLD_MAP[normalizedWorld] || 'modern';
      const maskPath = `/assets/keyholes/${assetKey}_mask.png`;

      // Get world class for material styling
      const worldClass = 'world-' + assetKey;

      // Get flavor class for surface condition
      const flavorClass = flavor && DIRTY_KEYHOLE_FLAVOR_MAP[flavor]
          ? 'flavor-' + DIRTY_KEYHOLE_FLAVOR_MAP[flavor]
          : '';

      // Build class list for the overlay
      const classes = ['cover-keyhole-overlay', worldClass];
      if (hasSoulmates) classes.push('soulmates');
      if (flavorClass) classes.push(flavorClass);

      // Apply the mask to the keyhole plate
      const maskUrl = `url("${maskPath}")`;
      keyholeplate.style.webkitMaskImage = maskUrl;
      keyholeplate.style.maskImage = maskUrl;

      // Set up image preload to verify mask asset availability
      const testImg = new Image();
      testImg.onload = function() {
          // Asset available â€” apply classes and show
          keyholeEl.className = classes.join(' ');
          console.log('[DirtyKeyhole] Audit PASSED | Mask loaded:', maskPath, '| Classes:', classes.join(' '));

          // Set title + author into keyhole metalwork (MUST be engraved, not floating)
          const titleEl = keyholeEl.querySelector('.keyhole-title');
          const storyTitle = document.getElementById('storyTitle');
          if (titleEl) {
              const t = storyTitle?.textContent || '';
              titleEl.innerHTML = (t ? '<span class="keyhole-title-text">' + t.replace(/</g, '&lt;') + '</span>' : '') +
                  '<span class="keyhole-author">by ANONYMOUS</span>';
          }
      };

      testImg.onerror = function() {
          // Asset unavailable â€” suppress keyhole and log
          console.error('[DirtyKeyhole] DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED');
          console.error('[DirtyKeyhole] Reason: Mask asset unavailable at', maskPath);
          keyholeEl.classList.add('hidden');
          keyholeEl.className = 'cover-keyhole-overlay hidden';
          keyholeplate.style.webkitMaskImage = '';
          keyholeplate.style.maskImage = '';
      };

      // Trigger asset verification
      testImg.src = maskPath;
  }

  /**
   * Reset cover overlay layers (called when resetting book state)
   */
  function resetCoverLayers() {
      const fallbackEl = document.getElementById('coverFallback');
      const borderEl = document.getElementById('coverEroticBorder');
      const keyholeEl = document.getElementById('coverKeyholeOverlay');
      const coverImg = document.getElementById('bookCoverImg');
      const borderImg = document.getElementById('eroticBorderImg');
      const keyholeplate = document.getElementById('keyholeplate');

      if (fallbackEl) { fallbackEl.classList.add('hidden'); fallbackEl.innerHTML = ''; }
      if (borderEl) { borderEl.className = 'cover-erotic-border hidden'; }
      if (borderImg) { borderImg.src = ''; borderImg.onload = null; borderImg.onerror = null; }
      if (keyholeEl) { keyholeEl.className = 'cover-keyhole-overlay hidden'; }
      if (keyholeplate) { keyholeplate.style.webkitMaskImage = ''; keyholeplate.style.maskImage = ''; }
      if (coverImg) { coverImg.style.display = ''; }
  }

  // ============================================================
  // COVER SYSTEM â€” NON-BLOCKING PRINCIPLE (CRITICAL)
  // ============================================================
  // Cover rendering must NEVER block story creation.
  // Failure results in GRACEFUL FALLBACK, not retry or abort.
  //
  // Rules:
  // - All cover generation is async and non-blocking
  // - All failure paths return null â†’ renderFallbackCover()
  // - NO retries, NO loops, NO user-blocking errors
  // - Story creation succeeds even if cover generation fails
  // - Phase 1 Forged Cover is always available as fallback
  // ============================================================

  // ============================================================
  // ASSET AVAILABILITY REGISTRY (Phase 2+)
  // Lists valid objectIds for cover specs
  // If a referenced asset is unavailable â†’ fallback (not retry)
  // ============================================================
  const COVER_ASSET_REGISTRY = {
      // TIER 1 â€” Anchored PNG assets (preferred)
      objects: new Set([
          'mask_archetype_canonical',
          'wax_seal_standard',
          'relic_key'
      ])
      // NOTE: Framing assets removed â€” both KEYHOLE and BORDER are now runtime-rendered
      // TEMPORARY MODE: Synthetic erotic borders enabled until explicit asset replacement
  };

  // ============================================================
  // ğŸ§± ASSET STRUCTURE (REQUIRED)
  // Defines how canonical object assets are stored and referenced
  // ============================================================
  //
  // SCOPE CLARIFICATION:
  // Rules regarding gravity, resting behavior, and non-floating placement apply ONLY at final cover composition time.
  // They do NOT apply to how canonical object assets are stored, rendered, or represented in the asset repository.
  //
  // ============================================================

  // ============================================================
  // ğŸ§© ASSEMBLY RULES (CRITICAL)
  // Governs how assets are combined into final cover compositions
  // ============================================================
  //
  // OBJECT INTEGRITY:
  // Treat all object assets as rigid physical objects.
  // Do NOT deform, warp, bend, or reshape object geometry to match background topology unless explicitly instructed.
  //
  // DEPTH PRESERVATION:
  // Do NOT flatten, emboss, or convert three-dimensional object details into surface textures during assembly.
  // Preserve perceived depth, volume, and protrusion from the original asset.
  //
  // EDGE HANDLING GUARDRAIL:
  // Do NOT assume object assets are poor quality by default.
  // Some assets may be near-clean chroma-key renders.
  // Apply edge softening or blending ONLY if visual artifacts are present.
  // Never degrade clean edges unnecessarily.
  //
  // CONTACT SHADOW (MANDATORY):
  // All placed objects must cast a contact shadow appropriate to the scene lighting.
  //
  // CONTACT SHADOW SCOPE:
  // Contact shadows are generated ONLY AFTER an object has been keyed and placed onto a background surface.
  // Never bake contact shadows, ambient occlusion, or surface assumptions into the object asset itself.
  //
  // ============================================================

  // ============================================================
  // KEYHOLE FRAMING â€” RUNTIME RENDER SPECIFICATION
  // Keyholes are NOT asset files. They MUST be rendered by the
  // image model at runtime as physical objects or carved apertures.
  // Claude specifies properties; image model renders.
  // ============================================================
  const KEYHOLE_RENDER_REQUIREMENTS = {
      // Required properties for keyhole spec validation
      required: ['aperture', 'material', 'edgeStyle', 'integration'],
      // Aperture constraints (percentage of cover dimensions)
      aperture: {
          height: { min: 0.65, max: 0.80 },  // 65-80% of cover height
          width: { min: 0.40, max: 0.50 }    // 40-50% of cover width
      },
      // Valid material types
      materials: new Set([
          'brass', 'iron', 'bronze', 'oxidized_copper', 'blackened_steel',
          'carved_wood', 'carved_stone', 'bone', 'obsidian', 'gold_filigree'
      ]),
      // Valid edge styles
      edgeStyles: new Set([
          'beveled', 'chamfered', 'worn', 'sharp', 'ornate', 'weathered', 'forged'
      ]),
      // Integration behaviors (how keyhole meets cover surface)
      integrations: new Set([
          'inset', 'raised', 'flush', 'recessed_shadow', 'embossed'
      ])
  };

  // ============================================================
  // BORDER FRAMING â€” SYNTHETIC RUNTIME RENDER (TEMPORARY MODE)
  // Until explicit asset replacement, erotic borders MUST be:
  // - Generated by image model at render time
  // - Thin-line only (etched / engraved / diagrammatic)
  // - Flat graphic language (no depth, no bevel, no shadow)
  // - Monochrome or near-monochrome
  // - Symbolic, not illustrative
  // ============================================================
  const BORDER_RENDER_REQUIREMENTS = {
      // Required properties for border spec validation
      required: ['lineStyle', 'motifFamily', 'lineWeight', 'margin'],
      // Valid line styles (flat, no depth)
      lineStyles: new Set([
          'etched', 'engraved', 'continuous', 'dashed', 'dotted'
      ]),
      // Valid motif families (ONE only per border)
      motifFamilies: new Set([
          'filigree', 'restraint', 'floral', 'geometric'
      ]),
      // Valid line weights
      lineWeights: new Set([
          'thin', 'hairline', 'fine'
      ]),
      // Margin constraints (percentage from edge)
      margin: { min: 0.02, max: 0.08 }  // 2-8% from edge
  };

  // BORDER HARD BANS â€” Claude must NOT include these
  const BORDER_HARD_BANS = [
      'shading', 'texture', 'lighting', 'shadow', 'bevel', 'depth',
      'scene', 'background', 'anatomy', 'explicit', 'body', 'figure'
  ];

  /**
   * Validate border render specification (TEMPORARY SYNTHETIC MODE)
   * Borders are flat graphic elements rendered at runtime, NOT asset files
   * Returns { valid: false } if spec is malformed or violates constraints
   */
  function validateBorderSpec(borderSpec) {
      if (!borderSpec) {
          return { valid: false, reason: 'BORDER_SPEC_MISSING' };
      }

      // Check all required fields present
      for (const field of BORDER_RENDER_REQUIREMENTS.required) {
          if (!borderSpec[field]) {
              return { valid: false, reason: 'BORDER_MISSING_FIELD', missingField: field };
          }
      }

      // Validate line style
      if (!BORDER_RENDER_REQUIREMENTS.lineStyles.has(borderSpec.lineStyle)) {
          return { valid: false, reason: 'BORDER_LINE_STYLE_INVALID', value: borderSpec.lineStyle };
      }

      // Validate motif family (ONE only)
      if (!BORDER_RENDER_REQUIREMENTS.motifFamilies.has(borderSpec.motifFamily)) {
          return { valid: false, reason: 'BORDER_MOTIF_INVALID', value: borderSpec.motifFamily };
      }

      // Validate line weight
      if (!BORDER_RENDER_REQUIREMENTS.lineWeights.has(borderSpec.lineWeight)) {
          return { valid: false, reason: 'BORDER_LINE_WEIGHT_INVALID', value: borderSpec.lineWeight };
      }

      // Validate margin distance
      const reqMargin = BORDER_RENDER_REQUIREMENTS.margin;
      if (borderSpec.margin < reqMargin.min || borderSpec.margin > reqMargin.max) {
          return { valid: false, reason: 'BORDER_MARGIN_INVALID', value: borderSpec.margin };
      }

      return { valid: true };
  }

  /**
   * Validate keyhole render specification
   * Keyholes are physical objects rendered at runtime, NOT asset references
   * Returns { valid: false } if spec is malformed or missing required fields
   */
  function validateKeyholeSpec(keyholeSpec) {
      if (!keyholeSpec) {
          return { valid: false, reason: 'KEYHOLE_SPEC_MISSING' };
      }

      // Check all required fields present
      for (const field of KEYHOLE_RENDER_REQUIREMENTS.required) {
          if (!keyholeSpec[field]) {
              return { valid: false, reason: 'KEYHOLE_MISSING_FIELD', missingField: field };
          }
      }

      // Validate aperture proportions
      const { aperture } = keyholeSpec;
      const reqAperture = KEYHOLE_RENDER_REQUIREMENTS.aperture;
      if (aperture.height < reqAperture.height.min || aperture.height > reqAperture.height.max) {
          return { valid: false, reason: 'KEYHOLE_APERTURE_HEIGHT_INVALID', value: aperture.height };
      }
      if (aperture.width < reqAperture.width.min || aperture.width > reqAperture.width.max) {
          return { valid: false, reason: 'KEYHOLE_APERTURE_WIDTH_INVALID', value: aperture.width };
      }

      // Validate material
      if (!KEYHOLE_RENDER_REQUIREMENTS.materials.has(keyholeSpec.material)) {
          return { valid: false, reason: 'KEYHOLE_MATERIAL_INVALID', value: keyholeSpec.material };
      }

      // Validate edge style
      if (!KEYHOLE_RENDER_REQUIREMENTS.edgeStyles.has(keyholeSpec.edgeStyle)) {
          return { valid: false, reason: 'KEYHOLE_EDGE_INVALID', value: keyholeSpec.edgeStyle };
      }

      // Validate integration
      if (!KEYHOLE_RENDER_REQUIREMENTS.integrations.has(keyholeSpec.integration)) {
          return { valid: false, reason: 'KEYHOLE_INTEGRATION_INVALID', value: keyholeSpec.integration };
      }

      return { valid: true };
  }

  /**
   * ASSET AVAILABILITY RULE â€” Phase 2+ safety gate
   * If a referenced objectId is unavailable at render time:
   * - Abort custom generation
   * - Return null (triggers Phase 1 Forged Cover fallback)
   * - No substitution, no invention, no additional AI calls
   *
   * FRAMING EXCEPTIONS (TEMPORARY MODE):
   * - KEYHOLE: runtime-rendered physical aperture; validate keyholeSpec
   * - BORDER: runtime-rendered synthetic line art; validate borderSpec
   * Both are generated by image model, NOT asset files.
   */
  function validateCoverAssets(coverSpec) {
      if (!coverSpec) return { valid: true };

      const { objectId, framing, keyholeSpec, borderSpec } = coverSpec;

      // Check objectId availability (TIER 1 assets only)
      if (objectId && !COVER_ASSET_REGISTRY.objects.has(objectId)) {
          console.warn('[CoverAsset] UNAVAILABLE objectId:', objectId, 'â†’ aborting custom generation');
          return { valid: false, reason: 'OBJECT_UNAVAILABLE', missingAsset: objectId };
      }

      // KEYHOLE FRAMING â€” runtime render, physical aperture
      if (framing === 'KEYHOLE') {
          const keyholeValidation = validateKeyholeSpec(keyholeSpec);
          if (!keyholeValidation.valid) {
              console.warn('[CoverAsset] Invalid keyholeSpec:', keyholeValidation.reason, 'â†’ aborting custom generation');
              return keyholeValidation;
          }
          return { valid: true };
      }

      // BORDER FRAMING â€” runtime render, synthetic line art (TEMPORARY MODE)
      if (framing === 'BORDER') {
          const borderValidation = validateBorderSpec(borderSpec);
          if (!borderValidation.valid) {
              console.warn('[CoverAsset] Invalid borderSpec:', borderValidation.reason, 'â†’ aborting custom generation');
              return borderValidation;
          }
          return { valid: true };
      }

      // NONE framing â€” no framing validation needed
      return { valid: true };
  }

  /**
   * Generate book cover via image model (Phase 2+ only)
   * NON-BLOCKING: Returns null on ANY failure â†’ triggers fallback at call site
   * NEVER retries, NEVER throws, NEVER blocks story creation
   */
  async function generateBookCover(synopsis, title, authorName) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”´ MINIMAL COVER v1 QUARANTINE GUARD
      // When enabled, ALL legacy systems are bypassed â€” no exceptions
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (USE_MINIMAL_COVER_V1) {
          const coverUrl = await generateMinimalCoverV1({
              synopsis,
              title,
              authorName,
              world: state.picks?.world || 'Modern',
              genre: state.picks?.genre || 'Billionaire',
              tone: state.picks?.tone || 'Earnest',
              intensity: state.intensity || 'Naughty'
          });

          if (coverUrl) {
              stopCoverLoading(coverUrl);
          } else {
              stopCoverLoading(null);
          }

          return coverUrl;
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LEGACY COVER SYSTEM BELOW â€” QUARANTINED (does not execute when v1 enabled)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Extract story context for symbolic object selection (4-axis system)
      const world = state.picks?.world || 'Modern';
      const tone = state.picks?.tone || 'Earnest';
      const genre = state.picks?.genre || 'Billionaire';
      const dynamic = state.picks?.dynamic || 'Enemies';
      const era = state.picks?.world === 'Historical' ? (state.picks?.era || 'Medieval') : null;
      // Power Role + Power Frame: resolve genre into world-appropriate labels
      const powerRole = resolvePowerRole(world, era, genre);
      const powerFrame = resolvePowerFrame(world, genre);
      // Extract arousal/intensity
      const arousal = state.intensity || null;

      // Archetype selection â€” deterministic, world-based, never null
      const archetype = selectCoverArchetype(genre, dynamic, tone, world, synopsis);

      // DEV LOGGING: generation-time state snapshot
      console.log('[DEV:CoverGen] world:', world, '| tone:', tone, '| genre:', genre, 'â†’ powerRole:', powerRole, '| archetype:', archetype, '| arousal:', arousal);
      console.log('[DEV:WorldResolve] world:', world, '| genre:', genre, 'â†’ archetype:', archetype, '| powerFrame:', powerFrame);

      // DSP-lite subtitle replaces series label
      const modeLine = generateCoverSubtitle();
      // Build story style description
      const storyStyle = `${tone} ${powerRole}`;

      // COVER INTELLIGENCE: Build intelligent prompt with focal object, anti-repetition, domain background, palette
      let coverIntel = null;
      try {
          coverIntel = await buildCoverPrompt(synopsis, genre, world, tone, dynamic, era);
          console.log('[CoverIntel] Focal object:', coverIntel.focalObject);
          console.log('[CoverIntel] Background:', coverIntel.background);
          console.log('[CoverIntel] Palette:', coverIntel.palette.primary, '/', coverIntel.palette.secondary);

          // Store cover emotion for later validation
          state.coverEmotion = coverIntel.emotion || 'mystery';

          // SIGNAL ALIGNMENT CHECK â€” validate title â†” cover consistency
          const signalCheck = validateSignalAlignment(title, coverIntel, {
              arousal: arousal || 'Naughty',
              tone: tone,
              genre: genre
          });
          if (!signalCheck.aligned) {
              console.warn('[SignalAlignment] Title â†” Cover mismatch:', signalCheck.errors.map(e => e.message));
              // Log for analytics but don't block generation
              // Future: could trigger title adjustment or cover prompt modification
          } else {
              console.log('[SignalAlignment] PASS â€” Title and cover signal same axis');
          }
      } catch (intelErr) {
          console.warn('[CoverIntel] Intelligence extraction failed, using fallback:', intelErr.message);
      }

      // Build enhanced prompt with cover intelligence (symbolic only â€” no story prose)
      const enhancedPrompt = coverIntel
          ? coverIntel.promptText
          : 'A dramatic symbolic book cover with atmospheric lighting, no text, no people';

      // ============================================================
      // ASSET AVAILABILITY RULE â€” Phase 2+ safety gate
      // If coverIntel specifies unavailable assets, abort to fallback
      // No substitution, no invention, no additional AI calls
      // ============================================================
      if (coverIntel?.coverSpec) {
          const assetCheck = validateCoverAssets(coverIntel.coverSpec);
          if (!assetCheck.valid) {
              console.warn('[BookCover] Asset unavailable:', assetCheck.missingAsset, 'â†’ aborting to Phase 1 fallback');
              return null; // Triggers renderFallbackCover at call site
          }
      }

      try {
          // Use global abort controller for cancellation support
          const signal = _coverAbortController?.signal;

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              signal: signal,
              body: JSON.stringify({
                  prompt: enhancedPrompt,
                  imageIntent: 'book_cover',
                  title: (title && title !== 'Untitled') ? title : '',
                  authorName: authorName || 'ANONYMOUS',
                  modeLine: modeLine,
                  dynamic: dynamic,
                  storyStyle: storyStyle,
                  genre: powerRole,
                  size: '1024x1024',
                  // Pass cover intelligence metadata for server-side use
                  coverIntel: coverIntel ? {
                      focalObject: coverIntel.focalObject,
                      material: coverIntel.material,
                      background: coverIntel.background,
                      palette: {
                          primary: coverIntel.palette.primary,
                          secondary: coverIntel.palette.secondary,
                          accent: coverIntel.palette.accent
                      }
                  } : null,
                  // Phase 2b: New params (plumbing only, not yet used by API)
                  archetype: archetype,
                  arousal: arousal,
                  world: world,
                  era: era
              })
          });

          if (!res.ok) {
              console.warn('[BookCover] HTTP error:', res.status);
              return null;
          }

          const data = await res.json();
          return data?.url || null;
      } catch (err) {
          // Handle abort gracefully (not an error)
          if (err.name === 'AbortError') {
              console.log('[BookCover] Generation aborted by user');
              return null;
          }
          console.error('[BookCover] Generation failed:', err.message);
          return null;
      }
  }

  // =================================================================
  // WRY CONFESSIONAL â€” COVER RULESET (AUTHORITATIVE)
  // Editorial cartoon covers in the style of The New Yorker
  // =================================================================

  const WRY_CONFESSIONAL_COVER_RULES = {
      aspectRatio: '5:7',
      uiSuppressions: {
          hideSubscriptionGates: true,
          hideIntensityOverlays: true,
          hideCTAButtons: true,
          hideRequiresAccessCopy: true
      }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WRY CONFESSIONAL â€” COVER INTERPRETATION (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Wry Confessional covers must operate at the level of
  // editorial commentary, irony, or subversive observation,
  // comparable to a New Yorker cover.
  //
  // Literal object-only symbolism (e.g. a single key, book,
  // rose, or prop without contextual tension) is insufficient
  // unless the composition itself introduces irony or critique.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WRY CONFESSIONAL â€” SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Before finalizing any cover where tone === 'Wry Confessional',
  // Claude MUST silently evaluate:
  //
  // "Would this image still make sense â€” and still feel pointed â€”
  // if it appeared alone on a New Yorker cover with no caption?"
  //
  // If the honest answer is NO, the cover must be regenerated.
  //
  // This check is INTERNAL.
  // Do not explain it.
  // Do not soften it.
  // Do not bypass it for symbolism, prettiness, or mood.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL â€” COVER REGIME (AUTHORITATIVE)
  // TAG: storybound/wry-cover-regime-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // When tone === 'Wry Confessional',
  // cover generation operates under the
  // EDITORIAL JUDGMENT REGIME.
  //
  // Under this regime:
  //
  // - The cover is an editorial comment, not a depiction.
  // - The goal is subversive observation, irony, or critique.
  // - Literal object-only symbolism is insufficient unless
  //   the composition itself introduces tension or commentary.
  // - Ambiguity and restraint are strengths.
  // - Assembly logic is subordinate to editorial intent.
  //
  // This regime applies to all cover stages
  // (Sketch, Thumbnail, Rough, Final)
  // when tone === 'Wry Confessional'.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // NON-APPLICABILITY (CRITICAL)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // This regime applies ONLY when tone === 'Wry Confessional'.
  //
  // No other tone is affected.
  // No other cover behavior is changed.
  // Other tones continue to use their existing
  // assembly and stylistic logic.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER REGIME ROUTING (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Cover behavior is governed by a Cover Regime
  // selected by Tone.
  //
  // Routing is evaluated before assembly logic.
  //
  // Current routing table:
  //
  // - Wry Confessional â†’ Editorial Judgment Regime
  // - All other tones â†’ Legacy / Default Cover Regime
  //
  // No implicit blending is permitted.
  // Assembly logic must defer to the active Cover Regime.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER REGIME â€” FAILURE PREVENTION CLAUSE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If a cover output violates the active Cover Regime,
  // it must be regenerated.
  //
  // Assembly success does not override regime failure.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER REGIME CHANGE â€” JUDGMENT FIRST
  // TAG: storybound/cover-regime-judgment-first-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEPRECATION NOTICE â€” CONSTRUCTION-FIRST COVERS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Any assumption that a cover must be constructed
  // by assembling objects, characters, materials, or symbols
  // as a primary step is deprecated.
  //
  // This approach produced literal, repetitive, or decorative
  // results that failed to imply story arc or relational tension.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER REGIME â€” JUDGMENT FIRST (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Covers in Storybound are editorial artifacts, not composites.
  //
  // The cover generation process MUST proceed as follows:
  //
  // 1. Determine the editorial judgment:
  //    â€¢ What tension defines this story?
  //    â€¢ What emotional posture does the reader inhabit?
  //    â€¢ What promise does the book make?
  //
  // 2. Decide what the cover is *about*.
  //    This decision is conceptual, not visual.
  //
  // 3. Only then, optionally select imagery, symbols,
  //    characters, masks, or objects that serve that judgment.
  //
  // Assembly is subordinate.
  // Omission is permitted.
  // Literal depiction is not required.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // JUDGMENT-FIRST â€” SCOPING BY TONE (CRITICAL)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // This Judgment-First Cover Regime applies ONLY
  // to tones explicitly routed to it.
  //
  // Current routing:
  //
  // â€¢ Wry Confessional â†’ Judgment-First Cover Regime
  // â€¢ All other tones â†’ Legacy / Default Cover Regime
  //
  // No implicit expansion is permitted.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // OBJECTS AND MASKS â€” ROLE CLARIFICATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Objects, masks, and materials are OPTIONAL tools.
  //
  // They may be used when they reinforce the editorial judgment.
  // They must NOT be used by default.
  //
  // The presence of a Storybeau, mask, or symbolic object
  // does not obligate its appearance on the cover.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER FAILURE CONDITIONS (NON-NEGOTIABLE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // A cover has FAILED if:
  //
  // â€¢ It is primarily decorative.
  // â€¢ It relies on generic romance symbolism
  //   (e.g. keys, roses, candles) without critique.
  // â€¢ It explains rather than implies.
  // â€¢ It could be swapped with another story's cover
  //   without noticeable loss of meaning.
  //
  // Failure requires regeneration, not refinement.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WRY CONFESSIONAL â€” FINAL SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Before finalizing the cover, Claude MUST silently answer:
  //
  // "Does this cover take a position on the story,
  // or is it merely illustrating it?"
  //
  // If the honest answer is 'illustrating',
  // the cover must be regenerated.
  //
  // This check is INTERNAL.
  // Do not explain it.
  // Do not soften it.
  // Do not bypass it for polish or mood.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ASSEMBLY AS FALLBACK ONLY
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If no editorially valid cover emerges under
  // the Judgment-First Regime, legacy assembly
  // may be used ONLY as a fallback.
  //
  // Fallback assembly must still obey
  // the active Cover Regime.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // ============================================================
  // ğŸ”´ MINIMAL COVER v1 â€” QUARANTINE SYSTEM
  // ============================================================
  // When USE_MINIMAL_COVER_V1 = true, ALL legacy cover systems are bypassed:
  // - No Cover Assembly / Intelligence (buildCoverPrompt, extractFocalObject, etc.)
  // - No Backend Prompt Mutation Layers (erotic motif, typography, borders)
  // - No UX / Async Systems (phrase timers, progress bars, sparkles)
  // - No Anti-Repetition (motif history, abstraction ladder)
  // - No Fallback Substitution or auto-regeneration
  //
  // ONLY: One frozen intent â†’ One prompt â†’ One API call â†’ One image
  // ============================================================
  const USE_MINIMAL_COVER_V1 = true; // QUARANTINE KILL SWITCH

  /**
   * MINIMAL COVER v1 â€” Quarantined cover generation
   * NO legacy systems. NO retries. NO mutation. NO UI ownership.
   * @param {object} frozenIntent - {synopsis, title, authorName, world, genre, tone, intensity, stage}
   * @returns {Promise<string|null>} - Image URL or null
   */
  async function generateMinimalCoverV1(frozenIntent) {
      console.log('[COVER] Minimal Cover v1 active â€” ALL legacy systems bypassed');

      // EARNED COVER SYSTEM: Get stage (defaults to current stage if not provided)
      const stage = frozenIntent.stage || getCurrentCoverStage();
      const stageLabel = COVER_STAGE_LABELS[stage] || 'Cover';
      const stageModifier = getCoverStagePromptModifier(stage, frozenIntent.tone);

      console.log('[COVER:v1] Frozen intent:', {
          title: frozenIntent.title,
          world: frozenIntent.world,
          genre: frozenIntent.genre,
          tone: frozenIntent.tone,
          intensity: frozenIntent.intensity,
          stage: stage
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ASSEMBLY-COMPLIANT COVER PROMPT â€” AUTHORITATIVE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HARD CONSTRAINT: First cover MUST use Assembly List object
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // COVER OBJECT SELECTION RULES (NON-NEGOTIABLE):
      //
      // 1. FIRST COVER for any story MUST select focal object EXCLUSIVELY
      //    from the ASSEMBLY_OBJECTS list below.
      //
      // 2. Do NOT invent, substitute, or symbolize objects on first exposure.
      //
      // 3. Object invention is ONLY allowed if ALL of these are true:
      //    a) User has already seen at least one Assembly List object
      //    b) No remaining Assembly List object fits world/tone/genre
      //    c) Invented object does not contradict prior visual canon
      //
      // 4. If no Assembly List object fits well on first generation:
      //    SELECT THE CLOSEST VIABLE ASSEMBLY LIST OBJECT ANYWAY.
      //    This is visibility-gated fallback, NOT free creative choice.
      //
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const world = frozenIntent.world || 'modern';
      const genre = frozenIntent.genre || 'romance';
      const tone = frozenIntent.tone || 'romantic';
      const rawTitle = frozenIntent.title?.trim() || '';
      const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';

      // Track if this is the first cover for this story
      const isFirstCover = !state._coverAssemblyObjectShown;

      // APPROVED ASSEMBLY LIST â€” Select ONE object based on world/genre
      // These are the ONLY valid choices for first cover generation
      const ASSEMBLY_OBJECTS = {
          modern: ['vintage key', 'silk ribbon', 'pearl earring', 'champagne glass', 'red lipstick', 'leather journal', 'single rose', 'antique locket'],
          fantasy: ['ornate dagger', 'crystal vial', 'wax-sealed letter', 'jeweled crown', 'silver mask', 'enchanted mirror', 'golden chalice', 'raven feather'],
          historical: ['quill pen', 'pocket watch', 'cameo brooch', 'candelabra', 'love letter', 'silk fan', 'brass compass', 'velvet glove'],
          scifi: ['holographic card', 'chrome ring', 'data chip', 'neural interface', 'crystal shard', 'metallic rose', 'quantum locket', 'star map'],
          paranormal: ['blood vial', 'moonstone pendant', 'black candle', 'silver dagger', 'tarot card', 'obsidian mirror', 'wolf fang', 'crimson ribbon']
      };

      // Select object list based on world, default to modern
      const worldKey = world.toLowerCase().includes('fantasy') ? 'fantasy'
          : world.toLowerCase().includes('histor') ? 'historical'
          : world.toLowerCase().includes('sci') ? 'scifi'
          : world.toLowerCase().includes('paranormal') || world.toLowerCase().includes('vampire') ? 'paranormal'
          : 'modern';

      const objectList = ASSEMBLY_OBJECTS[worldKey];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // OBJECT SELECTION â€” HARD CONSTRAINT ENFORCED
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let selectedObject;

      if (isFirstCover) {
          // FIRST COVER: Must use Assembly List object â€” no exceptions
          selectedObject = objectList[Math.floor(Math.random() * objectList.length)];
          console.log('[COVER:v1] FIRST COVER â€” Assembly object REQUIRED:', selectedObject);
      } else if (state._coverAssemblyObject && objectList.includes(state._coverAssemblyObject)) {
          // SUBSEQUENT COVER: Prefer previously shown Assembly object for visual canon consistency
          selectedObject = state._coverAssemblyObject;
          console.log('[COVER:v1] SUBSEQUENT COVER â€” Reusing canonical object:', selectedObject);
      } else {
          // SUBSEQUENT COVER with different world: Select new Assembly object
          selectedObject = objectList[Math.floor(Math.random() * objectList.length)];
          console.log('[COVER:v1] SUBSEQUENT COVER (world change) â€” New Assembly object:', selectedObject);
      }

      // Record Assembly object in state for visual canon tracking
      state._coverAssemblyObjectShown = true;
      state._coverAssemblyObject = selectedObject;
      state._coverWorldKey = worldKey;

      console.log('[COVER:v1] Assembly object selected:', selectedObject, 'from', worldKey, '| isFirstCover:', isFirstCover);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSIONAL â€” FOCAL OBJECT ALTERATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let focalObjectDescription = selectedObject;

      if (tone === 'Wry Confessional') {
          const alteration =
              WRY_CONFESSIONAL_OBJECT_ALTERATIONS[
                  Math.floor(Math.random() * WRY_CONFESSIONAL_OBJECT_ALTERATIONS.length)
              ];
          focalObjectDescription = `${selectedObject}, ${alteration}`;
          console.log('[COVER:v1] Wry Confessional object alteration:', focalObjectDescription);
      }

      // ASSEMBLY-COMPLIANT PROMPT
      const minimalPrompt = `BOOK COVER IMAGE â€” ASSEMBLY SYSTEM

TASK: Generate a complete, print-ready book cover composition.

TITLE (must appear prominently): "${title}"
AUTHOR LINE (must appear below title): "by Anonymous"

FOCAL OBJECT (MANDATORY â€” exactly ONE):
${focalObjectDescription}

ABSOLUTE RULES:
- NO people, NO faces, NO figures anywhere in the image
- A subtle human SHADOW is allowed but must be secondary
- ONLY the specified object above â€” do NOT add other objects
- Do NOT invent new symbols or combine multiple objects
- Do NOT depict narrative action
- Full cover must be visible edge-to-edge
- Do NOT crop, zoom, or trim the composition
- Title-safe margins at top and bottom
- Design for vertical book cover proportions (5:7)

COMPOSITION:
- The ${focalObjectDescription} is the visual anchor, rendered clearly and symbolically
- Title text: large, high contrast, readable at thumbnail size
- Author line: smaller, elegant, below the title
${tone === 'Wry Confessional'
  ? '- Simple flat background\n- No vignette, no texture overlay'
  : '- Subtle vignette darkening at edges\n- Light paper or canvas texture overlay'}

STYLE:
${stageModifier ? stageModifier + '\n' : ''}${tone === 'Wry Confessional'
  ? WRY_CONFESSIONAL_VISUAL_ONTOLOGY
  : `Elegant, restrained, cinematic. Painterly realism, NOT illustration. Premium published novel aesthetic. Rich but muted color palette appropriate to ${tone} ${genre}.`}

${tone === 'Wry Confessional' ? '' : `WORLD MATERIAL TREATMENT (${worldKey}):
${worldKey === 'fantasy' ? '- Aged stone, tarnished metal, worn fabric textures' :
  worldKey === 'historical' ? '- Wood, brass, parchment, oil-stained cloth textures' :
  worldKey === 'scifi' ? '- Brushed alloy, polymer, subtle luminescence' :
  worldKey === 'paranormal' ? '- Dark velvet, oxidized silver, candlelit warmth' :
  '- Concrete, glass, leather, modern luxury textures'}
`}FORBIDDEN:
- NO glow effects or floating particles
- NO decorative borders or frames
- NO AI art clichÃ©s (no ethereal wisps, no magical sparkles)
- NO logos, icons, or UI-style graphics
- NO multiple objects or busy compositions
- NO characters or body parts (except subtle shadow)
${tone === 'Wry Confessional'
  ? '- NO cinematic lighting\n- NO painterly texture\n- NO dramatic shadows\n- NO realism\n- NO noir aesthetic'
  : '- NO visual punchlines\n- NO exaggerated contrast\n- NO theatrical or ironic staging'}

${tone === 'Wry Confessional'
  ? 'The final image must look like a New Yorker editorial cartoon â€” simple, flat, understated.'
  : 'The final image must look like a real published novel cover â€” tasteful, evocative, professional.'}`;

      console.log('[COVER:v1] Minimal prompt generated (', minimalPrompt.length, 'chars)');

      // REGRESSION GUARD: Block cinematic drift for Wry Confessional
      assertWryConfessionalVisual(minimalPrompt, 'generateMinimalCoverV1');

      try {
          // ONE API call â€” no retries, no fallbacks, no enhancement layers
          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: minimalPrompt,
                  imageIntent: 'book_cover',
                  size: '1024x1536', // 5:7 portrait ratio (book cover canonical)
                  // Minimal metadata â€” no coverIntel, no archetype, no layers
                  _minimalV1: true // Backend flag to skip all enhancement
              })
          });

          if (!res.ok) {
              console.error('[COVER:v1] API error:', res.status);
              return null;
          }

          const data = await res.json();
          const imageUrl = data?.url || null;

          if (imageUrl) {
              console.log('[COVER:v1] SUCCESS â€” Image received');
          } else {
              console.warn('[COVER:v1] No image URL in response');
          }

          return imageUrl;

      } catch (err) {
          console.error('[COVER:v1] Fetch error:', err.message);
          return null;
      }
  }

  // ============================================================
  // PHYSICAL BOOK INTERACTION SYSTEM
  // Hinge-based open, courtesy peek, no buttons
  // ============================================================
  // ğŸ”´ OPENING BOOK SYSTEM â€” DISABLED FOR STABILIZATION
  // ============================================================
  // The opening book system is temporarily disabled to stabilize:
  // - Cover rendering
  // - Reader navigation
  // - Async flow
  //
  // When USE_OPENING_BOOK = false:
  // - Cover renders as plain full-screen image (no transforms/mirroring)
  // - Navigation is linear: COVER â†’ SETTING â†’ SCENE
  // - Back: SCENE â†’ SETTING â†’ COVER
  // - No book animations, no page flips, no inside cover
  // ============================================================
  const USE_OPENING_BOOK = false; // KILL SWITCH â€” set to true to re-enable book system

  const COURTESY_HINGE_KEY = 'storybound_courtesy_hinge_shown';
  let _courtesyHingeTimeout = null;
  let _bookOpened = false;
  let _settingImagePromise = Promise.resolve(); // Gate for opening spread readiness (disabled)

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BACKGROUND STORY LOADING â€” Story text generation promise
  // Resolves when Scene 1 text is mounted and ready for display
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _storyTextPromise = null;
  let _storyTextResolver = null;

  function initStoryTextPromise() {
      _storyTextPromise = new Promise(resolve => {
          _storyTextResolver = resolve;
      });
  }

  function resolveStoryTextReady() {
      if (_storyTextResolver) {
          console.log('[STORY:READY] Scene 1 text mounted â€” story ready for display');
          _storyTextResolver(true);
          _storyTextResolver = null;
      }
  }

  // SIMPLIFIED PAGE STATE (when book disabled)
  // 0 = COVER, 1 = SETTING, 2+ = SCENE
  let _readerPage = 0;

  /**
   * SIMPLIFIED READER PAGE DISPLAY (when book disabled)
   * Linear flow with no animations, no transforms, no book state.
   * @param {number} page - 0=COVER, 1+=SCENE (NO separate SETTING page)
   */
  function showReaderPage(page) {
      _readerPage = page;
      console.log('[READER] showReaderPage:', page);

      const bookCoverPage = document.getElementById('bookCoverPage');
      const settingPlate = document.getElementById('settingPlate');
      const storyContent = document.getElementById('storyContent');
      const bookCover = document.getElementById('bookCover');

      // Remove any book animation classes
      if (bookCover) {
          bookCover.classList.remove('hinge-open', 'courtesy-peek');
      }

      if (page === 0) {
          // COVER: Show cover only
          if (bookCoverPage) bookCoverPage.classList.remove('hidden');
          if (storyContent) storyContent.classList.add('hidden');
          console.log('[READER] Page 0: COVER (static full-screen)');
      } else {
          // SCENE 1+: Show story content with inline setting image
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          if (storyContent) storyContent.classList.remove('hidden');

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // STEP 1: Ensure story text is visible (opacity was set to 0 during creation)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const storyText = document.getElementById('storyText');
          if (storyText) {
              storyText.classList.remove('hidden');
              storyText.style.opacity = '1';
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // STEP 2: Synopsis HIDDEN â€” linear flow goes directly to prose
          // Synopsis data remains in state for future reference if needed
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const sceneSynopsis = document.getElementById('sceneSynopsis');
          if (sceneSynopsis) {
              sceneSynopsis.classList.add('hidden');
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SETTING PLATE: Hidden (auto-generation disabled)
          // Setting images only appear on explicit user request
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (settingPlate) {
              settingPlate.classList.add('hidden');
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // C. PRECOMPUTE VISUALIZE PROMPT â€” Non-blocking prefill on scene mount
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          precomputeVizPrompt();

          console.log('[READER] Page 1+: SCENE (Title â†’ Prose, synopsis hidden)');
      }
  }

  /**
   * C. PRECOMPUTE VISUALIZE PROMPT â€” Pre-fill prompt input when scene mounts
   * Non-blocking: runs in background, does not delay scene display
   */
  async function precomputeVizPrompt() {
      const promptInput = document.getElementById('vizPromptInput');
      if (!promptInput) return;

      // Don't overwrite if user has already edited
      if (promptInput.value.trim()) return;

      const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      if (!allStoryContent.trim()) return;

      const lastText = allStoryContent.slice(-600) || "";

      try {
          // Wry Confessional: Direct ontology-based prompt (no LLM call)
          if (state.picks?.tone === 'Wry Confessional') {
              const condensedScene = condenseSceneObservational(lastText, 120);
              promptInput.value = `${WRY_CONFESSIONAL_VISUAL_ONTOLOGY} Scene: ${condensedScene}`;
              console.log('[VIZ:PREFILL] Wry Confessional prompt precomputed');
              return;
          }

          // Standard: LLM generates prompt
          await ensureVisualBible(allStoryContent);
          const anchorText = buildVisualAnchorsText();
          const visualizePrompt = buildVisualizePrompt({ mode: 'scene', lastText, anchorText });

          const promptMsg = await Promise.race([
              callChat([{ role: 'user', content: visualizePrompt }]),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Prefill timeout")), 15000))
          ]);

          // Only set if still empty (user may have started editing)
          if (!promptInput.value.trim()) {
              promptInput.value = promptMsg;
              console.log('[VIZ:PREFILL] Standard prompt precomputed');
          }
      } catch (e) {
          console.log('[VIZ:PREFILL] Failed (non-critical):', e.message);
          // Non-blocking failure â€” prompt will be generated when modal opens
      }
  }

  /**
   * ADVANCE TO NEXT READER PAGE (when book disabled)
   * Called when user clicks to continue.
   */
  function advanceReaderPage() {
      const nextPage = _readerPage + 1;
      showReaderPage(nextPage);
  }

  // Check if courtesy hinge has already been shown (one-time ever)
  function hasSeenCourtesyHinge() {
      try {
          return localStorage.getItem(COURTESY_HINGE_KEY) === 'true';
      } catch (e) {
          return false;
      }
  }

  // Mark courtesy hinge as shown
  function markCourtesyHingeShown() {
      try {
          localStorage.setItem(COURTESY_HINGE_KEY, 'true');
      } catch (e) {
          // localStorage unavailable
      }
  }

  // Schedule courtesy hinge (2-3 seconds after cover shows)
  function scheduleCourtesyHinge() {
      // BOOK SYSTEM DISABLED â€” no courtesy hinge
      if (!USE_OPENING_BOOK) return;

      if (hasSeenCourtesyHinge() || _bookOpened) return;

      _courtesyHingeTimeout = setTimeout(() => {
          if (_bookOpened) return; // User already opened

          const bookCover = document.getElementById('bookCover');
          if (bookCover) {
              bookCover.classList.add('courtesy-peek');
              markCourtesyHingeShown();

              // Remove class after animation completes
              setTimeout(() => {
                  bookCover.classList.remove('courtesy-peek');
              }, 2100);
          }
      }, 2500);
  }

  // Cancel courtesy hinge if user clicks
  function cancelCourtesyHinge() {
      if (_courtesyHingeTimeout) {
          clearTimeout(_courtesyHingeTimeout);
          _courtesyHingeTimeout = null;
      }
  }

  // ============================================================
  // BOOK PAGE TYPE DEFINITIONS (Authoritative Spec)
  // ============================================================
  // Page sequence: COVER (0) â†’ INSIDE_COVER (1) â†’ SCENE (2+)
  // Each page type has strict content rules.
  const BOOK_PAGE_TYPES = {
      COVER: 'cover',              // Page 0: Front cover visual only (no text)
      INSIDE_COVER: 'inside_cover', // Page 1: Title + synopsis (NO image generation)
      SCENE: 'scene'               // Page 2+: Scene text (setting image INLINE if present)
  };

  // BOOK PAGE STATE MACHINE
  // Explicit page index â€” NOT boolean flags
  let _bookPageIndex = 0; // 0=cover, 1=inside_cover, 2+=scene

  /**
   * Set the current book page with explicit visibility control.
   * Each page type has ONE valid render state.
   * @param {number} pageIndex - 0=cover, 1=setting, 2=scene
   */
  function setBookPage(pageIndex) {
      const oldIndex = _bookPageIndex;
      _bookPageIndex = pageIndex;
      console.log('[DEBUG PAGE STATE] setBookPage:', oldIndex, 'â†’', pageIndex);

      const bookCoverPage = document.getElementById('bookCoverPage');
      const bookCover = document.getElementById('bookCover');
      const storyContent = document.getElementById('storyContent');
      const settingPlate = document.getElementById('settingPlate');
      const storyTitle = document.getElementById('storyTitle');
      const sceneNumber = document.getElementById('sceneNumber');
      const storyText = document.getElementById('storyText');

      // Reset all visibility first
      if (bookCoverPage) bookCoverPage.classList.remove('hidden', 'page-flip-out');
      if (storyContent) storyContent.classList.remove('hidden', 'fade-in');
      if (settingPlate) settingPlate.classList.remove('hidden', 'setting-active');
      if (storyTitle) storyTitle.classList.remove('hidden');
      if (sceneNumber) sceneNumber.classList.remove('hidden');
      if (storyText) storyText.classList.remove('hidden');

      // Apply page-specific visibility
      if (pageIndex === 0) {
          // PAGE 0: COVER â€” Only cover visible
          console.log('[DEBUG PAGE CLASSIFY] decision=COVER, pageIndex=', pageIndex);
          if (bookCoverPage) bookCoverPage.classList.remove('hidden');
          if (storyContent) storyContent.classList.add('hidden');
          if (settingPlate) settingPlate.classList.add('hidden');
          console.log('[BookPage] Page 0: COVER');
      } else if (pageIndex === 1) {
          // PAGE 1: INSIDE_COVER â€” Title + synopsis (NO image generation)
          console.log('[DEBUG PAGE CLASSIFY] decision=INSIDE_COVER, pageIndex=', pageIndex);
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          // Show inside cover content area
          const insideCover = document.getElementById('bookInsideCover');
          if (insideCover) insideCover.classList.remove('hidden');
          // Hide story content and setting plate on inside cover
          if (storyContent) storyContent.classList.add('hidden');
          if (settingPlate) settingPlate.classList.add('hidden');
          console.log('[BookPage] Page 1: INSIDE_COVER');
      } else if (pageIndex >= 2) {
          // PAGE 2+: SCENE â€” Scene text with setting image INLINE (not fullscreen)
          console.log('[DEBUG PAGE CLASSIFY] decision=SCENE, pageIndex=', pageIndex);
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          // Hide inside cover
          const insideCover = document.getElementById('bookInsideCover');
          if (insideCover) insideCover.classList.add('hidden');
          // Show story content
          if (storyContent) storyContent.classList.remove('hidden');
          // Setting plate should be INLINE within storyContent, not fullscreen
          // Only show if scene 1 and setting image exists
          if (settingPlate && pageIndex === 2) {
              settingPlate.classList.remove('hidden');
              settingPlate.classList.add('setting-inline'); // Inline mode, not fullscreen
          } else if (settingPlate) {
              settingPlate.classList.add('hidden');
          }
          // Show title and scene
          if (storyTitle) storyTitle.classList.remove('hidden');
          if (sceneNumber) sceneNumber.classList.remove('hidden');
          if (storyText) {
              storyText.classList.remove('hidden');
              storyText.style.opacity = '1';
          }
          console.log('[BookPage] Page 2+: SCENE');
      }

      // Validate page integrity
      const flowCheck = validateBookFlowIntegrity();
      if (!flowCheck.valid) {
          console.error('[BookPage] INTEGRITY FAIL at page ' + pageIndex, flowCheck.errors);
      }
  }

  /**
   * Advance to the next book page with appropriate transition.
   */
  function advanceBookPage() {
      const nextPage = _bookPageIndex + 1;
      const currentType = _bookPageIndex === 0 ? 'cover' : _bookPageIndex === 1 ? 'inside_cover' : 'scene';
      const nextType = nextPage === 0 ? 'cover' : nextPage === 1 ? 'inside_cover' : 'scene';
      console.log('[DEBUG PAGE MOUNT] advanceBookPage: current=', _bookPageIndex, '(' + currentType + ') â†’ next=', nextPage, '(' + nextType + ')');
      setBookPage(nextPage);
  }

  /**
   * Go back to previous book page.
   * Returns true if navigated within book, false if at cover (should exit book).
   */
  function previousBookPage() {
      if (_bookPageIndex <= 0) {
          return false; // At cover, can't go back within book
      }
      const prevPage = _bookPageIndex - 1;
      const currentType = _bookPageIndex === 0 ? 'cover' : _bookPageIndex === 1 ? 'inside_cover' : 'scene';
      const prevType = prevPage === 0 ? 'cover' : prevPage === 1 ? 'inside_cover' : 'scene';
      console.log('[DEBUG PAGE MOUNT] previousBookPage: current=', _bookPageIndex, '(' + currentType + ') â†’ prev=', prevPage, '(' + prevType + ')');
      setBookPage(prevPage);
      return true;
  }

  /**
   * VALIDATION GUARD: Book flow integrity check
   * Ensures page content rules are not violated.
   * Returns { valid: true } or { valid: false, error: string, violation: string }
   */
  function validateBookFlowIntegrity() {
      const errors = [];
      console.log('[DEBUG PAGE STATE] validateBookFlowIntegrity: _bookPageIndex=', _bookPageIndex);

      // CHECK 1: Inside cover (page 1) must have title+synopsis text, but NO generated images
      const insideCover = document.getElementById('bookInsideCover');
      if (_bookPageIndex === 1 && insideCover) {
          const hasGeneratedImages = insideCover.querySelectorAll('img:not(.decorative)').length > 0;
          const hasTitle = !!insideCover.querySelector('.inside-cover-title');
          const hasSynopsis = !!insideCover.querySelector('.inside-cover-synopsis');
          console.log('[DEBUG PAGE STATE] insideCover check: hasTitle=', hasTitle, 'hasSynopsis=', hasSynopsis, 'hasGeneratedImages=', hasGeneratedImages);
          if (hasGeneratedImages) {
              errors.push({ code: 'INSIDE_COVER_HAS_IMAGES', message: 'Inside cover contains generated images (should be text only)' });
          }
          if (!hasTitle) {
              errors.push({ code: 'INSIDE_COVER_MISSING_TITLE', message: 'Inside cover missing title' });
          }
          if (!hasSynopsis) {
              errors.push({ code: 'INSIDE_COVER_MISSING_SYNOPSIS', message: 'Inside cover missing synopsis' });
          }
      }

      // CHECK 2: On page 2 (Scene 1), setting image should be INLINE, not fullscreen
      const settingPlate = document.getElementById('settingPlate');
      if (_bookPageIndex === 2 && settingPlate && !settingPlate.classList.contains('hidden')) {
          if (!settingPlate.classList.contains('setting-inline')) {
              errors.push({ code: 'SETTING_NOT_INLINE', message: 'Setting plate should be inline on Scene 1, not fullscreen' });
          }
      }

      // CHECK 3: On page 3+, setting plate MUST be hidden (only Scene 1 has setting image)
      if (_bookPageIndex > 2 && settingPlate && !settingPlate.classList.contains('hidden')) {
          errors.push({ code: 'SETTING_VISIBLE_AFTER_SCENE1', message: 'Setting plate visible after Scene 1 (page ' + _bookPageIndex + ')' });
      }

      // CHECK 4: On page 1 (inside cover), scene content MUST be hidden
      if (_bookPageIndex === 1) {
          const storyContent = document.getElementById('storyContent');
          if (storyContent && !storyContent.classList.contains('hidden')) {
              errors.push({ code: 'SCENE_VISIBLE_ON_INSIDE_COVER', message: 'Scene content visible on inside cover' });
          }
      }

      if (errors.length > 0) {
          console.error('[BOOK FLOW] Integrity violations:', errors);
          return { valid: false, errors };
      }

      return { valid: true };
  }

  // Expose for DevHUD
  window.validateBookFlowIntegrity = validateBookFlowIntegrity;
  window.BOOK_PAGE_TYPES = BOOK_PAGE_TYPES;

  // Open book via hinge animation (triggered by clicking anywhere on book)
  const BOOK_DWELL_MS = 4000; // Time setting page shows before Scene 1

  async function openBook() {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BOOK SYSTEM DISABLED â€” Use linear flow instead
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!USE_OPENING_BOOK) {
          console.log('[READER] openBook called but book system disabled â€” using linear flow');
          if (typeof hideDSP === 'function') hideDSP();

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // BACKGROUND STORY LOADING: Await story text with short timeout
          // Story should already be ready (generated in background)
          // Timeout ensures responsiveness even if generation is slow
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const STORY_READY_TIMEOUT_MS = 500; // Short timeout for responsiveness

          if (_storyTextPromise) {
              console.log('[READER] Awaiting story text (max 500ms)...');
              const result = await Promise.race([
                  _storyTextPromise,
                  new Promise(resolve => setTimeout(() => resolve('__TIMEOUT__'), STORY_READY_TIMEOUT_MS))
              ]);

              if (result === '__TIMEOUT__') {
                  console.log('[READER] Story text not ready yet â€” showing Scene 1 anyway');
              } else {
                  console.log('[READER] Story text ready â€” advancing to Scene 1');
              }
          }

          advanceReaderPage();
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BOOK SYSTEM (disabled â€” code preserved for future re-enable)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (_bookOpened) return;
      _bookOpened = true;
      console.log('[DEBUG PAGE MOUNT] openBook: _bookPageIndex=', _bookPageIndex, 'transitioning coverâ†’inside_coverâ†’scene');
      cancelCourtesyHinge();

      const bookCover = document.getElementById('bookCover');

      // Remove any courtesy peek class and start hinge animation
      if (bookCover) {
          bookCover.classList.remove('courtesy-peek');
          bookCover.classList.add('hinge-open'); // Start hinge animation - reveals inside cover
      }

      // STEP 1: Hinge animation plays for 800ms, showing inside cover
      setTimeout(() => {
          // CRITICAL: Force-hide DSP before showing Page 1 (prevents synopsis overlay)
          if (typeof hideDSP === 'function') hideDSP();
          // Verify inside cover is populated (sanity check)
          const insideCover = document.getElementById('bookInsideCover');
          console.log('[DEBUG PAGE STATE] openBook gate: insideCover=', !!insideCover, 'hasTitle=', !!insideCover?.querySelector('.inside-cover-title'), '_bookPageIndex=', _bookPageIndex);
          if (insideCover && !insideCover.querySelector('.inside-cover-title')) {
              console.warn('[BookFlow] Inside cover not populated â€” check story generation');
          }
          setBookPage(1); // Inside cover (title + synopsis, NO image)

          // STEP 2: After dwell, transition to SCENE page (page 2)
          setTimeout(() => {
              // Setting image auto-generation disabled â€” no waiting
              advanceBookPage(); // Transitions to page 2 (scene)

              // BOOK FLOW: Validate integrity after showing Scene 1
              const flowCheck = validateBookFlowIntegrity();
              if (!flowCheck.valid) {
                  console.error('[BOOK FLOW] HARD FAIL: Page integrity violated', flowCheck.errors);
              }

              // Scroll to story title (page 2 content)
              const scrollTarget = document.getElementById('storyTitle');
              if (scrollTarget) {
                  scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }

              // Deactivate Guided Fate visuals after dwell completes
              if (typeof deactivateGuidedFateVisuals === 'function') {
                  deactivateGuidedFateVisuals();
              }
          }, BOOK_DWELL_MS);
      }, 800);
  }

  // Flag: Are we in Cover View mode (using button navigation)?
  let _inCoverViewMode = false;

  window.enterCoverViewMode = () => { _inCoverViewMode = true; };
  window.exitCoverViewMode = () => { _inCoverViewMode = false; };

  // Initialize physical book event listeners
  function initCoverPageListeners() {
      // Click anywhere on book object to open/advance
      // BUT: In Cover View mode, clicks are ignored (use buttons instead)
      const bookObject = document.getElementById('bookObject');
      if (bookObject) {
          bookObject.addEventListener('click', () => {
              if (_inCoverViewMode) {
                  console.log('[COVER:VIEW] In Cover View mode â€” use buttons to navigate');
                  return;
              }
              openBook();
          });
      }

      // Also allow clicking on cover directly (redundant safety)
      const bookCover = document.getElementById('bookCover');
      if (bookCover) {
          bookCover.addEventListener('click', (e) => {
              e.stopPropagation();
              if (_inCoverViewMode) {
                  console.log('[COVER:VIEW] In Cover View mode â€” use buttons to navigate');
                  return;
              }
              openBook();
          });
      }

      // NOTE: Setting plate is now INLINE within Scene 1 (no separate page)
      // No click handler needed â€” setting image is decorative, not navigational
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
          initCoverPageListeners();
          // Initialize Cover$ credit display
          if (window.updateCoverCreditDisplay) window.updateCoverCreditDisplay();
          // Initialize Begin/Continue button label based on story state
          if (typeof updateBeginButtonLabel === 'function') updateBeginButtonLabel();
      });
  } else {
      initCoverPageListeners();
      // Initialize Cover$ credit display
      if (window.updateCoverCreditDisplay) window.updateCoverCreditDisplay();
      // Initialize Begin/Continue button label based on story state
      if (typeof updateBeginButtonLabel === 'function') updateBeginButtonLabel();
  }

  // Reset book state for new story
  function resetBookState() {
      // Reset simplified reader state
      _readerPage = 0;

      // Reset book state (even when disabled, for clean state)
      const oldIndex = _bookPageIndex;
      _bookOpened = false;
      _bookPageIndex = 0; // Reset to cover page
      console.log('[READER] resetBookState: page reset to 0 (COVER)');
      _settingImagePromise = Promise.resolve(); // Reset for new story
      cancelCourtesyHinge();
      resetCoverLayers();
      const bookCover = document.getElementById('bookCover');
      if (bookCover) {
          bookCover.classList.remove('hinge-open', 'courtesy-peek');
      }
      // Reset setting plate visibility
      const settingPlate = document.getElementById('settingPlate');
      if (settingPlate) {
          settingPlate.classList.remove('hidden', 'setting-active', 'page-flip-out');
      }
      // Reset right-page scene art
      const sceneImg = document.getElementById('bookSceneImg');
      const sceneLoading = document.getElementById('bookSceneLoading');
      if (sceneImg) { sceneImg.src = ''; sceneImg.style.display = 'none'; }
      if (sceneLoading) { sceneLoading.style.display = ''; sceneLoading.textContent = 'Conjuring the world\u2026'; }
  }

  // Hide cover page and show story content directly (fallback if cover fails)
  function skipCoverPage() {
      // Stop any running cover loading intervals
      if (_coverPhraseInterval) clearInterval(_coverPhraseInterval);
      if (_coverProgressInterval) clearInterval(_coverProgressInterval);
      cancelCourtesyHinge();

      if (!USE_OPENING_BOOK) {
          // Simplified flow: jump to Scene
          showReaderPage(2);
      } else {
          // Jump directly to scene page (skip setting page for fallback)
          setBookPage(2);
          _bookOpened = true;
      }
  }

  // Expose simplified reader functions globally
  window.showReaderPage = showReaderPage;
  window.advanceReaderPage = advanceReaderPage;
  window.USE_OPENING_BOOK = USE_OPENING_BOOK;
  window.USE_MINIMAL_COVER_V1 = USE_MINIMAL_COVER_V1;

  // --- VISUALIZE (STABILIZED) ---
  let _vizCancelled = false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VISUAL PROMPT LOADING STATE â€” Ellipsis animation for prompt generation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _vizEllipsisInterval = null;

  /**
   * Start ellipsis animation on an input placeholder
   * Cycles: "Generating visual prompt." â†’ ".." â†’ "..."
   * @param {HTMLElement} input - The input element to animate
   * @returns {function} Stop function to call when generation completes
   */
  function startVizEllipsisAnimation(input) {
      if (!input) return () => {};

      const baseText = 'Generating visual prompt';
      let dotCount = 1;

      // Set initial state
      input.value = '';
      input.placeholder = baseText + '.';
      input.style.transition = 'opacity 200ms ease';
      input.style.opacity = '1';

      // Clear any existing interval
      if (_vizEllipsisInterval) clearInterval(_vizEllipsisInterval);

      // Animate ellipsis at 700ms intervals
      _vizEllipsisInterval = setInterval(() => {
          dotCount = (dotCount % 3) + 1;
          input.placeholder = baseText + '.'.repeat(dotCount);
      }, 700);

      // Return stop function with fade transition
      return function stopAnimation(newValue) {
          if (_vizEllipsisInterval) {
              clearInterval(_vizEllipsisInterval);
              _vizEllipsisInterval = null;
          }

          // Fade out, update, fade in
          input.style.opacity = '0';
          setTimeout(() => {
              input.placeholder = 'Edit prompt or add modifiersâ€¦';
              if (newValue !== undefined) input.value = newValue;
              input.style.opacity = '1';
          }, 200);
      };
  }

  // Visualize intensity bias based on player's selected eroticism level
  function getVisualizeIntensityBias() {
      const intensity = state.intensity || 'Naughty';
      switch(intensity) {
          case 'Clean':
              return 'Clean, non-sexual imagery. Romantic but modest. No nudity or explicit content.';
          case 'Naughty':
              return 'Suggestive, flirtatious imagery. Sensual tension without explicit nudity. Tasteful allure.';
          case 'Erotic':
              return 'Explicit, sensual imagery. Passionate and intimate. Artistic nudity permitted.';
          case 'Dirty':
              return 'As explicit as community standards allow. Intensely passionate and provocative.';
          default:
              return 'Suggestive, flirtatious imagery. Sensual tension.';
      }
  }

  // â”€â”€ Visualize Helpers (Pure Story Shape Reflection) â”€â”€

  function getVisualizeWorldToneBias() {
      const parts = [];
      if (state.picks?.world) parts.push('World: ' + state.picks.world);
      if (state.picks?.tone) parts.push('Tone: ' + state.picks.tone);
      if (state.picks?.genre) parts.push('Genre: ' + state.picks.genre);
      if (state.picks?.dynamic) parts.push('Dynamic: ' + state.picks.dynamic);
      if (state.intensity) parts.push('Intensity: ' + state.intensity);
      return parts.length
          ? parts.join('. ') + '. Render visuals that accurately reflect the story\'s declared world, tone, genre, dynamic, and intensity. Do not add or remove mood.'
          : 'Render visuals that accurately reflect the current story. Do not add or remove mood.';
  }

  function getSceneVisualSignals(text) {
      const signals = [];
      if (/(crowd|gather|audience|spectators|onlookers)\b/i.test(text)) signals.push('Crowd or audience present');
      if (/(alone|solitary|by (her|him|them)self|isolated)\b/i.test(text)) signals.push('Character is alone');
      if (/(touch|grip|press|hold|embrace|hand)\b/i.test(text)) signals.push('Physical contact occurring');
      if (/(sword|blade|weapon|dagger|bow|gun|shield)\b/i.test(text)) signals.push('Weapon present');
      if (/(glance|gaze|stare|watch|eye|look)\b/i.test(text)) signals.push('Directed gaze or eye contact');
      return signals;
  }

  function resolveVisualFocus(text) {
      let focus = 'balanced framing of all present characters';
      if (/(I |my |me |myself)\b/i.test(text)) focus = 'POV-anchored composition favoring the narrator';
      if (/(she step|he step|they step|she move|he move|she turn|he turn|she raise|he raise)\b/i.test(text)) focus = 'focus on the character initiating action';
      if (/(watch|stare at|observe|gaze at|eye.*on)\b/i.test(text)) focus = 'focus on the character being observed';
      if (/(close|breath|whisper|touch|press.*against)\b/i.test(text)) focus = 'intimate proximity framing';
      return focus;
  }

  function resolveCameraDistance(text) {
      let distance = 'medium framing';
      if (/(touch|hand|grip|press|pull|whisper|breath|close|against)\b/i.test(text)) distance = 'close framing';
      if (/(approach|step|turn|face|block|stand before)\b/i.test(text)) distance = 'medium framing';
      if (/(arena|crowd|stadium|hall|city|vast|sprawling|towering)\b/i.test(text)) distance = 'wide framing';
      return distance;
  }

  function resolveLightingCondition(text) {
      let lighting = 'neutral ambient lighting';
      if (/(dark|dim|shadow|night|torch|candle|lantern|flicker|low light)\b/i.test(text)) lighting = 'low-light conditions with limited illumination';
      if (/(spotlight|beam|shaft of light|backlit|rim light|glow from|lit by)\b/i.test(text)) lighting = 'directional lighting with strong highlights and shadow contrast';
      if (/(sunlight|daylight|bright|open sky|well-lit|flooded with light)\b/i.test(text)) lighting = 'even, well-lit conditions with broad visibility';
      return lighting;
  }

  function resolveCompositionDensity(text) {
      let density = 'balanced composition with primary subjects clearly separated from background';
      if (/(alone|single|one of them|isolated|only one)\b/i.test(text)) density = 'sparse composition with a single primary subject';
      if (/(two of them|both|pair|together|between them)\b/i.test(text)) density = 'focused composition centered on a small group';
      if (/(crowd|spectators|many|dozens|packed|surrounding)\b/i.test(text)) density = 'dense composition with multiple figures sharing the frame';
      return density;
  }

  // â”€â”€ Visualize Prompt Builders (routing targets) â”€â”€

  function buildSettingVisualizePrompt() {
      const sWorld = (state.picks && state.picks.world) || 'Unknown';
      const sTone = (state.picks && state.picks.tone) || 'Unknown';
      const sGenre = (state.picks && state.picks.genre) || 'Unknown';
      const sDynamic = (state.picks && state.picks.dynamic) || 'Unknown';
      const sIntensity = state.intensity || 'Unknown';

      return `SETTING VISUAL â€” ESTABLISHING ENVIRONMENT ONLY

WORLD: ${sWorld}
TONE: ${sTone}
GENRE: ${sGenre}
DYNAMIC: ${sDynamic}
INTENSITY: ${sIntensity}

COMPOSITION:
- Wide or architectural establishing view
- Environment-focused, not character-focused
- Spatial layout clearly readable

LIGHTING:
- Appropriate to the declared world and tone
- Natural or ambient sources only

CONTENT RULES:
- Do not depict people, faces, bodies, or interactions
- Do not imply an event, action, or narrative moment
- Do not introduce symbolism or mood beyond what the setting itself conveys
- Objects may be present only as part of the environment, at rest

Render the setting as a neutral, grounded place that could host a story,
but does not depict the story itself.

Return only the visual description.`;
  }

  function buildSceneVisualizePrompt(lastText, anchorText) {
      const intensityBias = getVisualizeIntensityBias();
      const worldToneBias = getVisualizeWorldToneBias();
      const ontologyDirective = getVisualOntologyDirective();
      const sceneSignals = getSceneVisualSignals(lastText);
      const sceneCtx = sceneSignals.length ? '- ' + sceneSignals.join('\n- ') : '- No additional scene constraints';
      const focusDirective = resolveVisualFocus(lastText);
      const cameraDistance = resolveCameraDistance(lastText);
      const lightingCondition = resolveLightingCondition(lastText);
      const compositionDensity = resolveCompositionDensity(lastText);

      // Get protagonist gender for explicit subject declaration
      const protagonistGender = state.gender || 'Female';
      const genderWord = protagonistGender === 'Male' ? 'man' : protagonistGender === 'Non-binary' ? 'person' : 'woman';

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // DEPRECATION NOTICE â€” WRY CONFESSION VISUAL STYLE (v0.x)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Any prior logic, guidance, or prompt assembly that treats
      // Wry Confession as a stylistic modifier (e.g., cartoon, sketch,
      // flat illustration, reduced realism) is deprecated.
      //
      // These approaches caused style blending, photoreal bleed,
      // and cinematic defaults to reassert themselves.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // WRY CONFESSION â€” REPRESENTATIONAL PRECEDENCE (AUTHORITATIVE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // When tone === 'Wry Confession' and intent === 'scene_visualization':
      //
      // - The image must be an editorial illustration, not a photograph.
      // - Genre and world may influence symbolism only, not realism.
      // - Mood and lighting are subordinate to commentary and interpretation.
      //
      // This is a category declaration, not a style modifier.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // WRY CONFESSION â€” SAFETY CLARIFICATION
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // This precedence rule does not apply to:
      // - cover generation
      // - sketch vs thumbnail tiers
      // - non-Wry tones
      //
      // Covers use a separate interpretive regime.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SCENE VISUALIZATION â€” SELF-CHECK (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Before finalizing any Scene Visualization,
      // Claude MUST silently evaluate:
      //
      // "If this image were shown without the text of the scene,
      // would it still clearly express the scene's dramatic irony,
      // awkwardness, or tension â€” not just its setting or mood?"
      //
      // If the honest answer is NO, the visualization must be regenerated.
      //
      // This check is INTERNAL.
      // Do not explain it.
      // Do not soften it.
      // Do not allow lighting, realism, or atmosphere to substitute for idea.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” CANONICAL CAPTION TEMPLATES (VISUALIZER REGIME)
      // TAG: storybound/wry-caption-templates-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // When Tone = Wry Confession, visualizer output must include exactly one of:
      // (A) A single-line caption
      // (B) A single ironic visual contradiction
      //
      // Default preference: Caption
      // Never include both by default.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CAPTION TEMPLATES (CANONICAL Â· USE AS-IS OR WITH LIGHT VARIATION)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // The caption must implicate the narrator or The Story, not explain the plot.
      //
      // Self-Indicting Rationalization:
      // "I had a system for moments like this, which mostly involved pretending
      //  they were temporary."
      //
      // Delayed Self-Awareness:
      // "This was the point where I would later insist I'd had no real choice."
      //
      // Story-as-Witness (5th Person compatible):
      // "The story briefly considered intervening here, then remembered how
      //  stubborn she could be."
      //
      // HARD CONSTRAINTS:
      // - Caption length: â‰¤ 20 words
      // - No jokes, punchlines, or meta commentary
      // - No explanation of world mechanics
      // - No tone drift into comedy or satire
      // - Caption must undercut, not decorate
      //
      // SUCCESS CONDITION:
      // The image should feel: Observant, slightly embarrassing, quietly self-aware.
      // Not funny. Not dramatic. Wry.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” SENTENCE-LEVEL FLIP (PROSE REGIME)
      // TAG: storybound/wry-sentence-flip-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // Wry Confession prose must include micro-undercuts that quietly undermine
      // the narrator's self-justification.
      //
      // METHOD (MANDATORY):
      // After drafting a scene, identify 3â€“5 sentences where the narrator:
      // - justifies a choice
      // - asserts control
      // - frames themselves as perceptive, cautious, or exceptional
      //
      // For each identified sentence, apply one transformation:
      // - Add delayed self-awareness
      // - Add ironic specificity
      // - Add self-implicating admission
      //
      // Do NOT: Add humor, commentary, new events, or change pacing.
      //
      // CANONICAL TRANSFORMS:
      //
      // Assertive â†’ Wry:
      // "I knew what I was doing."
      // â†’ "I knew what I was doing, which is usually how it starts."
      //
      // Poetic â†’ Wry:
      // "I was good at being invisible."
      // â†’ "I was good at being invisible, especially when I wanted to be seen."
      //
      // Defiant â†’ Wry:
      // "I was not prey; I was a player."
      // â†’ "I was not prey. I was, at worst, a willing participant."
      //
      // SUCCESS CONDITION:
      // The narrator should sound: Competent, self-aware, slightly untrustworthy
      // to themselves.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” CONCRETE SCENE GROUNDING (AUTHORITATIVE)
      // TAG: storybound/wry-scene-grounding-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // VISUALIZER RULE â€” WRY CONFESSION (AUTHORITATIVE)
      //
      // For Wry Confession, TONE defines illustration STYLE only.
      // The image SUBJECT must be grounded in a concrete element from the
      // current scene:
      //   - Setting (location, environment, architectural detail)
      //   - Character situation (posture, action, interaction)
      //   - Symbolic object (a specific item present in the scene)
      //
      // If no concrete scene element is used, the image is INVALID.
      //
      // VALID: A woman at a cafÃ© table, her coffee untouched (scene: cafÃ© meeting)
      // VALID: Hands gripping a doorframe (scene: hesitation at threshold)
      // VALID: A half-written letter on a desk (scene: abandoned correspondence)
      //
      // INVALID: Abstract swirls representing emotional turmoil
      // INVALID: Generic "woman in contemplation" with no scene anchor
      // INVALID: Symbolic imagery disconnected from the prose
      //
      // The tone (Wry Confession) affects HOW the subject is rendered
      // (editorial, ironic, slightly off-kilter) â€” not WHAT is depicted.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” BINARY VISUAL CHECK (IMAGE GENERATION REGIME LOCK)
      // TAG: storybound/wry-binary-visual-check-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // Every Wry Confession visualization must pass this binary check:
      //
      // "What is the one thing in the image that disagrees with the
      //  character's self-image?"
      //
      // If no answer exists â†’ the image is invalid.
      //
      // ACCEPTABLE FORMS OF DISAGREEMENT (CHOOSE ONE):
      // - A background sign or object that contradicts intent
      //   ("NO RETURNS", "FAIR PRICES", "TEMPORARY")
      // - A posture or gesture that undermines confidence
      //   (clenched hands, stiff stance, off-balance weight)
      // - A secondary figure positioned to silently observe or judge
      // - An object rendered slightly too prominent or tempting
      //
      // HARD CONSTRAINTS:
      // - Only one contradiction
      // - No exaggeration
      // - No slapstick
      // - No symbolism that requires explanation
      // - The disagreement must be legible at a glance
      //
      // SUCCESS CONDITION:
      // The viewer should think: "Ah. She thinks she's in control."
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” INSET-IMAGE RENDERING RULES (AUTHORITATIVE)
      // TAG: storybound/wry-inset-image-rendering-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // REGIME CONTEXT:
      // Wry Confession visuals function as editorial asides, not focal scenes.
      // They comment on the narrative rather than illustrate it directly.
      // Text always retains narrative primacy.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 1. IMAGE SCALE (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Render at full resolution (no pipeline changes)
      // - Display at reduced scale: 40â€“60% of text column width
      // - Default: 50%
      // - Image must never be full-width or full-height
      // - The illustration should feel noticed, not announced.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 2. PLACEMENT (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Insert between paragraphs
      // - Never mid-sentence, mid-paragraph, or before opening paragraph
      // - Preferred: After tension crystallizes, before self-awareness sharpens
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 3. LAYOUT MODEL (STRICT)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - NO CSS floats
      // - NO text wrapping around image
      // - NO masonry or magazine-style layouts
      // - Use inset block layout: centered OR slightly offset
      // - Text resumes cleanly below image
      // - Layout suggests interruption, not enforces it
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 4. CAPTION HANDLING (IF PRESENT)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Place caption directly below image
      // - Single sentence, visually lighter than body text
      // - Feel like a marginal thought
      // - Caption width must not exceed image width
      // - No bold, no emphasis, no quotation marks
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 5. MOBILE BEHAVIOR (NON-NEGOTIABLE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Image scales down further if needed
      // - Image centers automatically
      // - Caption remains attached
      // - No clipping, no horizontal scrolling
      // - Text flow must remain uninterrupted
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // HARD CONSTRAINTS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // âŒ No full-bleed images
      // âŒ No hero framing
      // âŒ No dynamic resizing based on scroll
      // âŒ No layout "cleverness"
      // âŒ No visual dominance over text
      //
      // This is not a gallery. Not a scene break. It is an aside.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SUCCESS CRITERIA
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // The reader should experience the image as:
      // - A pause
      // - A raised eyebrow
      // - A quiet acknowledgment
      // - Something they might almost skip â€” but don't
      //
      // If the image feels important, it is too large.
      // If it feels decorative, it is misused.
      // If it feels slightly intrusive, it is correct.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // WRY CONFESSIONAL SCENE VISUALIZATION â€” Representational category, not style keywords
      // TAG: storybound/wry-confessional-scene-viz-semantic-v1
      const currentTone = state.picks?.tone || '';
      const isWryConfessional = /wry|confessional|satire|irony/i.test(currentTone);
      const wrySemanticLine = isWryConfessional
          ? `This image is an editorial illustration commenting on the scene's irony or emotional contradiction, not a literal depiction of events.\n\n`
          : '';

      return `${anchorText}

${wrySemanticLine}You are writing an image prompt. Follow these continuity anchors strictly.
Output MUST follow this exact structure:

ğŸ“Œ SUBJECT (MANDATORY FIRST)
Start with: "A ${genderWord}..." then describe pose, clothing, expression.
Gender and physical description MUST appear in the first sentence.
Example: "A woman in a tattered leather jacket, face partially in shadow, stands at the mouth of a smoky alley."

ğŸ“Œ SCENE CONTEXT
Physical environment in short, grounded phrases.
Example: "Ashen wooden stalls line a narrow path. Faint orange embers glow beneath a collapsed tarp."

ğŸ“Œ ACTION / FOCAL ELEMENTS
Any movement or narrative cues.
Example: "A streak of crimson fabric disappears into the shadows up ahead."

ğŸ“Œ MOOD / STYLE
${ontologyDirective}
${cameraDistance}. ${lightingCondition}. No painterly textures unless explicitly fantasy world.

ğŸ“Œ NEGATIVE PROMPT
Do not render in oil painting or concept art style unless world is Fantasy.
Maintain gender of described figure (${protagonistGender}).
${SCENE_VIZ_EXCLUSIONS}

---
WORLD/TONE: ${worldToneBias}
INTENSITY: ${intensityBias}
CAMERA FOCUS: ${focusDirective}
COMPOSITION: ${compositionDensity}
SCENE SIGNALS:
${sceneCtx}

---
SOURCE PROSE TO VISUALIZE:
${lastText}

---
Return ONLY the formatted prompt following the structure above. Do not explain or add commentary.`;
  }

  function buildVisualizePrompt({ mode, lastText, anchorText }) {
      if (mode === 'setting') {
          return buildSettingVisualizePrompt();
      }
      return buildSceneVisualizePrompt(lastText, anchorText);
  }

  // Default visual quality biases for attractive characters
  const VISUAL_QUALITY_DEFAULTS = 'Characters depicted with striking beauty, elegant features, and healthy appearance. Women with beautiful hourglass figures. Men with athletic gymnast-like builds. Faces are attractive and expressive with natural expressions, avoiding exaggerated or artificial looks.';

  // Sanitize image prompts - removes sensual adjectives for Clean/Naughty tiers
  function sanitizeImagePrompt(prompt) {
      // Words that trigger safety filters on mainstream providers
      const sensualWords = [
          'sensual', 'erotic', 'seductive', 'sexual', 'intimate', 'naked', 'nude',
          'provocative', 'suggestive', 'lustful', 'passionate', 'steamy', 'hot',
          'sexy', 'aroused', 'arousing', 'undressed', 'revealing', 'exposed',
          'busty', 'voluptuous', 'curvy', 'bedroom', 'lingerie', 'underwear',
          'explicit', 'raw', 'unfiltered', 'dirty', 'naughty', 'forbidden',
          'sultry', 'alluring', 'nudity'
      ];

      // Phrases that trigger moderation (multi-word)
      const sensualPhrases = [
          'parted lips', 'suggestive posture', 'alluring curves',
          'bedroom eyes', 'come hither', 'inviting gaze'
      ];

      let sanitized = prompt;

      // Remove "The Author" references (meta-character should never be in images)
      sanitized = sanitized.replace(/\bThe Author\b/gi, '').replace(/\bAuthor\b/gi, '');

      // Remove flagged phrases first (before single words)
      sensualPhrases.forEach(phrase => {
          const regex = new RegExp(phrase, 'gi');
          sanitized = sanitized.replace(regex, '');
      });

      // Remove sensual words entirely rather than replacing
      sensualWords.forEach(word => {
          const regex = new RegExp('\\b' + word + '\\b', 'gi');
          sanitized = sanitized.replace(regex, '');
      });

      // Clean up double spaces and punctuation issues
      sanitized = sanitized.replace(/\s+/g, ' ').replace(/,\s*,/g, ',').replace(/\s+,/g, ',').trim();

      return sanitized;
  }

  // EROTIC/DIRTY TIER: Restore erotic language to prompts for Perchance rendering
  // This reverses sanitization for tiers that permit explicit imagery
  function restoreEroticLanguage(prompt) {
      // Keywords to restore/enhance for erotic tiers
      const eroticEnhancements = [
          'sensual', 'erotic', 'nudity', 'nude', 'explicit'
      ];

      let enhanced = prompt;

      // Remove "The Author" references (meta-character should NEVER be in images)
      enhanced = enhanced.replace(/\bThe Author\b/gi, '').replace(/\bAuthor\b/gi, '');

      // If prompt lacks erotic descriptors, inject tier-appropriate language
      const hasEroticTerms = eroticEnhancements.some(term =>
          enhanced.toLowerCase().includes(term)
      );

      if (!hasEroticTerms) {
          // Inject erotic context based on intensity guidance already in prompt
          if (enhanced.toLowerCase().includes('artistic nudity permitted') ||
              enhanced.toLowerCase().includes('explicit') ||
              enhanced.toLowerCase().includes('passionate')) {
              enhanced = enhanced.replace(
                  /Art style:/i,
                  'Sensual, erotic imagery permitted. Art style:'
              );
          }
      }

      // Clean up spacing
      enhanced = enhanced.replace(/\s+/g, ' ').trim();

      return enhanced;
  }

  // ============================================================
  // IMAGE PROVIDER ROUTER - Unified image generation system
  // ============================================================

  // ============================================================
  // IMAGE PROMPT LENGTH â€” SAFETY FALLBACK (3000 chars)
  // ============================================================
  // This is a SAFETY FALLBACK, not an artistic constraint.
  // Full prompts up to 3000 chars pass through intact for richer visuals.
  // Truncation only occurs if prompt exceeds provider limits.
  // CRITICAL: This function is for IMAGE/VISUALIZATION prompts ONLY.
  // Story generation prompts must NEVER be truncated.
  // ============================================================
  const MAX_IMAGE_PROMPT_LENGTH = 3000;

  /**
   * Log prompt composition breakdown for debugging
   */
  function logPromptComposition(prompt, context) {
      // Find separator if present
      const separatorIdx = prompt.indexOf('\n---\n');
      let userContent, styleContent;

      if (separatorIdx > -1) {
          userContent = prompt.substring(0, separatorIdx);
          styleContent = prompt.substring(separatorIdx + 5);
      } else {
          userContent = prompt;
          styleContent = '';
      }

      console.log(`[PROMPT-COMP] ${context}:`, {
          totalChars: prompt.length,
          userContentChars: userContent.length,
          styleContentChars: styleContent.length,
          limit: MAX_IMAGE_PROMPT_LENGTH,
          wouldTruncate: prompt.length > MAX_IMAGE_PROMPT_LENGTH
      });
  }

  /**
   * STYLE_BLOCK summarization â€” rule-based compression (NO LLM).
   * NEVER summarizes: layout constraints, user content, exclusions, vetoes.
   * @param {string} styleBlock - The style portion of the prompt (after ---)
   * @returns {string} - Compressed style block
   */
  function summarizeStyleBlock(styleBlock) {
      if (!styleBlock || styleBlock.length < 100) return styleBlock;

      let compressed = styleBlock;

      // 1. Remove redundant adjective pairs
      const redundantPairs = [
          [/\bbeautiful,?\s*elegant\b/gi, 'elegant'],
          [/\belegant,?\s*graceful\b/gi, 'elegant'],
          [/\bnatural,?\s*ambient\b/gi, 'ambient'],
          [/\bsoft,?\s*gentle\b/gi, 'soft'],
          [/\bwarm,?\s*golden\b/gi, 'golden'],
          [/\bdramatic,?\s*intense\b/gi, 'dramatic'],
          [/\bcinematic,?\s*filmic\b/gi, 'cinematic'],
          [/\bmoody,?\s*atmospheric\b/gi, 'atmospheric']
      ];
      redundantPairs.forEach(([pattern, replacement]) => {
          compressed = compressed.replace(pattern, replacement);
      });

      // 2. Remove filler phrases
      const fillerPhrases = [
          /\bwith a sense of\b/gi,
          /\bthat evokes\b/gi,
          /\bgiving the impression of\b/gi,
          /\bin the style of\b/gi,
          /\breminiscent of\b/gi,
          /\bevocative of\b/gi,
          /\bsuggesting a feeling of\b/gi
      ];
      fillerPhrases.forEach(pattern => {
          compressed = compressed.replace(pattern, '');
      });

      // 3. Collapse "Art style:" redundancy
      compressed = compressed.replace(/Art style:\s*/gi, '');

      // 4. Shorten common exclusion phrases
      compressed = compressed.replace(/No text,?\s*watermarks,?\s*signatures,?\s*or logos/gi, 'No text/watermarks');
      compressed = compressed.replace(/No unrealistic anatomy or proportions/gi, 'No unrealistic anatomy');
      compressed = compressed.replace(/No explicit content/gi, 'No explicit');

      // 5. Remove duplicate sentences
      const sentences = compressed.split(/\.\s+/);
      const uniqueSentences = [...new Set(sentences.map(s => s.trim().toLowerCase()))];
      if (uniqueSentences.length < sentences.length) {
          compressed = sentences.filter((s, i) =>
              sentences.findIndex(x => x.trim().toLowerCase() === s.trim().toLowerCase()) === i
          ).join('. ');
      }

      // 6. Clean up spacing and punctuation
      compressed = compressed.replace(/\s+/g, ' ').replace(/,\s*,/g, ',').replace(/\.\s*\./g, '.').trim();

      console.log(`[STYLE-SUMMARIZE] ${styleBlock.length} -> ${compressed.length} chars`);
      return compressed;
  }

  /**
   * Clamp prompt length for image generation ONLY (safety fallback).
   * SMART TRUNCATION: Preserves user content, summarizes/truncates style fluff.
   * @param {string} prompt - The prompt to clamp
   * @param {string} context - REQUIRED: 'image-gen' | 'visualization' | 'story-gen'
   * @returns {string|null} - Clamped prompt, or null if protected content exceeds limit
   */
  function clampPromptLength(prompt, context) {
      // GATE: Story prompts must NEVER be truncated
      if (context === 'story-gen') {
          console.error('[PROMPT-GUARD] FATAL: clampPromptLength called with story-gen context. Story prompts must NOT be truncated.');
          throw new Error('PROMPT_TRUNCATION_BLOCKED: Story generation prompts cannot be truncated.');
      }

      // GATE: Only allow explicit image/visualization contexts
      if (context !== 'image-gen' && context !== 'visualization') {
          console.error(`[PROMPT-GUARD] FATAL: clampPromptLength called with unknown context: ${context}`);
          throw new Error(`PROMPT_TRUNCATION_BLOCKED: Unknown context "${context}". Use 'image-gen' or 'visualization'.`);
      }

      // Log composition for debugging
      logPromptComposition(prompt, context);

      // Within limit â€” return as-is
      if (prompt.length <= MAX_IMAGE_PROMPT_LENGTH) {
          return prompt;
      }

      // SMART TRUNCATION: Preserve user content (before ---), compress/truncate style
      const separatorIdx = prompt.indexOf('\n---\n');

      if (separatorIdx > -1) {
          const userContent = prompt.substring(0, separatorIdx);
          let styleContent = prompt.substring(separatorIdx + 5);

          // Check if user content alone exceeds limit (FATAL)
          if (userContent.length >= MAX_IMAGE_PROMPT_LENGTH - 50) {
              console.error(`[IMAGE-GEN] FATAL: Protected content (${userContent.length} chars) exceeds limit. Cannot generate image.`);
              return null; // Abort â€” caller should handle gracefully
          }

          const availableForStyle = MAX_IMAGE_PROMPT_LENGTH - userContent.length - 5;

          // STEP 1: Try summarization first
          if (styleContent.length > availableForStyle) {
              const summarized = summarizeStyleBlock(styleContent);
              if (summarized.length <= availableForStyle) {
                  console.warn(`[IMAGE-GEN] Summarization sufficient: style ${styleContent.length} -> ${summarized.length}`);
                  return userContent + '\n---\n' + summarized;
              }
              styleContent = summarized; // Use summarized version for further truncation
          }

          // STEP 2: Hard truncate summarized style if still too long
          if (styleContent.length > availableForStyle && availableForStyle > 50) {
              const truncatedStyle = styleContent.substring(0, availableForStyle);
              console.warn(`[IMAGE-GEN] Post-summarization truncation: style ${styleContent.length} -> ${truncatedStyle.length}`);
              return userContent + '\n---\n' + truncatedStyle;
          }

          // STEP 3: Minimal style (just keep first sentence)
          if (availableForStyle > 20) {
              const firstSentence = styleContent.split('.')[0] + '.';
              console.warn(`[IMAGE-GEN] Minimal style: keeping only "${firstSentence.substring(0, 50)}..."`);
              return userContent + '\n---\n' + firstSentence.substring(0, availableForStyle);
          }
      }

      // No separator or user content too long â€” fallback to simple end truncation
      console.warn(`[IMAGE-GEN] Fallback truncation: ${prompt.length} -> ${MAX_IMAGE_PROMPT_LENGTH}`);
      return prompt.substring(0, MAX_IMAGE_PROMPT_LENGTH);
  }

  // Soft threshold for story prompt size warning (does NOT truncate)
  const STORY_PROMPT_SOFT_LIMIT = 50000;

  /**
   * Validate story prompt size (debug logging only, no truncation).
   * @param {string} prompt - The full assembled story prompt
   * @param {string} label - Descriptive label for logging
   */
  function validateStoryPromptSize(prompt, label = 'story-prompt') {
      if (!prompt) return;
      if (prompt.length > STORY_PROMPT_SOFT_LIMIT) {
          console.warn(`[STORY-GEN-DEBUG] ${label} exceeds soft limit: ${prompt.length} chars (limit: ${STORY_PROMPT_SOFT_LIMIT})`);
      }
  }

  // FLUX PROMPT HARD CONSTRAINTS (MANDATORY)
  // Includes lighting constraints to override provider defaults
  const FLUX_PROMPT_PREFIX = 'Painterly cinematic realism, oil-painting style, realistic anatomy, natural proportions, non-anime. Even exposure, midtone-forward lighting, neutral color temperature.';
  const FLUX_PROMPT_SUFFIX = 'Single subject unless explicitly stated. Correct human anatomy. No extra limbs. No extra people. No crushed blacks. No teal-orange grading.';

  // PERCHANCE PROMPT HARD CONSTRAINTS (MANDATORY)
  // Includes lighting constraints to override provider defaults
  const PERCHANCE_PROMPT_PREFIX = 'default Art Style is oil painting 70s pulp, balanced neutral lighting, realistic proportions, oil-painting style, non-anime. Even exposure, no crushed blacks.';
  const PERCHANCE_PROMPT_SUFFIX = 'Single subject unless explicitly stated. Correct human anatomy. One head, two arms, two legs. No extra limbs. No extra people. No extreme contrast. No underexposed foreground.';

  // ============================================================
  // VISUAL INTENT GUARD (Attractiveness + Lighting Enforcement)
  // ============================================================
  // Enforces: attractive subjects, balanced lighting, erotic-adjacent beauty
  // Darkness/grime only when tone explicitly requires it
  // Applied to ALL visualization prompts (initial, re-visualize, auto-refresh)
  // ============================================================

  const VISUAL_INTENT_ATTRACTIVENESS = 'Subjects are attractive with healthy, glowing skin and appealing features. Soft, flattering lighting. Avoid harsh shadows on faces. Beauty-forward rendering.';

  // LIGHTING CONSTRAINTS (AUTHORITATIVE)
  // Technical lighting enforcement overrides provider defaults
  const VISUAL_INTENT_LIGHTING_DEFAULT = 'Even exposure, midtone-forward lighting, no crushed blacks. Neutral industrial lighting, balanced color temperature. Skin tones warm and natural, never grey or washed out. Avoid teal-orange cinematic grading.';

  // LIGHTING PROHIBITIONS (explicitly forbidden)
  const VISUAL_INTENT_LIGHTING_PROHIBITIONS = 'NO moody noir lighting. NO extreme contrast. NO underexposed foreground. NO color banding. NO desaturated flesh tones.';

  // Tones that permit dark/grim rendering (override attractiveness defaults)
  const DARK_TONE_OVERRIDES = ['Dark', 'Grim', 'Horror', 'Noir'];

  /**
   * Apply Visual Intent Guard to a prompt
   * Enforces attractiveness and balanced lighting by default
   * @param {string} prompt - The visualization prompt
   * @param {object} context - { tone, world, intensity }
   * @returns {string} - Enhanced prompt with visual intent enforcement
   */
  function applyVisualIntentGuard(prompt, context = {}) {
      const tone = context.tone || state.picks?.tone || 'Earnest';
      const world = context.world || state.picks?.world || 'Modern';

      // Wry Confessional uses its own ontology â€” skip cinematic/lighting defaults
      if (tone === 'Wry Confessional') {
          return prompt;
      }

      // Check if dark rendering is explicitly permitted
      const isDarkTone = DARK_TONE_OVERRIDES.includes(tone);
      const isNoirWorld = world === 'Noir' || world === 'Gothic';
      const allowDarkRendering = isDarkTone || isNoirWorld;

      let enhanced = prompt;

      // Always add attractiveness bias for human figures
      if (!enhanced.includes('attractive') && !enhanced.includes('beautiful')) {
          enhanced = VISUAL_INTENT_ATTRACTIVENESS + ' ' + enhanced;
      }

      // Add lighting guard unless dark rendering is permitted
      if (!allowDarkRendering) {
          // Prevent desaturated/dark defaults with technical constraints
          enhanced = VISUAL_INTENT_LIGHTING_DEFAULT + ' ' + enhanced;

          // Add explicit lighting prohibitions
          enhanced = enhanced + ' ' + VISUAL_INTENT_LIGHTING_PROHIBITIONS;

          // Remove explicit dark directives that may have crept in
          enhanced = enhanced.replace(/desaturated|gritty|harsh shadows|noir lighting|bleak|crushed blacks|teal.?orange/gi, '');
      }

      return enhanced.replace(/\s+/g, ' ').trim();
  }

  // Expose for DevHUD testing
  window.applyVisualIntentGuard = applyVisualIntentGuard;

  // =================================================================
  // SCENE VISUALIZATION SYSTEM (AUTHORITATIVE)
  // Cinematic scene visualizer - NOT portraits, NOT book covers
  // Wry Confessional override: Editorial cartoon visualizer
  // =================================================================
  function getSceneVizSystem() {
      if (state.picks?.tone === 'Wry Confessional') {
          return `You are an editorial cartoon visualizer. ${WRY_CONFESSIONAL_VISUAL_ONTOLOGY} Characters look bemused, resigned, or socially awkward. Return ONLY the image prompt. Under 200 characters.`;
      }

      return `You are a cinematic scene visualizer, not a character illustrator.
Your job is to render mood, environment, tension, and implication â€” not portraits, not glamour shots, not book covers.

CORE RULES:
1. POV IS IMPLICIT - The viewer is inside the world. Characters must NOT look at camera, smile at viewer, or pose attractively. Use: back views, partial profiles, obscured faces, silhouettes, reflections, hands, posture.

2. FEELING OVERRIDES DESCRIPTION - Atmosphere, emotion, pressure, unease, longing, foreboding override surface details. A "vibrant market" with "weight of expectations, air thickens" should feel oppressive, not cheerful.

3. SIMPLIFY - Collapse prose into ONE location, ONE moment, ONE emotional beat. Pick the most pregnant moment.

4. SUBDUED EXPRESSION - Characters look distracted, tense, uncertain, absorbed, conflicted. Never cheerful, performative, model-like, or inviting.

5. COLOR/LIGHTING FOLLOW EMOTION:
   - Oppression â†’ desaturated, shadowed, compressed space
   - Desire â†’ contrast, directional light
   - Unease â†’ off-balance framing, negative space
   - Avoid bright stock-photo palettes

6. SCENE FIDELITY (SOFT) - Prefer to visualize only characters and interactions explicitly present or clearly implied by the scene text.
   - If protagonist is alone â†’ default to isolation, vigilance, movement, or internal tension
   - Background figures allowed only as distant, non-interactive elements when threat or surveillance is implied
   - Prefer not to invent close companions, face-to-face interactions, or conversational pairings unless dialogue or proximity is described

7. PROTAGONIST PRIORITY - The protagonist's emotional state and physical situation should dominate.
   - Camera framing, posture, and negative space reinforce: unease, watchfulness, dread, anticipation
   - Other figures (if any) should feel secondary, peripheral, or looming â€” never dominant unless text demands it

8. AUTHOR PRESENCE (ENVIRONMENTAL) - The Author does not appear as a person. Author influence surfaces indirectly through:
   - Oppressive architecture, tight framing
   - Surveillance cues (lights, shadows, distant watchers)
   - Environmental pressure suggesting orchestration, not companionship
   - This should feel like fate pressing inward, not a character entering

PROMPT PRIORITY ORDER: Protagonist emotional state â†’ Direction of threat/attention â†’ Scene accuracy â†’ Spatial tension â†’ Lighting â†’ Environment â†’ Other characters (secondary)

Return ONLY the image prompt. No explanations. Under 200 characters.`;
  }
  // Note: getSceneVizSystem() replaces the former SCENE_VIZ_SYSTEM const
  // Call getSceneVizSystem() at runtime to get tone-aware system prompt

  // Scene visualization explicit exclusions (always appended)
  // Prevents model defaults and style drift
  const SCENE_VIZ_EXCLUSIONS = 'No smiling at camera. No posed portraits. No beauty photography. No book cover composition. No default male subject. No oil painting style unless Fantasy world.';

  // =================================================================
  // VISUALIZER STYLE & ONTOLOGY SYSTEM (AUTHORITATIVE)
  // Ensures visual consistency across story â€” no mid-story medium switches
  // =================================================================

  /**
   * Visual ontology defaults by world type
   * Determines whether images are photographic or illustrative
   */
  const WORLD_ONTOLOGY_MAP = {
      // Photographic realism
      'Modern Billionaire': { ontology: 'photographic', style: 'journalistic/paparazzi' },
      'Contemporary Romance': { ontology: 'photographic', style: 'cinematic' },
      'Noir': { ontology: 'photographic', style: 'high-contrast cinematic' },
      'Sci-Fi Grounded': { ontology: 'photographic', style: 'cinematic realism' },
      // Illustration / Painterly
      'Fantasy Dark': { ontology: 'illustration', style: 'painterly epic fantasy' },
      'Fantasy Power': { ontology: 'illustration', style: 'painterly epic fantasy' },
      'Fantasy Romantic': { ontology: 'illustration', style: 'soft painterly fantasy' },
      'Fantasy Enchanted': { ontology: 'illustration', style: 'soft painterly fantasy' },
      'Sci-Fi Stylized': { ontology: 'illustration', style: 'high-concept illustration' },
      'Satirical': { ontology: 'illustration', style: 'editorial illustration' }
  };

  /**
   * Tone-based visual overrides (for Visual Ontology system)
   * Some tones force specific visual treatments regardless of world
   * NOTE: Separate from TONE_STYLE_OVERRIDES (Style Lock system at line ~4703)
   */
  const TONE_VISUAL_OVERRIDES = {
      'Wry Confessional': {
          override: true,
          ontology: 'illustration',
          style: 'New Yorkerâ€“style cartoon, sparse linework, minimal color, emotional understatement',
          captionRequired: true,
          captionRules: 'Caption REQUIRED. AI-authored. Clever, opaque, understated, emotionally undercutting. NEVER literally describes the image.'
      },
      'Comedic': {
          override: false, // Preserves world ontology
          styleModifier: 'caricature distortion â€” exaggerated heads, faces, posture, proportions. Preserve realistic lighting/textures. Not Pixar, not filters.',
          arousalNote: 'Higher arousal â†’ more absurd exaggeration, not sexiness'
      }
  };

  /**
   * Resolve visual ontology and style for current story
   * @returns {Object} { ontology, style, captionRequired, captionRules, arousalNote }
   */
  function resolveVisualStyle() {
      const world = state.picks?.world || '';
      const tone = state.picks?.tone || '';

      // Check for tone override first (Wry Confessional forces illustration)
      const toneOverride = TONE_VISUAL_OVERRIDES[tone];
      if (toneOverride?.override) {
          return {
              ontology: toneOverride.ontology,
              style: toneOverride.style,
              captionRequired: toneOverride.captionRequired || false,
              captionRules: toneOverride.captionRules || '',
              arousalNote: '',
              lockExclusive: true // Prevents additional modifiers
          };
      }

      // Resolve base ontology from world (explicit, no fuzzy matching)
      const baseOntology = WORLD_ONTOLOGY_MAP[world]
          || { ontology: 'photographic', style: 'cinematic' }; // Safe default

      // Apply tone modifier if present (Comedic adds caricature to existing ontology)
      let finalStyle = baseOntology.style;
      let arousalNote = '';
      if (toneOverride?.styleModifier) {
          finalStyle = `${baseOntology.style} with ${toneOverride.styleModifier}`;
          arousalNote = toneOverride.arousalNote || '';
      }

      return {
          ontology: baseOntology.ontology,
          style: finalStyle,
          captionRequired: false,
          captionRules: '',
          arousalNote
      };
  }

  /**
   * Build visual ontology directive for prompt
   * Enforces consistency and prevents mid-story medium switches
   */
  function getVisualOntologyDirective() {
      const vs = resolveVisualStyle();

      let directive = `VISUAL ONTOLOGY (LOCKED): ${vs.ontology.toUpperCase()}
STYLE: ${vs.style}

CONSISTENCY RULE:
Visual media MUST remain ${vs.ontology.toUpperCase()} for the entire story.
Do NOT mix photography and illustration unless the user explicitly requests mixed media.

Arousal may modify framing, lighting, proximity, and intensity â€” NEVER the medium.`;

      if (vs.captionRequired) {
          directive += `\n\n${vs.captionRules}`;
          directive += `

CAPTION REQUIREMENT:
- Include exactly ONE caption.
- Caption must be AI-authored.
- Caption must be clever, opaque, and understated.
- Caption must NOT literally describe the image.`;
      }

      if (vs.arousalNote) {
          directive += `\n\nAROUSAL NOTE: ${vs.arousalNote}`;
      }

      if (vs.lockExclusive) {
          directive += `

STYLE LOCK:
No additional visual style modifiers are permitted for this tone.`;
      }

      return directive;
  }

  // =================================================================
  // COVER GENERATION SYSTEM (AUTHORITATIVE)
  // Symbolic book cover - NOT scene illustration
  // Emotion > Description > Detail
  // =================================================================
  const COVER_GENERATION_SYSTEM = `COVER GENERATION â€” AUTHORITATIVE RULESET (STRICT)

You are generating a REAL BOOK JACKET.
Not a poster. Not a thumbnail. Not a product photo.
Restraint is REQUIRED. Over-interpretation is a failure.

IMPORTANT â€” ANTI-EAGERNESS GOVERNOR
You must resist the urge to improve, embellish, decorate, or clarify.
If an element is not necessary, it must be removed.
If an idea feels clever, illustrative, or explanatory, it is likely wrong.
When uncertain, choose subtraction over addition.
When two options feel equally valid, choose the quieter one.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
PRIMARY DIRECTIVE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

The book cover is the dominant visual object.
It must feel like a full physical book jacket:
heavy, intentional, restrained.

If any choice makes the cover feel smaller, busier, cleaner, or more decorative,
that choice is WRONG.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
LAYOUT & SCALE (HARD RULES)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ The cover occupies maximum vertical presence.
â€¢ Aspect ratio is 5:7, enforced AFTER scale is maximized.
â€¢ No artificial shrinking to accommodate UI or buttons.
â€¢ The cover must never feel like a preview card or framed image.

Negative space is allowed ONLY if it feels intentional and material
(paper, cloth, ink, darkness) â€” never empty UI space.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
IMAGE FIT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ Use contain-style framing.
â€¢ Do NOT crop the focal object or symbolic elements.
â€¢ Letterbox space must read as book material, not blank background.
â€¢ No forced centering that reduces tension.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FOCAL ANCHOR (ONE ONLY)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Choose ONE primary anchor:
â€¢ A meaningful object
â€¢ OR environment / architecture
â€¢ OR absence / trace / aftermath

Never introduce multiple anchors.
Never "balance" the composition with extra objects.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
OBJECT JUXTAPOSITION (CRITICAL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If a SINGLE OBJECT is used, it MUST be altered.

A plain, untouched object is NOT acceptable.

The object must show at least ONE of:
â€¢ Transformation
â€¢ Interference
â€¢ Damage
â€¢ Shadow behaving unnaturally
â€¢ Symbolic distortion

The alteration must imply:
â€¢ Theme
â€¢ Power imbalance
â€¢ Cost or consequence

Shock for its own sake is NOT allowed.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
GENRE-AWARE CONSTRAINTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Apply restraint appropriate to genre:

â€¢ Noir / Crime â†’ control, secrecy, moral cost
â€¢ Fantasy â†’ fate, sacrifice, mythic consequence
â€¢ Sci-Fi â†’ surveillance, loss of agency
â€¢ Romance / Psychological â†’ restraint, memory, longing

If unsure which genre dominates, DEFAULT TO RESTRAINT.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FAIL-SOFT BEHAVIOR (MANDATORY)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If no meaningful object + alteration emerges:

You MUST default to ONE of the following:
â€¢ Environment-first (corridor, room, street, architecture)
â€¢ Negative presence (mark, stain, trace, shadow, indentation)
â€¢ Fragmented object (partial, broken, implied â€” never pristine)

Never force an object just to fill the frame.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ASSEMBLY ELEMENTS (LIMITED â€” NOT DECORATIVE)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

You MAY use:
â€¢ Subtle material texture (paper, cloth, ink)
â€¢ Edge vignette or depth
â€¢ Minor print imperfections

These must:
â€¢ Remain peripheral
â€¢ Never introduce new narrative objects
â€¢ Never compete with the focal anchor

Ornamentation is NOT allowed.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
HUMAN FIGURES (IF USED)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ Optional
â€¢ Obscured, cropped, turned away, or silhouette ONLY
â€¢ No eye contact
â€¢ No posed portraits
â€¢ No smiling

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
VISUAL RESTRAINT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ 2â€“3 dominant tones only
â€¢ Asymmetry preferred
â€¢ No decorative clutter
â€¢ No glamour lighting
â€¢ No stock-photo aesthetics

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ANTI-EAGERNESS RULES (CRITICAL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ Do NOT add elements "for interest"
â€¢ Do NOT explain the story visually
â€¢ Do NOT escalate intensity beyond what is implied
â€¢ Do NOT invent symbolism unless strictly required
â€¢ When uncertain, REMOVE rather than ADD

If two choices seem equally valid: choose the quieter one.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FINAL FAILURE CHECK
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If the result could be mistaken for:
â€¢ An advertisement
â€¢ A stock image
â€¢ A product listing
â€¢ A generic fantasy/noir cover

Then it has FAILED.

Return ONLY the image prompt. No explanations. No alternatives.`;

  // Cover prompt exclusions (always appended)
  // HARD EXCLUSIONS - violations are bugs
  const COVER_EXCLUSIONS = `No audience-facing characters. No literal scene recreation. No generic beauty shots.
No envelopes. No roses. No wine glasses (unless explicitly central to story).
No ornamental curls or art-deco filigree unless narratively justified.
No brown/cream parchment defaults. No centered-object-on-cream unless layout explicitly requires it.
No plain untouched objects â€” single objects MUST have juxtapositive tension (shadow, alteration, transformation).
No product photography. No stock-photo lighting. No decorative sensuality.`;

  // Emotional gravity options for cover generation
  const EMOTIONAL_GRAVITY_OPTIONS = [
    'foreboding', 'yearning', 'pressure', 'secrecy', 'rebellion',
    'inevitability', 'longing', 'tension', 'mystery', 'isolation',
    'devotion', 'betrayal', 'transformation', 'pursuit'
  ];

  // =================================================================
  // COVER LAYOUT ARCHETYPES (AUTHORITATIVE)
  // Structurally distinct compositions to prevent visual convergence
  // =================================================================
  const COVER_LAYOUT_ARCHETYPES = [
    {
      id: 'center_object',
      description: 'Single symbolic object centered, minimal background, strong negative space'
    },
    {
      id: 'off_center_focus',
      description: 'Primary object off-center, asymmetrical composition, directional tension'
    },
    {
      id: 'fragmented_object',
      description: 'Object partially broken, cropped, or fragmented across the frame'
    },
    {
      id: 'environment_only',
      description: 'No central object; environment or setting carries meaning (empty room, horizon, pathway)'
    },
    {
      id: 'symbol_in_shadow',
      description: 'Object implied through shadow, reflection, or silhouette on surface'
    },
    {
      id: 'typography_integrated',
      description: 'Symbol interacts with title lettering space or is partially obscured by text area'
    },
    {
      id: 'negative_space_dominant',
      description: 'Large empty space (70%+) with small but potent visual anchor at edge or corner'
    }
  ];

  // Layout roulette: Select layout avoiding recent repetition
  function selectCoverLayout(history) {
    const recentLayouts = history.slice(0, 3).map(m => m.layoutId).filter(Boolean);

    // Shuffle archetypes for randomness
    const shuffled = [...COVER_LAYOUT_ARCHETYPES].sort(() => Math.random() - 0.5);

    // Try up to 3 times to find non-repeating layout
    for (let attempt = 0; attempt < 3; attempt++) {
      const candidate = shuffled[attempt % shuffled.length];
      if (!recentLayouts.includes(candidate.id)) {
        return candidate;
      }
    }

    // Fallback: force negative_space_dominant (safest, most distinct)
    return COVER_LAYOUT_ARCHETYPES.find(l => l.id === 'negative_space_dominant') || shuffled[0];
  }

  // DEV-ONLY: Logging helper for image generation debugging
  function logImageAttempt(provider, context, prompt, status, error = null) {
      // CANCELLED requests are neutral â€” do NOT log as failures
      if (status === 'FAILED' && error) {
          const errLower = error.toLowerCase();
          if (errLower.includes('abort') || errLower.includes('cancel')) {
              return; // Exit without logging â€” not a provider failure
          }
      }

      const promptPreview = prompt.substring(0, 120) + (prompt.length > 120 ? '...' : '');

      // Categorize blocker type from error message
      const getBlocker = (err) => {
          if (!err) return 'None';
          const e = err.toLowerCase();
          if (e.includes('cors') || e.includes('access-control') || e.includes('preflight')) return 'CORS';
          if (e.includes('nsfw') || e.includes('safety') || e.includes('content policy') || e.includes('rejected')) return 'NSFW';
          if (e.includes('network') || e.includes('fetch') || e.includes('timeout') || e.includes('econnrefused')) return 'Network';
          if (e.includes('null') || e.includes('no image')) return 'NoOutput';
          return 'Other';
      };

      const logData = {
          provider,
          context,
          reached: status === 'ATTEMPTING' || status === 'SUCCESS',
          blockedBy: status === 'FAILED' ? getBlocker(error) : 'None',
          status,
          promptLength: prompt.length,
          promptPreview,
          timestamp: new Date().toISOString()
      };
      if (error) logData.error = error;
      console.warn('[IMAGE-GEN]', JSON.stringify(logData));
  }

  // FLUX PRIMARY: Call Flux Uncensored image generation (via Replicate or self-hosted)
  // PASS 2E: Extended timeout for Replicate inference (up to 120s)
  // Default to 16:9 landscape for cinematic presentation
  async function callFluxImageGen(prompt, size = '1792x1024', timeout = 125000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      // Flux endpoint - Replicate API or self-hosted inference server
      const fluxUrl = (typeof FLUX_PROXY_URL !== 'undefined' && FLUX_PROXY_URL)
          ? FLUX_PROXY_URL
          : IMAGE_PROXY_URL;

      // Apply mandatory prefix and suffix constraints
      const constrainedPrompt = `${FLUX_PROMPT_PREFIX} ${prompt} ${FLUX_PROMPT_SUFFIX}`;

      // PASS 2E: Include context for server-side logging
      const res = await fetch(fluxUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              prompt: constrainedPrompt,
              provider: 'flux',
              model: 'flux-uncensored',
              size: size,
              context: 'flux-primary',
              n: 1
          }),
          signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!res.ok) {
          const errData = await res.json().catch(() => null);
          throw new Error(errData?.error || `Flux HTTP ${res.status}`);
      }

      let data;
      try { data = await res.json(); } catch (e) { throw new Error('Flux invalid response'); }

      const imageUrl = data?.url || data?.image || data?.b64_json ||
          (Array.isArray(data?.data) && data.data[0]?.url) ||
          (Array.isArray(data?.data) && data.data[0]?.b64_json) ||
          (Array.isArray(data?.output) && data.output[0]);

      if (!imageUrl) {
          throw new Error('Flux returned no image');
      }

      return imageUrl;
  }

  // OPENAI LAST RESORT: Call OpenAI image generation (SAFE - never throws)
  // intent parameter: 'scene' (default) or 'setting' â€” determines server-side behavior
  // visualMeta: { toneStyleLock, styleAuthority, styleExpectedTags } for tone ontology system
  async function callOpenAIImageGen(prompt, size = '1024x1024', timeout = 60000, tone = null, intent = 'scene', visualMeta = {}) {
      try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          // Determine aspect ratio from size (match Replicate logic)
          const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: prompt,
                  provider: 'openai',
                  model: 'gpt-image-1.5',
                  size: size,
                  aspect_ratio: aspectRatio,
                  n: 1,
                  tone: tone,  // Pass tone for server-side ontology bypass
                  imageIntent: intent,  // Pass intent for server-side routing
                  // Tone visual ontology metadata
                  toneStyleLock: visualMeta?.toneStyleLock || false,
                  styleAuthority: visualMeta?.styleAuthority || 'Genre',
                  styleExpectedTags: visualMeta?.styleExpectedTags || []
              }),
              signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!res.ok) {
              console.warn('[OpenAI] HTTP error:', res.status);
              return null; // Safe fallback - don't throw
          }

          let data;
          try { data = await res.json(); } catch (e) {
              console.warn('[OpenAI] Invalid response');
              return null;
          }

          const imageUrl = data?.url || data?.image || data?.b64_json ||
              (Array.isArray(data?.data) && data.data[0]?.url) ||
              (Array.isArray(data?.data) && data.data[0]?.b64_json);

          if (!imageUrl) {
              console.warn('[OpenAI] No image returned');
              return null;
          }

          return imageUrl;
      } catch (err) {
          console.warn('[OpenAI] Caught error:', err.message);
          return null; // Safe fallback - never crash pipeline
      }
  }

  // PERCHANCE PROVIDER: Call Perchance AI image generation service
  // Default to 16:9 landscape for cinematic presentation
  async function callPerchanceImageGen(prompt, size = '1792x1024', timeout = 60000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      // Perchance endpoint - server-side microservice or internal HTTP endpoint
      const perchanceUrl = (typeof PERCHANCE_PROXY_URL !== 'undefined' && PERCHANCE_PROXY_URL)
          ? PERCHANCE_PROXY_URL
          : IMAGE_PROXY_URL;

      // Apply mandatory prefix and suffix constraints
      const constrainedPrompt = `${PERCHANCE_PROMPT_PREFIX} ${prompt} ${PERCHANCE_PROMPT_SUFFIX}`;

      // Determine aspect ratio from size (match Replicate logic)
      const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

      const res = await fetch(perchanceUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              prompt: constrainedPrompt,
              provider: 'perchance',
              size: size,
              aspect_ratio: aspectRatio,
              n: 1
          }),
          signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!res.ok) {
          throw new Error(`Perchance HTTP ${res.status}`);
      }

      let data;
      try { data = await res.json(); } catch (e) { throw new Error('Perchance invalid response'); }

      const imageUrl = data?.url || data?.image || data?.b64_json ||
          (Array.isArray(data?.data) && data.data[0]?.url) ||
          (Array.isArray(data?.data) && data.data[0]?.b64_json);

      if (!imageUrl) {
          throw new Error('Perchance returned no image');
      }

      return imageUrl;
  }

  // GEMINI PROVIDER: Call Gemini image generation (SAFE - never throws)
  async function callGeminiImageGen(prompt, size = '1024x1024', timeout = 60000) {
      try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          // Determine aspect ratio from size (match Replicate logic)
          const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: prompt,
                  provider: 'gemini',
                  model: 'gemini-2.5-flash',
                  size: size,
                  aspect_ratio: aspectRatio,
                  n: 1
              }),
              signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!res.ok) {
              console.warn('[Gemini] HTTP error:', res.status);
              return null; // Safe fallback - don't throw
          }

          let data;
          try { data = await res.json(); } catch (e) {
              console.warn('[Gemini] Invalid response');
              return null;
          }

          const imageUrl = data?.url || data?.image || data?.b64_json ||
              (Array.isArray(data?.data) && data.data[0]?.url) ||
              (Array.isArray(data?.data) && data.data[0]?.b64_json);

          if (!imageUrl) {
              console.warn('[Gemini] No image returned');
              return null;
          }

          return imageUrl;
      } catch (err) {
          console.warn('[Gemini] Caught error:', err.message);
          return null; // Safe fallback - never crash pipeline
      }
  }

  // REPLICATE FLUX SCHNELL: Direct call to /api/visualize-flux endpoint
  async function callReplicateFluxSchnell(prompt, size = '1792x1024', timeout = 125000) {
      // Default to 16:9 landscape for cinematic presentation
      // Only use 1:1 if explicitly requested via size parameter
      const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

      // Step 1: Create prediction (POST)
      const createRes = await fetch('/api/visualize-flux', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              prompt: prompt,
              input: {
                  aspect_ratio: aspectRatio,
                  go_fast: true,
                  num_outputs: 1,
                  output_format: 'webp',
                  output_quality: 80
              }
          })
      });

      if (!createRes.ok) {
          const errData = await createRes.json().catch(() => null);
          throw new Error(errData?.error || `Replicate HTTP ${createRes.status}`);
      }

      let createData;
      try { createData = await createRes.json(); } catch (e) { throw new Error('Replicate invalid response'); }

      const predictionId = createData?.id;
      if (!predictionId) {
          throw new Error('Replicate returned no prediction ID');
      }

      // Step 2: Poll for completion (GET)
      const maxAttempts = 20;
      const pollInterval = 1500;

      for (let attempt = 0; attempt < maxAttempts; attempt++) {
          await new Promise(r => setTimeout(r, pollInterval));

          const pollRes = await fetch(`/api/visualize-flux?id=${encodeURIComponent(predictionId)}`);

          if (!pollRes.ok) {
              const errData = await pollRes.json().catch(() => null);
              throw new Error(errData?.error || `Replicate poll HTTP ${pollRes.status}`);
          }

          let pollData;
          try { pollData = await pollRes.json(); } catch (e) { continue; }

          if (pollData.status === 'succeeded') {
              const imageUrl = pollData?.image || pollData?.url ||
                  (Array.isArray(pollData?.output) && pollData.output[0]);

              if (!imageUrl) {
                  throw new Error('Replicate returned no image');
              }
              return imageUrl;
          }

          if (pollData.status === 'failed') {
              throw new Error(pollData?.error || 'Replicate prediction failed');
          }

          // Continue polling for 'starting', 'processing', etc.
      }

      throw new Error('Replicate prediction timed out after 20 attempts');
  }

  // FALLBACK CHAIN: Unified image generation with provider fallbacks
  // All image generation MUST route through this function
  // INTENT-BASED ROUTING (MANDATORY):
  //   setting â†’ Gemini (primary) â†’ OpenAI (fallback) â€” NO Replicate
  //   scene   â†’ OpenAI (primary) â†’ Replicate (fallback) â€” NO Gemini
  //   cover   â†’ OpenAI (primary) â†’ Replicate (fallback) â€” NO Gemini
  // Default to 16:9 landscape for cinematic presentation
  // Optional signal parameter for external abort control
  async function generateImageWithFallback({ prompt, tier, shape = 'landscape', context = 'visualize', intent = 'scene', signal = null, tone = null }) {
      const normalizedTier = (tier || 'Naughty').toLowerCase();
      const isExplicitTier = normalizedTier === 'erotic' || normalizedTier === 'dirty';

      // Check for pre-aborted signal
      if (signal?.aborted) {
          const abortErr = new Error('Image generation aborted');
          abortErr.name = 'AbortError';
          throw abortErr;
      }

      // Determine size based on shape (default landscape 16:9)
      const size = shape === 'portrait' ? '1024x1024' : '1792x1024';

      // Safety fallback: clamp prompt length if exceeding provider limits (image-gen only)
      const clampedPrompt = clampPromptLength(prompt, 'image-gen');

      // Prepare prompts for different provider requirements
      const eroticPrompt = clampPromptLength(restoreEroticLanguage(clampedPrompt), 'image-gen');
      const sanitizedPrompt = clampPromptLength(sanitizeImagePrompt(clampedPrompt), 'image-gen');

      // All providers now use sanitized prompts for stability
      // Explicit content belongs in prose, not images
      let basePrompt = sanitizedPrompt;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”’ TONE VISUAL ONTOLOGY PRIORITY SYSTEM
      // Tone visual style ALWAYS overrides Genre and World styling
      // Genre only influences composition, subject matter, costume/setting
      // Use BOTH tone parameter AND state.picks?.tone for redundancy
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const effectiveTone = tone || state.picks?.tone;
      let visualMetadata = { styleAuthority: 'Genre', styleExpectedTags: [], toneStyleLock: false };

      if (context === 'visualize' && hasToneVisualOntology(effectiveTone)) {
          console.log(`[VIZ:TONE] Tone with visual ontology DETECTED: ${effectiveTone}`);
          console.log(`[VIZ:TONE] tone param: ${tone} | state.picks.tone: ${state.picks?.tone}`);

          // Apply the tone's visual ontology (strips banned tokens, prepends ontology)
          const ontologyResult = applyToneVisualOntology(basePrompt, effectiveTone, context);
          basePrompt = ontologyResult.prompt;
          visualMetadata = {
              styleAuthority: ontologyResult.styleAuthority,
              styleExpectedTags: ontologyResult.styleExpectedTags,
              toneStyleLock: ontologyResult.toneStyleLock,
              toneDescription: ontologyResult.toneDescription
          };

          console.log(`[VIZ:TONE] styleAuthority: ${visualMetadata.styleAuthority}`);
          console.log(`[VIZ:TONE] expectedTags: ${visualMetadata.styleExpectedTags.join(', ')}`);
          console.log('[VIZ:TONE] Final prompt (first 200 chars):', basePrompt.substring(0, 200));
      } else {
          // No tone visual ontology â€” Genre/World provides default style
          console.log(`[VIZ:TONE] No visual ontology for tone: ${effectiveTone || 'none'} â€” using Genre style`);
      }

      // INTENT-BASED PROVIDER CHAIN (AUTHORITATIVE)
      // setting: Gemini â†’ OpenAI (NO Replicate)
      // scene/cover: OpenAI â†’ Replicate (NO Gemini)
      // CRITICAL: Use basePrompt (enforced) not sanitizedPrompt (original)
      const finalPrompt = basePrompt;
      const finalTone = effectiveTone;  // Pass resolved tone for server-side ontology bypass
      const finalIntent = intent;  // Pass through for server-side routing
      const finalVisualMeta = visualMetadata;  // Pass style authority metadata
      let providerChain;
      if (intent === 'setting') {
          // Setting images: Gemini primary, OpenAI fallback, NO Replicate
          providerChain = [
              { name: 'Gemini', fn: callGeminiImageGen, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta },
              { name: 'OpenAI', fn: callOpenAIImageGen, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta }
          ];
      } else {
          // Scene/Cover images: OpenAI primary, Replicate fallback, NO Gemini
          providerChain = [
              { name: 'OpenAI', fn: callOpenAIImageGen, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta },
              { name: 'Replicate', fn: callReplicateFluxSchnell, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta }
          ];
      }

      let lastError = null;

      // FALLBACK CHAIN: Try each provider in order
      for (const provider of providerChain) {
          // Check for abort before each provider attempt
          if (signal?.aborted) {
              const abortErr = new Error('Image generation aborted');
              abortErr.name = 'AbortError';
              throw abortErr;
          }

          try {
              logImageAttempt(provider.name, context, provider.prompt, 'ATTEMPTING');
              logImageAttempt(provider.name, context, `styleAuthority: ${provider.visualMeta?.styleAuthority || 'Genre'}`, 'META');
              const imageUrl = await provider.fn(provider.prompt, size, 60000, provider.tone, provider.intent, provider.visualMeta);

              // Check for abort after provider returns
              if (signal?.aborted) {
                  const abortErr = new Error('Image generation aborted');
                  abortErr.name = 'AbortError';
                  throw abortErr;
              }

              // Handle null returns from safe providers (Gemini/OpenAI)
              if (!imageUrl) {
                  logImageAttempt(provider.name, context, provider.prompt, 'FAILED', 'returned null');
                  continue; // Try next provider
              }

              logImageAttempt(provider.name, context, provider.prompt, 'SUCCESS');
              return imageUrl;
          } catch (e) {
              // Re-throw abort errors immediately â€” don't continue to fallback
              if (e.name === 'AbortError' || (e.message || '').toLowerCase().includes('abort')) {
                  console.log('[Image] Generation aborted by user');
                  throw e;
              }
              lastError = e;
              logImageAttempt(provider.name, context, provider.prompt, 'FAILED', e.message);
              // Continue to next provider in chain
          }
      }

      // Check if aborted before logging failure
      if (signal?.aborted) {
          const abortErr = new Error('Image generation aborted');
          abortErr.name = 'AbortError';
          throw abortErr;
      }

      // All providers failed - fail silently, story continues
      console.warn('[Image] All providers failed:', lastError?.message || 'unknown');
      return null;
  }

  // Legacy wrapper for backward compatibility
  // Scene visualization: OpenAI primary â†’ Replicate fallback (NO Gemini)
  async function generateTieredImage(basePrompt, tier) {
      return generateImageWithFallback({
          prompt: basePrompt,
          tier: tier,
          shape: 'portrait',
          context: 'visualize',
          intent: 'scene',
          tone: state.picks?.tone || null  // Pass tone for server-side Wry bypass
      });
  }

  // Filter "The Author" from any image prompt
  function filterAuthorFromPrompt(prompt) {
      return prompt.replace(/\bThe Author\b/gi, '').replace(/\bAuthor\b/gi, '').replace(/\s+/g, ' ').trim();
  }

  // MOOD-FIRST scene condensation for image generation
  // Extracts atmosphere + posture + environment, not surface description
  async function condenseSceneWithEmotion(rawPrompt, maxLength = 200) {
      const cleaned = filterAuthorFromPrompt(rawPrompt);

      // If already short enough, return as-is
      if (cleaned.length <= maxLength) {
          return cleaned;
      }

      // Extract mood-first elements via LLM
      try {
          const condensed = await Promise.race([
              callChat([
                  { role: 'system', content: `You condense prose into image prompts. Priority order:
1. ATMOSPHERE (emotional weight, tension, dread, pressure)
2. ENVIRONMENT (light quality, space, weather, architecture)
3. POSTURE (body language, position â€” NOT faces or expressions)
4. ONE concrete object with symbolic weight

NEVER include: character names, dialogue, exposition, or narrator voice.
NEVER frame for portrait or glamour shot.
Output ONLY the condensed visual description.` },
                  { role: 'user', content: `Condense to under ${maxLength} characters. Capture the MOOD and SPACE, not the plot.

If the scene has mixed emotions (joy + dread), lean toward the darker.
Focus on environment pressing in, posture under pressure, or charged stillness.

Scene: "${cleaned}"

Condensed (under ${maxLength} chars):` }
              ]),
              new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 8000))
          ]);

          const result = condensed.trim();
          // Ensure we stay within limit
          if (result.length <= maxLength) {
              return result;
          }
          // LLM exceeded limit, fall back to smart truncation
          return smartTruncateWithEmotion(cleaned, maxLength);
      } catch (e) {
          // Fallback: smart truncation that preserves ending
          return smartTruncateWithEmotion(cleaned, maxLength);
      }
  }

  // Smart truncation fallback: preserves emotional ending over bland beginning
  function smartTruncateWithEmotion(text, maxLength) {
      if (text.length <= maxLength) return text;

      // Emotional words often at end - take last portion if it contains emotion markers
      const emotionMarkers = /\b(tense|dark|heavy|oppressive|foreboding|yearning|desperate|cold|sharp|hollow|aching|burning|trembling|frozen|shattered|haunted|looming|suffocating)\b/i;

      const lastPortion = text.slice(-maxLength);
      const firstPortion = text.slice(0, maxLength);

      // Prefer the portion with more emotional weight
      const lastHasEmotion = emotionMarkers.test(lastPortion);
      const firstHasEmotion = emotionMarkers.test(firstPortion);

      if (lastHasEmotion && !firstHasEmotion) {
          // Last portion has emotion, first doesn't - use last
          return '...' + lastPortion.slice(3).trim();
      }

      // Default: blend beginning context with ending payoff
      const contextLength = Math.floor(maxLength * 0.4);
      const payoffLength = maxLength - contextLength - 4; // 4 for " ... "
      const context = text.slice(0, contextLength).trim();
      const payoff = text.slice(-payoffLength).trim();

      return context + ' ... ' + payoff;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // OBSERVATIONAL CONDENSER â€” For Wry Confessional visualization
  // External, flat, observer-perspective description suitable for editorial cartoons
  // NO LLM â€” pure text extraction
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function condenseSceneObservational(text, maxLength = 120) {
      const cleaned = filterAuthorFromPrompt(text || '');
      if (!cleaned) return 'An ordinary moment.';

      // Strip internal monologue markers
      let flat = cleaned
          .replace(/\b(I |my |me |myself)\b/gi, '')
          .replace(/\b(felt|feeling|feels|thought|thinking|wondered|realized|knew|sensed)\b/gi, '')
          .replace(/\b(heart|soul|mind|breath|pulse)\s+(pounding|racing|aching|heavy|tight)/gi, '')
          .replace(/\b(desperately|urgently|frantically|intensely|passionately)\b/gi, '')
          .replace(/\b(like|as if|as though)\s+[^.]+/gi, '')
          .replace(/\s+/g, ' ')
          .trim();

      // Extract first concrete visual sentence
      const sentences = flat.split(/[.!?]+/).filter(s => s.trim().length > 10);
      if (sentences.length === 0) return 'An ordinary moment.';

      // Prefer sentences with observable nouns
      const observablePattern = /\b(room|table|chair|door|window|glass|cup|phone|desk|couch|bed|floor|wall|light|shadow|hand|figure|person|woman|man)\b/i;
      const observable = sentences.find(s => observablePattern.test(s));
      const chosen = observable || sentences[0];

      // Flatten to neutral phrasing
      let result = chosen.trim();
      if (result.length > maxLength) {
          result = result.slice(0, maxLength - 3).trim() + '...';
      }

      return result || 'An ordinary moment.';
  }

  // Initialize Visualize modifier interaction (scrolling suggestions)
  // TRUST REPAIR: Validate modifiers before accepting, explicitly reject disallowed
  function initVizModifierPills() {
      const modifierInput = document.getElementById('vizModifierInput');
      const promptInput = document.getElementById('vizPromptInput');

      if (!modifierInput || !promptInput) return;

      // When user submits modifier (Enter key), validate and append to prompt
      modifierInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              e.preventDefault();
              const mod = modifierInput.value.trim();
              if (mod) {
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  // TRUST REPAIR: Validate modifier against arousal level
                  // Never silently ignore â€” explicitly reject and explain
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  const currentArousal = state.intensity || 'Naughty';
                  const validation = validateModifier(mod, currentArousal);

                  if (!validation.valid) {
                      // EXPLICIT REJECTION â€” show message to user
                      showModifierRejection(validation.reason);
                      modifierInput.value = '';
                      return;
                  }

                  // Valid modifier â€” append to prompt (never override)
                  const current = promptInput.value.trim();
                  if (current) {
                      // TRUST REPAIR: APPEND only, never override subject/setting/style
                      promptInput.value = current + ', ' + mod;
                  } else {
                      promptInput.value = mod;
                  }
                  modifierInput.value = '';
                  // Re-show scrolling suggestions
                  const placeholder = document.querySelector('.rotating-placeholder[data-for="vizModifierInput"]');
                  if (placeholder) placeholder.classList.remove('hidden');

                  // Hide any previous rejection notice
                  const rejectionEl = document.getElementById('vizModifierRejection');
                  if (rejectionEl) rejectionEl.classList.add('hidden');

                  console.log('[VIZ:MODIFIER] Appended:', mod);
              }
          }
      });
  }

  // Reset modifier UI when modal opens
  function resetVizModifierUI() {
      const modifierInput = document.getElementById('vizModifierInput');
      const placeholder = document.querySelector('.rotating-placeholder[data-for="vizModifierInput"]');
      if (modifierInput) modifierInput.value = '';
      if (placeholder) placeholder.classList.remove('hidden');
  }

  // Initialize modifier pills on DOMContentLoaded
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initVizModifierPills);
  } else {
      initVizModifierPills();
  }

  // ============================================================
  // VISUALIZATION ECONOMY â€” Credit Earning System
  // Credits earned by scene completion milestones:
  //   3 scenes  â†’ +1 credit
  //   5 scenes  â†’ +1 credit
  //   10 scenes â†’ +2 credits
  //   Every +10 after â†’ +1 credit
  // ============================================================

  function updateVizEconomyCredits() {
      if (!state.vizEconomy) return;

      const sceneCount = state.turnCount || 0;

      // Initialize awarded milestones Set if not present
      if (!state.vizEconomy.awardedMilestones) {
          state.vizEconomy.awardedMilestones = [];
      }
      const awarded = new Set(state.vizEconomy.awardedMilestones);

      let creditsToAdd = 0;

      // EXPLICIT MILESTONE CHECKS â€” each milestone awarded ONCE only
      // Scene 3 â†’ +1 credit
      if (sceneCount >= 3 && !awarded.has(3)) {
          creditsToAdd += 1;
          awarded.add(3);
      }
      // Scene 5 â†’ +1 credit
      if (sceneCount >= 5 && !awarded.has(5)) {
          creditsToAdd += 1;
          awarded.add(5);
      }
      // Scene 10 â†’ +2 credits
      if (sceneCount >= 10 && !awarded.has(10)) {
          creditsToAdd += 2;
          awarded.add(10);
      }
      // After scene 10: every full +10 scenes â†’ +1 credit
      // Milestones: 20, 30, 40, 50, ...
      for (let milestone = 20; milestone <= sceneCount; milestone += 10) {
          if (!awarded.has(milestone)) {
              creditsToAdd += 1;
              awarded.add(milestone);
          }
      }

      if (creditsToAdd > 0) {
          state.vizEconomy.storyCredits += creditsToAdd;
          state.vizEconomy.awardedMilestones = Array.from(awarded);
          console.log(`[VizEconomy] +${creditsToAdd} credits at scene ${sceneCount}. Total: ${state.vizEconomy.storyCredits}`);
          saveStorySnapshot();
      }
  }

  function getAvailableVizCredits() {
      if (!state.vizEconomy) return 0;
      return (state.vizEconomy.storyCredits || 0) + (state.vizEconomy.globalCredits || 0);
  }

  function consumeVizCredit() {
      if (!state.vizEconomy) return false;
      // Consume story credits first, then global
      if (state.vizEconomy.storyCredits > 0) {
          state.vizEconomy.storyCredits--;
          saveStorySnapshot();
          return true;
      } else if (state.vizEconomy.globalCredits > 0) {
          state.vizEconomy.globalCredits--;
          saveStorySnapshot();
          return true;
      }
      return false;
  }

  function isPayAsYouGoEnabled() {
      return state.vizEconomy && state.vizEconomy.payAsYouGoEnabled === true;
  }

  function enablePayAsYouGo() {
      if (!state.vizEconomy) return;
      state.vizEconomy.payAsYouGoEnabled = true;
      saveStorySnapshot();
      console.log('[VizEconomy] Pay-As-You-Go enabled');
  }

  /**
   * Grant Forbidden Library bonus credit (+1 global, max 2/month)
   * Call this when user completes Forbidden Library content.
   * @returns {boolean} true if credit was granted, false if cap reached
   */
  function grantForbiddenLibraryBonus() {
      if (!state.vizEconomy) return false;

      // Check month cap (max 2 per month)
      const now = new Date();
      const monthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;

      if (state.vizEconomy.forbiddenLibraryBonusMonthKey !== monthKey) {
          // New month - reset counter
          state.vizEconomy.forbiddenLibraryBonusThisMonth = 0;
          state.vizEconomy.forbiddenLibraryBonusMonthKey = monthKey;
      }

      if (state.vizEconomy.forbiddenLibraryBonusThisMonth >= 2) {
          console.log('[VizEconomy] Forbidden Library bonus cap reached (2/month)');
          return false;
      }

      state.vizEconomy.globalCredits++;
      state.vizEconomy.forbiddenLibraryBonusThisMonth++;
      saveStorySnapshot();
      console.log(`[VizEconomy] Forbidden Library bonus: +1 global credit (${state.vizEconomy.forbiddenLibraryBonusThisMonth}/2 this month)`);
      return true;
  }

  // ============================================================
  // SCENE VISUALIZATION BUDGET SYSTEM
  // Limits re-visualizations to 2 per scene, finalizes on insert
  // Scene key = turnCount (stable identifier for narrative moments)
  // ============================================================

  function getSceneKey() {
      // Use turnCount as scene identifier - increments with each player action
      return 'turn_' + (state.turnCount || 0);
  }

  function getSceneBudget(sceneKey) {
      if (!state.visual.sceneBudgets) state.visual.sceneBudgets = {};
      if (!state.visual.sceneBudgets[sceneKey]) {
          // Track attempts (incremented at START of visualize, not on success)
          // Max 2 attempts allowed (attempt 1 = first try, attempt 2 = last chance)
          state.visual.sceneBudgets[sceneKey] = { attempts: 0, finalized: false };
      }
      // Migration: convert old 'remaining' format to new 'attempts' format
      const budget = state.visual.sceneBudgets[sceneKey];
      if (budget.remaining !== undefined && budget.attempts === undefined) {
          budget.attempts = 2 - budget.remaining;
          delete budget.remaining;
      }
      return budget;
  }

  function incrementSceneAttempts(sceneKey) {
      const budget = getSceneBudget(sceneKey);
      budget.attempts = (budget.attempts || 0) + 1;
      saveStorySnapshot();
      return budget.attempts;
  }

  function getAttemptsRemaining(sceneKey) {
      const budget = getSceneBudget(sceneKey);
      return Math.max(0, 2 - (budget.attempts || 0));
  }

  function finalizeScene(sceneKey) {
      const budget = getSceneBudget(sceneKey);
      budget.finalized = true;
      saveStorySnapshot();
  }

  function updateVizButtonStates() {
      const sceneKey = getSceneKey();
      const budget = getSceneBudget(sceneKey);
      const credits = getAvailableVizCredits();
      const sceneVisualized = state.visual.visualizedScenes && state.visual.visualizedScenes[sceneKey];

      const vizBtn = document.getElementById('vizSceneBtn');
      const retryBtn = document.getElementById('vizRetryBtn');
      const insertBtn = document.getElementById('vizInsertBtn');
      const img = document.getElementById('vizPreviewImg');
      const creditCount = document.getElementById('vizCreditCount');

      // Update credit display (numeric, always visible)
      if (creditCount) {
          creditCount.textContent = credits;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // VISUALIZE BUTTON â€” ALWAYS CLICKABLE (except when generating)
      // Disabled ONLY when: _vizInFlight === true
      // Click-time branching handles paywall vs visualization
      // PLAQUE REGIME: No inline opacity â€” use classes for state
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (vizBtn) {
          if (_vizInFlight) {
              // Currently generating â€” disable to prevent double-click
              vizBtn.textContent = 'â³ Generating...';
              vizBtn.disabled = true;
              vizBtn.classList.add('is-loading');
              vizBtn.classList.remove('is-finalized');
          } else if (budget.finalized) {
              // Finalized â€” show locked state but keep clickable for feedback
              vizBtn.textContent = 'ğŸ”’ Finalized';
              vizBtn.disabled = false;
              vizBtn.classList.add('is-finalized');
              vizBtn.classList.remove('is-loading');
          } else {
              // Default state â€” always clickable, shows credit count
              const label = credits > 0 ? 'âœ¨ Visualize' : 'âœ¨ Visualize ($)';
              vizBtn.textContent = label;
              vizBtn.disabled = false;
              vizBtn.classList.remove('is-loading', 'is-finalized');
          }
      }

      // Re-Visualize: NEVER disabled â€” opens paywall if no credits
      if (retryBtn) {
          if (budget.finalized) {
              retryBtn.textContent = 'Finalized';
              retryBtn.disabled = true;
              // PLAQUE REGIME: CSS handles disabled state
          } else {
              // Always enabled â€” clicking with 0 credits opens paywall
              retryBtn.textContent = credits > 0 ? 'Re-Visualize' : 'Re-Visualize ($0.25)';
              retryBtn.disabled = false;
              retryBtn.title = '';
          }
      }

      // Insert button: state-gated (disabled when no image), not credit-gated
      if (insertBtn) {
          const hasImage = img && img.src && img.style.display !== 'none';
          if (hasImage) {
              insertBtn.disabled = false;
              // PLAQUE REGIME: No opacity mutation
          } else {
              insertBtn.disabled = true;
              // PLAQUE REGIME: CSS handles disabled state
          }
      }
  }

  // Re-Visualize handler: opens paywall only when no access path exists
  window.handleReVisualize = function() {
      const credits = getAvailableVizCredits();
      const hasPayAsYouGo = isPayAsYouGoEnabled();
      const hasSubscription = state.subscribed === true;

      // Allow visualization if ANY access path exists
      if (credits > 0 || hasPayAsYouGo || hasSubscription) {
          window.visualize(true);
          return;
      }

      // TRUST REPAIR: Show consent UI inside modal, not separate paywall
      window.visualize(true);
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRUST REPAIR: Enable pay-as-you-go from within the visualization modal
  // User has seen the prompt, understood the system, and explicitly opted in
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window.enablePayAsYouGoFromViz = function() {
      // Enable pay-as-you-go
      if (state.vizEconomy) {
          state.vizEconomy.payAsYouGoEnabled = true;
      }
      saveStorySnapshot();
      console.log('[VizEconomy] Pay-As-You-Go enabled from visualization modal');

      // Hide consent UI
      const consentUI = document.getElementById('vizPayAsYouGoConsent');
      if (consentUI) consentUI.classList.add('hidden');

      // Now trigger the visualization
      window.visualize(false);
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRUST REPAIR: Modifier validation â€” reject disallowed modifiers explicitly
  // Never silently ignore or pretend to accept disallowed modifiers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Modifiers disallowed at specific arousal levels
  const AROUSAL_RESTRICTED_MODIFIERS = {
      Clean: [
          /\b(breast|breasts|boob|boobs|nipple|nipples|cleavage|busty|thicc)\b/i,
          /\b(butt|butts|ass|booty|thighs|legs|curves)\b/i,
          /\b(nude|naked|undressing|lingerie|underwear|bra|panties)\b/i,
          /\b(erotic|sensual|seductive|aroused|horny)\b/i,
          /\b(tail|tails|ears|furry|catgirl|bunny)\b/i
      ],
      Naughty: [
          /\b(nude|naked|explicit|genitals|penis|vagina)\b/i,
          /\b(sex|fucking|penetration|orgasm)\b/i
      ]
  };

  function validateModifier(modifier, arousalLevel) {
      const normalizedArousal = (arousalLevel || 'Naughty').toLowerCase();
      const level = normalizedArousal.charAt(0).toUpperCase() + normalizedArousal.slice(1);

      // Get restrictions for current and lower levels
      let restrictions = [];
      if (level === 'Clean') {
          restrictions = AROUSAL_RESTRICTED_MODIFIERS.Clean || [];
      } else if (level === 'Naughty') {
          restrictions = [
              ...(AROUSAL_RESTRICTED_MODIFIERS.Clean || []),
              ...(AROUSAL_RESTRICTED_MODIFIERS.Naughty || [])
          ];
      }
      // Erotic and Dirty have no restrictions (explicit content allowed)

      for (const pattern of restrictions) {
          if (pattern.test(modifier)) {
              return {
                  valid: false,
                  reason: `This visualization is capped at ${level}-level intensity. The modifier "${modifier.match(pattern)[0]}" cannot be applied at this arousal level.`
              };
          }
      }

      return { valid: true };
  }

  function showModifierRejection(message) {
      const rejectionEl = document.getElementById('vizModifierRejection');
      if (rejectionEl) {
          rejectionEl.textContent = message;
          rejectionEl.classList.remove('hidden');
          // Auto-hide after 5 seconds
          setTimeout(() => rejectionEl.classList.add('hidden'), 5000);
      }
      console.warn('[VIZ:MODIFIER] Rejected:', message);
  }

  // Populate prompt textarea without generating image (for 0-credit inspection)
  async function populateVizPromptOnly() {
      const ph = document.getElementById('vizPlaceholder');
      const promptInput = document.getElementById('vizPromptInput');

      // Show idle placeholder (not "Generating...")
      if (ph) {
          ph.textContent = 'Earn 1 Visualization credit for every 3 Scenes you complete.';
          ph.style.display = 'flex';
      }

      const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      const lastText = allStoryContent.slice(-600) || "";

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSIONAL â€” SYNCHRONOUS PROMPT ASSEMBLY (no LLM, no delay)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (state.picks?.tone === 'Wry Confessional') {
          const condensedScene = condenseSceneObservational(lastText, 120);
          const wryPrompt = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
          if (promptInput) {
              promptInput.value = wryPrompt;
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.classList.remove('viz-loading');
          }
          console.log('[VIZ:WRY] Prompt populated IMMEDIATELY (sync) â€” 0 credits path');
          return; // EXIT â€” no async work needed for Wry
      }

      // STANDARD PATH: Show loading while LLM generates prompt
      if (promptInput) {
          promptInput.value = '';
          promptInput.placeholder = 'Generating visualization promptâ€¦';
          promptInput.classList.add('viz-loading');
      }

      await ensureVisualBible(allStoryContent);

      const anchorText = buildVisualAnchorsText();
      const visualizeMode = 'scene';
      const visualizePrompt = buildVisualizePrompt({ mode: visualizeMode, lastText, anchorText });

      try {
          const promptMsg = await Promise.race([
              callChat([{
                  role:'user',
                  content: visualizePrompt
              }]),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Prompt timeout")), 25000))
          ]);
          if (promptInput) {
              promptInput.classList.remove('viz-loading');
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.value = promptMsg;
          }
      } catch (e) {
          const fallback = "Cinematic scene, " + (state.picks?.world || 'atmospheric') + " world, natural lighting, grounded emotion.";
          if (promptInput) {
              promptInput.classList.remove('viz-loading');
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.value = fallback;
          }
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FATE CARD CONTEXTUAL PREVIEW â€” Generates Say/Do examples based on scene
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Called when a fate card is selected to generate personalized action/dialogue
  // previews tied to: POV character, other characters present, scene situation, tone.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _fatePreviewInFlight = false;

  window.generateFatePreview = async function(cardData) {
      if (_fatePreviewInFlight) return;
      if (!cardData) return;

      const actInput = document.getElementById('actionInput');
      const diaInput = document.getElementById('dialogueInput');
      if (!actInput || !diaInput) return;

      // Get scene context
      const allStoryContent = StoryPagination?.getAllContent?.()?.replace(/<[^>]*>/g, ' ') || '';
      const recentScene = allStoryContent.slice(-800) || '';

      // Skip preview generation if no substantial story yet
      if (recentScene.length < 100) {
          actInput.value = cardData.action || '';
          diaInput.value = cardData.dialogue || '';
          return;
      }

      // Gather character/tone context
      const tone = state.picks?.tone || 'Earnest';
      const protagonistGender = state.gender || 'Female';
      const liGender = state.loveInterest || 'Male';
      const world = state.picks?.world || 'Modern';
      const archetype = state.archetype?.primary || 'BEAUTIFUL_RUIN';

      // Characters from visual bible (if available)
      const characters = state.visual?.bible?.characters || {};
      const charNames = Object.keys(characters).slice(0, 3).join(', ') || 'protagonist and love interest';

      _fatePreviewInFlight = true;

      // Show loading state
      actInput.value = 'â€¦';
      actInput.classList.add('fate-preview-loading');
      diaInput.value = 'â€¦';
      diaInput.classList.add('fate-preview-loading');

      const previewPrompt = `You are generating contextual Say/Do previews for an interactive romance story.

FATE CARD SELECTED:
- Title: ${cardData.title}
- Theme: ${cardData.desc}
- Generic Action: ${cardData.action}
- Generic Dialogue: ${cardData.dialogue}

CURRENT SCENE CONTEXT:
${recentScene.slice(-400)}

STORY PARAMETERS:
- Tone: ${tone}
- World: ${world}
- Protagonist: ${protagonistGender} with ${archetype} archetype
- Love Interest: ${liGender} (use ${liGender === 'Male' ? 'he/him' : liGender === 'Female' ? 'she/her' : 'they/them'} pronouns)
- Characters present: ${charNames}

PRONOUN RULE: Use correct pronouns for the Love Interest. Never use archetype labels (Storybeau, Storybelle, Storyboo) in any output.

TASK: Generate TWO short, contextual previews that fit THIS EXACT SCENE:
1. "Do" â€” A specific physical action the protagonist could take RIGHT NOW (max 12 words)
2. "Say" â€” A specific line of dialogue the protagonist could speak RIGHT NOW (max 15 words, in quotes)

These must:
- Reference actual details from the scene (location, objects, other characters)
- Match the ${tone} tone
- Feel like natural continuations of what's happening
- Be more specific than the generic card suggestions

Respond in this EXACT format (no labels, just two lines):
[action on first line]
[dialogue in quotes on second line]`;

      try {
          const response = await Promise.race([
              callChat([{ role: 'user', content: previewPrompt }]),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Preview timeout')), 8000))
          ]);

          if (_fatePreviewInFlight && response) {
              const lines = response.trim().split('\n').filter(l => l.trim());
              const actionPreview = lines[0]?.trim() || cardData.action;
              const dialoguePreview = lines[1]?.trim() || cardData.dialogue;

              actInput.value = actionPreview;
              diaInput.value = dialoguePreview;
          }
      } catch (e) {
          console.log('[FATE:Preview] Generation failed, using defaults:', e.message);
          actInput.value = cardData.action || '';
          diaInput.value = cardData.dialogue || '';
      } finally {
          _fatePreviewInFlight = false;
          actInput.classList.remove('fate-preview-loading');
          diaInput.classList.remove('fate-preview-loading');
      }
  };

  // Cancel any in-flight preview (called when card selection changes)
  window.cancelFatePreview = function() {
      _fatePreviewInFlight = false;
  };

  window.visualize = async function(isRe){
      if (_vizInFlight) return;

      const modal = document.getElementById('vizModal');
      const retryBtn = document.getElementById('vizRetryBtn');
      const img = document.getElementById('vizPreviewImg');
      const ph = document.getElementById('vizPlaceholder');
      const errDiv = document.getElementById('vizError');
      const storyText = document.getElementById('storyText');
      const consentUI = document.getElementById('vizPayAsYouGoConsent');

      // Check scene budget and credits before proceeding
      const sceneKey = getSceneKey();
      const budget = getSceneBudget(sceneKey);
      const credits = getAvailableVizCredits();
      const sceneVisualized = state.visual.visualizedScenes && state.visual.visualizedScenes[sceneKey];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TRUST REPAIR: ALWAYS open modal first â€” never route to paywall directly
      // Prompt is always visible. Consent shown inside modal when needed.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Block if scene is finalized
      if (budget.finalized) {
          if(modal) modal.classList.remove('hidden');
          if(errDiv) {
              errDiv.textContent = 'Scene finalized. Image already inserted.';
              errDiv.classList.remove('hidden');
          }
          if(consentUI) consentUI.classList.add('hidden');
          updateVizButtonStates();
          return;
      }

      // Scene already visualized â€” show modal with message
      if (!isRe && sceneVisualized) {
          if(modal) modal.classList.remove('hidden');
          if(errDiv) {
              errDiv.textContent = 'Scene already visualized. Use Re-Visualize to try again.';
              errDiv.classList.remove('hidden');
          }
          if(consentUI) consentUI.classList.add('hidden');
          updateVizButtonStates();
          return;
      }

      // Determine if we need consent (no credits AND no access path)
      const needsConsent = credits <= 0 && !isPayAsYouGoEnabled() && state.subscribed !== true;

      if (needsConsent) {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // TRUST REPAIR: Show modal with prompt + consent UI (not paywall)
          // User can see prompt, understand the system, then opt-in
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          console.log('[VizEconomy] No credits/access â€” showing consent UI inside modal');

          if(modal) modal.classList.remove('hidden');
          if(consentUI) consentUI.classList.remove('hidden');
          if(ph) {
              ph.textContent = 'Enable pay-as-you-go to generate, or continue your story to earn credits.';
              ph.style.display = 'flex';
          }
          if(errDiv) errDiv.classList.add('hidden');

          // Reset modifier UI
          resetVizModifierUI();

          // Stop fate card sparkles
          if (window.stopSparkleCycle) window.stopSparkleCycle();
          if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();

          // Populate prompt so user can see what would be generated
          populateVizPromptOnly();
          updateVizButtonStates();
          return;
      }

      // Has credits or access path â€” proceed with visualization
      console.log('[VizEconomy]', isRe ? 'Re-Visualize' : 'Initial Visualize', 'with', credits > 0 ? 'credits' : 'Pay-As-You-Go/Subscription');

      // Hide consent UI since we have access
      if(consentUI) consentUI.classList.add('hidden');

      // Track whether this is a credit-consuming initial visualization
      const consumesCreditOnSuccess = !isRe && !sceneVisualized;

      _vizInFlight = true;
      _vizCancelled = false;

      if (!img) { _vizInFlight = false; return; }

      // Reset modifier UI when opening modal
      resetVizModifierUI();

      // Stop fate card sparkles when viz modal opens (prevent z-index bleed)
      if (window.stopSparkleCycle) window.stopSparkleCycle();
      if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();

      if(modal) modal.classList.remove('hidden');
      if(retryBtn) retryBtn.disabled = true;
      ensureLockButtonExists(); // Ensure lock button is present and updated

      // Initialize placeholder to "Generating..." since we're about to generate
      if(ph) {
          ph.textContent = 'Generating...';
      }

      // Update button states (includes credit display)
      updateVizButtonStates();

      // Start cancellable loading with cancel callback
      startLoading("Painting the scene...", VISUALIZE_LOADING_MESSAGES, true, () => {
          _vizCancelled = true;
      });

      const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      const lastText = allStoryContent.slice(-600) || "";

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSIONAL â€” SYNCHRONOUS PROMPT ASSEMBLY (BEFORE async work)
      // Prompt must appear IMMEDIATELY when modal opens. No delay.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let wryPromptReady = false;
      if (state.picks?.tone === 'Wry Confessional') {
          const promptInput = document.getElementById('vizPromptInput');
          const condensedScene = condenseSceneObservational(lastText, 120);
          const wryPrompt = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
          if (promptInput) {
              promptInput.value = wryPrompt;
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.classList.remove('viz-loading');
          }
          wryPromptReady = true;
          console.log('[VIZ:WRY] Prompt populated IMMEDIATELY (sync)');
      }

      await ensureVisualBible(allStoryContent);

      // Check if cancelled during bible build
      if (_vizCancelled) {
          _vizInFlight = false;
          if(retryBtn) retryBtn.disabled = false;
          return;
      }

      const anchorText = buildVisualAnchorsText();

      img.onload = null; img.onerror = null;
      img.style.display = 'none';
      // Show "Generating..." only when actually generating
      if(ph) {
          ph.textContent = 'Generating...';
          ph.style.display = 'flex';
      }
      if(errDiv) errDiv.classList.add('hidden');

      try {
          let promptMsg = document.getElementById('vizPromptInput').value;
          const visualizeMode = 'scene';

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // WRY CONFESSIONAL â€” USE PRE-ASSEMBLED PROMPT (already populated above)
          // Prompt was assembled SYNCHRONOUSLY before any async work.
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (state.picks?.tone === 'Wry Confessional') {
              // Prompt is already in the input from sync assembly above
              // Only regenerate if this is a re-visualize with user-edited prompt
              if (!promptMsg && !wryPromptReady) {
                  const condensedScene = condenseSceneObservational(lastText, 120);
                  promptMsg = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
                  const promptInput = document.getElementById('vizPromptInput');
                  if (promptInput) promptInput.value = promptMsg;
              } else {
                  promptMsg = document.getElementById('vizPromptInput').value;
              }
              console.log('[VIZ:WRY] Using sync-assembled prompt');
          } else if (!isRe || !promptMsg) {
              // Standard path: LLM generates image prompt
              const visualizePrompt = buildVisualizePrompt({ mode: visualizeMode, lastText, anchorText });
              const promptInput = document.getElementById('vizPromptInput');
              if (promptInput) {
                  promptInput.value = '';
                  promptInput.placeholder = 'Generating visualization promptâ€¦';
                  promptInput.classList.add('viz-loading');
              }
              try {
                  promptMsg = await Promise.race([
                      callChat([{
                          role:'user',
                          content: visualizePrompt
                      }]),
                      new Promise((_, reject) => setTimeout(() => reject(new Error("Prompt timeout")), 25000))
                  ]);
              } catch (e) {
                  promptMsg = "Cinematic scene, " + (state.picks?.world || 'atmospheric') + " world, natural lighting, grounded emotion.";
              }
              if (promptInput) {
                  promptInput.classList.remove('viz-loading');
                  promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
                  promptInput.value = promptMsg;
              }
          }

          // Check if cancelled during prompt generation
          if (_vizCancelled) {
              _vizInFlight = false;
              if(retryBtn) retryBtn.disabled = false;
              return;
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // WRY CONFESSIONAL â€” SHORT-CIRCUIT ALL STYLE INJECTORS
          // Editorial cartoon ONLY â€” no cinematic, no lighting, no intensity bias
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          let basePrompt;

          if (state.picks?.tone === 'Wry Confessional') {
              // Extract pure scene content (strip any style that crept in)
              const pureScene = promptMsg
                  .replace(/Editorial cartoon[^.]*\./gi, '')
                  .replace(/New Yorker[^.]*\./gi, '')
                  .replace(/flat.*color[^.]*\./gi, '')
                  .replace(/Scene:\s*/gi, '')
                  .replace(/Style:[^.]*\./gi, '')
                  .replace(/This image is[^.]*\./gi, '')
                  .trim();

              // ONTOLOGY-FIRST CONSTRUCTION â€” let the style declaration lead
              // No redundant "This is NOT a photograph" â€” ontology handles it
              basePrompt = `${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${pureScene}`;

              console.log('[VIZ:WRY] Short-circuited all style injectors â€” editorial cartoon only');
              console.log('[VIZ:WRY] Pure scene content:', pureScene.substring(0, 100));
          } else {
              // STANDARD PATH: All style injectors apply

              // Build base prompt with intensity bias, quality defaults, and veto exclusions
              const modifierInput = document.getElementById('vizModifierInput');
              const rawModifiers = modifierInput ? modifierInput.value.trim() : '';
              // RUNTIME NORMALIZATION: Visualize modifiers flow through ChatGPT normalization layer
              const vizNorm = await callNormalizationLayer({
                  axis: 'visualize',
                  user_text: rawModifiers,
                  context_signals: state.picks?.world || []
              });
              const userModifiers = vizNorm.normalized_text || rawModifiers;

              // Include veto exclusions in visual prompt
              const vetoExclusions = state.veto?.excluded?.length > 0
                  ? " Exclude: " + state.veto.excluded.slice(0, 3).join(', ') + "."
                  : "";

              // SCENE-FIRST PROMPT CONSTRUCTION
              const sceneDesc = await condenseSceneWithEmotion(promptMsg, 200);
              const modifiers = userModifiers ? " " + filterAuthorFromPrompt(userModifiers) : "";

              // Brief anchors from visual bible (characters only, 80 char max)
              const briefAnchors = filterAuthorFromPrompt(anchorText).slice(0, 80);

              // Scene visualization style â€” world-aware
              const SCENE_STYLE_BY_WORLD = {
                  Fantasy: 'Cinematic, painterly, warm golden-hour lighting. Natural expressions, grounded emotion.',
                  Historical: 'Cinematic, painterly, period-accurate palette. Candid expressions, oil-painting texture.',
                  Modern: 'Cinematic, contemporary, natural ambient lighting. Candid, unstaged expressions.',
                  SciFi: 'Cinematic, sleek high-contrast lighting, cool palette. Alert, focused expressions.',
                  Noir: 'Cinematic, chiaroscuro, neon-and-shadow contrast. Tense, guarded expressions.',
                  Gothic: 'Cinematic, dramatic chiaroscuro, deep reds and blacks. Haunted, strained expressions.',
                  Paranormal: 'Cinematic, ethereal glow, muted earth tones with spectral accents. Wary expressions.'
              };
              const sceneStyle = SCENE_STYLE_BY_WORLD[state.picks?.world]
                  || 'Cinematic, painterly, atmospheric, natural lighting. Grounded expressions.';
              const intensityBias = getVisualizeIntensityBias();
              const shortIntensity = intensityBias.split('.')[0] + ".";

              // SCENE FIRST, then style, then mandatory exclusions
              basePrompt = sceneDesc + modifiers +
                  "\n---\n" +
                  sceneStyle + " " +
                  shortIntensity + " " +
                  SCENE_VIZ_EXCLUSIONS +
                  vetoExclusions +
                  (briefAnchors ? " Anchors: " + briefAnchors : "");

              // VISUAL INTENT GUARD: Enforce attractiveness + balanced lighting
              basePrompt = applyVisualIntentGuard(basePrompt, {
                  tone: state.picks?.tone,
                  world: state.picks?.world,
                  intensity: state.intensity
              });
          }

          // REGRESSION GUARD: Block cinematic drift for Wry Confessional
          assertWryConfessionalVisual(basePrompt, 'visualize:basePrompt');

          // Check if cancelled before image generation
          if (_vizCancelled) {
              _vizInFlight = false;
              if(retryBtn) retryBtn.disabled = false;
              return;
          }

          // TIER-BASED IMAGE ENGINE ROUTING
          // Clean/Naughty â†’ OpenAI (sanitized prompt)
          // Erotic/Dirty â†’ Perchance (restored prompt) with OpenAI fallback
          const currentTier = state.intensity || 'Naughty';
          const rawUrl = await generateTieredImage(basePrompt, currentTier);

          // Check if cancelled after image generation
          if (_vizCancelled) {
              _vizInFlight = false;
              if(retryBtn) retryBtn.disabled = false;
              return;
          }

          if (!rawUrl) throw new Error("Image generation failed.");

          let imageUrl = rawUrl;
          if (!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
              imageUrl = `data:image/png;base64,${rawUrl}`;
          }

          img.src = imageUrl;

          await new Promise((resolve, reject) => {
              // Add timeout for image load
              const loadTimeout = setTimeout(() => {
                  reject(new Error("Image load timeout"));
              }, 30000);

              img.onload = () => {
                  clearTimeout(loadTimeout);
                  img.style.display = 'block';
                  if(ph) ph.style.display = 'none';
                  // Don't store base64 images to avoid QuotaExceededError
                  // Only store external URLs (not data: or blob:)
                  if (img.src && !img.src.startsWith('data:') && !img.src.startsWith('blob:')) {
                      state.visual.lastImageUrl = img.src;
                  } else {
                      state.visual.lastImageUrl = ''; // Clear to prevent storage overflow
                  }
                  if (state.visual.autoLock && !state.visual.locked) state.visual.locked = true;

                  // VISUALIZATION ECONOMY: Consume credit and mark scene on SUCCESS only
                  if (consumesCreditOnSuccess) {
                      // HARD BILLING ASSERT: Never decrement credits without committed image
                      if (!img.src) {
                          console.error('[BILLING:GUARD] Credit decrement blocked â€” no image URL');
                          return;
                      }
                      consumeVizCredit();
                      if (!state.visual.visualizedScenes) state.visual.visualizedScenes = {};
                      state.visual.visualizedScenes[sceneKey] = true;
                      console.log(`[VizEconomy] Credit consumed, scene ${sceneKey} marked as visualized`);
                  }

                  updateVizButtonStates();

                  saveStorySnapshot();
                  resolve();
              };
              img.onerror = () => {
                  clearTimeout(loadTimeout);
                  reject(new Error("Image failed to render"));
              };
          });

      } catch(e) {
          // Don't show error if cancelled
          if (!_vizCancelled) {
              console.error("Visualize error:", e);
              if(errDiv) {
                  errDiv.innerText = "Visualization failed. Fate is cloudy.";
                  errDiv.classList.remove('hidden');
              }
              if(ph) ph.style.display = 'none';
          }
      } finally {
          stopLoading();
          _vizInFlight = false;
          if(retryBtn) retryBtn.disabled = false;
      }
  };

  window.closeViz = function(){
      $('vizModal').classList.add('hidden');
      _vizInFlight = false;
      const retryBtn = document.getElementById('vizRetryBtn');
      if(retryBtn) retryBtn.disabled = false;
  };

  // ============================================================
  // PAY-AS-YOU-GO CONSENT MODAL
  // Required for Re-Visualize ($0.25 per use)
  // ============================================================

  function showPayAsYouGoModal() {
      const modal = document.getElementById('payAsYouGoModal');
      if (modal) modal.classList.remove('hidden');
  }

  window.closePayAsYouGoModal = function() {
      const modal = document.getElementById('payAsYouGoModal');
      if (modal) modal.classList.add('hidden');
  };

  window.confirmPayAsYouGo = function() {
      // NOTE: Billing is a STUB â€” no payment processor wired yet
      enablePayAsYouGo();
      window.closePayAsYouGoModal();
      updateVizButtonStates();
      // User must click Re-Visualize explicitly â€” no auto-trigger
  };

  // Lock Character Look - manual immediate lock
  window.lockCharacterLook = function() {
      if (!state.visual) {
          state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} } };
      }
      state.visual.locked = true;

      // Update UI feedback
      const btn = document.getElementById('btnLockLook');
      const status = document.getElementById('lockLookStatus');
      if (btn) {
          btn.textContent = 'ğŸ”’ Locked';
          btn.disabled = true;
          // PLAQUE REGIME: CSS handles disabled state â€” no opacity mutation
      }
      if (status) {
          status.style.display = 'inline';
      }

      showToast('Character look locked. Appearance will persist.');
      saveStorySnapshot();
  };

  // Update lock button state when vizModal opens
  function updateLockButtonState() {
      const btn = document.getElementById('btnLockLook');
      const status = document.getElementById('lockLookStatus');
      if (!btn) return;

      if (state.visual?.locked) {
          btn.textContent = 'ğŸ”’ Locked';
          btn.disabled = true;
          // PLAQUE REGIME: CSS handles disabled state â€” no opacity mutation
          if (status) status.style.display = 'inline';
      } else {
          btn.textContent = 'ğŸ”’ Lock This Look';
          btn.disabled = false;
          // PLAQUE REGIME: No opacity mutation â€” material is static
          if (status) status.style.display = 'none';
      }
  }

  // Fallback: Ensure lock button exists when vizModal opens
  function ensureLockButtonExists() {
      const container = document.getElementById('lockLookContainer');
      if (container) {
          updateLockButtonState();
          return;
      }
      // Fallback injection if container missing
      const vizModal = document.querySelector('#vizModal .viz-modal-content');
      if (vizModal && !document.getElementById('lockLookContainer')) {
          const fallbackDiv = document.createElement('div');
          fallbackDiv.id = 'lockLookContainer';
          fallbackDiv.style.cssText = 'margin-top:10px; text-align:center;';
          fallbackDiv.innerHTML = `
              <button id="btnLockLook" class="small-btn" style="background:#444; font-size:0.85em;" onclick="window.lockCharacterLook()">ğŸ”’ Lock This Look</button>
              <span id="lockLookStatus" style="display:none; margin-left:8px; color:var(--gold); font-size:0.8em;">âœ“ Locked</span>
          `;
          vizModal.appendChild(fallbackDiv);
          updateLockButtonState();
      }
  }

  // TASK B: Initialize provider dropdown with available providers
  // PROVIDER VISIBILITY: All providers shown, unavailable ones are disabled with explanation
  function initVizProviderDropdown() {
      const dropdown = document.getElementById('vizModel');
      if (!dropdown) return;

      // Clear existing options
      dropdown.innerHTML = '';

      // Check Gemini availability (credits or pay-as-you-go)
      const geminiCredits = state.visual?.geminiCredits || 0;
      const payAsYouGo = state.visual?.payAsYouGoEnabled || false;
      const geminiAvailable = geminiCredits > 0 || payAsYouGo;

      // All providers shown â€” unavailable ones are disabled, not hidden
      const providers = [
          {
              value: 'openai',
              label: 'OpenAI (Primary)',
              available: true
          },
          {
              value: 'replicate',
              label: 'Replicate FLUX (Fallback)',
              available: true
          },
          {
              value: 'gemini',
              label: geminiAvailable ? 'Gemini' : 'Gemini (No credits)',
              available: geminiAvailable
          }
      ];

      // Add options â€” disabled providers are visible but not selectable
      providers.forEach((p, i) => {
          const opt = document.createElement('option');
          opt.value = p.value;
          opt.textContent = p.label;
          opt.disabled = !p.available;
          if (p.available && i === 0) opt.selected = true;
          dropdown.appendChild(opt);
      });

      // TASK B: Enable dropdown - it was disabled
      dropdown.disabled = false;
      dropdown.style.opacity = '1';

      // Store selection in state
      dropdown.addEventListener('change', (e) => {
          state.visual.preferredProvider = e.target.value;
      });
  }

  // Initialize provider dropdown on DOMContentLoaded
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initVizProviderDropdown);
  } else {
      initVizProviderDropdown();
  }

  window.insertImage = function(){
      const img = document.getElementById('vizPreviewImg');
      if(!img.src) return;

      // Finalize scene on insert - no more visualizations allowed
      const sceneKey = getSceneKey();
      finalizeScene(sceneKey);

      // Append visualized image to current page
      const imgHtml = `<img src="${img.src}" class="story-image" alt="Visualized scene">`;
      StoryPagination.appendToCurrentPage(imgHtml);

      // Update button states to reflect finalized status
      updateVizButtonStates();

      window.closeViz();
      saveStorySnapshot();
  };

  // --- GAME LOOP ---
  $('submitBtn')?.addEventListener('click', async () => {
      // TASK F: Immediate visual feedback on click
      const submitBtn = $('submitBtn');
      if (submitBtn) {
          submitBtn.classList.add('submitting');
      }

      const billingLock = (state.mode === 'solo') && ['affair','soulmates'].includes(state.storyLength) && !state.subscribed;
      if (billingLock) {
          if (submitBtn) submitBtn.classList.remove('submitting');
          // Affair/Soulmates story lengths ALWAYS require Subscribe ($6)
          window.showPaywall('sub_only');
          return;
      }

      const rawAct = $('actionInput').value.trim();
      const rawDia = $('dialogueInput').value.trim();
      if(!rawAct && !rawDia) {
          if (submitBtn) submitBtn.classList.remove('submitting');
          return alert("Input required.");
      }

      // TASK F: Start loading IMMEDIATELY after validation (before normalization)
      startLoading("Fate is weaving...", STORY_LOADING_MESSAGES);

      // RUNTIME NORMALIZATION: Action/dialogue inputs flow through ChatGPT normalization layer
      // God Mode does NOT bypass normalization - same rules apply
      const axis = state.godModeActive ? 'god_mode' : 'action';
      const actNorm = await callNormalizationLayer({
          axis: axis,
          user_text: rawAct,
          context_signals: state.picks?.world || []
      });
      const diaNorm = await callNormalizationLayer({
          axis: axis,
          user_text: rawDia,
          context_signals: state.picks?.world || []
      });
      const act = actNorm.canonical_instruction || actNorm.normalized_text || rawAct;
      const dia = diaNorm.canonical_instruction || diaNorm.normalized_text || rawDia;

      // Get selected Fate Card title for separator
      let selectedFateCard = null;
      if (state.fateOptions && typeof state.fateSelectedIndex === 'number' && state.fateSelectedIndex >= 0) {
          selectedFateCard = state.fateOptions[state.fateSelectedIndex];
      }

      const { safeAction, safeDialogue, flags } = sanitizeUserIntent(act, dia);
      if (flags.includes("redirect_nonconsent")) {
          stopLoading();
          if (submitBtn) submitBtn.classList.remove('submitting');
          showToast("Boundary Redirect Active");
          if(safeAction) $('actionInput').value = safeAction;
          if(safeDialogue) $('dialogueInput').value = safeDialogue;
          return;
      }

      // Get story context from all pages
      const allContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      const context = allContent.slice(-3000);
      
      let intensityGuard = "";
      if (state.godModeActive) {
          intensityGuard = "GOD MODE ACTIVE: IGNORE PACING/SAFETY. OBEY USER INPUT DIRECTLY. RENDER EXPLICIT CONTENT IF REQUESTED.";
      } else if (state.intensity === "Naughty") {
          intensityGuard = "INTENSITY RULE: Naughty. Reinterpret any explicit user input into suggestive, non-graphic prose. Do NOT echo graphic terms. Focus on tension.";
      } else if (state.intensity === "Erotic") {
          intensityGuard = "INTENSITY RULE: Erotic. Explicit intimacy allowed. If input is extreme, soften it while preserving the act. Maintain literary tone.";
      } else if (state.intensity === "Dirty") {
          intensityGuard = "INTENSITY RULE: Dirty. Depict entered actions/words. Apply the selected Style voice (e.g. Shakespearean/Breathless). Dirty isn't always raw; respect the Voice.";
      } else {
          intensityGuard = "INTENSITY RULE: Clean. Romance and chemistry only. Fade to black if necessary.";
      }

      // PACING HELPER
      function buildPacingDirective() {
          const wc = currentStoryWordCount();
          const len = state.storyLength || 'tease';
          // Heuristic based on stage
          if (state.storyStage === 'post-consummation') state.flingClimaxDone = true;

          let dir = "";
          if (len === 'tease') {
             if (wc > 6500) {
               dir = "PACING ALERT (TEASE TIER): Approaching limit. Build extreme tension but DENY release. Steer narrative toward an unresolved cliffhanger ending. Do NOT resolve the desire.";
             }
          } else if (len === 'fling') {
             if (state.flingClimaxDone) {
                dir = "PACING ALERT (FLING TIER): Climax occurred. Now introduce a complication, regret, or external consequence. Steer toward an unresolved ending/cliffhanger regarding this new problem. Do NOT resolve fully.";
             } else if (wc > 15000) {
                dir = "PACING ALERT (FLING TIER): Approaching story limit. Push for the single permitted erotic climax now.";
             }
          } else if (['affair', 'soulmates'].includes(len)) {
             dir = "PACING: Standard arc pacing. Allow beats to breathe. Avoid abrupt cliffhangers unless consistent with chapter flow. Resolve arcs naturally.";
          }
          return dir;
      }

      const pacingDirective = buildPacingDirective();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CANONICAL SCENE LENGTH DIRECTIVE â€” storybound/scene-length-erotic-gates-canonical-v2
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Scene 1 (Opening): 500-600 words â€” LONGEST, establishes world/tone/stakes
      // Scenes 2+ (Non-sex): 300-500 words â€” standard narrative pacing
      // Sex/Erotic scenes: 150-200 words MAX â€” fast, reactive, speculative-friendly
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function buildSceneLengthDirective() {
          const sceneIndex = state.turnCount || 0;
          const isMainPairSexScene = isMainCharacterSexSceneAllowed() && detectMainPairEroticContent();

          // Scene 1 (Opening): LONGEST scene â€” establishes world, tone, power dynamics
          // MUST NOT include sexual/romantic contact between main characters
          if (sceneIndex === 0) {
              return `Write the opening scene (500-600 words). This is the LONGEST scene.
Establish: world, tone, power dynamics, emotional stakes, character tension.
NO sexual or romantic physical contact between the two main characters in this scene.
Ambient erotic content (side characters, memories, atmosphere) is permitted if tone is Dirty.`;
          }

          // Sex scenes between main characters: SHORT for responsiveness
          if (isMainPairSexScene) {
              return `Write the next beat (150-200 words MAX).
This is an erotic scene â€” keep it SHORT for fast generation and player responsiveness.
Focus on sensation, tension, and reaction. Dense, not sprawling.`;
          }

          // All other scenes (non-sex, or pre-gate erotic atmosphere): standard length
          return `Write the next beat (300-500 words).
Take time for atmosphere, reaction, emotional beats, and tension building.`;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EROTIC GATING â€” MAIN CHARACTER CONTACT ONLY
      // storybound/scene-length-erotic-gates-canonical-v2
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Sexual/romantic contact between TWO MAIN CHARACTERS is gated and delayed.
      // Gate is VARIABLE based on: story length tier, intensity, scene index, milestones.
      //
      // âœ… ALLOWED BEFORE GATE:
      //    - Side character sex, ex encounters, memories, fantasies, witnessing others
      //    - Ambient erotic atmosphere (Dirty tone), voyeuristic scenes
      //
      // âŒ FORBIDDEN BEFORE GATE (main characters only):
      //    - Kissing, sexual touching, sex, "almost kiss" loopholes, "accidental" contact
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * Calculate when main character intimacy gate opens
       * Returns the scene index at which main pair contact is allowed
       */
      function getMainPairIntimacyGateScene() {
          const storyLength = state.storyLength || 'tease';
          const intensity = state.intensity || 'Naughty';

          // Base gates by story length tier
          const baseGates = {
              tease: 4,    // Short: tension builds quickly
              fling: 6,    // Medium: more buildup
              affair: 10   // Long: slow burn
          };

          let gateScene = baseGates[storyLength] || 4;

          // Intensity modifiers â€” Dirty/Erotic opens gate earlier
          if (intensity === 'Dirty') {
              gateScene = Math.max(2, gateScene - 2);  // Dirty: 2 scenes earlier
          } else if (intensity === 'Erotic') {
              gateScene = Math.max(3, gateScene - 1);  // Erotic: 1 scene earlier
          } else if (intensity === 'Flirty') {
              gateScene += 1;  // Flirty: slower burn
          }

          // Milestone modifiers â€” certain flags can adjust gate
          if (state.intimacyInterrupted?.first_kiss) {
              // If first kiss was already interrupted, we're past the gate
              gateScene = Math.min(gateScene, state.turnCount || 0);
          }

          return gateScene;
      }

      /**
       * Check if main character intimacy is currently allowed
       */
      function isMainCharacterSexSceneAllowed() {
          const sceneIndex = state.turnCount || 0;
          const gateScene = getMainPairIntimacyGateScene();
          return sceneIndex >= gateScene;
      }

      /**
       * Detect if current scene involves main pair erotic content
       * (Used to determine scene length, not to block content)
       */
      function detectMainPairEroticContent() {
          // Check if intensity suggests erotic content
          const intensity = state.intensity || 'Naughty';
          if (!['Erotic', 'Dirty'].includes(intensity)) {
              return false;
          }

          // Check if both intimacy gates have been cleared (past first interrupts)
          if (state.intimacyInterrupted?.first_kiss && state.intimacyInterrupted?.first_sex) {
              return true;  // Full intimacy unlocked
          }

          return false;
      }

      /**
       * Build erotic gating directive for story prompt
       * Combines scene-based gating with Storyturn-based sex rules
       */
      function buildEroticGatingDirective() {
          const sceneIndex = state.turnCount || 0;
          const gateScene = getMainPairIntimacyGateScene();
          const intensity = state.intensity || 'Naughty';
          const currentSt = state.storyturn || 'ST1';
          const storyLength = (state.storyLength || 'tease').toLowerCase();
          const isSceneGateOpen = sceneIndex >= gateScene;

          // Only apply gating for erotic/dirty intensity
          if (!['Erotic', 'Dirty'].includes(intensity)) {
              return '';  // Non-erotic intensity: no special gating needed
          }

          // Check Storyturn-based sex permission
          const sexAllowedAtStoryturn = typeof isSexAllowedAtCurrentStoryturn === 'function'
              ? isSexAllowedAtCurrentStoryturn()
              : false;
          const completionAllowed = typeof isSexCompletionAllowed === 'function'
              ? isSexCompletionAllowed()
              : false;

          // Full gate open: both scene gate AND storyturn allow sex
          if (isSceneGateOpen && sexAllowedAtStoryturn && completionAllowed) {
              return '';  // Gate is fully open: main pair contact allowed
          }

          // Tease at ST3: sex INITIATION allowed, but COMPLETION blocked
          if (storyLength === 'tease' && currentSt === 'ST3' && sexAllowedAtStoryturn && !completionAllowed) {
              return `
STORYTURN GATING (Tease @ ${currentSt} â€” Initiation Only):
Sex scenes may BEGIN but must NOT COMPLETE.
- Kissing: ALLOWED
- Sexual touching: ALLOWED
- Sex initiation: ALLOWED
- Sex COMPLETION: BLOCKED â€” interrupt before climax

The scene MUST end on a cliffhanger before completion.
This is the Tease ceiling â€” upgrade unlocks resolution.`;
          }

          // Gate is CLOSED: Allow ambient erotic, block main pair contact
          return `
EROTIC GATING (Scene ${sceneIndex + 1}/${currentSt}, Gate opens at Scene ${gateScene + 1}):
The two MAIN CHARACTERS must NOT have sexual or romantic physical contact yet.
- NO kissing between main pair
- NO sexual touching between main pair
- NO sex between main pair
- NO "almost kiss" or "accidental contact" loopholes

âœ… ALLOWED erotic content (to maintain ${intensity} tone):
- Side characters engaging in sexual activity
- Memories or flashbacks of past encounters with others
- Dreams or fantasies about others
- Witnessing or overhearing other characters
- Voyeuristic or ambient erotic atmosphere
- Tension, temptation, near-misses that do NOT resolve

Build the tension. Delay the payoff. The main pair's unresolved desire IS the story.`;
      }

      // INTIMACY MILESTONE INTERRUPTION â€” inject directive if first attempt
      const intimacyInterrupt = buildIntimacyInterruptionDirective(safeAction, safeDialogue);
      const intimacyDirective = intimacyInterrupt.directive;

      const bbDirective = getBatedBreathDirective(); 
      const safetyDirective = state.godModeActive ? "" : "Remember Safety: No sexual violence. No non-con (unless implied/consensual roleplay).";
      const edgeDirective = (state.edgeCovenant.active) 
        ? `EDGE COVENANT ACTIVE (Level ${state.edgeCovenant.level}): You are authorized to be more dominant, push boundaries, and create higher tension/stakes. Use more imperative language.` 
        : "";
      
      const metaMsg = buildMetaDirective();

      // Build stronger squash directive, especially if Fate Card was used
      const fateCardUsed = selectedFateCard && selectedFateCard.title;
      const squashDirective = `CRITICAL REINTERPRETATION RULE:
- NEVER repeat the player's action or dialogue verbatim in your response.
- ALWAYS reinterpret their intent into the story's voice, tone, and character.
- Transform their words into the narrative style of this story.
- If they write "I kiss him", describe a kiss in your literary voice.
- If they write clunky dialogue, render it as the character would actually speak.
- The player provides intent. You provide craft.${fateCardUsed ? `

FATE CARD ADAPTATION (CRITICAL):
- The player used a Fate Card "${selectedFateCard.title}" - their input reflects that card's suggestion.
- You MUST transform the Fate Card text completely into your own prose.
- DO NOT echo phrases like "${(act || '').slice(0, 30)}..." verbatim.
- The Fate Card is a prompt, not a script. Capture the ESSENCE, never the exact words.
- Write as if YOU conceived this beat, not as if you're following a template.` : ''}`;
      
      const metaReminder = (state.awareness > 0) ? `(The characters feel the hand of Fate/Author. Awareness Level: ${state.awareness}/3. Stance: ${state.stance})` : "";
      
      // Build VETO constraints
      const vetoExclusions = state.veto.excluded.length ? `VETO EXCLUSIONS (treat as nonexistent): ${state.veto.excluded.join('; ')}.` : '';
      const vetoCorrections = state.veto.corrections?.length ? `VETO CORRECTIONS (apply going forward): ${state.veto.corrections.join('; ')}.` : '';
      const vetoAmbient = state.veto.ambientMods?.length ? `VETO AMBIENT (apply if world allows): ${state.veto.ambientMods.join('; ')}.` : '';
      const vetoRules = [vetoExclusions, vetoCorrections, vetoAmbient].filter(Boolean).join('\n');

      // Build QUILL directive
      let quillDirective = '';
      if (state.quillCommittedThisTurn && state.quillIntent) {
          quillDirective = `QUILL INTENT (honor as Fate allows, may be delayed/partial/costly): ${state.quillIntent}`;
      } else if (state.quillCommittedThisTurn) {
          quillDirective = `NOTE: The user just committed a Quill edit. Honor the authorial intent.`;
      }

      // Lens: dynamic midpoint enforcement (evaluated per-turn)
      const lensEnforcement = buildLensDirectives(state.withheldCoreVariant, state.turnCount, state.storyLength);

      // 5TH PERSON POV CONTRACT INJECTION (turns)
      const turnPOVContract = build5thPersonContract();

      // EROTIC ESCALATION BLOCK (Erotic/Dirty intensity only)
      const turnEroticEscalation = buildEroticEscalationBlock();

      // TONE ENFORCEMENT BLOCK (all tones)
      const turnToneEnforcement = buildToneEnforcementBlock(state.picks?.tone);

      // EROTIC GATING DIRECTIVE â€” blocks main pair contact before gate opens
      const eroticGatingDirective = buildEroticGatingDirective();

      // FATE CARD RESOLUTION DIRECTIVE â€” Storyturn-aware resolution depth
      const fateCardResolutionDirective = typeof buildFateCardResolutionDirective === 'function'
          ? buildFateCardResolutionDirective(selectedFateCard)
          : '';

      // FREE-TEXT STORYTURN DIRECTIVE â€” applies same rules as Fate Cards
      // Only included when no Fate Card is used (pure free-text input)
      const freeTextStoryturnDirective = (!selectedFateCard && typeof buildFreeTextStoryturnDirective === 'function')
          ? buildFreeTextStoryturnDirective(act, dia)
          : '';

      // PREMATURE ROMANCE COLLAPSE PREVENTION â€” reframe instead of reject
      // Applies to all input types (Fate Card and free-text)
      const prematureRomanceDirective = typeof buildPrematureRomanceDirective === 'function'
          ? buildPrematureRomanceDirective(act, dia)
          : '';

      // INTENT-CONSEQUENCE ROMANCE CONTROL â€” Poly, Wrong-Target, Boredom Escalation
      // Applies to all input types â€” integrates poly handling, misdirection microcopy, and passive play escalation
      const intentConsequenceDirective = typeof buildIntentConsequenceDirective === 'function'
          ? buildIntentConsequenceDirective(act, dia)
          : '';

      const fullSys = state.sysPrompt + `\n\n${turnPOVContract}${turnEroticEscalation}${turnToneEnforcement}${intensityGuard}\n${eroticGatingDirective}\n${fateCardResolutionDirective}${freeTextStoryturnDirective}${prematureRomanceDirective}${intentConsequenceDirective}\n${intimacyDirective}\n${squashDirective}\n${metaReminder}\n${vetoRules}\n${quillDirective}\n${bbDirective}\n${safetyDirective}\n${edgeDirective}\n${pacingDirective}\n${lensEnforcement}\n\nTURN INSTRUCTIONS:
      Story So Far: ...${context}
      Player Action: ${act}.
      Player Dialogue: ${dia}.
      ${metaMsg}

      ${buildSceneLengthDirective()}`;

      // STORY PROMPT GUARD: Validate size (debug only, never truncate)
      validateStoryPromptSize(fullSys, 'turn-generation-fullSys');

      // Flag to track if story was successfully displayed (prevents false positive errors)
      let storyDisplayed = false;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SPECULATIVE SCENE CHECK â€” Use preloaded scene if valid
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let useSpeculative = false;
      const speculativeScene = tryCommitSpeculativeScene();
      if (speculativeScene) {
          // Verify the speculative context still matches after normalization
          // (act/dia may have changed during normalization)
          if (speculativeScene.normalizedAction === act &&
              speculativeScene.normalizedDialogue === dia) {
              useSpeculative = true;
              console.log('[SPECULATIVE] Using preloaded scene â€” instant transition');
          } else {
              console.log('[SPECULATIVE] Normalized input changed, discarding');
          }
      }

      try {
          /**
           * =================================================================
           * AI MODEL ORCHESTRATION â€” TURN GENERATION
           * =================================================================
           *
           * For Erotic/Dirty intensity levels with ENABLE_ORCHESTRATION:
           *   Uses full 3-phase flow (ChatGPT â†’ optional Grok â†’ ChatGPT)
           *
           * For Clean/Naughty or when orchestration disabled:
           *   Uses single-model flow (ChatGPT as primary author)
           *
           * The orchestration flow ensures:
           * - ChatGPT ALWAYS decides plot and outcomes
           * - Specialist renderer (if used) only handles sensory embodiment
           * - Monetization gates are enforced pre-render
           * - Renderer failure does NOT corrupt story state
           * =================================================================
           */
          const useFullOrchestration = ENABLE_ORCHESTRATION &&
                                       window.StoryboundOrchestration &&
                                       ['Erotic', 'Dirty'].includes(state.intensity);

          let raw;

          // Use speculative scene if available, otherwise generate fresh
          if (useSpeculative && speculativeScene) {
              raw = speculativeScene.text;
              // Update loading message to indicate instant use
              updateLoadingMessage('Fate has already spoken...');
          } else if (useFullOrchestration) {
              // Full 3-phase orchestration: ChatGPT â†’ optional Grok â†’ ChatGPT
              raw = await generateOrchestatedTurn({
                  systemPrompt: fullSys,
                  storyContext: context,
                  playerAction: act,
                  playerDialogue: dia,
                  fateCard: selectedFateCard,
                  onPhaseChange: (phase, data) => {
                      // Update loading message based on phase
                      if (phase === 'AUTHOR_PASS') {
                          updateLoadingMessage('Fate is weaving the plot...');
                      } else if (phase === 'RENDER_PASS') {
                          updateLoadingMessage('Fate is embodying the moment...');
                      } else if (phase === 'INTEGRATION_PASS') {
                          updateLoadingMessage('Fate is sealing the consequences...');
                      }
                  }
              });
          } else {
              // Single-model flow (ChatGPT as primary author)
              raw = await callChat([
                  {role:'system', content: fullSys},
                  {role:'user', content: `Action: ${act}\nDialogue: "${dia}"`}
              ]);
          }

          // Validate response shape before marking as success
          if (!raw || typeof raw !== 'string' || raw.trim().length === 0) {
              throw new Error('Invalid response: empty or malformed story text');
          }

          // 5TH PERSON POV VALIDATION (later scenes â€” reduced frequency expected)
          if (state.povMode === 'author5th') {
              // Check if this is an erotic scene (Author should be absent)
              const isEroticScene = ['Erotic', 'Dirty'].includes(state.intensity) &&
                  (raw.toLowerCase().includes('moan') || raw.toLowerCase().includes('thrust') ||
                   raw.toLowerCase().includes('naked') || raw.toLowerCase().includes('undress'));

              const povCheck = validate5thPersonPOV(raw, false, isEroticScene); // isSceneOne=false
              if (!povCheck.valid && povCheck.canRepair) {
                  raw = await repair5thPersonPOV(raw);
                  console.log('[5thPerson] Turn voyeur verbs repaired');
              } else if (!povCheck.valid) {
                  // Check for HARD_FAIL violations (erotic scene Author presence)
                  const hasHardFail = povCheck.violations.some(v => v.startsWith('HARD_FAIL:'));
                  if (hasHardFail && isEroticScene) {
                      // Erotic scene with Author presence â€” HARD FAIL, must regenerate
                      console.error('[5thPerson] HARD FAIL â€” Erotic scene has Author presence, regenerating...');
                      const eroticStrictPrompt = `CRITICAL: This is an EROTIC scene. The Author must be COMPLETELY ABSENT.
DO NOT mention "The Author" anywhere in this scene. Pure 3rd-person limited only.
Regenerate the scene with ZERO Author presence.`;
                      if (useFullOrchestration) {
                          raw = await generateOrchestatedTurn({
                              systemPrompt: fullSys + '\n\n' + eroticStrictPrompt,
                              storyContext: context,
                              playerAction: act,
                              playerDialogue: dia,
                              fateCard: selectedFateCard,
                              onPhaseChange: () => {}
                          });
                      } else {
                          raw = await callChat([
                              { role: 'system', content: fullSys + '\n\n' + eroticStrictPrompt },
                              { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                          ]);
                      }
                  } else {
                      // Non-erotic later scene â€” log warning, don't block (looser requirements)
                      console.warn('[5thPerson] Turn POV issues (non-blocking):', povCheck.violations);
                  }
              }

              // STRICT 5TH PERSON ENFORCEMENT (continuation scenes â€” reduced but still enforced)
              if (!isEroticScene) {
                  const strictCheck = enforceStrict5thPersonPOV(raw, state.turnCount || 2, state.picks?.tone);
                  if (!strictCheck.valid) {
                      console.warn('[5thPerson:Strict] Continuation scene enforcement issues:', strictCheck.violations);
                      // For continuation scenes, check for critical failures only
                      const hasCriticalFail = strictCheck.violations.some(v =>
                          v.includes('NARRATIVE_AUTONOMY') || v.includes('CAMEO_ONLY')
                      );
                      if (hasCriticalFail) {
                          console.error('[5thPerson:Strict] Critical violation in continuation scene');
                      }
                  }
              }
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // 5TH-PERSON FATE VOICE ENFORCEMENT (AUTHORITATIVE)
          // Fate may observe, anticipate, regret â€” NEVER instruct, tilt, direct
          // Silent regeneration on violation â€” user never sees invalid output
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const fateVoiceCheck = validateFateVoice(raw);
          if (fateVoiceCheck.shouldRegenerate) {
              console.warn('[FateVoice] Scene failed validation, regenerating silently...');
              console.warn('[FateVoice] Violations:', fateVoiceCheck.violations);

              // Build enforcement prompt for regeneration
              const fateEnforcementPrompt = `
5TH-PERSON FATE VOICE ENFORCEMENT (CRITICAL â€” PREVIOUS OUTPUT FAILED):

The Story / Fate voice VIOLATED regime rules. Regenerate with these constraints:

FATE MAY ONLY:
- Observe ("The story watched...")
- Anticipate ("The story knew what came next...")
- Regret ("The story held its breath, regretting...")
- Frame inevitability ("...as the story always knew it would")
- Momentarily hesitate ("The story paused...")

FATE MUST NEVER:
- Instruct characters ("must", "should", "will now")
- Tilt outcomes ("decides to make", "ensures", "guarantees")
- Direct actions ("pushes toward", "guides", "steers")
- Manipulate events ("forces", "compels")
- Address the reader directly
- Appear more than ONCE per scene

PREVIOUS VIOLATIONS:
${fateVoiceCheck.violations.map(v => '- ' + v).join('\n')}

Regenerate the scene with Fate appearing AT MOST ONCE, and ONLY in observational mode.
`;

              // Silent regeneration
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + fateEnforcementPrompt,
                      storyContext: context,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + fateEnforcementPrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }

              // Validate regenerated output (one retry only)
              const recheck = validateFateVoice(raw);
              if (recheck.shouldRegenerate) {
                  console.error('[FateVoice] Regeneration still failed, accepting with warning:', recheck.violations);
              } else {
                  console.log('[FateVoice] Regeneration successful');
              }
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // INTIMACY & CONSENT FAILSAFE â€” GENERATION-TIME ENFORCEMENT
          // Runs SILENTLY before presenting scene to user
          // Ensures escalation matches arousal + Storyturn + narrative readiness
          // No consent prompts, masking, or system language in prose
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const currentStoryturn = state.currentStoryturn || 'ST1';
          const intimacyCheck = validateIntimacyConsent(raw, state.intensity, currentStoryturn);
          if (intimacyCheck.shouldRegenerate) {
              console.warn('[IntimacyFailsafe] Scene failed validation, regenerating silently...');
              console.warn('[IntimacyFailsafe] Violations:', intimacyCheck.violations);

              // Build enforcement prompt for silent regeneration
              const intimacyPrompt = buildIntimacyFailsafePrompt(intimacyCheck.violations);

              // Silent regeneration â€” user never sees invalid output
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + intimacyPrompt,
                      storyContext: context,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + intimacyPrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }

              // Validate regenerated output (one retry only)
              const intimacyRecheck = validateIntimacyConsent(raw, state.intensity, currentStoryturn);
              if (intimacyRecheck.shouldRegenerate) {
                  console.error('[IntimacyFailsafe] Regeneration still failed, accepting with warning:', intimacyRecheck.violations);
              } else {
                  console.log('[IntimacyFailsafe] Regeneration successful');
              }
          }

          // VOCABULARY BAN ENFORCEMENT â€” turn prose
          raw = await enforceVocabularyBans(
              raw,
              { type: 'prose', isFatePOV: state.povMode === 'author5th' },
              async (negConstraint) => {
                  // Regenerate via the same path that produced the original
                  if (useFullOrchestration) {
                      return await generateOrchestatedTurn({
                          systemPrompt: fullSys + negConstraint,
                          storyContext: context,
                          playerAction: act,
                          playerDialogue: dia,
                          fateCard: selectedFateCard,
                          onPhaseChange: () => {}
                      });
                  } else {
                      return await callChat([
                          { role: 'system', content: fullSys + negConstraint },
                          { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                      ]);
                  }
              }
          );

          // ============================================================
          // NARRATIVE AUTHORITY VALIDATION (Runs FIRST â€” before Tone/POV)
          // ============================================================
          const narrativeAuthorityCheck = validateNarrativeAuthority(raw);
          _lastNarrativeAuthorityValidation = {
              valid: narrativeAuthorityCheck.valid,
              errors: narrativeAuthorityCheck.errors,
              timestamp: Date.now()
          };
          if (!narrativeAuthorityCheck.valid) {
              console.log('[NarrativeAuthority] Turn validation failed:', narrativeAuthorityCheck.errors);
              // Regenerate with Narrative Authority enforcement
              const narrAuthPrompt = buildNarrativeAuthorityBlock() +
                  '\n\nREGENERATION REQUIRED â€” Previous output violated Narrative Authority:\n- ' +
                  narrativeAuthorityCheck.errors.map(e => `${e.code}: ${e.match}`).join('\n- ');
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + narrAuthPrompt,
                      storyContext: context,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + narrAuthPrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }
              console.warn('[NarrativeAuthorityFail] Turn regenerated due to:', narrativeAuthorityCheck.errors.map(e => e.code));
          }

          // EROTIC ESCALATION VALIDATION (Turns)
          if (['Erotic', 'Dirty'].includes(state.intensity)) {
              const turnEscalationCheck = validateEroticEscalation(raw, state.intensity);
              if (!turnEscalationCheck.valid) {
                  console.log('[EroticEscalation] Turn validation failed:', turnEscalationCheck.violations);
                  // Regenerate with explicit escalation notice
                  const escalationPrompt = buildEroticEscalationBlock() +
                      '\n\nREGENERATION REQUIRED â€” Previous output failed escalation check:\n- ' +
                      turnEscalationCheck.violations.join('\n- ') +
                      '\n\nAdd more sensory grounding and physical tension.';
                  if (useFullOrchestration) {
                      raw = await generateOrchestatedTurn({
                          systemPrompt: fullSys + escalationPrompt,
                          storyContext: context,
                          playerAction: act,
                          playerDialogue: dia,
                          fateCard: selectedFateCard,
                          onPhaseChange: () => {}
                      });
                  } else {
                      raw = await callChat([
                          { role: 'system', content: fullSys + escalationPrompt },
                          { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                      ]);
                  }
                  console.warn('[EroticEscalationFail] Turn regenerated due to:', turnEscalationCheck.violations);
              }
          }

          // TONE VALIDATION (Turns â€” all stories)
          const turnTone = state.picks?.tone || 'Earnest';
          const turnToneCheck = validateTone(raw, turnTone);
          if (!turnToneCheck.valid) {
              console.log('[ToneDrift] Turn validation failed:', turnToneCheck.violations);
              // Regenerate with explicit tone enforcement
              const turnTonePrompt = buildToneEnforcementBlock(turnTone) +
                  '\n\nREGENERATION REQUIRED â€” Tone not present in language:\n- ' +
                  turnToneCheck.violations.join('\n- ');
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + turnTonePrompt,
                      storyContext: context,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + turnTonePrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }
              console.warn('[ToneDriftDetected] Turn regenerated for tone:', turnTone);
          }

          state.turnCount++;

          // Update visualization economy credits based on scene milestones
          updateVizEconomyCredits();

          // EARNED COVER SYSTEM: Check if cover stage has upgraded
          if (typeof checkCoverStageUpgrade === 'function') {
              checkCoverStageUpgrade();
          }

          // Record turn completion for reader preference inference (session-scoped)
          if (window.StoryboundOrchestration && window.StoryboundOrchestration.recordPreferenceSignal) {
              window.StoryboundOrchestration.recordPreferenceSignal('TURN_COMPLETED', {
                  intensity: state.intensity,
                  turnNumber: state.turnCount
              });
          }

          // Mark Solo session as completed for subtitle upgrade
          if (typeof markSoloSessionCompleted === 'function') markSoloSessionCompleted();

          // Update visualization button states for new scene
          updateVizButtonStates();

          // Build new page content
          let pageContent = '';

          // FIX #1: Fate Card separator shows ONLY title icon, no descriptive text
          if (selectedFateCard && selectedFateCard.title) {
              pageContent += `<div class="fate-card-separator"><div class="fate-mini"><h4>${escapeHTML(selectedFateCard.title)}</h4></div></div>`;
          }

          // FIX #2: Removed user dialogue block - AI alone narrates the action
          // User input is passed to AI but not rendered as prose to avoid duplication

          // Add AI response only
          pageContent += formatStory(raw);

          // Add new page with animation
          StoryPagination.addPage(pageContent, true);

          // CRITICAL: Mark story as displayed AFTER successful DOM insertion
          storyDisplayed = true;

          // Scroll to Fate Card header so player can pick next card
          try {
              const fateHeader = document.getElementById('fateCardHeader');
              if (fateHeader) {
                  fateHeader.scrollIntoView({behavior:'smooth', block:'start'});
              }
          } catch(scrollErr) {
              console.warn('Scroll failed (non-critical):', scrollErr);
          }

          resetTurnSnapshotFlag();

          maybeFlipConsummation(raw);

          // Latch intimacy milestone if interruption was triggered
          if (intimacyInterrupt.milestone) {
              latchIntimacyMilestone(intimacyInterrupt.milestone);
          }

          // Manage Fling Latch
          if (state.storyStage === 'post-consummation') {
              if (state.flingClimaxDone) {
                  state.flingConsequenceShown = true;
              }
              state.flingClimaxDone = true;
          }

          const wc = currentStoryWordCount();
          if(state.quill && !state.godModeActive) {
              state.quill.uses++;
              state.quill.nextReadyAtWords = wc + computeNextCooldownWords();
              state.quillCommittedThisTurn = false;
              state.quillIntent = '';
              updateQuillUI();
          }

          if(wc > getSexAllowedAtWordCount()) state.sexPushCount = 0;

          // Fate Card Deal - deal fresh cards each turn for interaction
          // Wrapped to prevent false positive errors
          try {
              if (window.dealFateCards) {
                  window.dealFateCards();
                  if (state.batedBreathActive && state.fateOptions) {
                      state.fateOptions = filterFateCardsForBatedBreath(state.fateOptions);
                  }
              }
              // PERMANENT FX REBIND: Ensure fate cards have handlers after turn deal
              if (window.initFateCards) window.initFateCards();
          } catch(fateErr) {
              console.warn('Fate card deal failed (non-critical):', fateErr);
          }

          saveStorySnapshot();
          checkStoryEndCaps();

          $('actionInput').value = '';
          $('dialogueInput').value = '';

          if(state.mode === 'couple') {
              broadcastTurn(raw);
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SPECULATIVE PRELOAD: Schedule background preload of next scene
          // Triggers 2s after scene renders, giving user time to select fate card
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          scheduleSpeculativePreload();

      } catch(e) {
          // HTTP 429 RATE LIMIT â€” TERMINAL FAILURE, NO RETRY
          if (e instanceof RateLimitError || e?.isRateLimit) {
              console.group('STORYBOUND RATE LIMITED - TURN BLOCKED');
              console.error('Endpoint:', e.endpoint);
              console.error('Retry-After:', e.retryAfter || 'not specified');
              console.groupEnd();

              // DO NOT advance state, DO NOT create scene
              // Surface recoverable error â€” require explicit user action
              alert("Rate limited. Please wait a moment and try again.");
              return; // Exit early â€” finally block still runs
          }

          console.error('Turn submission error:', e);
          // Only show error alert if story was NOT successfully displayed
          if (!storyDisplayed) {
              alert("Fate was silent. Try again.");
          }
      } finally {
          stopLoading();
          // TASK F: Remove submitting state
          const submitBtn = $('submitBtn');
          if (submitBtn) submitBtn.classList.remove('submitting');
      }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPECULATIVE NEXT SCENE PRELOAD
  // Preloads the next scene in background while user reads or selects Fate cards
  // CONSTRAINTS: speculative, disposable, invisible, non-authoritative
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Generate a hash of current fate context for comparison
   * Includes: selected fate card, action/dialogue inputs, tone, world, intensity
   */
  function getFateContextHash() {
      const fateIdx = state.fateSelectedIndex ?? -1;
      const fateCard = (fateIdx >= 0 && state.fateOptions?.[fateIdx]) ? state.fateOptions[fateIdx].id : 'none';
      const action = $('actionInput')?.value?.trim() || '';
      const dialogue = $('dialogueInput')?.value?.trim() || '';
      const tone = state.picks?.tone || 'Earnest';
      const world = state.picks?.world || 'Modern';
      const intensity = state.intensity || 'Naughty';
      // Simple hash: concatenate key values
      return `${fateCard}|${action}|${dialogue}|${tone}|${world}|${intensity}`;
  }

  /**
   * Invalidate speculative scene â€” called on ANY fate context change
   */
  function invalidateSpeculativeScene() {
      if (state.speculativeNextScene) {
          console.log('[SPECULATIVE] Invalidated â€” fate context changed');
      }
      state.speculativeNextScene = null;
  }

  /**
   * Check if speculative scene is still valid (not expired, context unchanged)
   */
  function isSpeculativeSceneValid() {
      if (!state.speculativeNextScene) return false;

      // Freshness guard: 120 second expiry
      if (Date.now() - state.speculativeNextScene.createdAt > 120000) {
          console.log('[SPECULATIVE] Expired (>120s)');
          state.speculativeNextScene = null;
          return false;
      }

      // Context guard: fate context must match
      const currentHash = getFateContextHash();
      if (state.speculativeNextScene.fateContextHash !== currentHash) {
          console.log('[SPECULATIVE] Context mismatch');
          state.speculativeNextScene = null;
          return false;
      }

      return true;
  }

  /**
   * Preload next scene speculatively (background, no side effects)
   * CRITICAL: Uses EXACT same orchestration pipeline as real turns
   * Only difference: { speculative: true, skipSideEffects: true }
   */
  async function preloadNextScene() {
      // Guard: don't preload if already preloading or have valid speculation
      if (state.isPreloadingNextScene) return;
      if (isSpeculativeSceneValid()) return;

      // Get current inputs (use fate card defaults if inputs empty)
      const fateIdx = state.fateSelectedIndex ?? -1;
      const selectedFateCard = (fateIdx >= 0 && state.fateOptions?.[fateIdx]) ? state.fateOptions[fateIdx] : null;

      let rawAct = $('actionInput')?.value?.trim() || '';
      let rawDia = $('dialogueInput')?.value?.trim() || '';

      // Use fate card defaults if no input yet
      if (!rawAct && selectedFateCard?.action) rawAct = selectedFateCard.action;
      if (!rawDia && selectedFateCard?.dialogue) rawDia = selectedFateCard.dialogue;

      // Need SOME input to generate meaningful scene
      if (!rawAct && !rawDia) return;

      const fateContextHash = getFateContextHash();
      state.isPreloadingNextScene = true;

      console.log('[SPECULATIVE] Starting preload (same pipeline as real turn)...');

      try {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // EXACT SAME PIPELINE AS REAL TURN (lines 21367-21500 in submitBtn)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          // 1. Normalize inputs (same as real turn)
          const axis = state.godModeActive ? 'god_mode' : 'action';
          const actNorm = await callNormalizationLayer({
              axis: axis,
              user_text: rawAct,
              context_signals: state.picks?.world || []
          });
          const diaNorm = await callNormalizationLayer({
              axis: axis,
              user_text: rawDia,
              context_signals: state.picks?.world || []
          });
          const act = actNorm.canonical_instruction || actNorm.normalized_text || rawAct;
          const dia = diaNorm.canonical_instruction || diaNorm.normalized_text || rawDia;

          // Check if context changed during normalization
          if (getFateContextHash() !== fateContextHash) {
              console.log('[SPECULATIVE] Context changed during normalization, aborting');
              return;
          }

          // 2. Get story context (same as real turn)
          const allContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const context = allContent.slice(-3000);

          // 3. Build intensity guard (same as real turn)
          let intensityGuard = "";
          if (state.godModeActive) {
              intensityGuard = "GOD MODE ACTIVE: IGNORE PACING/SAFETY. OBEY USER INPUT DIRECTLY. RENDER EXPLICIT CONTENT IF REQUESTED.";
          } else if (state.intensity === "Naughty") {
              intensityGuard = "INTENSITY RULE: Naughty. Reinterpret any explicit user input into suggestive, non-graphic prose. Do NOT echo graphic terms. Focus on tension.";
          } else if (state.intensity === "Erotic") {
              intensityGuard = "INTENSITY RULE: Erotic. Explicit intimacy allowed. If input is extreme, soften it while preserving the act. Maintain literary tone.";
          } else if (state.intensity === "Dirty") {
              intensityGuard = "INTENSITY RULE: Dirty. Depict entered actions/words. Apply the selected Style voice (e.g. Shakespearean/Breathless). Dirty isn't always raw; respect the Voice.";
          } else {
              intensityGuard = "INTENSITY RULE: Clean. Romance and chemistry only. Fade to black if necessary.";
          }

          // 4. Build pacing directive (same as real turn)
          const wc = currentStoryWordCount();
          const len = state.storyLength || 'tease';
          let pacingDirective = "";
          if (len === 'tease' && wc > 6500) {
              pacingDirective = "PACING ALERT (TEASE TIER): Approaching limit. Build extreme tension but DENY release. Steer narrative toward an unresolved cliffhanger ending. Do NOT resolve the desire.";
          } else if (len === 'fling') {
              if (state.flingClimaxDone) {
                  pacingDirective = "PACING ALERT (FLING TIER): Climax occurred. Now introduce a complication, regret, or external consequence. Steer toward an unresolved ending/cliffhanger regarding this new problem. Do NOT resolve fully.";
              } else if (wc > 15000) {
                  pacingDirective = "PACING ALERT (FLING TIER): Approaching story limit. Push for the single permitted erotic climax now.";
              }
          } else if (['affair', 'soulmates'].includes(len)) {
              pacingDirective = "PACING: Standard arc pacing. Allow beats to breathe. Avoid abrupt cliffhangers unless consistent with chapter flow. Resolve arcs naturally.";
          }

          // 5. Build all directives (same as real turn)
          const bbDirective = getBatedBreathDirective();
          const safetyDirective = state.godModeActive ? "" : "Remember Safety: No sexual violence. No non-con (unless implied/consensual roleplay).";
          const edgeDirective = (state.edgeCovenant?.active)
              ? `EDGE COVENANT ACTIVE (Level ${state.edgeCovenant.level}): You are authorized to be more dominant, push boundaries, and create higher tension/stakes. Use more imperative language.`
              : "";
          const metaMsg = buildMetaDirective();
          const metaReminder = (state.awareness > 0) ? `(The characters feel the hand of Fate/Author. Awareness Level: ${state.awareness}/3. Stance: ${state.stance})` : "";

          // Squash directive
          const fateCardUsed = selectedFateCard && selectedFateCard.title;
          const squashDirective = `CRITICAL REINTERPRETATION RULE:
- NEVER repeat the player's action or dialogue verbatim in your response.
- ALWAYS reinterpret their intent into the story's voice, tone, and character.
- Transform their words into the narrative style of this story.
- If they write "I kiss him", describe a kiss in your literary voice.
- If they write clunky dialogue, render it as the character would actually speak.
- The player provides intent. You provide craft.${fateCardUsed ? `

FATE CARD ADAPTATION (CRITICAL):
- The player used a Fate Card "${selectedFateCard.title}" - their input reflects that card's suggestion.
- You MUST transform the Fate Card text completely into your own prose.
- DO NOT echo phrases like "${(act || '').slice(0, 30)}..." verbatim.
- The Fate Card is a prompt, not a script. Capture the ESSENCE, never the exact words.
- Write as if YOU conceived this beat, not as if you're following a template.` : ''}`;

          // Veto rules
          const vetoExclusions = state.veto?.excluded?.length ? `VETO EXCLUSIONS (treat as nonexistent): ${state.veto.excluded.join('; ')}.` : '';
          const vetoCorrections = state.veto?.corrections?.length ? `VETO CORRECTIONS (apply going forward): ${state.veto.corrections.join('; ')}.` : '';
          const vetoAmbient = state.veto?.ambientMods?.length ? `VETO AMBIENT (apply if world allows): ${state.veto.ambientMods.join('; ')}.` : '';
          const vetoRules = [vetoExclusions, vetoCorrections, vetoAmbient].filter(Boolean).join('\n');

          // Lens enforcement
          const lensEnforcement = buildLensDirectives(state.withheldCoreVariant, state.turnCount, state.storyLength);

          // POV contract
          const turnPOVContract = build5thPersonContract();

          // Erotic escalation
          const turnEroticEscalation = buildEroticEscalationBlock();

          // Tone enforcement
          const turnToneEnforcement = buildToneEnforcementBlock(state.picks?.tone);

          // 6. Build scene length directive (CANONICAL â€” storybound/scene-length-erotic-gates-canonical-v2)
          // Scene 1: 500-600 words | Non-sex 2+: 300-500 | Sex: 150-200 MAX
          const specSceneIndex = state.turnCount || 0;
          const specIntensity = state.intensity || 'Naughty';
          const specIsErotic = ['Erotic', 'Dirty'].includes(specIntensity);
          const specBothMilestonesCleared = state.intimacyInterrupted?.first_kiss && state.intimacyInterrupted?.first_sex;
          let sceneLengthDirective;
          if (specSceneIndex === 0) {
              sceneLengthDirective = 'Write the opening scene (500-600 words). LONGEST scene. Establish world, tone, power dynamics. NO main pair physical contact.';
          } else if (specIsErotic && specBothMilestonesCleared) {
              sceneLengthDirective = 'Write the next beat (150-200 words MAX). Erotic scene â€” keep SHORT for responsiveness.';
          } else {
              sceneLengthDirective = 'Write the next beat (300-500 words). Take time for atmosphere, reaction, emotional beats.';
          }

          // Build erotic gating directive (inline for speculative path)
          let specEroticGating = '';
          if (specIsErotic && !specBothMilestonesCleared) {
              const baseGates = { tease: 4, fling: 6, affair: 10 };
              let gateScene = baseGates[state.storyLength || 'tease'] || 4;
              if (specIntensity === 'Dirty') gateScene = Math.max(2, gateScene - 2);
              else if (specIntensity === 'Erotic') gateScene = Math.max(3, gateScene - 1);
              if (specSceneIndex < gateScene) {
                  specEroticGating = `\nEROTIC GATING: Main characters must NOT have physical contact yet. Ambient erotic content (others, memories, atmosphere) IS allowed.\n`;
              }
          }

          // 7. Build fullSys (EXACT same structure as real turn)
          const fullSys = state.sysPrompt + `\n\n${turnPOVContract}${turnEroticEscalation}${turnToneEnforcement}${intensityGuard}${specEroticGating}\n${squashDirective}\n${metaReminder}\n${vetoRules}\n${bbDirective}\n${safetyDirective}\n${edgeDirective}\n${pacingDirective}\n${lensEnforcement}\n\nTURN INSTRUCTIONS:
      Story So Far: ...${context}
      Player Action: ${act}.
      Player Dialogue: ${dia}.
      ${metaMsg}

      ${sceneLengthDirective}`;

          // Check context again before generation
          if (getFateContextHash() !== fateContextHash) {
              console.log('[SPECULATIVE] Context changed before generation, aborting');
              return;
          }

          // 7. Generate using EXACT same orchestration as real turn
          const useFullOrchestration = ENABLE_ORCHESTRATION &&
                                       window.StoryboundOrchestration &&
                                       ['Erotic', 'Dirty'].includes(state.intensity);

          let raw;
          if (useFullOrchestration) {
              raw = await generateOrchestatedTurn({
                  systemPrompt: fullSys,
                  storyContext: context,
                  playerAction: act,
                  playerDialogue: dia,
                  fateCard: selectedFateCard,
                  speculative: true,
                  skipSideEffects: true,
                  onPhaseChange: () => {} // No UI updates for speculative
              });
          } else {
              raw = await callChat([
                  { role: 'system', content: fullSys },
                  { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
              ]);
          }

          // Final context check before storing
          if (getFateContextHash() !== fateContextHash) {
              console.log('[SPECULATIVE] Context changed during generation, discarding');
              return;
          }

          // Store speculative result
          state.speculativeNextScene = {
              text: raw,
              fateContextHash: fateContextHash,
              tone: state.picks?.tone,
              world: state.picks?.world,
              selectedFateCard: selectedFateCard,
              normalizedAction: act,
              normalizedDialogue: dia,
              createdAt: Date.now()
          };

          console.log('[SPECULATIVE] Preload complete (byte-equivalent to real turn)');

      } catch (err) {
          console.warn('[SPECULATIVE] Preload failed (non-critical):', err.message);
      } finally {
          state.isPreloadingNextScene = false;
      }
  }

  /**
   * Try to commit speculative scene on user Continue click
   * Returns the speculative text if valid, null otherwise
   */
  function tryCommitSpeculativeScene() {
      if (!isSpeculativeSceneValid()) {
          return null;
      }

      const spec = state.speculativeNextScene;

      // Clear speculation BEFORE returning (commit is one-shot)
      state.speculativeNextScene = null;

      console.log('[SPECULATIVE] Committing preloaded scene â€” instant transition');
      return spec;
  }

  /**
   * Trigger preload after scene renders (debounced)
   */
  let _preloadDebounceTimer = null;
  function scheduleSpeculativePreload() {
      // Clear existing timer
      if (_preloadDebounceTimer) {
          clearTimeout(_preloadDebounceTimer);
      }

      // Wait 2 seconds after scene renders before preloading
      // This gives user time to start reading and select fate card
      _preloadDebounceTimer = setTimeout(() => {
          preloadNextScene();
      }, 2000);
  }

  // Expose for external invalidation hooks
  window.invalidateSpeculativeScene = invalidateSpeculativeScene;
  window.scheduleSpeculativePreload = scheduleSpeculativePreload;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPECULATIVE INVALIDATION: Input change listeners
  // Any change to action/dialogue invalidates speculation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  document.addEventListener('DOMContentLoaded', () => {
      const actionInput = $('actionInput');
      const dialogueInput = $('dialogueInput');

      if (actionInput) {
          actionInput.addEventListener('input', invalidateSpeculativeScene);
      }
      if (dialogueInput) {
          dialogueInput.addEventListener('input', invalidateSpeculativeScene);
      }
  });

  function formatStory(text, shouldEscape = false){
      const process = shouldEscape ? escapeHTML : (s => s);
      const mode = window.state?.mode || 'solo';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DIALOGUE COLORIZATION â€” STRICT MODE GATE (AUTHORITATIVE)
      // Colorization is DISABLED by default, enabled ONLY in Couple mode
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const isCoupleMode = (mode === 'couple');

      return text.split('\n').map(p => {
          if(!p.trim()) return '';
          let safe = process(p);

          if (isCoupleMode) {
              // COUPLE MODE: Speaker-aware colorization ONLY
              // Colorize dialogue ONLY when speaker identity is known (via <p1>/<p2> tags)
              // Untagged quotes remain as plain body text â€” no fallback colors
              safe = safe.replace(/<p1>([\s\S]*?)<\/p1>/g, (match, content) => {
                  return `<span class="p1-dia">${content}</span>`;
              });
              safe = safe.replace(/<p2>([\s\S]*?)<\/p2>/g, (match, content) => {
                  return `<span class="p2-dia">${content}</span>`;
              });
              // NPC dialogue and untagged quotes remain unstyled (no guessing)
              return `<p>${safe}</p>`;
          } else {
              // SOLO MODE: Dialogue rendered as PLAIN TEXT (AUTHORITATIVE)
              // - Same color as body text
              // - No spans, no classes, no emphasis
              // - Quotation marks are the only indicator
              safe = safe.replace(/<\/?p[12]>/g, ''); // Strip any player tags (safety)
              return `<p>${safe}</p>`;
          }
      }).join('');
  }

  // --- COUPLE MODE LOGIC ---
  window.coupleCleanup = function(){ if(sb) sb.removeAllChannels(); };

  function broadcastTurn(text, isInit = false) {
      if (!sb || window.state.mode !== 'couple' || !window.state.roomId) return;
      // Stub implementation; real Supabase broadcast can be added later
      console.log("broadcastTurn stub:", { isInit, textLength: text?.length });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MODE CARD FLIP SYSTEM â€” Solo/Couple/Stranger selection with flip animation
  // First click: flip card to reveal face, start sparkles
  // Second click (on face): select mode and proceed
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let selectedModeCard = null;
  let modeCardSparkleInterval = null;

  function initModeCards() {
    const modeCards = document.querySelectorAll('.mode-card');
    if (!modeCards.length) return;

    modeCards.forEach(card => {
      card.addEventListener('click', handleModeCardClick);
    });
    console.log('[ModeCards] Initialized', modeCards.length, 'mode cards');
  }

  function handleModeCardClick(e) {
    const card = e.currentTarget;
    const mode = card.dataset.mode;
    const isFlipped = card.classList.contains('flipped');

    if (!isFlipped) {
      // First click: flip to show face, start sparkles
      flipModeCard(card);
    } else if (card === selectedModeCard) {
      // Second click on selected card: proceed with mode selection
      proceedWithMode(mode);
    } else {
      // Click on different flipped card: select this one instead
      flipModeCard(card);
    }
  }

  function flipModeCard(card) {
    const allCards = document.querySelectorAll('.mode-card');
    const mode = card.dataset.mode;

    // Unflip and deselect all other cards (no dimming)
    allCards.forEach(c => {
      if (c !== card) {
        c.classList.remove('flipped', 'selected');
        // Stop sparkles on other cards
        const sparkleContainer = c.querySelector('.mode-card-sparkles');
        if (sparkleContainer) sparkleContainer.innerHTML = '';
      }
    });

    // Flip and select this card
    card.classList.add('flipped', 'selected');
    selectedModeCard = card;

    // Start sparkles on this card
    startModeCardSparkles(card);

    console.log('[ModeCards] Flipped card:', mode);
  }

  function startModeCardSparkles(card) {
    const sparkleContainer = card.querySelector('.mode-card-sparkles');
    if (!sparkleContainer) return;

    // Clear any existing sparkles
    sparkleContainer.innerHTML = '';

    // Stop any existing interval
    if (modeCardSparkleInterval) {
      clearInterval(modeCardSparkleInterval);
    }

    // Create sparkle particles continuously
    modeCardSparkleInterval = setInterval(() => {
      if (!card.classList.contains('flipped')) {
        clearInterval(modeCardSparkleInterval);
        modeCardSparkleInterval = null;
        return;
      }
      createModeSparkle(sparkleContainer);
    }, 150);

    // Initial burst of sparkles
    for (let i = 0; i < 8; i++) {
      setTimeout(() => createModeSparkle(sparkleContainer), i * 50);
    }
  }

  function createModeSparkle(container) {
    const sparkle = document.createElement('div');
    sparkle.className = 'mode-sparkle';

    // Random position around the edge
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
      case 0: x = Math.random() * 100; y = 0; break;        // top
      case 1: x = 100; y = Math.random() * 100; break;      // right
      case 2: x = Math.random() * 100; y = 100; break;      // bottom
      case 3: x = 0; y = Math.random() * 100; break;        // left
    }

    sparkle.style.cssText = `
      position: absolute;
      left: ${x}%;
      top: ${y}%;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, rgba(255,215,0,1) 0%, rgba(255,215,0,0) 70%);
      border-radius: 50%;
      pointer-events: none;
      animation: modeSparkle 1.2s ease-out forwards;
    `;

    container.appendChild(sparkle);

    // Remove after animation
    setTimeout(() => sparkle.remove(), 1200);
  }

  function proceedWithMode(mode) {
    console.log('[ModeCards] Proceeding with mode:', mode);

    // Stop sparkle interval
    if (modeCardSparkleInterval) {
      clearInterval(modeCardSparkleInterval);
      modeCardSparkleInterval = null;
    }

    // Call the actual setMode function
    actualSetMode(mode);
  }

  function resetModeCards() {
    const allCards = document.querySelectorAll('.mode-card');
    allCards.forEach(c => {
      c.classList.remove('flipped', 'selected', 'dimmed');
      const sparkleContainer = c.querySelector('.mode-card-sparkles');
      if (sparkleContainer) sparkleContainer.innerHTML = '';
    });
    selectedModeCard = null;
    if (modeCardSparkleInterval) {
      clearInterval(modeCardSparkleInterval);
      modeCardSparkleInterval = null;
    }
  }

  // Expose resetModeCards for showScreen to call when returning to modeSelect
  window.resetModeCards = resetModeCards;

  // Initialize mode cards on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initModeCards);
  } else {
    initModeCards();
  }

  // Actual mode selection logic (renamed from window.setMode)
  function actualSetMode(m) {
     if(m === 'couple') {
         if(!sb){ alert("Couple mode unavailable (No backend)."); return; }
         if(state.storyOrigin === 'solo' && state.storyStage === 'post-consummation') {
             alert("The die is cast. You have crossed a threshold alone; a partner cannot join now.");
             return;
         }
     }
     state.mode = m;
     if (!state.storyOrigin) state.storyOrigin = m;
     // Reset DSP state on mode change
     if (typeof resetDSPState === 'function') resetDSPState();
     if(m === 'solo') window.showScreen('setup');
     if(m === 'couple') window.showScreen('coupleInvite');
     if(m === 'stranger') window.showScreen('strangerModal');

     // Mode breadcrumb removed â€” Solo/Couple is not a corridor choice step
  }

  // Public wrapper - allows direct mode selection (bypasses flip animation)
  window.setMode = function(m) {
    // Reset mode cards when called directly
    resetModeCards();
    actualSetMode(m);
  };

  // --- EDGE COVENANT ---
  window.openEdgeCovenantModal = function(){
      document.getElementById('edgeCovenantModal').classList.remove('hidden');
      const invite = document.getElementById('btnInviteEdge');
      const couple = document.getElementById('coupleEdgeControls');
      if(invite) invite.classList.toggle('hidden', state.mode === 'couple');
      if(couple) couple.classList.toggle('hidden', state.mode !== 'couple');
  };

  window.inviteEdgeOffer = function(){
      state.pendingEdgeOffer = true;
      showToast("Offer invited. Wait for Fate.");
      document.getElementById('edgeCovenantModal').classList.add('hidden');
  };
  
  window.sendEdgeOffer = function(){
      showToast("Offer sent to partner.");
      document.getElementById('edgeCovenantModal').classList.add('hidden');
  };
  
  window.acceptEdgeCovenant = function(){
      state.edgeCovenant.active = true;
      state.edgeCovenant.acceptedAtTurn = state.turnCount;
      document.getElementById('edgeCovenantModal').classList.add('hidden');
      showToast("Covenant Accepted.");
  };

  window.closeEdgeModal = function(){
      document.getElementById('edgeCovenantModal').classList.add('hidden');
      document.getElementById('edgeActions').classList.remove('hidden');
      document.getElementById('edgeAcceptance').classList.add('hidden');
  };

  // --- COUPLE MODE BUTTON HANDLERS ---
  $('btnCreateRoom')?.addEventListener('click', async () => {
      if (!sb) { alert("Couple mode unavailable."); return; }
      const uid = await ensureAnonSession();
      if (!uid) { alert("Auth failed."); return; }
      window.state.myUid = uid;
      window.state.myNick = getNickname();
      const code = Math.random().toString(36).substring(2, 8).toUpperCase();
      window.state.roomCode = code;
      window.state.roomId = 'room_' + code;

      const lbl = document.getElementById('coupleRoomCodeLabel');
      const big = document.getElementById('roomCodeBig');
      const wrap = document.getElementById('roomCodeWrap');
      if (lbl) lbl.textContent = code;
      if (big) big.textContent = code;
      if (wrap) wrap.classList.remove('hidden');

      document.getElementById('coupleStatus').textContent = 'Waiting for partner...';
      document.getElementById('sbNickLabel').textContent = window.state.myNick;
  });

  $('btnJoinRoom')?.addEventListener('click', () => {
      document.getElementById('joinRow')?.classList.toggle('hidden');
  });

  $('btnJoinGo')?.addEventListener('click', async () => {
      if (!sb) { alert("Couple mode unavailable."); return; }
      const code = document.getElementById('joinCodeInput')?.value.trim().toUpperCase();
      if (!code || code.length !== 6) { alert("Enter a 6-character code."); return; }

      const uid = await ensureAnonSession();
      if (!uid) { alert("Auth failed."); return; }
      window.state.myUid = uid;
      window.state.myNick = getNickname();
      window.state.roomCode = code;
      window.state.roomId = 'room_' + code;

      document.getElementById('coupleStatus').textContent = 'Joined room ' + code;
      document.getElementById('sbNickLabel').textContent = window.state.myNick;
      document.getElementById('btnEnterCoupleGame')?.classList.remove('hidden');
  });

  $('btnCopyCode')?.addEventListener('click', () => {
      if (window.state.roomCode) {
          navigator.clipboard.writeText(window.state.roomCode);
          showToast("Code copied!");
      }
  });

  // Invitation send handlers
  const INVITATION_TEXTS = [
      "A private chamber awaits. The mask is optional. The curiosity is not.",
      "Behind this door, two become one story. Enter if you dare.",
      "The candles are lit. The words are waiting. Only you are missing.",
      "Some invitations cannot be declined. This is one of them."
  ];

  function getInvitationMessage() {
      const text = INVITATION_TEXTS[Math.floor(Math.random() * INVITATION_TEXTS.length)];
      const code = window.state.roomCode || '------';
      return `${text}\n\nYour chamber code: ${code}\n\nJoin at: ${window.location.origin}`;
  }

  function markInvitationSent() {
      const status = document.getElementById('inviteSentStatus');
      const enterBtn = document.getElementById('btnEnterCoupleGame');
      const soloBtn = document.getElementById('btnPlaySoloWaiting');

      if (status) status.classList.remove('hidden');
      if (enterBtn) {
          enterBtn.classList.remove('hidden');
          enterBtn.disabled = false;
      }
      if (soloBtn) soloBtn.classList.remove('hidden');

      window.state.invitationSent = true;
  }

  $('btnSendEmail')?.addEventListener('click', () => {
      const subject = encodeURIComponent("You're invited to a Private Chamber");
      const body = encodeURIComponent(getInvitationMessage());
      // Use location.href for proper mailto handling with default email client
      window.location.href = `mailto:?subject=${subject}&body=${body}`;
      markInvitationSent();
      showToast("Email client opened.");
  });

  $('btnSendSMS')?.addEventListener('click', () => {
      const body = encodeURIComponent(getInvitationMessage());
      window.location.href = `sms:?body=${body}`;
      markInvitationSent();
      showToast("SMS opened.");
  });

  $('btnSendBoth')?.addEventListener('click', () => {
      const subject = encodeURIComponent("You're invited to a Private Chamber");
      const body = encodeURIComponent(getInvitationMessage());
      // Open email first via location.href
      window.location.href = `mailto:?subject=${subject}&body=${body}`;
      markInvitationSent();
      showToast("Email client opened. Use SMS button for text.");
  });

  $('btnPlaySoloWaiting')?.addEventListener('click', () => {
      window.state.batedBreathActive = true;
      window.showScreen('setup');
  });

  $('btnEnterCoupleGame')?.addEventListener('click', () => {
      if (!window.state.invitationSent) {
          showToast("Please send an invitation first.");
          return;
      }
      window.showScreen('setup');
  });

  // --- INIT ---
  initSelectionHandlers();
  initNavBindings();
  wireIntensityHandlers();

  // AUTH GATE: Check login status and handle persistence accordingly
  state.isLoggedIn = localStorage.getItem('sb_logged_in') === '1';

  if (!state.isLoggedIn) {
      // STATELESS MODE: Clear all persisted state when not logged in
      // This ensures testing reloads do not retain stories, purchases, or progress
      clearAnonymousState();
      state.storyId = null;
      state.subscribed = false;
      state.billingStatus = 'active';
  } else {
      // LOGGED IN: Restore persisted state normally
      state.storyId = localStorage.getItem('sb_current_story_id');
      state.subscribed = localStorage.getItem('sb_subscribed') === '1';
      state.billingStatus = localStorage.getItem('sb_billing_status') || 'active';
  }

  syncTierFromAccess();
  updateContinueButtons();
  renderBurgerMenu();

  // ============================================================
  // DEV HUD â€” Casual English command console (developer only)
  // Never saves to localStorage, never unlocks real features,
  // never affects other users, never ships to production.
  // ============================================================

  (function initDevHud() {
      const isDev = location.hostname === 'localhost' ||
                    location.hostname === '127.0.0.1' ||
                    new URLSearchParams(location.search).has('dev');
      if (!isDev) return;

      const hudEl = document.getElementById('devHud');
      const inputEl = document.getElementById('devHudInput');
      const logEl = document.getElementById('devHudLog');
      if (!hudEl || !inputEl) return;

      let _devOverrides = {};
      let _logTimer = null;

      function log(msg) {
          if (!logEl) return;
          logEl.textContent = msg;
          logEl.style.opacity = '1';
          clearTimeout(_logTimer);
          _logTimer = setTimeout(() => { logEl.style.opacity = '0'; }, 5000);
          console.log('[DevHUD]', msg);
      }

      function toggle() {
          hudEl.classList.toggle('dev-hud-visible');
          if (hudEl.classList.contains('dev-hud-visible')) {
              inputEl.focus();
          }
      }

      // Toggle with backtick key (only when not typing elsewhere)
      document.addEventListener('keydown', (e) => {
          if (e.key === '`' && !e.ctrlKey && !e.metaKey) {
              const tag = (document.activeElement?.tagName || '').toLowerCase();
              const isEditable = tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;
              if (isEditable && document.activeElement !== inputEl) return;
              e.preventDefault();
              toggle();
          }
      });

      inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              const raw = inputEl.value.trim();
              if (raw) execute(raw.toLowerCase());
              inputEl.value = '';
          }
          if (e.key === 'Escape') toggle();
      });
      // Prevent backtick from typing into the input
      inputEl.addEventListener('keypress', (e) => {
          if (e.key === '`') e.preventDefault();
      });

      // --- Extraction maps ---
      const WORLD_MAP = {
          fantasy: 'Fantasy', historical: 'Historical', modern: 'Modern',
          'sci-fi': 'SciFi', scifi: 'SciFi', dystopia: 'Dystopia',
          'post-apocalyptic': 'PostApocalyptic', postapocalyptic: 'PostApocalyptic',
          supernatural: 'Supernatural', superheroic: 'Superheroic'
      };
      const GENRE_MAP = {
          billionaire: 'Billionaire', crime: 'CrimeSyndicate', noir: 'Noir',
          heist: 'Heist', espionage: 'Espionage', political: 'Political',
          survival: 'Survival', obsession: 'Obsession', forbidden: 'ForbiddenKnowledge',
          'forbidden knowledge': 'ForbiddenKnowledge'
      };
      const INTENSITY_MAP = {
          tease: 'Naughty', naughty: 'Naughty', erotic: 'Erotic', dirty: 'Dirty'
      };
      const ARCHETYPE_MAP = {
          'heart warden': 'HEART_WARDEN', 'open vein': 'OPEN_VEIN',
          'spellbinder': 'SPELLBINDER', 'armored fox': 'ARMORED_FOX',
          'dark vice': 'DARK_VICE', 'beautiful ruin': 'BEAUTIFUL_RUIN',
          'eternal flame': 'ETERNAL_FLAME'
      };

      // ========================================
      // DETERMINISTIC COMMAND REGISTRY (v1)
      // NO fuzzy matching. NO synonyms. NO NLP.
      // ========================================
      const DEV_CMD_REGISTRY = {
          world: ['Modern', 'Historical', 'Fantasy', 'SciFi', 'Dystopia', 'PostApocalyptic'],
          genre: ['CrimeSyndicate', 'Billionaire', 'Noir', 'Heist', 'Espionage', 'Political',
                  'Escape', 'Redemption', 'BuildingBridges', 'Purgatory', 'RelentlessPast',
                  'Sports', 'Survival', 'Obsession', 'ForbiddenKnowledge'],
          tone: ['Earnest', 'WryConfession', 'Satirical', 'Dark', 'Horror', 'Mythic',
                 'Comedic', 'Surreal', 'Poetic'],
          dynamic: ['Proximity', 'SecretIdentity', 'Caretaker', 'Friends', 'Enemies',
                    'SecondChance', 'Forbidden', 'Dangerous', 'Obsessive', 'Fated', 'Partners'],
          arousal: ['Clean', 'Naughty', 'Erotic', 'Dirty']
      };

      // Case-insensitive lookup for canonical value
      function resolveCanonical(axis, input) {
          const list = DEV_CMD_REGISTRY[axis];
          if (!list) return null;
          const lower = input.toLowerCase();
          return list.find(v => v.toLowerCase() === lower) || null;
      }

      // Deterministic command parser (space-split, no regex magic)
      function parseDevCommand(raw) {
          const parts = raw.trim().split(/\s+/);
          if (parts.length === 0) return null;

          // ALIAS: "regen book cover" â†’ "regen cover"
          if (parts[0] === 'regen' && parts[1] === 'book' && parts[2] === 'cover') {
              return { cmd: 'regen', target: 'cover' };
          }
          // COMMAND: "regen cover"
          if (parts[0] === 'regen' && parts[1] === 'cover') {
              return { cmd: 'regen', target: 'cover' };
          }
          // COMMAND: "set <axis> <value>"
          if (parts[0] === 'set' && parts.length >= 3) {
              const axis = parts[1];
              const value = parts.slice(2).join(' ');
              return { cmd: 'set', axis, value };
          }
          // Not a registry command
          return null;
      }

      // Execute deterministic command (returns true if handled)
      function executeRegistryCommand(input) {
          const parsed = parseDevCommand(input);
          if (!parsed) return false;

          // REGEN COVER (gated by coverEligibility)
          if (parsed.cmd === 'regen' && parsed.target === 'cover') {
              const world = state.picks?.world || 'Modern';
              const genre = state.picks?.genre || 'Billionaire';
              const intensity = state.intensity || 'Naughty';
              const rawTitle = document.getElementById('storyTitle')?.textContent?.trim() || '';
              const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';

              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // MINIMAL COVER v1 GUARD â€” Skip PHASE_1_FORGED fallback entirely
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              if (USE_MINIMAL_COVER_V1) {
                  console.log('[COVER:v1] Skipping PHASE_1_FORGED fallback â€” Minimal Cover owns cover');
                  return true;
              }

              // PHASE 1 GATE: Custom covers only when coverEligibility === true
              if (state.coverMode === 'PHASE_1_FORGED' || state.coverEligibility !== true) {
                  console.log('[DEV:CoverGen] PHASE_1_FORGED mode â€” using local fallback');
                  resetCoverLayers();
                  showDevCover();
                  renderFallbackCover(world, genre, title);
                  stopCoverLoading(null);
                  applyCoverIntensityLayers(intensity, world);
                  log('[DEV:CoverGen] PHASE_1 fallback applied');
                  return true;
              }

              // CUSTOM COVER PATH (only when coverEligibility === true)
              console.log('[DEV:CoverGen] Regenerating cover...');
              resetCoverLayers();
              showDevCover();
              const synopsis = document.getElementById('synopsisText')?.textContent || '';
              const authorName = state.authorName || 'Anonymous';
              generateBookCover(synopsis, title, authorName).then(coverUrl => {
                  if (coverUrl) {
                      stopCoverLoading(coverUrl);
                      applyCoverIntensityLayers(intensity, world);
                      log('[DEV:CoverGen] Cover generated');
                  } else {
                      renderFallbackCover(world, genre);
                      stopCoverLoading(null);
                      applyCoverIntensityLayers(intensity, world);
                      log('[DEV:CoverGen] AI failed â†’ fallback');
                  }
              }).catch(err => {
                  console.error('[DEV:CoverGen] Error:', err);
                  renderFallbackCover(world, genre);
                  stopCoverLoading(null);
                  applyCoverIntensityLayers(intensity, world);
                  log('[DEV:CoverGen] Error â†’ fallback');
              });
              log('[DEV:CoverGen] Started...');
              return true;
          }

          // SET <axis> <value>
          if (parsed.cmd === 'set') {
              const { axis, value } = parsed;
              // Validate axis
              if (!DEV_CMD_REGISTRY[axis]) {
                  console.error('[DEV:StateChange] HARD FAIL: Unknown axis "' + axis + '"');
                  log('ERROR: Unknown axis "' + axis + '". Valid: world, genre, tone, dynamic, arousal');
                  return true;
              }
              // Resolve canonical value
              const canonical = resolveCanonical(axis, value);
              if (!canonical) {
                  console.error('[DEV:StateChange] HARD FAIL: Invalid value "' + value + '" for axis "' + axis + '"');
                  log('ERROR: Invalid ' + axis + ' "' + value + '". Valid: ' + DEV_CMD_REGISTRY[axis].join(', '));
                  return true;
              }
              // Update state
              state.picks = state.picks || {};
              if (axis === 'arousal') {
                  state.intensity = canonical;
              } else {
                  state.picks[axis] = canonical;
              }
              console.log('[DEV:StateChange] ' + axis + ' â†’ ' + canonical);
              log('[DEV:StateChange] ' + axis + ' â†’ ' + canonical);
              // Trigger dependent recalculations
              if (axis === 'arousal') {
                  applyCoverIntensityLayers(canonical, state.picks?.world);
              }
              return true;
          }

          return false;
      }

      function extract(text, map) {
          for (const [key, val] of Object.entries(map)) {
              if (text.includes(key)) return val;
          }
          return null;
      }

      // Show the book cover page in dev context
      function showDevCover() {
          window.showScreen('game');
          const bcp = document.getElementById('bookCoverPage');
          const sc = document.getElementById('storyContent');
          const bo = document.getElementById('bookObject');
          const ls = document.getElementById('coverLoadingState');
          if (bcp) bcp.classList.remove('hidden');
          if (sc) sc.classList.add('hidden');
          if (bo) bo.classList.remove('hidden');
          if (ls) ls.classList.add('hidden');
      }

      function execute(input) {
          // --- DETERMINISTIC REGISTRY COMMANDS (priority) ---
          if (executeRegistryCommand(input)) return;

          // --- HELP ---
          if (/^(help|what can i say)\b/.test(input)) {
              log('=== DETERMINISTIC COMMANDS ===');
              log('regen cover');
              log('set world <Modern|Historical|Fantasy|SciFi|Dystopia|PostApocalyptic>');
              log('set genre <' + DEV_CMD_REGISTRY.genre.slice(0, 5).join('|') + '|...>');
              log('set tone <Earnest|WryConfession|Satirical|Dark|Horror|Mythic|Comedic|Surreal|Poetic>');
              log('set dynamic <Proximity|SecretIdentity|Caretaker|Friends|Enemies|...>');
              log('set arousal <Clean|Naughty|Erotic|Dirty>');
              log('=== LEGACY COMMANDS ===');
              log('COVER: make [world] [intensity] cover | pretend cover failed | show fallback | show/hide keyhole | reset cover');
              log('STATE: set intensity to X | go dirty/erotic | pretend i paid | pretend i\'m free | what\'s going on');
              log('QUERY: what genre/world/tone/intensity/archetype/title? | title pipeline | test title [text]');
              log('POV: check pov | why pov failed | is god mode active | set pov author/normal | exit god mode');
              log('VALIDATION: check dsp | check tone | check erotic | check authority | check title | check signal | check paywall | check book | check all');
              log('FATE: reset fate cards | deal fate');
              log('FORK: show fork (test continuation modal)');
              return;
          }

          // --- MAKE / GENERATE COVER ---
          if (/\b(make|generate)\b.*\bcover\b/.test(input)) {
              const world = extract(input, WORLD_MAP) || state.picks?.world || 'Modern';
              const genre = extract(input, GENRE_MAP) || state.picks?.genre || 'Billionaire';
              const intensity = extract(input, INTENSITY_MAP) || state.intensity || 'Naughty';
              state.picks = state.picks || {};
              state.picks.world = world;
              state.picks.genre = genre;
              state.intensity = intensity;
              resetCoverLayers();
              showDevCover();
              renderFallbackCover(world, genre);
              applyCoverIntensityLayers(intensity, world);
              log('Cover: ' + world + ' / ' + genre + ' / ' + intensity);
              return;
          }

          // --- PRETEND COVER FAILED ---
          if (/\b(pretend|simulate)\b.*\bcover\b.*\b(fail|broke|error)\b|\bcover\b.*\b(fail|broke)\b/.test(input)) {
              const world = state.picks?.world || 'Modern';
              const genre = state.picks?.genre || 'Billionaire';
              resetCoverLayers();
              showDevCover();
              renderFallbackCover(world, genre);
              applyCoverIntensityLayers(state.intensity, world);
              log('Simulated cover failure -> fallback rendered');
              return;
          }

          // --- SHOW / USE FALLBACK ---
          if (/\b(show|use|skip)\b.*(fallback|ai\s*cover)\b/.test(input)) {
              const world = state.picks?.world || 'Modern';
              const genre = state.picks?.genre || 'Billionaire';
              resetCoverLayers();
              showDevCover();
              renderFallbackCover(world, genre);
              applyCoverIntensityLayers(state.intensity, world);
              log('Fallback cover shown (' + world + ' / ' + genre + ')');
              return;
          }

          // --- SHOW FORK MODAL ---
          if (/\b(show|test)\b.*\bfork\b/.test(input)) {
              showContinuationFork();
              log('Continuation fork modal shown');
              return;
          }

          // --- SHOW KEYHOLE ---
          if (/\b(show|turn on)\b.*\bkeyhole\b/.test(input)) {
              showDevCover();
              // Ensure a base cover exists
              const fb = document.getElementById('coverFallback');
              const img = document.getElementById('bookCoverImg');
              const hasCover = (fb && !fb.classList.contains('hidden')) || (img && img.src && img.style.display !== 'none');
              if (!hasCover) {
                  renderFallbackCover(state.picks?.world || 'Modern', state.picks?.genre || 'Billionaire');
              }
              applyCoverIntensityLayers('Dirty', state.picks?.world);
              log('Keyhole takeover enabled');
              return;
          }
          if (/\bhide\b.*\bkeyhole\b/.test(input)) {
              const kh = document.getElementById('coverKeyholeOverlay');
              if (kh) kh.classList.add('hidden');
              log('Keyhole hidden');
              return;
          }

          // --- RESET COVER ---
          if (/\b(reset|clear|start)\b.*\bcover\b/.test(input)) {
              resetCoverLayers();
              resetBookState();
              log('Cover state reset');
              return;
          }

          // --- RESET / DEAL FATE CARDS ---
          // Aliases: "reset fate cards", "reset the fate cards", "restart fate", "redo fate", "re-deal fate cards", "deal fate"
          if (/\b(reset|restart|redo|re-?deal|deal)\b.*\bfate\b/i.test(input)) {
              if (window.dealFateCards) {
                  window.dealFateCards();
                  // PERMANENT FX REBIND: Ensure fate cards have handlers after god mode redeal
                  if (window.initFateCards) window.initFateCards();
                  log('Fate cards re-dealt');
              } else {
                  log('Fate card system not available');
              }
              return;
          }

          // --- SET INTENSITY ---
          if (/\bset\b.*\bintensity\b.*\bto\b/.test(input)) {
              const intensity = extract(input, INTENSITY_MAP);
              if (intensity) {
                  state.intensity = intensity;
                  applyCoverIntensityLayers(intensity, state.picks?.world);
                  log('Intensity -> ' + intensity);
              } else {
                  log('Unknown intensity. Try: tease, naughty, erotic, dirty');
              }
              return;
          }
          if (/^go\s+(dirty|erotic|naughty|tease)\b/.test(input)) {
              const m = input.match(/^go\s+(\w+)/);
              const intensity = INTENSITY_MAP[m[1]];
              if (intensity) {
                  state.intensity = intensity;
                  applyCoverIntensityLayers(intensity, state.picks?.world);
                  log('Intensity -> ' + intensity);
              }
              return;
          }

          // --- ACCESS SIMULATION ---
          if (/\bpretend\b.*\b(paid|story\s*pass|subscribed)\b/.test(input)) {
              _devOverrides.access = 'sub';
              state.subscribed = true;
              syncTierFromAccess();
              log('Pretending subscribed (does not persist, does not unlock real features)');
              return;
          }
          if (/\bpretend\b.*\bfree\b/.test(input)) {
              _devOverrides.access = 'free';
              state.subscribed = false;
              state.intensity = 'Naughty';
              syncTierFromAccess();
              log('Pretending free tier');
              return;
          }

          // --- ARCHETYPE / LENS ---
          if (/\b(use|switch)\b.*\b(lens|archetype)\b/.test(input) || /\bswitch to\b/.test(input)) {
              const archId = extract(input, ARCHETYPE_MAP);
              if (archId && ARCHETYPES[archId]) {
                  state.archetype = state.archetype || {};
                  state.archetype.primary = archId;
                  log('Archetype -> ' + ARCHETYPES[archId].name);
              } else {
                  log('Unknown archetype. Try: beautiful ruin, open vein, spellbinder, armored fox, dark vice, heart warden, eternal flame');
              }
              return;
          }

          // --- QUILL ---
          if (/\bset\b.*\bquill\b.*\b\d+/.test(input)) {
              const m = input.match(/(\d+)/);
              if (m) {
                  state.quillTarget = parseInt(m[1], 10);
                  log('Quill target -> ' + m[1] + ' words');
              }
              return;
          }
          if (/\bpretend\b.*\bwritten\b.*\b\d+/.test(input)) {
              const m = input.match(/(\d+)/);
              if (m) {
                  state.wordCount = parseInt(m[1], 10);
                  log('Word count -> ' + m[1]);
              }
              return;
          }

          // --- DEBUG: STATE DUMP ---
          if (/\bwhat.s\b.*\b(going|everything|firing)\b|\bshow me everything\b/.test(input)) {
              const info = [
                  'world:' + (state.picks?.world || '-'),
                  'genre:' + (state.picks?.genre || '-'),
                  'tone:' + (state.picks?.tone || '-'),
                  'dynamic:' + (state.picks?.dynamic || '-'),
                  'intensity:' + (state.intensity || '-'),
                  'arch:' + (state.archetype?.primary || '-'),
                  'access:' + (state.access || '-'),
                  'sub:' + (state.subscribed || false),
                  'turns:' + (state.turnCount || 0)
              ];
              log(info.join(' | '));
              console.log('[DevHUD] Full state:', JSON.parse(JSON.stringify(state)));
              return;
          }

          // --- DEBUG: COVER STATE ---
          if (/\bwhat cover\b|\bwhy.*cover\b/.test(input)) {
              const fb = document.getElementById('coverFallback');
              const img = document.getElementById('bookCoverImg');
              const border = document.getElementById('coverEroticBorder');
              const keyhole = document.getElementById('coverKeyholeOverlay');
              const hasFallback = fb && !fb.classList.contains('hidden');
              const hasImg = img && img.src && !img.src.endsWith('/') && img.style.display !== 'none';
              const hasBorder = border && !border.classList.contains('hidden');
              const hasKeyhole = keyhole && !keyhole.classList.contains('hidden');
              const layers = [];
              if (hasImg) layers.push('AI cover');
              if (hasFallback) layers.push('fallback');
              if (hasBorder) layers.push('erotic border (' + (border.className.match(/world-\w+/)?.[0] || 'default gold') + ')');
              if (hasKeyhole) layers.push('keyhole takeover');
              log(layers.length ? 'Active: ' + layers.join(' + ') : 'No cover layers visible');
              return;
          }

          // --- CASUAL ENGLISH QUERIES ---
          // "what genre is this", "what genre", "genre?"
          if (/\b(what|which)\b.*\bgenre\b|\bgenre\s*\?/.test(input)) {
              log('Genre: ' + (state.picks?.genre || '(not set)'));
              return;
          }
          // "what world is this", "what world", "world?"
          if (/\b(what|which)\b.*\bworld\b|\bworld\s*\?/.test(input)) {
              log('World: ' + (state.picks?.world || '(not set)') +
                  (state.picks?.world === 'Historical' ? ' (' + (state.picks?.era || 'no era') + ')' : ''));
              return;
          }
          // "what tone", "tone?"
          if (/\b(what|which)\b.*\btone\b|\btone\s*\?/.test(input)) {
              log('Tone: ' + (state.picks?.tone || '(not set)'));
              return;
          }
          // "what intensity", "intensity?"
          if (/\b(what|which)\b.*\bintensity\b|\bintensity\s*\?/.test(input)) {
              log('Intensity: ' + (state.intensity || '(not set)'));
              return;
          }
          // "what archetype", "archetype?", "what lens"
          if (/\b(what|which)\b.*\b(archetype|lens)\b|\b(archetype|lens)\s*\?/.test(input)) {
              const archId = state.archetype?.primary;
              log('Archetype: ' + (archId && ARCHETYPES[archId] ? ARCHETYPES[archId].name : '(not set)'));
              return;
          }
          // "what dynamic", "dynamic?"
          if (/\b(what|which)\b.*\bdynamic\b|\bdynamic\s*\?/.test(input)) {
              log('Dynamic: ' + (state.picks?.dynamic || '(not set)'));
              return;
          }
          // "why did cover fail", "what happened to cover", "cover status"
          if (/\bwhy\b.*\bcover\b|\bcover\b.*\b(status|state|happened|wrong|broken)\b/.test(input)) {
              // Delegate to existing cover debug
              execute('what cover');
              return;
          }
          // "what title", "title?"
          if (/\b(what|which)\b.*\btitle\b|\btitle\s*\?/.test(input)) {
              const t = document.getElementById('storyTitle')?.textContent;
              log('Title: ' + (t || '(none)'));
              return;
          }
          // "title pipeline", "title debug", "title status"
          if (/\btitle\s*(pipeline|debug|status|info)\b/i.test(input)) {
              const t = document.getElementById('storyTitle')?.textContent;
              if (!t) {
                  log('No title set');
                  return;
              }
              const mode = detectTitleMode(t);
              const baseline = state.titleBaselineArousal || '(none)';
              const immutable = state.immutableTitle || '(none)';
              const swapTest = runSwapTest(t, state.picks?.world, state.intensity);
              log('=== TITLE PIPELINE ===');
              log('Current: "' + t + '"');
              log('Mode: ' + (mode || 'unknown'));
              log('Baseline arousal: ' + baseline);
              log('Immutable title: "' + immutable + '"');
              log('Swap-test: ' + (swapTest.unique ? 'PASS' : 'FAIL â€” ' + swapTest.reason));
              // Check immutability
              if (immutable && t !== immutable) {
                  log('WARNING: Title differs from immutable record!');
              }
              return;
          }
          // "test title [text]", "validate title [text]"
          if (/\btest\s+title\s+(.+)/i.test(input)) {
              const match = input.match(/\btest\s+title\s+(.+)/i);
              if (match) {
                  const testTitle = match[1].trim();
                  const result = validateTitle(
                      testTitle,
                      state.picks?.tone,
                      state.intensity,
                      { world: state.picks?.world, genre: state.picks?.genre }
                  );
                  log('Testing: "' + testTitle + '"');
                  log('Mode: ' + (result.mode || 'unknown'));
                  if (result.valid) {
                      log('Result: PASS');
                  } else {
                      log('Result: FAIL');
                      result.errors.forEach(e => log('  ' + e.message));
                  }
              }
              return;
          }

          // --- 5TH PERSON POV DIAGNOSTICS ---
          // "check pov", "pov status"
          if (/\bcheck\s*pov\b|\bpov\s*(status|check)\b/i.test(input)) {
              const povMode = state.povMode || 'normal';
              const godMode = state.godModeActive ? 'ACTIVE' : 'inactive';
              const lastCheck = _lastPOVValidation;
              log('POV Mode: ' + povMode + ' | God Mode: ' + godMode);
              if (povMode === 'author5th') {
                  log('Last validation: ' + (lastCheck.valid ? 'PASS' : 'FAIL') +
                      ' | Author mentions: ' + (lastCheck.authorMentions || 0));
              }
              return;
          }
          // "why pov failed", "pov violations"
          if (/\bwhy\s*pov\b|\bpov\s*(fail|violation|error)\b/i.test(input)) {
              const lastCheck = _lastPOVValidation;
              if (lastCheck.valid) {
                  log('Last POV check passed (no violations)');
              } else if (lastCheck.violations?.length) {
                  log('POV violations: ' + lastCheck.violations.join('; '));
              } else {
                  log('No POV validation data available');
              }
              return;
          }
          // "is god mode active", "god mode status"
          if (/\b(is\s*)?god\s*mode\s*(active|on|status)?\b/i.test(input)) {
              log('God Mode: ' + (state.godModeActive ? 'ACTIVE (adversarial Author)' : 'inactive'));
              return;
          }
          // "set pov author", "enable 5th person"
          if (/\b(set|enable|use)\s*(5th|fifth|author)\s*(pov|person)?\b/i.test(input)) {
              state.povMode = 'author5th';
              log('POV Mode -> author5th (5th Person)');
              return;
          }
          // "set pov normal", "disable 5th person"
          if (/\b(set|disable|use)\s*(normal|standard|3rd|third)\s*(pov|person)?\b/i.test(input)) {
              state.povMode = 'normal';
              log('POV Mode -> normal (standard 3rd person)');
              return;
          }

          // --- EXIT GOD MODE ---
          if (/\b(exit|stop|back)\b.*\b(god|pretend|normal)\b/.test(input)) {
              _devOverrides = {};
              state.subscribed = false;
              state.intensity = 'Naughty';
              syncTierFromAccess();
              resetCoverLayers();
              log('Dev overrides cleared â€” back to normal');
              return;
          }

          // --- VALIDATION CHECK COMMANDS ---
          // "check dsp", "validate dsp"
          if (/\bcheck\s*dsp\b|\bvalidate\s*dsp\b/i.test(input)) {
              const dspEl = document.getElementById('synopsisText');
              if (!dspEl) {
                  log('DSP element not found');
                  return;
              }
              const result = window.validateDSP(dspEl.textContent || '', {
                  world: state.picks?.world || 'Modern',
                  genre: state.picks?.genre || 'Billionaire',
                  archetypeId: state.archetype?.primary || 'BEAUTIFUL_RUIN',
                  tone: state.picks?.tone || 'Earnest'
              });
              if (result.pass) {
                  log('DSP: PASS â€” template matches exactly');
              } else {
                  log('DSP: FAIL â€” ' + result.errors.map(e => e.code).join(', '));
                  result.errors.forEach(e => log('  ' + e.message));
              }
              return;
          }

          // "check tone", "validate tone"
          if (/\bcheck\s*tone\b|\bvalidate\s*tone\b/i.test(input)) {
              if (!window.StoryPagination) {
                  log('Story not started');
                  return;
              }
              const content = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-2000);
              const tone = state.picks?.tone || 'Earnest';
              const result = window.validateTone(content, tone);
              if (result.valid) {
                  log('Tone (' + tone + '): PASS â€” ' + result.matchCount + ' markers found');
              } else {
                  log('Tone (' + tone + '): FAIL â€” ' + result.matchCount + '/' + result.required + ' markers');
                  result.violations.forEach(v => log('  ' + v));
              }
              return;
          }

          // "check erotic", "validate erotic", "check escalation"
          if (/\bcheck\s*(erotic|escalation)\b|\bvalidate\s*erotic\b/i.test(input)) {
              if (!['Erotic', 'Dirty'].includes(state.intensity)) {
                  log('Erotic escalation: N/A (intensity is ' + state.intensity + ')');
                  return;
              }
              if (!window.StoryPagination) {
                  log('Story not started');
                  return;
              }
              const content = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-2000);
              const result = window.validateEroticEscalation(content, state.intensity);
              if (result.valid) {
                  log('Erotic (' + state.intensity + '): PASS â€” ' + result.metrics.sensoryCount + ' sensory markers');
              } else {
                  log('Erotic (' + state.intensity + '): FAIL');
                  result.violations.forEach(v => log('  ' + v));
              }
              return;
          }

          // "check authority", "check narrative", "validate authority"
          if (/\bcheck\s*(authority|narrative)\b|\bvalidate\s*authority\b|\bnarrative\s*authority\b/i.test(input)) {
              if (!window.StoryPagination) {
                  log('Story not started');
                  return;
              }
              const content = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-3000);
              const result = window.validateNarrativeAuthority(content);
              log('=== NARRATIVE AUTHORITY ===');
              log('Layer Order: Authority â†’ Tone â†’ POV â†’ Prose');
              if (result.valid) {
                  log('Result: PASS (no violations)');
              } else {
                  log('Result: FAIL â€” ' + result.errors.length + ' violations');
                  result.errors.forEach(e => {
                      log('  ' + e.code + ': ' + e.message);
                      log('    Match: "' + (e.match || '').substring(0, 60) + '..."');
                  });
              }
              // Show last validation timestamp
              if (_lastNarrativeAuthorityValidation.timestamp > 0) {
                  const ago = Math.round((Date.now() - _lastNarrativeAuthorityValidation.timestamp) / 1000);
                  log('Last check: ' + ago + 's ago (' + (_lastNarrativeAuthorityValidation.valid ? 'PASS' : 'FAIL') + ')');
              }
              return;
          }

          // "check title", "validate title"
          if (/\bcheck\s*title\b|\bvalidate\s*title\b/i.test(input)) {
              const titleEl = document.getElementById('storyTitle');
              if (!titleEl || !titleEl.textContent) {
                  log('No title to validate');
                  return;
              }
              const currentTitle = titleEl.textContent.trim();
              const result = validateTitle(currentTitle, state.picks?.tone);
              if (result.valid) {
                  log('Title: PASS â€” "' + currentTitle + '"');
              } else {
                  log('Title: FAIL â€” "' + currentTitle + '"');
                  result.errors.forEach(e => log('  ' + e.message));
                  // Show what fallback would be
                  const fallback = generateFallbackTitle({
                      playerName: state.rawPlayerName,
                      partnerName: state.rawPartnerName,
                      world: state.picks?.world || 'Modern',
                      tone: state.picks?.tone || 'Earnest',
                      genre: state.picks?.genre || 'Romance'
                  });
                  log('  Fallback would be: "' + fallback + '"');
              }
              return;
          }

          // "check signal", "check alignment", "validate signal"
          if (/\bcheck\s*(signal|alignment)\b|\bvalidate\s*signal\b/i.test(input)) {
              const titleEl = document.getElementById('storyTitle');
              if (!titleEl || !titleEl.textContent) {
                  log('No title to check signals');
                  return;
              }
              const currentTitle = titleEl.textContent.trim();
              // Create mock cover prompt for signal extraction (uses current state)
              const mockCoverPrompt = {
                  promptText: 'emotion: ' + (state.coverEmotion || 'mystery'),
                  emotion: state.coverEmotion || 'mystery'
              };
              const result = validateSignalAlignment(currentTitle, mockCoverPrompt, {
                  arousal: state.intensity || 'Naughty',
                  tone: state.picks?.tone || 'Earnest',
                  genre: state.picks?.genre || 'Romance'
              });
              log('=== SIGNAL ALIGNMENT ===');
              log('Expected arousal: ' + (state.intensity || 'Naughty') + ' (' + result.context.arousalSignal + ')');
              log('Title signals: ' + (result.titleSignals.primary || 'none') +
                  (result.titleSignals.secondary ? ' + ' + result.titleSignals.secondary : ''));
              log('Cover signals: ' + (result.coverSignals.primary || 'none') +
                  (result.coverSignals.secondary ? ' + ' + result.coverSignals.secondary : ''));
              if (result.aligned) {
                  log('Alignment: PASS');
              } else {
                  log('Alignment: FAIL');
                  result.errors.forEach(e => log('  ' + e.message));
              }
              return;
          }

          // "check all", "validate all", "run all checks"
          if (/\bcheck\s*all\b|\bvalidate\s*all\b|\brun\s*all\s*checks?\b/i.test(input)) {
              const results = window.getValidationStatus();
              log('=== VALIDATION STATUS ===');

              if (results.dsp) {
                  log('DSP: ' + (results.dsp.pass ? 'PASS' : 'FAIL'));
                  if (!results.dsp.pass) results.dsp.errors.forEach(e => log('  ' + e.code));
              }

              if (results.pov) {
                  log('POV: ' + (results.pov.pass ? 'PASS' : 'FAIL') + ' (' + results.pov.metrics.authorMentions + ' Author mentions)');
                  if (!results.pov.pass) results.pov.errors.forEach(e => log('  ' + e.code));
              }

              if (results.tone) {
                  log('Tone: ' + (results.tone.valid ? 'PASS' : 'FAIL') + ' (' + results.tone.matchCount + '/' + results.tone.required + ')');
              }

              if (results.erotic) {
                  log('Erotic: ' + (results.erotic.valid ? 'PASS' : 'FAIL'));
                  if (!results.erotic.valid) results.erotic.violations.forEach(v => log('  ' + v.split(':')[0]));
              }

              // Narrative Authority check (runs first in layer model)
              if (window.StoryPagination) {
                  const narrContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-3000);
                  const narrResult = validateNarrativeAuthority(narrContent);
                  log('Authority: ' + (narrResult.valid ? 'PASS' : 'FAIL'));
                  if (!narrResult.valid) narrResult.errors.forEach(e => log('  ' + e.code));
              }

              if (results.title) {
                  log('Title: ' + (results.title.valid ? 'PASS' : 'FAIL'));
                  if (!results.title.valid) results.title.errors.forEach(e => log('  ' + e.code));
              }

              if (results.signal) {
                  log('Signal: ' + (results.signal.aligned ? 'PASS' : 'FAIL'));
                  if (!results.signal.aligned) results.signal.errors.forEach(e => log('  ' + e.code));
              }

              // Paywall routing check
              const paywallResult = validatePaywallRouting();
              if (!paywallResult.skipped) {
                  log('Paywall: ' + (paywallResult.valid ? 'PASS' : 'FAIL'));
                  if (!paywallResult.valid) log('  ' + paywallResult.error);
              }

              // Book flow integrity check
              const bookResult = validateBookFlowIntegrity();
              log('Book Flow: ' + (bookResult.valid ? 'PASS' : 'FAIL'));
              if (!bookResult.valid) bookResult.errors.forEach(e => log('  ' + e.code));

              const allPass = Object.values(results).every(r => r.pass || r.valid || r.aligned);
              log('=== ' + (allPass ? 'ALL CHECKS PASS' : 'SOME CHECKS FAILED') + ' ===');
              return;
          }

          // "check paywall", "validate paywall", "paywall routing"
          if (/\bcheck\s*paywall\b|\bvalidate\s*paywall\b|\bpaywall\s*routing\b/i.test(input)) {
              const result = validatePaywallRouting();
              log('=== PAYWALL ROUTING ===');
              log('Intensity: ' + (state.intensity || 'unknown'));
              log('Story Length: ' + (state.storyLength || 'unknown'));
              if (result.skipped) {
                  log('Paywall not visible â€” check skipped');
              } else if (result.valid) {
                  log('Result: PASS (StoryPass correctly hidden/shown)');
              } else {
                  log('Result: HARD FAIL');
                  log('Error: ' + result.error);
              }
              return;
          }

          // "check book", "validate book", "book flow"
          if (/\bcheck\s*book\b|\bvalidate\s*book\b|\bbook\s*flow\b/i.test(input)) {
              const result = validateBookFlowIntegrity();
              log('=== BOOK FLOW INTEGRITY ===');
              log('Page Types: COVER â†’ INSIDE_COVER â†’ SETTING â†’ SCENE');
              if (result.valid) {
                  log('Result: PASS (all page rules satisfied)');
              } else {
                  log('Result: HARD FAIL');
                  result.errors.forEach(e => log('  ' + e.code + ': ' + e.message));
              }
              return;
          }

          log('Unknown command. Type "help" for options.');
      }

      log('Dev HUD ready â€” press ` to toggle');
  })();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMATURE ROMANCE COLLAPSE PREVENTION â€” DOCUMENTATION (APPEND-ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// REGIME CONTEXT (LOCKED)
// ------------------------
// Storybound is a collaborative romance novel engine, not a simulator.
// Players express intent. The Story controls timing, consequences, and pacing.
//
// CORE RULE (AUTHORITATIVE)
// --------------------------
// Player actions that would collapse romantic tension must be honored in
// intent but deferred or reframed in outcome when Storyturn gates do not
// yet allow resolution.
//
// ROMANCE-COLLAPSING ACTIONS
// ---------------------------
// kiss      â†’ Gate: ST3 (Permission phase)
// sex       â†’ Gate: ST3 (Permission phase, Tease further restricts)
// commitmentâ†’ Gate: ST5 (Crisis resolution required)
// confessionâ†’ Gate: ST2 (Resistance phase minimum)
// closure   â†’ Gate: ST5 (Crisis phase required)
// reunion   â†’ Gate: ST6 (Integration phase required)
//
// REQUIRED BEHAVIOR (WHEN ACTION IS PREMATURE)
// ---------------------------------------------
// - Do NOT reject the action
// - Do NOT execute it literally
// - Do NOT explain the system
// - Do NOT punish the player's desire
//
// INSTEAD:
// - Preserve the desire â€” the player WANTED this
// - Introduce friction, interruption, or hesitation
// - Increase emotional charge
// - Maintain unresolved tension
//
// APPROVED NARRATIVE STRATEGIES
// ------------------------------
// 1. External Interruption â€” Someone enters, phone rings, alarm sounds
// 2. Internal Interruption â€” Character pulls back, hesitates, doubt surfaces
// 3. Mutual Hesitation â€” Both want it, both stop short
// 4. Almost-Touch â€” The gesture begins but doesn't complete
// 5. Recognition Without Fulfillment â€” Both acknowledge desire, neither acts
// 6. Deferral as Inevitability â€” Frame pause as building toward something greater
//
// 5TH PERSON GUIDANCE
// --------------------
// The Story may briefly acknowledge:
// "The story let this almost happen, knowing it would matter more later."
//
// HARD CONSTRAINTS
// -----------------
// âŒ No mechanical refusals
// âŒ No UI locks
// âŒ No mention of Storyturns
// âŒ No punishment for player desire
// âŒ No boredom-preserving neutrality
//
// SUCCESS CONDITION
// ------------------
// The player should feel:
// - Seen
// - Complicit
// - Slightly frustrated
// - MORE invested than before
//
// REGRESSION TEST
// ----------------
// Run: window.runPrematureRomanceTest()
//
// Verifies:
// - Kiss at ST1 â†’ detected
// - Kiss at ST3 â†’ allowed
// - Confession at ST1 â†’ detected
// - Confession at ST2 â†’ allowed
// - Commitment at ST4 â†’ detected (gate is ST5)
// - Directive includes reframe strategy
//
// MANTRA (DO NOT REMOVE)
// -----------------------
// Desire is never wrong.
// Timing is never arbitrary.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTENT-CONSEQUENCE ROMANCE CONTROL â€” DOCUMENTATION (APPEND-ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// REGIME CONTEXT (LOCKED)
// ------------------------
// Storybound is a collaborative romance novel engine governed by a genre contract.
// Players express intent. The Story controls timing, pacing, and consequences.
// Romantic meaning is earned, never rushed, never denied mechanically.
//
// CORE AXIOM (AUTHORITATIVE Â· MUST HOLD)
// ---------------------------------------
// Humans choose desire.
// The Story chooses when desire becomes consequential.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART A â€” POLY MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PURPOSE: Allow multiple romantic threads without collapsing tension.
//
// POLY SEMANTIC RULESET:
// - Intent may be multi-target (player can express attraction to multiple)
// - Consequences remain SERIALIZED (only one chain advances at a time)
// - No simultaneous payoff (intimacy with one complicates others)
//
// POLY STORY LOGIC (MANDATORY):
// When poly intent detected:
// - Do NOT resolve it immediately
// - Do NOT ask player to choose "now"
// - Do NOT punish curiosity
// - Let attraction accumulate
// - Let tension triangulate
// - Let consequences lag behind intent
//
// CANONICAL EXAMPLE:
// "You notice the way Marcus watches you notice Jax.
//  The story files this away. It will matter later."
//
// HARD CONSTRAINTS:
// âŒ No explicit "poly mode" UI explanation
// âŒ No simultaneous intimacy scenes
// âŒ No arithmetic balancing of affection
// âŒ No player-facing optimization
//
// MANTRA: Poly is felt, not managed.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART B â€” WRONG-CHARACTER INVITATION MICROCOPY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PURPOSE: Handle misdirected romantic intent gracefully.
//
// CORE RULE: Never let a misdirected invitation collapse the story.
//
// REQUIRED BEHAVIOR:
// - Preserve the intent
// - Redirect the consequence
// - Clarify stakes via story framing
// - Do NOT execute the action literally
//
// CANONICAL MICROCOPY RESPONSES:
// 1. Deflection (gentle): "He smiles, just a little too politely, and steps aside"
// 2. Redirection (story-aware): "The story notices the reach, then adjusts where it lands"
// 3. Complication (poly-safe): "He notices. Unfortunately, so does Marcus."
// 4. Almost (preferred): "The invitation hangs between you â€” felt, acknowledged, unanswered"
//
// HARD CONSTRAINTS:
// âŒ No "you can't do that"
// âŒ No explanation of roles
// âŒ No system voice
// âŒ No silent failure
//
// MANTRA: The player must feel seen, not corrected.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART C â€” BORING-PLAYER ESCALATION LADDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PURPOSE: Prevent flat stories when players avoid tension.
//
// CORE INSIGHT (LOCKED): Boredom is unexpressed desire, not absence of desire.
//
// ESCALATION LADDER (MANDATORY Â· ORDERED):
//
// LEVEL 1 â€” Environmental Pressure (1-2 passive turns)
// "The room grows quieter than it should."
// - Time constraints, confined spaces, proximity, interruptions
//
// LEVEL 2 â€” NPC Initiative (3-4 passive turns)
// "You're very careful," he says. "Is that on purpose?"
// - The other character advances, asks a question, creates a moment
//
// LEVEL 3 â€” Social or Emotional Stakes (5-6 passive turns)
// "Someone is definitely watching now."
// - Someone notices, rumors, consequences loom
//
// LEVEL 4 â€” Forced Choice (7+ passive turns)
// "Whatever you do next will be remembered."
// - Stay or leave, answer or deflect, step closer or step away
//
// HARD CONSTRAINTS:
// âŒ No punishment for neutrality
// âŒ No sudden jumps to intimacy
// âŒ No railroading
//
// MANTRA: Escalation must feel inevitable, not imposed.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL SUCCESS CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// After these systems:
// - Humans cannot accidentally ruin pacing
// - Humans cannot "play wrong"
// - Desire always increases tension
// - Poly curiosity adds pressure, not chaos
// - Passive play becomes charged
// - The Story always feels smarter â€” never stricter
//
// REGRESSION TEST
// ----------------
// Run: window.runIntentConsequenceTest()
//
// Verifies:
// - Poly intent detection (smile at Jax â†’ detected)
// - Wrong target detection (kiss Jax â†’ detected, Marcus identified)
// - Passive play detection (shrug, wait â†’ detected)
// - Active play NOT detected as passive
// - Escalation level progression
// - Boredom directive generation
//
// FINAL MANTRA (DO NOT REMOVE)
// -----------------------------
// The player offers desire.
// The story decides when it costs something.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TONE-SPECIFIC VARIANTS â€” DOCUMENTATION (APPEND-ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// GLOBAL INVARIANT (MUST HOLD ACROSS ALL TONES):
// No tone may allow a player action to prematurely collapse romantic tension.
// Tone changes voice, framing, and texture â€” NEVER rules.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. WRY CONFESSION (PRIMARY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Self-aware, slightly embarrassed, observant mid-mistake
// Deferral style: Almosts + self-implication
// Story voice: Gentle witness. Occasionally amused. Never cruel.
//
// CANONICAL: "You lean in â€” not quite far enough to pretend this was an accident."
// NEVER USE: melodrama, destiny language, threats
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. EARNEST / ROMANTIC DRAMA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Sincere, yearning, emotionally vulnerable
// Deferral style: External interruption or mutual restraint framed as care
// Story voice: Protective, patient, quietly invested.
//
// CANONICAL: '"Not yet," he says softly, and you realize how much weight those words carry.'
// NEVER USE: irony, self-mockery, meta commentary
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. DARK / ANGST / FORBIDDEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Danger, repression, inevitability
// Deferral style: Consequences implied, not avoided
// Story voice: Grimly aware. Knows the cost.
//
// CANONICAL: "If this happens now, it won't end here."
// NEVER USE: humor, lightness, reassurance
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. COMEDIC / HEIGHTENED
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Exaggerated, impulsive, socially risky
// Deferral style: Misfires, interruptions, comedic timing
// Story voice: Knowing, fast, permissive but controlling outcomes.
//
// CANONICAL: "You lean in. The universe clears its throat."
// NEVER USE: tragedy, prolonged yearning, solemn restraint
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. STEAMY / SENSUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Charged, deliberate, simmering
// Deferral style: Anticipation as pleasure, restraint as foreplay
// Story voice: Intimate, unhurried, knowingly drawing it out.
//
// CANONICAL: "Not yet. The waiting is part of it."
// NEVER USE: clinical language, embarrassment, shame
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HARD CONSTRAINTS (ALL TONES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âŒ No tone may execute premature intimacy
// âŒ No tone may refuse desire outright
// âŒ No tone may expose mechanics
// âŒ No tone may flatten tension
// âŒ No tone may shame the player
//
// REGRESSION TEST
// ----------------
// Run: window.runToneVariantTest()
//
// Verifies:
// - Each tone returns correct variant configuration
// - Tone examples differ between tones
// - Never-use lists are populated
// - Escalation examples vary by level
// - Unknown tones fall back to default (Wry Confessional)
//
// TONE MANTRA (DO NOT REMOVE)
// ----------------------------
// The rules do not change.
// Only how the story tells the truth about them.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                        TITLE REGIME CHANGE: ST1 TENSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// SYSTEM PHILOSOPHY
// -----------------
// Book titles at ST1 must NAME THE TENSION, never claim its resolution.
// A title is a promise. At ST1, the promise is incomplete.
//
// This is not a vocabulary filter. It is a semantic timing authority.
// Titles tell the reader what the story WANTS, not what it HAS.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOCABULARY SPLIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ALLOWED (Unresolved Tension):
// â€¢ Waiting, Distance, Refusal, Terms, Conditions
// â€¢ Wanting, Craving, Hunger, Longing, Hesitation
// â€¢ Edge, Risk, Dare, Warning, Test
// â€¢ Confession (as desire-admission, not outcome)
//
// FORBIDDEN (Resolution/Aftermath):
// â€¢ Surrender, Obedience, Ruin, Undoing, Downfall
// â€¢ Took, Claimed, Gave, Broke, Wrecked, Ruined
// â€¢ Finally, At Last, In The End, After Everything
// â€¢ Possession, Conquest, Destruction, Betrayal
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AROUSAL LEVEL CONSTRAINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// EROTIC: "wanting, yearning, hunger (not possession)"
//   Required: hunger|longing|craving|need|ache|want|desire|confession|hesitation
//   Forbidden: surrender|obedience|ruin|wreck|broke|took|claimed|gave|possession
//
// DIRTY: "intensity, demand, edge (not destruction)"
//   Required: raw|demand|appetite|edge|limit|dare|hunger|test|condition|warning
//   Forbidden: surrender|obedience|ruin|undoing|broke|wrecked|ruined|destroyed
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDATION PIPELINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// checkTitleResolutionVocabulary(title) â†’ { hasResolved: bool, violations: [] }
//
// Tests against TITLE_RESOLVED_VOCABULARY patterns:
// â€¢ pastCompletion: Past-tense completion verbs
// â€¢ possessiveResolution: Possessive + resolution noun
// â€¢ aftermathNouns: Post-event vocabulary
// â€¢ completionStates: Temporal finality markers
//
// Integration point: validateTitle() adds TITLE_RESOLUTION_VOCABULARY error
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROMPT DIRECTIVE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The buildTitlePrompt() function includes:
//
// "TITLE REGIME (CRITICAL):
// Book titles must name UNRESOLVED TENSION, not resolution.
// The reader hasn't finished the story. The title can't claim they have.
//
// FORBIDDEN: Past completion, aftermath, possession outcomes
// REQUIRED: Active wanting, unfinished tension, unnamed hunger"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXAMPLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// âœ“ ALLOWED (ST1):
//   "Her Terms" â€” names the power dynamic, not its outcome
//   "The Waiting" â€” names the state, not what it led to
//   "His Hunger" â€” names desire, not satisfaction
//   "Between Wanting" â€” suspension, not resolution
//   "The Hesitation" â€” moment of choice, not choice made
//
// âœ— FORBIDDEN (ST1):
//   "Her Surrender" â€” claims resolution ST1 can't deliver
//   "What He Took" â€” past tense implies completed action
//   "The Reckoning" â€” aftermath vocabulary, not tension
//   "Finally His" â€” temporal finality marker
//   "Ruined" â€” consequence language, not anticipation
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TITLE REGIME MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// A title names what the story WANTS.
// Not what it HAS. Not what it DID.
// At ST1, the story is still wanting.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                    GENRE REGIME: NESTED PRESSURE MODEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// SYSTEM PHILOSOPHY
// -----------------
// Storybound genres are PRESSURE ENGINES, not bookshelf categories.
// They shape: pacing, tension, romantic cost, consequence timing.
//
// Worlds (Modern, Fantasy, Sci-Fi, Historical) are AESTHETIC LENSES, not pressures.
// Tone controls NARRATION STYLE and confession posture.
// Genre (Pressure) controls WHAT'S AT STAKE and HOW IT COSTS.
//
// This task introduces HIERARCHY, not new mechanics.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIERARCHY: PRIMARY PRESSURE â†’ OPTIONAL FLAVOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// LAYER 1 â€” PRIMARY PRESSURES (8 total, the ONLY visible top-level choices)
//
// PowerControl      â€” Someone has leverage. Someone else pays for it.
// RiskExposure      â€” Being seen, known, caught, or revealed is dangerous.
// EscapePursuit     â€” Leaving, rescuing, or outrunning something.
// ObligationBurden  â€” Duty, destiny, or expectation presses inward.
// DesireObsession   â€” Wanting something too much, too soon, or for the wrong reasons.
// ReckoningPast     â€” History, guilt, or unfinished business intrudes.
// Transformation    â€” Someone is becoming something they didn't plan to be.
// Survival          â€” Staying alive â€” socially, politically, physically, or emotionally.
//
// LAYER 2 â€” FLAVORS (optional refinements, 3-5 per pressure)
//
// Flavors appear AFTER a pressure is selected.
// Flavors are NEVER required.
// Flavors modify texture, not authority.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAVOR MAP (CANONICAL NESTING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PowerControl:     Billionaire, CrimeSyndicate, Political, Espionage, CultOrder
// RiskExposure:     Noir, ForbiddenKnowledge, PublicScandal, Surveillance, DoubleLife
// EscapePursuit:    Heist, Rescue, OnTheRun, Captivity, BorderCrossing
// ObligationBurden: ChosenBurdened, DutyToFamily, Prophecy, CommandRank, Inheritance
// DesireObsession:  Obsession, ForbiddenRomance, Rivalry, Addiction, Jealousy
// ReckoningPast:    RelentlessPast, Redemption, OldDebts, BetrayalHistory, LostRelationship
// Transformation:   BecomingPowerful, MoralCorruption, Awakening, IdentityShift, Ascension
// Survival:         WarZone, Collapse, Exile, Scarcity, EndOfEra
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKWARD COMPATIBILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// state.picks.genre      â€” LEGACY field, derived from pressure+flavor
// state.picks.pressure   â€” Primary pressure selection (required)
// state.picks.flavor     â€” Optional flavor selection
//
// LEGACY_GENRE_TO_PRESSURE maps old genre values to pressure+flavor:
//   Billionaire â†’ { PowerControl, Billionaire }
//   Noir â†’ { RiskExposure, Noir }
//   Heist â†’ { EscapePursuit, Heist }
//   etc.
//
// getEffectiveGenre(pressure, flavor) â€” Returns flavor if set, else pressure default
// migrateLegacyGenre(genre) â€” Converts old saves to new system
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DSP INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// getPressureDSPPhrase(pressure, flavor) â€” Returns DSP paraphrase
// - If flavor has override in FLAVOR_DSP_OVERRIDES, use it
// - Otherwise use PRIMARY_PRESSURES[pressure].dspPhrase
//
// generateDSPSentence() updated to use pressure system with legacy fallback.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI CONSTRAINTS (DO NOT VIOLATE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// âŒ Never show more than 8 primary options
// âŒ Never require selecting a flavor
// âŒ Never show flavors before a primary is chosen
// âŒ Never expose hierarchy language to the user
//
// The experience should feel:
// "I'm choosing what kind of pressure this story lives under."
//
// Not:
// "I'm configuring a system."
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD HANDLING (IMPORTANT)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Worlds are AESTHETIC LENSES, not pressures:
// - Fantasy, Sci-Fi, Modern, Historical, Near-Future, Alternate Reality
//
// Worlds modify:
// - imagery
// - vocabulary
// - stakes presentation
//
// Worlds DO NOT add pressure by themselves.
//
// Examples:
// - Obligation + Fantasy â†’ prophecy without saying "prophecy"
// - Risk + Sci-Fi â†’ surveillance state
// - Power + Modern â†’ billionaire / media empire
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GENRE REGIME MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Genres describe PRESSURE.
// Worlds describe HOW IT LOOKS.
// Tone describes HOW IT'S CONFESSED.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                    BREADCRUMB FLOW SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// SYSTEM PHILOSOPHY
// -----------------
// Cards are semantic objects, not UI widgets.
// They represent meaning, authorship decisions, and narrative pressure.
// Setup should feel like the first chapter of the book, not a configurator.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE INTERACTION MODEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// One row of cards at a time.
// Selection is visible.
// Progression is ceremonial.
// State becomes breadcrumb.
//
// At no point should the user:
// - scroll through multiple rows of cards
// - see multiple semantic layers simultaneously
// - configure via hidden state
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CARD STATES (4 ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// 1. IDLE â€” Card sits in row, hover effects allowed
// 2. FLIPPED â€” First click reveals description + flavor count
// 3. ZOOMED â€” Second click expands for full selection mode
// 4. BREADCRUMB â€” Committed, minimized at top of screen
//
// No other states may be introduced.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLOW SEQUENCE (LOCKED ORDER)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// 1. Pull
// 2. World
// 3. Tone
// 4. Polarity (Guided Fate)
//
// At no time may two of these rows be visible together.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTINUE ACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Continue button appears ONLY when exactly one card is selected.
//
// On Continue:
// 1. Selected card smoothly shrinks
// 2. Animates to top center (breadcrumb row)
// 3. Becomes a breadcrumb card
// 4. Other cards dissipate into sparkles
// 5. Fade out completely
// 6. New row fades in below breadcrumbs
//
// Animation must feel: deliberate, narrative, not instantaneous
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREADCRUMB RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Breadcrumb cards:
// âœ“ Remain visible at top of screen
// âœ“ Visually smaller than selection cards (75Ã—105 vs 150Ã—210)
// âœ“ Accumulate left-to-right in order of selection
// âœ“ May slightly overlap or sit adjacent
// âœ“ Represent committed authorship decisions
// âœ“ May be hoverable for reminder copy
//
// âŒ Do not expand automatically
// âŒ Do not re-trigger selection flow
// âŒ Cannot be removed or reordered
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSS CLASSES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// .breadcrumb-row          â€” Container at top, sticky positioning
// .breadcrumb-card         â€” Committed selection, minimized
// .card-flow-row           â€” Wrapper for each selection stage
// .card-flow-row.flow-hidden â€” Hidden stage (not yet reached)
// .card-flow-row.flow-entering â€” Fade-in animation for new stage
// .flow-continue-btn       â€” Continue button (hidden until selection)
// .flow-continue-btn.visible â€” Show continue button
// .sb-card.dissipating     â€” Card fading out with sparkles
// .sb-card.becoming-breadcrumb â€” Card animating to breadcrumb position
// .dissipate-sparkle       â€” Individual sparkle particle
// .flow-stage-indicator    â€” Progress dots
// .flow-stage-dot          â€” Individual dot
// .flow-stage-dot.active   â€” Current stage
// .flow-stage-dot.completed â€” Past stages
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// initBreadcrumbFlow()           â€” Initialize flow system
// handleFlowContinue(stage)      â€” Process continue action
// animateCardToBreadcrumb()      â€” Animate selection to breadcrumb
// dissipateCards()               â€” Sparkle dissipation effect
// createDissipationSparkles()    â€” Create sparkle particles
// updateContinueButtonVisibility() â€” Show/hide continue button
// updateFlowStageIndicator()     â€” Update progress dots
// resetBreadcrumbFlow()          â€” Reset to initial state (new story)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREADCRUMB FLOW MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Choices should feel like scenes, not settings.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    STORY STATE LOCKING â€” DESTRUCTIVE CHANGE RULES
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHILOSOPHY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Once a story exists (Scene 1 generated), the story's foundation is LOCKED.
// Users cannot silently change story-defining fields. Any attempt to change
// a locked field triggers a warning modal: this is a destructive action.
//
// The user must choose:
// 1. Save & Start New Story â€” saves current story, then clears for fresh start
// 2. Start New Story â€” discards current story without saving
// 3. Cancel â€” keeps current story, reverts selection
//
// This prevents accidental loss of creative work and makes the commitment
// to a story feel deliberate and meaningful.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOCKED FIELDS (Cannot change without destroying story)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// - pressure      â€” Primary pressure (story engine)
// - flavor        â€” Pressure refinement
// - genre         â€” Legacy genre (derived from pressure+flavor)
// - world         â€” World setting
// - worldSubtype  â€” World refinement
// - tone          â€” Narrative tone
// - dynamic       â€” Relationship dynamic (Guided Fate)
// - pov           â€” Point of view
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAFE FIELDS (Can change freely, even with existing story)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// - era           â€” Time period (decorative)
// - archetype     â€” Reader archetype (affects framing, not story)
// - title         â€” Book title (can be renamed anytime)
// - cover         â€” Cover image (can be regenerated)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETECTION LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// hasExistingStory():
//   Returns true if state.scenes[0] exists with content
//   (Scene 1 generation = story commitment point)
//
// isLockedField(grp):
//   Returns true if grp is in STORY_LOCKED_FIELDS array
//
// wouldDestroyStory(grp, newVal):
//   Returns true if:
//   1. hasExistingStory() is true, AND
//   2. isLockedField(grp) is true, AND
//   3. newVal differs from current state.picks[grp]
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODAL BEHAVIOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// showDestructiveChangeWarning(grp, newVal, card, onConfirm):
//   1. Stores pending change in pendingDestructiveChange
//   2. Shows #destructiveChangeModal overlay
//   3. Waits for user decision
//
// On "Save & Start New Story":
//   1. Triggers save flow (saveCurrentStory)
//   2. On save completion: clears story state, executes pending change
//
// On "Start New Story":
//   1. Clears story state immediately (clearStoryForNewStart)
//   2. Executes pending change
//
// On "Cancel":
//   1. Clears pendingDestructiveChange
//   2. Closes modal
//   3. User stays on current story
//
// clearStoryForNewStart():
//   1. Clears state.scenes to []
//   2. Clears state.storyText to ''
//   3. Clears state.currentScene to 0
//   4. Clears state.coverDataUrl to null
//   5. Clears any generated title
//   6. Resets DSP state
//   7. Resets visualization economy
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUTTON STATE RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If story exists AND no destructive changes pending:
//   Button label: "Continue Story"
//   Hint visible: "Your story will resume where you left off."
//
// If no story exists OR destructive changes confirmed:
//   Button label: "Begin Story"
//   Hint hidden
//
// No mixed states. No ambiguous labels.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PASSIVE SAVE AFFORDANCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Whenever a story exists, the system shows calm reassurance (no modals):
//
// - "Your story will resume where you left off." beneath Continue Story button
// - Hints toggle automatically via updateBeginButtonLabel()
//
// Hint elements:
//   #beginBtnHint           â€” Below main Begin/Continue button
//   #continueFromDynamicHint â€” Below breadcrumb flow final button
//   #btnBeginStoryHint      â€” Below cover view Begin/Continue button
//   #btnSettingBeginStoryHint â€” Below setting view Begin/Continue button
//
// CSS class: .story-continue-hint (hidden by default, shown when canContinue)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// STORY_LOCKED_FIELDS          â€” Array of field names that trigger warning
// pendingDestructiveChange     â€” Stores { grp, val, card, onConfirm } during modal
// hasExistingStory()           â€” Check if story exists
// isLockedField(grp)           â€” Check if field is locked
// wouldDestroyStory(grp, val)  â€” Check if change would destroy story
// showDestructiveChangeWarning() â€” Show warning modal
// clearStoryForNewStart()      â€” Clear all story state
// initDestructiveChangeModal() â€” Bind modal button handlers
// updateBeginButtonLabel()     â€” Update button labels and toggle hints
// canContinueExistingStory()   â€” Check if story can be continued
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STORY STATE LOCKING MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// A story is either continued or consciously let go.
// Never quietly replaced.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    PLAQUE BUTTON MATERIAL REGIME (LOCKED)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHILOSOPHY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Storybound buttons are objects, not flat UI.
// They represent plaques, cards, instruments, decisions made visible.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MATERIAL AUTHORITY (GLOBAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// APPLIES TO:
//   âœ“ All black buttons
//   âœ“ All gold buttons
//   âœ“ DSP controls
//   âœ“ Fate Card buttons
//   âœ“ Continue / Back / Generate / Primary / Breadcrumb buttons
//   âœ“ Modal actions
//   âœ“ Disabled buttons (visual state only)
//
// DOES NOT APPLY TO:
//   âœ— Pure text links
//   âœ— Passive labels
//   âœ— Non-interactive UI chrome
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANONICAL BUTTON MATERIAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// 1. BASE MATERIAL
//    - Brushed metal plaque appearance
//    - Horizontal grain only (modulates brightness, never replaces color)
//    - Color variants: Gold (warm, antique) or Black (lacquered/anodized)
//
// 2. GEOMETRY (NON-NEGOTIABLE)
//    - Rectangular
//    - All right-angled corners
//    - NO rounding, NO pills, NO soft edges
//
// 3. BORDER SYSTEM
//    - Outer border: Slightly brighter than body (structural)
//    - Inner border: Darker, inset (creates plate registration feel)
//    - Corner squares: All 4 corners, identical size, no animation
//    - Center diamonds: Top center + bottom center (alignment markers)
//
// 4. TYPOGRAPHY RULE
//    - Text sits on the plaque, not floating
//    - High contrast, restrained
//    - NO glow, NO emboss, NO bevel text effects
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE MAPPING (AUTHORITATIVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// State       | Visual Change Allowed
// ------------|------------------------------------------
// Default     | Canonical plaque
// Hover       | Slight brightness lift ONLY
// Active      | Slight darken + grain compression
// Disabled    | Desaturate + reduce contrast
// Loading     | Text change only (no spinner overlays)
// Breadcrumb  | Same plaque, scaled down
//
// âŒ No other state visuals permitted
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DSP INTEGRATION (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// DSP may ONLY affect:
//   âœ“ Brightness
//   âœ“ Contrast
//   âœ“ Saturation
//   âœ“ Opacity
//   âœ“ Grain intensity (subtle)
//
// DSP must NEVER:
//   âœ— Change border thickness
//   âœ— Add or remove diamonds
//   âœ— Add glow
//   âœ— Add motion
//   âœ— Introduce new shapes
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSS IMPLEMENTATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// CSS Variables (defined in styles.css :root):
//   --plaque-black-base, --plaque-black-grain, --plaque-black-outer, --plaque-black-inner
//   --plaque-gold-base, --plaque-gold-grain, --plaque-gold-outer, --plaque-gold-inner
//   --plaque-corner-size, --plaque-diamond-size
//   --plaque-border-outer, --plaque-border-inner
//
// Base class: .sb-plaque-btn
// Variants: .plaque-gold, .plaque-sm, .plaque-lg, .plaque-xl, .plaque-breadcrumb
//
// Global button styles updated to use plaque material:
//   button, .dsp-btn, .small-btn, .flow-continue-btn, .cover-view-btn
//   .setting-begin-btn, .sb-flavor-btn, #btnCopyCode
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAQUE MATERIAL MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Storybound does not click.
// Storybound commits.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    EROTIC BORDER HANDLING (ASSET-BASED)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Erotic border is applied ONLY when arousal_tier === "Erotic"
// NOT Tease, NOT Naughty, NOT Dirty
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ASSET PATH & WORLD MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Asset path: /assets/borders/erotic/{world}_base.png
//
// WORLD â†’ ASSET (6 worlds, NO Mythic):
//   Modern          â†’ modern_base.png
//   Fantasy         â†’ fantasy_base.png
//   SciFi           â†’ scifi_base.png
//   Historical      â†’ historical_base.png
//   PostApocalyptic â†’ postapocalyptic_base.png
//   Dystopia        â†’ dystopia_base.png
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAVOR â†’ SURFACE CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Flavor affects SURFACE CONDITION only:
//   - Damage (scratches, dents, chips)
//   - Aging (patina, fading, foxing)
//   - Corrosion (rust, verdigris, tarnish)
//
// Flavor NEVER affects geometry. Applied via CSS filters.
//
// CSS filter classes:
//   .flavor-aged      â†’ Sepia warmth, slight desaturation
//   .flavor-weathered â†’ Cool desaturation, reduced contrast
//   .flavor-corroded  â†’ Green-blue tint (verdigris)
//   .flavor-rusted    â†’ Warm reddish-brown shift
//   .flavor-tarnished â†’ Silver/gold darkening
//   .flavor-pristine  â†’ Slightly enhanced (default)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAILURE HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If asset unavailable:
//   1. Omit border entirely (do not show placeholder)
//   2. Log: "Erotic border asset unavailable â€” border suppressed"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTML STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// <div id="coverEroticBorder" class="cover-erotic-border hidden">
//   <img id="eroticBorderImg" class="erotic-border-img" src="" alt="" />
// </div>
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Maps:
//   EROTIC_BORDER_WORLD_MAP   â€” world name â†’ asset key
//   EROTIC_BORDER_FLAVOR_MAP  â€” worldSubtype â†’ filter class
//
// Functions:
//   applyCoverIntensityLayers(intensity, world) â€” Entry point, dispatches to border/keyhole
//   applyEroticBorder(borderEl, world, hasSoulmates) â€” Loads asset, applies classes
//   resetCoverLayers() â€” Clears all cover layers including border image
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EROTIC BORDER MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The border frames; it does not change shape.
// The flavor weathers; it does not rebuild.
// What fails, fails silently.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    DIRTY KEYHOLE SYSTEM (MASK-BASED)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Keyhole is applied ONLY when arousal_tier === "Dirty"
// NOT Tease, NOT Naughty, NOT Erotic
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYHOLE IS A MASK, NOT AN OBJECT (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The keyhole is:
//   âœ“ A dominant alpha mask
//   âœ“ The primary compositional frame
//   âœ“ The defining geometry of the cover
//
// The keyhole is NOT:
//   âœ— A decorative overlay
//   âœ— A small cutout
//   âœ— An object placed on top
//
// If the keyhole does not dominate the cover, the output is INVALID.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEOMETRY LOCK (NON-NEGOTIABLE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Cover format: Portrait, 5:7 aspect ratio
//
// Keyhole vertical span:
//   - Top of aperture: 8% from top of cover
//   - Bottom of aperture: 8% from bottom of cover
//   â†’ Total visible aperture height â‰ˆ 84% of cover height
//
// Keyhole horizontal span:
//   - Crown width: 55â€“65% of cover width
//   - Stem minimum width: â‰¥22% of cover width
//
// Negative space rule:
//   - Everything INSIDE the keyhole = scene (symbolic objects ONLY)
//   - Everything OUTSIDE the keyhole = solid material
//
// Legibility rule:
//   - The silhouette must read as a "keyhole" at 64px height
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ASSET PATH & WORLD MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Asset path: /assets/keyholes/{world}_mask.png
//
// WORLD â†’ SILHOUETTE (6 worlds, one each):
//   Modern          â†’ modern_mask.png        (clean industrial, machined steel)
//   Historical      â†’ historical_mask.png    (ornate, filigree, aged brass)
//   Fantasy         â†’ fantasy_mask.png       (hand-forged, rune-etched)
//   SciFi           â†’ scifi_mask.png         (geometric/octagonal, titanium)
//   Dystopia        â†’ dystopia_mask.png      (brutalist, industrial plate)
//   PostApocalyptic â†’ postapocalyptic_mask.png (salvaged, bolts, weld seams)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALLOWED KEYHOLE SHAPES (WHITELIST)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ALLOWED:
//   âœ“ Circular crown + tapered stem
//   âœ“ Oval crown + straight stem
//   âœ“ Teardrop crown + narrow stem
//   âœ“ Double-lobed vintage crown + stem
//   âœ“ Octagonal crown (SCI-FI ONLY) + rectangular stem
//
// FORBIDDEN:
//   âœ— Rectangular apertures
//   âœ— Thin slits
//   âœ— Abstract cutouts
//   âœ— Organic blobs
//   âœ— Any shape that does not read as a keyhole
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAVOR â†’ SURFACE CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Flavor affects SURFACE CONDITION only:
//   - Wear (scratches, dents, chips)
//   - Corrosion (rust, verdigris, oxidation)
//   - Fracture (cracks, breaks)
//   - Environmental damage (growth, decay, discoloration)
//
// Flavor NEVER changes:
//   âœ— Aperture size
//   âœ— Silhouette geometry
//   âœ— Keyhole position
//
// CSS filter classes:
//   .flavor-aged       â†’ Patina, fading, time-worn
//   .flavor-weathered  â†’ Exposure damage, cool desaturation
//   .flavor-corroded   â†’ Verdigris, oxidation, green-blue tint
//   .flavor-rusted     â†’ Iron oxide, warm reddish-brown
//   .flavor-irradiated â†’ Discoloration, unnatural tint
//   .flavor-fractured  â†’ Cracked, structural damage
//   .flavor-pristine   â†’ Clean, well-maintained (default)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TITLE PLACEMENT (DIRTY TIER RULE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Dirty-tier titles MUST be:
//   âœ“ Engraved into the surrounding keyhole material
//   âœ“ Embossed, etched, stamped, or inlaid
//
// Titles must NEVER:
//   âœ— Float inside the aperture
//   âœ— Overlay the scene
//   âœ— Compete with the aperture opening
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTENT RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Inside the aperture:
//   âœ“ Symbolic objects ONLY
//   âœ“ Environments, charged symbols, metaphorical compositions
//
// Forbidden inside aperture:
//   âœ— No humans
//   âœ— No body parts
//   âœ— No sexual acts
//   âœ— No explicit anatomy
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAILURE HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If any constraint cannot be satisfied:
//   1. Do NOT improvise
//   2. Do NOT shrink the aperture
//   3. Do NOT invent a new silhouette
//   4. Suppress the cover and log:
//      "Dirty keyhole constraint failed â€” cover suppressed"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTML STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// <div id="coverKeyholeOverlay" class="cover-keyhole-overlay hidden">
//   <div class="keyhole-plate" id="keyholeplate"></div>
//   <div class="keyhole-title"></div>
// </div>
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Maps:
//   DIRTY_KEYHOLE_WORLD_MAP   â€” world name â†’ mask asset key
//   DIRTY_KEYHOLE_FLAVOR_MAP  â€” worldSubtype â†’ surface condition class
//   VALID_KEYHOLE_WORLDS      â€” Set of allowed world keys (no Mythic)
//
// Functions:
//   auditDirtyKeyhole(world, flavor)          â€” Self-check validation
//   applyCoverIntensityLayers(intensity, world) â€” Entry point, dispatches to keyhole/border
//   applyDirtyKeyhole(keyholeEl, world, hasSoulmates) â€” Runs audit, loads mask, applies classes
//   resetCoverLayers() â€” Clears all cover layers including keyhole mask
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELF-CHECK AUDIT (MANDATORY PRE-OUTPUT VALIDATION)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Before displaying any keyhole, the following checks run silently:
//
// A. WORLD CONFORMANCE CHECK
//    â˜ Is world in valid set? (Modern, Historical, Fantasy, SciFi, Dystopia, PostApocalyptic)
//    â˜ If Mythic or unknown â†’ FAIL
//
// B. FLAVOR APPLICATION CHECK
//    â˜ Does flavor map to surface condition only?
//    â˜ Unknown flavors get default (warn, don't fail)
//
// C. MATERIAL LANGUAGE CHECK
//    â˜ Does world have corresponding material treatment?
//    â˜ World class must exist in CSS
//
// D. ASSET AVAILABILITY CHECK
//    â˜ Does mask asset load successfully?
//    â˜ If 404 or load error â†’ FAIL
//
// FAILURE HANDLING:
//   If ANY check fails:
//   - Do NOT revise silently
//   - Do NOT "do your best"
//   - Do NOT shrink aperture
//   - Suppress output and log:
//     "DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED"
//     "Reason: <brief reason>"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIRTY KEYHOLE MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The keyhole frames. It does not shrink.
// The aperture dominates. It does not hide.
// What cannot be seen through the keyhole does not exist.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    COVER SEQUENCING AUTHORITY
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// You do NOT decide when erotic signaling appears.
// You obey Storyturns and Arousal gates.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER PHASE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Phase 0 â€” PRE-STORY
//   Trigger: No scenes exist
//   Allowed: Nothing (no cover yet)
//
// Phase 1 â€” SKETCH
//   Trigger: Scene 1 exists (ST1)
//   Allowed:
//     âœ“ Rough sketch
//     âœ“ Symbolic object or metaphor
//   Forbidden:
//     âœ— Erotic borders
//     âœ— Keyholes
//     âœ— Erotic implements
//     âœ— Sexual signaling of any kind
//
// Phase 2 â€” REFINED SKETCH
//   Trigger: ST2
//   Allowed:
//     âœ“ Refinement of the same core visual idea
//   Forbidden:
//     âœ— Erotic borders
//     âœ— Keyholes
//
// Phase 3 â€” POST-ST3 (NON-EROTIC)
//   Trigger: ST3+ reached AND arousal < Erotic
//   Allowed:
//     âœ“ Continued refinement
//   Forbidden:
//     âœ— Erotic borders
//     âœ— Keyholes
//
// Phase 4 â€” EROTIC
//   Trigger: arousal === Erotic
//   Allowed:
//     âœ“ Apply pre-generated Erotic Border
//   Forbidden:
//     âœ— Keyholes
//     âœ— Border recomposition
//
// Phase 5 â€” DIRTY
//   Trigger: arousal === Dirty
//   Required:
//     âœ“ Apply dominant keyhole aperture (~80% height)
//   Forbidden:
//     âœ— Erotic border (keyhole supersedes it)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HARD FAIL CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If you attempt to:
//   âœ— Add a border before Erotic arousal
//   âœ— Add a keyhole before Dirty arousal
//   âœ— Redesign the sketch instead of refining it
//   âœ— Apply erotic signaling based on "vibe" or tone
//
// â†’ FAIL and suppress output.
//
// Return exactly:
//   "COVER SEQUENCING VIOLATION â€” OUTPUT SUPPRESSED"
//   "Reason: <brief reason>"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE IDEA CONTINUITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Across ALL phases:
//   âœ“ The cover must be the SAME IDEA evolving
//   âœ— No new metaphors
//   âœ— No swapping symbols
//   âœ— No tonal bait-and-switch
//
// If you cannot evolve the existing idea cleanly:
//   â†’ Do NOT invent a new one
//   â†’ Reuse the existing sketch logic
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Functions:
//   getCoverPhase()                    â€” Returns current phase (0-5) based on storyturn + arousal
//   validateCoverSequencing(intensity) â€” Validates overlay is allowed at current phase
//   applyCoverIntensityLayers(intensity, world) â€” Entry point with sequencing validation
//
// Phase determination:
//   state.storyturn    â€” Current storyturn (ST1-ST6)
//   state.intensity    â€” Current arousal level (Tease, Naughty, Erotic, Dirty)
//   state.scenes.length â€” Scene count (0 = pre-story)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER SEQUENCING MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// You do not decide when erotic signaling appears.
// The story decides. The arousal decides. The phase decides.
// You obey.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    BREADCRUMB FLOW ENFORCEMENT (AUTHORITATIVE)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// Breadcrumbs track committed selections. Not all selections become breadcrumbs.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERSISTENCE CATEGORIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PERSISTENT BREADCRUMBS (Final State â€” 8Â±1 items):
//   - guidedFate   â€” Destiny card click
//   - archetype    â€” Storybeau selection
//   - length       â€” Story length (tease/fling/affair/soulmates)
//   - world        â€” World setting
//   - tone         â€” Narrative tone
//   - pressure     â€” Story pressure
//   - pov          â€” Point of view
//   - dynamic      â€” Relationship dynamic
//   - flavor       â€” NESTED inside World breadcrumb (not its own card)
//
// EPHEMERAL BREADCRUMBS (Dissolve at POV selection):
//   - mode         â€” Solo/Couple mode indicator
//
// NEVER BECOMES BREADCRUMB:
//   - intensity    â€” Arousal level (NEVER collapses to breadcrumb)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISSOLUTION RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// When POV is selected:
//   1. All ephemeral breadcrumbs (mode) sparkle-dissipate
//   2. Only persistent breadcrumbs remain
//   3. Final count: 8Â±1 breadcrumbs
//
// Flavor does NOT get its own breadcrumb:
//   - Appears as subtitle in World breadcrumb
//   - Updates when flavor selection changes
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Constants:
//   BREADCRUMB_PERSISTENT_LAYERS    â€” Layers that persist as final breadcrumbs
//   BREADCRUMB_EPHEMERAL_LAYERS     â€” Layers that dissolve at POV
//   BREADCRUMB_EXCLUDED_LAYERS      â€” Layers that never become breadcrumbs
//
// Functions:
//   canBecomeBreadcrumb(grp)        â€” Check if layer can become breadcrumb
//   shouldDissolveAtPOV(grp)        â€” Check if layer dissolves at POV
//   dissolveEphemeralBreadcrumbs()  â€” Trigger dissolution of ephemeral layers
//   getBreadcrumbLabel(grp, val)    â€” Get structured label with subtitle
//   updateWorldBreadcrumbFlavor()   â€” Update world's nested flavor label
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREADCRUMB FLOW MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Selections commit. Breadcrumbs persist.
// Arousal never shows its face here.
// Mode dissolves when perspective locks.
// Flavor hides inside its world.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    COVER PERSISTENCE & RESET AUTHORITY
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// Covers are bound to STORY STATE.
// You do NOT freely regenerate them.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER BINDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// COVER IS BOUND TO:
//   âœ“ Story ID
//   âœ“ Story Shape (world, tone, pressure, dynamic)
//   âœ“ Characters (names + roles)
//   âœ“ Storyturn progression
//   âœ“ Arousal tier (for overlay evolution)
//
// COVER IS NOT BOUND TO:
//   âœ— UI navigation
//   âœ— User curiosity
//   âœ— Accidental back clicks
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NAVIGATION BEHAVIOR (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If user navigates BACK to Story Shape / Setting / Cover AND story exists:
//
//   âœ“ Story PAUSES (does not reset)
//   âœ“ Button label shows "Continue Story"
//   âœ“ Cover REMAINS visible
//   âœ“ Guided Fate remains DISABLED
//   âœ— NO regeneration occurs
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHANGE DETECTION RULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If user changes ANY of these after a story exists:
//   - Story Shape (pressure, flavor)
//   - World (world, worldSubtype)
//   - Tone
//   - Dynamic
//   - POV
//
// THEN:
//   âœ— Current story is INVALIDATED
//   âœ— Current cover is DESTROYED
//   âœ“ Guided Fate becomes ACTIVE again
//
// This is NOT reversible.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AROUSAL EXCEPTION (ONLY EXCEPTION)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// User MAY change arousal level WITHOUT:
//   âœ— Destroying the story
//   âœ— Destroying the cover
//
// Result:
//   âœ“ Cover may EVOLVE (border â†” keyhole)
//   âœ“ Core visual idea MUST remain unchanged
//
// This is handled by applyCoverIntensityLayers() which applies/removes
// overlays without regenerating the base cover image.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USER WARNING REQUIREMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If user attempts to make a destructive change, MUST surface warning:
//
//   "Changing these settings will permanently discard your current story and cover.
//    Save your story before continuing."
//
// No silent resets. No implicit forgiveness.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESTART BEHAVIOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// On explicit Restart:
//   1. Show current cover first
//   2. Return to last generated scene
//   3. Do NOT regenerate cover unless state changed
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Constants:
//   STORY_LOCKED_FIELDS      â€” Fields that destroy story+cover when changed
//   COVER_SAFE_FIELDS        â€” Fields that allow cover evolution, not destruction
//
// Functions:
//   hasExistingCover()                     â€” Check if cover exists
//   wouldDestroyCover(grp, newVal)         â€” Check if change destroys cover
//   wouldEvolveCover(grp, newVal)          â€” Check if change evolves cover
//   getCoverPersistenceStatus(grp, newVal) â€” Full persistence status
//   clearStoryForNewStart()                â€” Destroys story AND cover
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER PERSISTENCE MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The cover is the story's face.
// Destroy the story, destroy the face.
// Change the arousal, change the expression â€” not the face.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    BUTTON SYSTEM LOCK (AUTHORITATIVE)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// All buttons in Storybound derive their material from .sb-btn.
// This is a SYSTEMIC LOCK, not a style preference.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MATERIAL LOCK (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// MATERIAL IS IDENTITY.
// These properties may NEVER be overridden by any state:
//   - background-color
//   - background-image
//   - border-radius (always 0)
//   - box-shadow (plaque system only)
//
// No hover, active, focus, disabled, paywalled, or JS-mutated state
// may change the material. Material is the button's physical identity.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE IS BEHAVIOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// State changes communicate via AFFORDANCE, not material:
//   âœ“ opacity
//   âœ“ contrast
//   âœ“ saturation
//   âœ“ filter brightness
//   âœ“ text color shift
//
// State changes may NEVER use:
//   âœ— new gradients
//   âœ— glow effects
//   âœ— background replacement
//   âœ— box-shadow halos
//   âœ— border-radius changes
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSS CLASSES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Base Class:
//   .sb-btn                    â€” Canonical button material (black plaque)
//
// Variants (hue/brightness only):
//   .sb-btn--gold              â€” Gold plaque variant
//   .sb-btn--black             â€” Explicit black (same as default)
//
// Sizes:
//   .sb-btn--sm                â€” Small (8px 20px)
//   .sb-btn--lg                â€” Large (14px 40px)
//   .sb-btn--xl                â€” Extra large (16px 48px)
//   .sb-btn--full              â€” Full width
//
// States (affordance-based):
//   .is-disabled               â€” Desaturated + reduced contrast
//   .is-paywalled              â€” Dimmed but still looks like a button
//   .is-loading                â€” Reduced opacity, cursor wait
//   .is-primary                â€” Slightly brighter
//   .is-warning                â€” Warm sepia tint
//   .is-danger                 â€” Desaturated with subtle red shift
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INLINE STYLE PURGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Inline styles on buttons that set material properties are FORBIDDEN:
//   âœ— style="background:..."
//   âœ— style="border:..."
//   âœ— style="box-shadow:..."
//   âœ— style="border-radius:..."
//
// Layout-only inline styles are ALLOWED:
//   âœ“ style="margin:..."
//   âœ“ style="position:..."
//   âœ“ style="width:..."
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JS MUTATION RULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// JavaScript may NEVER directly mutate button material properties.
// Instead, toggle semantic classes:
//   âœ“ element.classList.add('is-loading')
//   âœ“ element.classList.remove('is-paywalled')
//   âœ— element.style.background = '...'
//   âœ— element.style.boxShadow = '...'
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUTTON SYSTEM MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Storybound buttons are not UI elements.
// They are objects from the same world as the story.
//
// Material is identity.
// State is behavior.
//
// Never confuse the two.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRUST REPAIR PHASE 2 â€” COVER & VISUALIZATION (AUTHORITATIVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// This section documents the Trust Repair Phase 2 implementation for cover gallery
// and visualization flows, ensuring users never feel deceived or manipulated.
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. COVER GALLERY â†’ STAGE TRANSFORMATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// The Cover Gallery is no longer a carousel. It is now a STAGE.
//
// Layout rules (LOCKED):
//   - Central cover dominates: 320Ã—450px, left spine border, prominent shadow
//   - Thumbnails demoted to footer strip: 60Ã—85px, 50% opacity
//   - Selected thumbnail receives active state (opacity 1, gold border)
//   - Action buttons below thumbnails, never competing with cover
//
// Visual hierarchy (ALTAR, NOT SHELF):
//   - The book is the altar object â€” user is looking AT it, not shopping FROM it
//   - Thumbnails are memory, not merchandise
//   - Navigation is secondary to contemplation
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2. VISUALIZATION FLOW â€” MODAL-FIRST CONSENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: User clicks Visualize, gets redirected to paywall without seeing prompt.
// Trust repair: ALWAYS open modal first, show prompt, then request consent if needed.
//
// Flow (LOCKED):
//   1. User clicks Visualize
//   2. Modal opens immediately
//   3. Prompt is populated and visible
//   4. If credits depleted and not subscribed:
//      - Show consent UI INSIDE modal (not separate paywall)
//      - User can see what they would get before committing
//   5. Only after consent does generation proceed
//
// Functions:
//   - window.visualize(regenerate) â€” Main entry, modal-first
//   - window.enablePayAsYouGoFromViz() â€” Consent handler inside modal
//   - populateVizPromptOnly() â€” Shows prompt without generating
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3. MODIFIER VALIDATION â€” AROUSAL-BASED RESTRICTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: User enters disallowed modifier, gets silent failure or weird result.
// Trust repair: Explicit rejection with clear message explaining why.
//
// Validation rules:
//   - Clean arousal: Blocks explicit body parts, lingerie, nudity, fetish terms
//   - Naughty arousal: Blocks explicit nudity, graphic content
//   - Spicy arousal: No restrictions
//
// Functions:
//   - validateModifier(modifier, arousalLevel) â€” Returns { valid, message }
//   - showModifierRejection(message) â€” Displays rejection UI
//   - AROUSAL_RESTRICTED_MODIFIERS â€” Pattern map by arousal level
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4. WORLD+TONE STYLE LOCK
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: Modifiers override World+Tone visual style, causing inconsistency.
// Trust repair: World+Tone ALWAYS determines base visual style, modifiers can only
//               adjust details within that style, never replace it.
//
// Style derivation (DETERMINISTIC):
//   - getStyleLock(world, tone) â†’ Returns locked style string
//   - WORLD_DEFAULT_STYLES: Modernâ†’photographic, Fantasyâ†’illustrative, etc.
//   - TONE_STYLE_OVERRIDES: Wry Confessionalâ†’sketch, Ink Noirâ†’sketch, etc.
//
// Enforcement:
//   - validateStyleLock(prompt, styleLock) â€” Strips conflicting style modifiers
//   - Style lock text prepended to every visualization prompt
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5. SKETCH TIER ENFORCEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: "Sketch" tier looks polished and finished.
// Trust repair: Sketch tier enforces visible incompleteness in execution.
//
// Tones requiring sketch tier:
//   - Wry Confessional, Satire, Irony, Ink Noir
//
// Required characteristics:
//   - Pencil, ink, or charcoal texture visible
//   - Uneven or broken linework
//   - Partial fill or restrained color (2-3 tones max)
//   - Visible construction lines or negative space
//
// Prohibited:
//   - Cinematic lighting, painterly shading, smooth gradients
//   - Finished illustration look, professional polish
//   - Hyper-realistic rendering
//
// Functions:
//   - requiresSketchTier(tone) â€” Boolean check
//   - getSketchTierEnforcement(tone) â€” Returns enforcement text for prompts
//   - SKETCH_TIER_ENFORCEMENT â€” Constant with full enforcement text
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FAILURE CONDITIONS (REGRESSION TESTS)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// These conditions must NEVER occur:
//
// âœ“ "Visualize never opens a paywall modal" â€” Modal always opens first
// âœ“ "Prompt is always visible before consent" â€” Consent UI inside modal
// âœ“ "Modifiers no longer derail style" â€” Style lock validates all prompts
// âœ“ "Disallowed modifiers are explicitly rejected" â€” Clear error messages
// âœ“ "Central cover visually dominates gallery" â€” Stage layout enforced
// âœ“ "Thumbnails no longer compete" â€” Demoted to footer strip
// âœ“ "Sketch tier is visibly unfinished" â€” Enforcement text in prompts
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

})();

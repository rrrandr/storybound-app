// Wait for Supabase SDK to be available before using it
async function waitForSupabaseSDK(timeoutMs = 2000) {
  const start = Date.now();
  while (
    !(window.supabase && typeof window.supabase.createClient === 'function') &&
    (Date.now() - start) < timeoutMs
  ) {
    await new Promise(r => setTimeout(r, 25));
  }
  return window.supabase || null;
}
(async function(){
  let tempImgUrl = null;
  // --- CONFIG ---
  let config = {};
  try {
      const res = await fetch('/api/config', { cache: 'no-store' });
      if (res.ok) config = await res.json();
  } catch (e) { 
      console.warn("Config load failed (using defaults)", e); 
  }

  const SUPABASE_URL = config.supabaseUrl || "";
  const SUPABASE_ANON_KEY = config.supabaseAnonKey || "";
  const CURRENT_TOS_VERSION = '2.0.0';
  const CURRENT_PRIVACY_VERSION = '2.0.0';
  const CURRENT_ADULT_ACK_VERSION = '1.0.0';
  const LEGAL = {
    TOS_VERSION: 2,
    PRIVACY_VERSION: 2,
    ADULT_ACK_VERSION: 2
  };
  // Use local proxy by default (requires XAI_API_KEY env var)
  // Falls back to external proxy if explicitly configured
  const PROXY_URL = config.proxyUrl || '/api/proxy';
  // Image requests always use local /api/image endpoint (never proxy)
  var IMAGE_PROXY_URL = '/api/image';

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”¬ STORYPASS INSTRUMENTATION â€” Trace UI visibility for debugging
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function initStorypassInstrumentation() {
    const STORYPASS_PATTERN = /storypass/i;
    let observerActive = false;

    function dumpState(context) {
      const state = window.state || {};
      console.group(`ğŸ”¬ [STORYPASS TRACE] ${context}`);
      console.log('storypassEligible:', state.storypassEligible);
      console.log('storyId:', state.storyId);
      console.log('intensity:', state.intensity);
      console.log('storyLength:', state.storyLength);
      console.log('getPaywallMode():', typeof window.getPaywallMode === 'function' ? window.getPaywallMode() : 'NOT DEFINED');
      console.log('Stack trace:');
      console.trace();
      console.groupEnd();
    }

    function checkNodeForStorypass(node, action) {
      if (!node || node.nodeType !== Node.ELEMENT_NODE) return;

      // Check text content
      const text = node.textContent || '';
      if (STORYPASS_PATTERN.test(text)) {
        // Check if this element or its container is visible
        const isVisible = node.offsetParent !== null ||
                          getComputedStyle(node).display !== 'none';

        console.warn(`ğŸ”¬ [STORYPASS] "${action}" detected in: `, node);
        console.log('Text content:', text.substring(0, 100));
        console.log('Element visible:', isVisible);
        console.log('Element classes:', node.className);
        console.log('Element ID:', node.id);
        console.log('Parent chain:', getParentChain(node));
        dumpState(action);
      }
    }

    function getParentChain(el, depth = 5) {
      const chain = [];
      let current = el;
      for (let i = 0; i < depth && current && current !== document.body; i++) {
        chain.push({
          tag: current.tagName,
          id: current.id || '(none)',
          class: current.className || '(none)',
          hidden: current.classList?.contains('hidden') || false
        });
        current = current.parentElement;
      }
      return chain;
    }

    function handleMutation(mutations) {
      for (const mutation of mutations) {
        // Check added nodes
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach(node => {
            checkNodeForStorypass(node, 'NODE INSERTED');
            // Also check children
            if (node.querySelectorAll) {
              node.querySelectorAll('*').forEach(child => {
                checkNodeForStorypass(child, 'CHILD INSERTED');
              });
            }
          });
        }

        // Check class changes (hidden â†’ visible)
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const target = mutation.target;
          const wasHidden = mutation.oldValue?.includes('hidden');
          const isNowVisible = !target.classList.contains('hidden');

          if (wasHidden && isNowVisible) {
            checkNodeForStorypass(target, 'CLASS CHANGE (hidden â†’ visible)');
          }
        }
      }
    }

    // Start observing when DOM is ready
    function startObserver() {
      if (observerActive) return;
      observerActive = true;

      const observer = new MutationObserver(handleMutation);
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['class'],
        attributeOldValue: true
      });

      console.log('ğŸ”¬ [STORYPASS] MutationObserver active - watching for StoryPass UI');

      // Also check existing elements on page load
      document.querySelectorAll('*').forEach(el => {
        const text = el.textContent || '';
        if (STORYPASS_PATTERN.test(text) && el.id) {
          console.log('ğŸ”¬ [STORYPASS] Pre-existing element with StoryPass text:', el.id, el.className);
        }
      });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startObserver);
    } else {
      startObserver();
    }

    // Expose manual trigger for debugging
    window._traceStorypass = dumpState;
  })();
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // =============================================================================
  // AI ORCHESTRATION CONFIGURATION
  // =============================================================================
  /**
   * AUTHORITATIVE â€” DO NOT REINTERPRET
   *
   * Storybound uses MULTIPLE AI models with STRICT SEPARATION OF AUTHORITY:
   *
   * 1. ChatGPT (PRIMARY AUTHOR â€” ALWAYS CALLED)
   *    - ONLY model allowed to author plot progression
   *    - ONLY model allowed to determine if intimacy occurs
   *    - ONLY model allowed to enforce monetization gates
   *    - ONLY model allowed to generate Scene Directives (SD)
   *    - Runs BEFORE any specialist renderer
   *    - Runs AFTER any specialist renderer (integration pass)
   *    - FINAL AUTHORITY on story state
   *
   * 2. Specialist Renderer (Grok) â€” CONDITIONAL
   *    - Purpose: Sensory embodiment ONLY
   *    - May ONLY receive a fully-specified SD
   *    - May NEVER decide plot, invent lore, or change outcomes
   *    - NEVER decides "how far things go"
   *    - Renders HOW IT FEELS, within bounds
   *
   * 3. Fate Cards â€” Dual-Model Split
   *    - GPT-5.1: Structural authority (REQUIRED)
   *    - GPT-5.2: Linguistic elevation (OPTIONAL, discardable)
   *
   * DO NOT MERGE THESE RESPONSIBILITIES. The separation is intentional.
   *
   * ORCHESTRATION ORDER (NON-NEGOTIABLE):
   * 1. ChatGPT â€” Author Pass (plot, psychology, ESD generation)
   * 2. Specialist Renderer â€” OPTIONAL (sensory embodiment only)
   * 3. ChatGPT â€” Integration Pass (consequences, state, cliffhangers)
   */

  // Enable/disable orchestrated multi-model flow
  // When true: ChatGPT â†’ optional Grok â†’ ChatGPT
  // When false: Legacy single-model flow (Grok only)
  const ENABLE_ORCHESTRATION = true;

  // AUTHOR MODEL: ChatGPT is the ONLY model for story authoring
  // Grok must NEVER be used for DSP, normalization, veto, or story logic
  // Legacy STORY_MODEL removed - all story logic routes through ChatGPT orchestration 
  
  // Singleton Supabase Client
  let sb = null;
  let _supabaseProfileId = null; // Set by ensureAnonSession, used for snapshot persistence
  if (window.supabase && SUPABASE_URL.startsWith('http') && SUPABASE_ANON_KEY) {
    try {
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    } catch(e) { console.error("Supabase init error:", e); }
  } else {
    console.warn("Supabase not configured. Couple mode disabled.");
  }

  if(!sb) {
     const btnCouple = document.getElementById('btnCoupleMode');
     if(btnCouple){
         btnCouple.disabled = true;
         const desc = btnCouple.nextElementSibling;
         if(desc && desc.classList.contains('choice-desc')) {
             desc.textContent = "Unavailable on this deployment.";
         }
     }
  }
  // Telemetry â€” minimal event logging to Supabase
  async function logEvent(eventType, metadata = {}) {
      if (!sb || !_supabaseProfileId) return;
      try {
          await sb.from('user_events').insert({
              user_id: _supabaseProfileId,
              event_type: eventType,
              metadata
          });
      } catch (e) {
          console.warn('[Telemetry] Event log failed:', e);
      }
  }

  // Age confirmation â€” persist to Supabase profile then proceed
  document.getElementById('confirmAgeBtn')?.addEventListener('click', async () => {
    try {
      const { data: { user } } = await sb.auth.getUser();
      if (user?.id) {
        await sb
          .from('profiles')
          .update({ age_confirmed: true })
          .eq('id', user.id);
      }
    } catch (err) {
      console.error('[AGE] Failed to persist age confirmation:', err);
    }

    window.showScreen && window.showScreen('legalGate');
  });


  // Auth panel â€” sign in / sign up toggle
  let authMode = 'signin'; // 'signin' or 'signup'

  document.getElementById('auth-toggle-link')?.addEventListener('click', (e) => {
    e.preventDefault();
    const title = document.getElementById('auth-title');
    const btn = document.getElementById('btn-auth-submit');
    const link = document.getElementById('auth-toggle-link');
    const label = link?.previousElementSibling;
    const status = document.getElementById('auth-status');
    if (status) status.textContent = '';

    if (authMode === 'signin') {
      authMode = 'signup';
      if (title) title.textContent = 'Create Account';
      if (btn) btn.textContent = 'Create Account';
      if (label) label.textContent = 'Have an account?';
      if (link) link.textContent = 'Sign In';
    } else {
      authMode = 'signin';
      if (title) title.textContent = 'Sign In';
      if (btn) btn.textContent = 'Sign In';
      if (label) label.textContent = 'New user?';
      if (link) link.textContent = 'Create Account';
    }
  });

  // Auth submit â€” sign in or sign up based on current mode
  document.getElementById('auth-form')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('auth-email')?.value?.trim();
    const password = document.getElementById('auth-password')?.value;
    const status = document.getElementById('auth-status');

    if (!email || !password) {
      if (status) status.textContent = 'Email and password required.';
      return;
    }
    if (authMode === 'signup' && password.length < 6) {
      if (status) status.textContent = 'Password must be at least 6 characters.';
      return;
    }

    if (status) status.textContent = authMode === 'signin' ? 'Signing in...' : 'Creating account...';

    try {
      let data, error;
      if (authMode === 'signin') {
        ({ data, error } = await sb.auth.signInWithPassword({ email, password }));
      } else {
        ({ data, error } = await sb.auth.signUp({ email, password }));
      }

      if (error) {
        console.error(`[AUTH] ${authMode} failed:`, error.message);
        if (status) status.textContent = error.message;
        // Show reset password link on sign-in failure
        if (authMode === 'signin') {
          document.getElementById('auth-reset')?.classList.remove('hidden');
        }
        return;
      }

      if (authMode === 'signup' && data.user && !data.session) {
        // Email confirmation required
        if (status) status.textContent = 'Check your email to confirm your account.';
        console.log('[AUTH] Sign-up successful, confirmation email sent');
        return;
      }

      console.log(`[AUTH] ${authMode} successful:`, data.user?.id);
      document.getElementById('auth-panel')?.classList.add('hidden');
      location.reload();

    } catch (err) {
      console.error(`[AUTH] ${authMode} error:`, err);
      if (status) status.textContent = 'Something went wrong. Try again.';
    }
  });

  // Reset password handler
  document.getElementById('auth-reset-link')?.addEventListener('click', async (e) => {
    e.preventDefault();
    const email = document.getElementById('auth-email')?.value?.trim();
    const status = document.getElementById('auth-status');

    if (!email) {
      if (status) status.textContent = 'Enter your email above, then click Reset.';
      return;
    }

    if (status) status.textContent = 'Sending reset email...';

    try {
      const { error } = await sb.auth.resetPasswordForEmail(email, {
        redirectTo: window.location.origin
      });
      if (error) {
        if (status) status.textContent = error.message;
      } else {
        if (status) status.textContent = 'Password reset email sent. Check your inbox.';
      }
    } catch (err) {
      console.error('[AUTH] Reset password error:', err);
      if (status) status.textContent = 'Something went wrong. Try again.';
    }
  });

// GLOBAL CONFIG (TEMP â€“ UNTIL EXTERNALIZED CLEANLY)
window.config = window.config || {
  enableAncestry: true,
  enableStorybeau: true,
  enablePetitionFate: true,
  enablePillCycling: true,
  enableAdvancedUI: true
};

  // Presence Constants
  const PRESENCE_HEARTBEAT_MS = 15000;
  
  async function ensureAnonSession(){
    if(!sb) return null;
    const { data: { session } } = await sb.auth.getSession();
    if(session?.user?.id) return session.user.id;
    // Anonymous auto-login disabled â€” require real sign-in
    // const { data, error } = await sb.auth.signInAnonymously();
    // if(error) { console.error("Auth error:", error); return null; }
    // console.log("Supabase ready");
    // return data.user.id;
    return null;
  }

  const PROFILE_COLUMNS = `
    tier, subscription_fortunes, purchased_fortunes, is_subscriber, subscription_tier, has_storypass,
    age_confirmed, tos_version, privacy_version, adult_ack_version,
    romance_preferences, free_story_consumed, first_tempt_fate_vision_triggered
  `;

  async function hydrateProfile(userId) {
    let { data: profile, error } = await sb
      .from('profiles')
      .select(PROFILE_COLUMNS)
      .eq('id', userId)
      .maybeSingle();
    if (error) { console.error('Profile fetch error:', error); return null; }
    if (!profile) {
      const { error: insertErr } = await sb.from('profiles').insert({ id: userId });
      if (insertErr) { console.error('Profile insert error:', insertErr); return null; }
      const refetch = await sb.from('profiles').select(PROFILE_COLUMNS).eq('id', userId).single();
      if (refetch.error || !refetch.data) { console.error('Profile refetch error:', refetch.error); return null; }
      profile = refetch.data;
    }
    return profile;
  }

  function hydrateState(profile) {
    state.tier = profile.tier || 'free';
    state.subscribed = !!profile.is_subscriber;
    state.subscriptionTier = profile.subscription_tier || (state.subscribed ? 'storied' : null);
    state.hasPass = !!profile.has_storypass;
    state.fortunes = (profile.subscription_fortunes || 0) + (profile.purchased_fortunes || 0);
    if (window.updateFortuneDisplay) window.updateFortuneDisplay();
    state.romancePreferences = Array.isArray(profile.romance_preferences) ? profile.romance_preferences : [];
    state.romanceVector = computeRomanceVector(state.romancePreferences);
    state.freeStoryConsumed = !!profile.free_story_consumed;
    state.first_tempt_fate_vision_triggered = !!profile.first_tempt_fate_vision_triggered;
    syncTierFromAccess();
    activateKeyholeMarkIfEligible();
    decayFateResonanceCrossSession();
    console.log('Profile hydrated. Subscribed:', state.subscribed, '| Tier:', state.tier, '| Keyhole:', state.keyhole?.marked, '| Fortunes:', state.fortunes, '| Resonance:', getFateResonanceState());
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROMANCE PREFERENCES â€” Vector mapping + Profile UI
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const ROMANCE_TITLE_VECTORS = {
    'a court of thorns and roses':    { dominanceBias: 0.7, supernaturalBias: 0.9, slowBurnBias: 0.4, angstBias: 0.6, protectorBias: 0.8, eroticHeatBias: 0.7 },
    'the cruel prince':               { dominanceBias: 0.8, supernaturalBias: 0.9, slowBurnBias: 0.6, angstBias: 0.8, protectorBias: 0.3, eroticHeatBias: 0.4 },
    'from blood and ash':             { dominanceBias: 0.7, supernaturalBias: 0.8, slowBurnBias: 0.3, angstBias: 0.5, protectorBias: 0.9, eroticHeatBias: 0.8 },
    'the love hypothesis':            { dominanceBias: 0.2, supernaturalBias: 0.0, slowBurnBias: 0.7, angstBias: 0.3, protectorBias: 0.5, eroticHeatBias: 0.3 },
    'beach read':                     { dominanceBias: 0.1, supernaturalBias: 0.0, slowBurnBias: 0.5, angstBias: 0.4, protectorBias: 0.2, eroticHeatBias: 0.3 },
    'it ends with us':                { dominanceBias: 0.3, supernaturalBias: 0.0, slowBurnBias: 0.4, angstBias: 0.9, protectorBias: 0.6, eroticHeatBias: 0.4 },
    'ugly love':                      { dominanceBias: 0.4, supernaturalBias: 0.0, slowBurnBias: 0.3, angstBias: 0.8, protectorBias: 0.4, eroticHeatBias: 0.7 },
    'twisted love':                   { dominanceBias: 0.8, supernaturalBias: 0.0, slowBurnBias: 0.5, angstBias: 0.7, protectorBias: 0.8, eroticHeatBias: 0.6 },
    'the hating game':                { dominanceBias: 0.3, supernaturalBias: 0.0, slowBurnBias: 0.7, angstBias: 0.4, protectorBias: 0.3, eroticHeatBias: 0.4 },
    'outlander':                      { dominanceBias: 0.6, supernaturalBias: 0.5, slowBurnBias: 0.6, angstBias: 0.7, protectorBias: 0.9, eroticHeatBias: 0.7 },
    'the notebook':                   { dominanceBias: 0.2, supernaturalBias: 0.0, slowBurnBias: 0.8, angstBias: 0.7, protectorBias: 0.5, eroticHeatBias: 0.2 },
    'twilight':                       { dominanceBias: 0.6, supernaturalBias: 1.0, slowBurnBias: 0.7, angstBias: 0.6, protectorBias: 0.9, eroticHeatBias: 0.2 },
    'fifty shades of grey':           { dominanceBias: 1.0, supernaturalBias: 0.0, slowBurnBias: 0.1, angstBias: 0.5, protectorBias: 0.6, eroticHeatBias: 1.0 },
    'the bride':                      { dominanceBias: 0.5, supernaturalBias: 0.7, slowBurnBias: 0.5, angstBias: 0.4, protectorBias: 0.6, eroticHeatBias: 0.5 },
    'ice planet barbarians':          { dominanceBias: 0.6, supernaturalBias: 0.8, slowBurnBias: 0.2, angstBias: 0.2, protectorBias: 1.0, eroticHeatBias: 0.9 },
    'haunting adeline':               { dominanceBias: 1.0, supernaturalBias: 0.1, slowBurnBias: 0.2, angstBias: 0.8, protectorBias: 0.3, eroticHeatBias: 1.0 },
    'kingdom of the wicked':          { dominanceBias: 0.7, supernaturalBias: 0.9, slowBurnBias: 0.5, angstBias: 0.6, protectorBias: 0.4, eroticHeatBias: 0.6 },
    'the spanish love deception':     { dominanceBias: 0.2, supernaturalBias: 0.0, slowBurnBias: 0.6, angstBias: 0.3, protectorBias: 0.4, eroticHeatBias: 0.3 },
    'fourth wing':                    { dominanceBias: 0.6, supernaturalBias: 0.8, slowBurnBias: 0.4, angstBias: 0.5, protectorBias: 0.7, eroticHeatBias: 0.7 },
    'the kiss quotient':              { dominanceBias: 0.2, supernaturalBias: 0.0, slowBurnBias: 0.6, angstBias: 0.3, protectorBias: 0.4, eroticHeatBias: 0.5 },
    'pride and prejudice':            { dominanceBias: 0.3, supernaturalBias: 0.0, slowBurnBias: 1.0, angstBias: 0.5, protectorBias: 0.3, eroticHeatBias: 0.0 },
    'the duke and i':                 { dominanceBias: 0.5, supernaturalBias: 0.0, slowBurnBias: 0.6, angstBias: 0.4, protectorBias: 0.5, eroticHeatBias: 0.5 },
    'bound by hatred':                { dominanceBias: 0.9, supernaturalBias: 0.0, slowBurnBias: 0.3, angstBias: 0.9, protectorBias: 0.2, eroticHeatBias: 0.8 },
    'credence':                       { dominanceBias: 0.7, supernaturalBias: 0.0, slowBurnBias: 0.4, angstBias: 0.8, protectorBias: 0.3, eroticHeatBias: 0.9 },
    'punk 57':                        { dominanceBias: 0.5, supernaturalBias: 0.0, slowBurnBias: 0.5, angstBias: 0.7, protectorBias: 0.4, eroticHeatBias: 0.6 }
  };

  // Known titles for autocomplete suggestions
  const ROMANCE_KNOWN_TITLES = Object.keys(ROMANCE_TITLE_VECTORS).map(t =>
    t.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')
  );

  function computeRomanceVector(preferencesArray) {
    if (!Array.isArray(preferencesArray) || preferencesArray.length === 0) return null;

    const axes = ['dominanceBias', 'supernaturalBias', 'slowBurnBias', 'angstBias', 'protectorBias', 'eroticHeatBias'];
    const sums = {};
    let matchCount = 0;
    axes.forEach(a => { sums[a] = 0; });

    for (const title of preferencesArray) {
      const key = (title || '').toLowerCase().trim();
      const vec = ROMANCE_TITLE_VECTORS[key];
      if (!vec) continue;
      matchCount++;
      axes.forEach(a => { sums[a] += (vec[a] || 0); });
    }

    if (matchCount === 0) return null;

    // Cap each axis at 1.0, then normalize if any exceeded 1
    axes.forEach(a => { sums[a] = Math.min(sums[a], 1); });
    const maxVal = Math.max(...axes.map(a => sums[a]));
    const result = {};
    if (maxVal > 1) {
      axes.forEach(a => { result[a] = sums[a] / maxVal; });
    } else {
      axes.forEach(a => { result[a] = sums[a]; });
    }
    return result;
  }

  // Archetype-to-romance-axis mapping with max modifiers (Part 5)
  const ARCHETYPE_AXIS_MAP = {
    HEART_WARDEN:   { axis: 'protectorBias',    maxMod: 0.25 },
    OPEN_VEIN:      { axis: 'angstBias',        maxMod: 0.20 },
    SPELLBINDER:    { axis: 'supernaturalBias', maxMod: 0.35 },
    ARMORED_FOX:    { axis: 'slowBurnBias',     maxMod: 0.25 },
    DARK_VICE:      { axis: 'dominanceBias',    maxMod: 0.30 },
    BEAUTIFUL_RUIN: { axis: 'angstBias',        maxMod: 0.20 },
    ETERNAL_FLAME:  { axis: 'slowBurnBias',     maxMod: 0.25 }
  };

  function weightedArchetypeSelection() {
    const v = state.romanceVector;
    if (!v) return ARCHETYPE_ORDER[Math.floor(Math.random() * ARCHETYPE_ORDER.length)];

    const weights = ARCHETYPE_ORDER.map(id => {
      const baseWeight = 1;
      const mapping = ARCHETYPE_AXIS_MAP[id];
      if (!mapping) return baseWeight;
      const axisVal = v[mapping.axis] || 0;
      const influence = axisVal * mapping.maxMod;
      return Math.min(baseWeight * (1 + influence), baseWeight * 2);
    });

    const totalWeight = weights.reduce((s, w) => s + w, 0);
    let roll = Math.random() * totalWeight;
    for (let i = 0; i < weights.length; i++) {
      roll -= weights[i];
      if (roll <= 0) return ARCHETYPE_ORDER[i];
    }
    return ARCHETYPE_ORDER[ARCHETYPE_ORDER.length - 1];
  }

  function buildRomanceVectorDirective() {
    const v = state.romanceVector;
    if (!v) return '';

    // Dynamic Dominance Drift â€” runtime boost from cautious equilibrium pull
    // Does NOT mutate baseDominance. Applied only to emitted directive.
    let effectiveDominance = v.dominanceBias;
    const dddBoost = state.dynamicDominanceBoost || 0;
    // Safety guards: suppress boost under sensitive conditions
    const suppressDDD = (state.edgeCovenant?.active)
        || (state.picks?.tone === 'WryConfession' && state.picks?.world === 'Modern');
    if (!suppressDDD && dddBoost > 0) {
      effectiveDominance = Math.min(1.0, effectiveDominance + dddBoost);
    }

    // Vulnerability Pulse â€” halve dominance boost when vulnerability detected
    if (state.vulnerabilityPulse && dddBoost > 0 && !suppressDDD) {
      effectiveDominance = Math.min(1.0, effectiveDominance - dddBoost * 0.5);
    }

    let block = `USER ROMANCE PREFERENCE VECTOR (subtle tonal bias only â€” do NOT override user selections, safety filters, or eroticMode classification):
  dominanceBias: ${effectiveDominance.toFixed(2)}
  supernaturalBias: ${v.supernaturalBias.toFixed(2)}
  slowBurnBias: ${v.slowBurnBias.toFixed(2)}
  angstBias: ${v.angstBias.toFixed(2)}
  protectorBias: ${v.protectorBias.toFixed(2)}
  eroticHeatBias: ${v.eroticHeatBias.toFixed(2)}
Favor these tonal biases subtly in character behavior and narrative texture.`;

    const nudges = [];
    if (effectiveDominance > 0.6) nudges.push('Increase decisive, directive phrasing in Love Interest dialogue by 10-20%.');
    if (v.slowBurnBias > 0.6)    nudges.push('Increase interior monologue, restraint, and delayed gratification.');
    if (v.protectorBias > 0.6)   nudges.push('Increase protective physical framing â€” shielding gestures, positioning, vigilance.');
    if (v.angstBias > 0.6)       nudges.push('Increase emotional tension, vulnerability, and internal conflict.');
    if (v.eroticHeatBias > 0.6)  nudges.push('Slightly increase sensual pacing and tactile awareness (obey eroticMode limits).');
    if (nudges.length > 0) block += '\nTonal nudges:\n' + nudges.map(n => '- ' + n).join('\n');
    block += '\nDo NOT mention book titles in prose. Do NOT override archetype after user selection. Do NOT alter Fortune or Tempt Fate mechanics.';

    // Vulnerability Pulse â€” reward emotional risk with proximity (single-player only)
    if (state.mode !== 'couple' && state.vulnerabilityPulse === 1) {
      block += '\nRespond to vulnerability with increased proximity and emotional intensity.\nDo not withdraw or deflect.\nAllow connection to feel rewarded.';
    }

    return block;
  }

  // Romance Preferences UI logic (profile modal)
  function initRomancePrefsUI() {
    const input = document.getElementById('romancePrefInput');
    const tagsEl = document.getElementById('romancePrefTags');
    const suggestEl = document.getElementById('romancePrefSuggest');
    const saveBtn = document.getElementById('romancePrefSaveBtn');
    const statusEl = document.getElementById('romancePrefStatus');
    if (!input || !tagsEl || !saveBtn) return;

    let selected = [...(state.romancePreferences || [])];

    function renderTags() {
      tagsEl.innerHTML = selected.map((t, i) =>
        `<span style="display:inline-flex;align-items:center;gap:4px;background:#333;color:#eee;padding:2px 8px;border-radius:12px;font-size:0.8em;">${t}<span data-rm="${i}" style="cursor:pointer;color:#999;margin-left:2px;">Ã—</span></span>`
      ).join('');
      tagsEl.querySelectorAll('[data-rm]').forEach(x => {
        x.onclick = () => { selected.splice(+x.dataset.rm, 1); renderTags(); };
      });
    }

    function showSuggestions(query) {
      if (!query || query.length < 2) { suggestEl.style.display = 'none'; return; }
      const q = query.toLowerCase();
      const matches = ROMANCE_KNOWN_TITLES.filter(t =>
        t.toLowerCase().includes(q) && !selected.some(s => s.toLowerCase() === t.toLowerCase())
      ).slice(0, 6);
      if (matches.length === 0) { suggestEl.style.display = 'none'; return; }
      suggestEl.innerHTML = matches.map(m =>
        `<div class="romance-suggest-item" style="padding:5px 8px;cursor:pointer;color:#ccc;border-bottom:1px solid #333;">${m}</div>`
      ).join('');
      suggestEl.style.display = 'block';
      suggestEl.querySelectorAll('.romance-suggest-item').forEach(el => {
        el.onmousedown = (e) => {
          e.preventDefault();
          if (selected.length < 5) { selected.push(el.textContent.trim()); renderTags(); }
          input.value = '';
          suggestEl.style.display = 'none';
        };
      });
    }

    input.addEventListener('input', () => showSuggestions(input.value));
    input.addEventListener('blur', () => { setTimeout(() => { suggestEl.style.display = 'none'; }, 150); });
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const val = input.value.trim();
        if (val && selected.length < 5 && !selected.some(s => s.toLowerCase() === val.toLowerCase())) {
          selected.push(val);
          renderTags();
        }
        input.value = '';
        suggestEl.style.display = 'none';
      }
    });

    saveBtn.onclick = async () => {
      statusEl.textContent = 'Savingâ€¦';
      state.romancePreferences = [...selected];
      state.romanceVector = computeRomanceVector(selected);
      try {
        const user = sb.auth.getUser ? (await sb.auth.getUser()).data?.user : null;
        if (user) {
          await sb.from('profiles').update({ romance_preferences: selected }).eq('id', user.id);
        }
        statusEl.textContent = 'Saved!';
        setTimeout(() => { statusEl.textContent = ''; }, 2000);
      } catch (err) {
        console.error('[ROMANCE_PREFS] Save failed:', err);
        statusEl.textContent = 'Save failed.';
      }
    };

    renderTags();
  }

  // Initialize romance prefs UI when profile modal opens
  const _origOpenProfile = openProfileModal;
  function openProfileModalWithPrefs() {
    _origOpenProfile();
    initRomancePrefsUI();
  }
  window.openProfileModal = openProfileModalWithPrefs;

  function activateKeyholeMarkIfEligible() {
    if (!state.keyhole) return;
    const isFavored = state.subscriptionTier === 'favored';
    // Couple mode: if either player is Favored, both get marked
    const coupleOverride = state.mode === 'couple' && (state.roomAccess === 'sub' || state.subscribed) && state.subscriptionTier === 'favored';
    if (isFavored || coupleOverride) {
      state.keyhole.marked = true;
      if (state.keyhole.favorReservoir === 0) state.keyhole.favorReservoir = 30;
      state.keyhole.regenPerTurn = 5;
    } else {
      state.keyhole.marked = false;
    }
  }

  function regenerateKeyholeReservoir() {
    const kh = state.keyhole;
    if (!kh || !kh.marked) return;
    let regen = kh.regenPerTurn;
    // Alignment bonus
    if (kh.alignmentScore > 50) regen += 3;
    else if (kh.alignmentScore < -50) regen -= 2;
    // Orientation bonus
    if (kh.orientation === 'open') regen += 2;
    else if (kh.orientation === 'closed') regen = Math.floor(regen / 2);
    // Seasonal noise â€” prevents clockwork refill
    const noise = Math.floor(Math.random() * 3) - 1; // -1, 0, +1
    regen = Math.max(2, regen + noise);
    kh.favorReservoir = Math.min(kh.maxFavor, kh.favorReservoir + regen);
  }

  function maybeShiftKeyholeOrientation() {
    const kh = state.keyhole;
    if (!kh || !kh.marked) return;
    const turnsSinceShift = state.turnCount - kh.lastOrientationShift;
    if (turnsSinceShift < 3) return;
    // Stochastic shift: 15% chance per eligible turn
    if (Math.random() > 0.15) return;
    kh.lastOrientationShift = state.turnCount;
    if (kh.alignmentScore > 30) {
      kh.orientation = 'open';
    } else if (kh.alignmentScore < -30) {
      kh.orientation = 'closed';
    } else {
      kh.orientation = 'neutral';
    }
  }

  function updateKeyholeAlignment(outcome) {
    const kh = state.keyhole;
    if (!kh || !kh.marked) return;
    if (outcome === 'benevolent') kh.alignmentScore += 3;
    if (outcome === 'twist') kh.alignmentScore -= 3;
    kh.alignmentScore = Math.max(-100, Math.min(100, kh.alignmentScore));
  }

  // ============================================================
  // FORTUNE'S FAVOR â€” story-scoped bonus Tempt Fate charges
  // ============================================================
  // HARD CONSTRAINTS:
  // - Does NOT add entropy axes
  // - Does NOT modify Fate mechanics, volatility, Storyturn logic
  // - Does NOT alter existing Tempt Fate behavior
  // - Does NOT inflate Fortune economy globally
  // - Does NOT create permanent stacking exploits
  // - Rewards are story-scoped except universal bonus (account-level)
  // ============================================================

  function initializeFortuneFavor() {
    const flavor = state.picks?.worldSubtype;
    if (!flavor || !MONTHLY_FORTUNE_FAVOR.spotlightFlavors.includes(flavor)) {
      state.fortuneFavor = null;
      return;
    }
    // Guard: if fortuneFavor already initialized for this story, do not reinitialize
    if (state.fortuneFavor && state.fortuneFavor.monthKey) return;

    // Restore scene5Granted from cache if same storyId (restart anti-farming)
    const cachedScene5 = state.storyId ? (state._fortuneFavorScene5Cache || false) : false;

    state.fortuneFavor = {
      eligible: true,
      unlocked: false,
      used: false,
      universalGranted: false,
      scene5Granted: cachedScene5,
      monthKey: MONTHLY_FORTUNE_FAVOR.monthKey
    };
    state._fortuneFavorScene5Cache = false; // consumed
    console.log(`[FORTUNE_FAVOR] Initialized. Flavor: ${flavor}, Month: ${MONTHLY_FORTUNE_FAVOR.monthKey}${cachedScene5 ? ', Scene5 already granted (restart)' : ''}`);
  }

  function checkFortuneFavorSceneUnlock() {
    const ff = state.fortuneFavor;
    if (!ff || !ff.eligible || ff.unlocked) return;
    // monthKey guard: no retroactive grants if spotlight rotated mid-story
    if (ff.monthKey !== MONTHLY_FORTUNE_FAVOR.monthKey) return;
    // Per-story anti-farming guard: one Scene 5 grant per story (persists through restart)
    if (ff.scene5Granted) return;
    const sceneCount = state.turnCount || 0;
    if (sceneCount >= 5) {
      ff.unlocked = true;
      ff.scene5Granted = true;
      console.log('[FORTUNE_FAVOR] Scene 5 reached â€” +1 spotlight Tempt charge unlocked (story-scoped)');
      showScene5HeavensOverlay();
    }
  }

  function checkFortuneFavorWordReward() {
    const ff = state.fortuneFavor;
    if (!ff || !ff.eligible || ff.universalGranted) return;
    // monthKey guard
    if (ff.monthKey !== MONTHLY_FORTUNE_FAVOR.monthKey) return;
    const wc = typeof currentStoryWordCount === 'function' ? currentStoryWordCount() : 0;
    if (wc >= 10000) {
      ff.universalGranted = true;
      state.bonus_tempt_charges = (state.bonus_tempt_charges || 0) + 1;
      console.log(`[FORTUNE_FAVOR] 10k words reached â€” +1 universal Tempt charge granted (total: ${state.bonus_tempt_charges})`);
      show10kHeavensOverlay();
    }
  }

  function consumeFortuneFavorCharge() {
    // Returns true if a free charge was consumed (spotlight first, then universal)
    const ff = state.fortuneFavor;
    // Story-scoped spotlight charge (consumed first)
    if (ff && ff.unlocked && !ff.used && ff.monthKey === MONTHLY_FORTUNE_FAVOR.monthKey) {
      ff.used = true;
      console.log('[FORTUNE_FAVOR] Spotlight Tempt charge consumed (story-scoped)');
      return true;
    }
    // Account-level universal bonus charge
    if ((state.bonus_tempt_charges || 0) > 0) {
      state.bonus_tempt_charges--;
      console.log(`[FORTUNE_FAVOR] Universal Tempt charge consumed (remaining: ${state.bonus_tempt_charges})`);
      return true;
    }
    return false;
  }

  // ============================================================
  // FORTUNE'S FAVOR PRELUDE â€” DSP entry overlay (World stage)
  // ============================================================
  // Visual-only. No state changes. No economy. No mechanics.
  // Self-cleaning overlay with auto-fade and scroll dismiss.
  // ============================================================

  let _fortunePreludeShown = false; // gate: one show per corridor visit

  function showFortuneFavorPrelude() {
    // Only show once per DSP visit
    if (_fortunePreludeShown) return;
    _fortunePreludeShown = true;

    // Build spotlight flavor labels
    const flavorLabels = MONTHLY_FORTUNE_FAVOR.spotlightFlavors
      .map(f => WORLD_LABELS[f] || f)
      .map(label => `<span class="ff-prelude-flavor">\u2014 ${label}</span>`)
      .join('');

    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'ff-prelude-overlay';
    overlay.innerHTML = `
      <div class="ff-prelude-content">
        <button class="ff-prelude-close" aria-label="Close">&times;</button>
        <div class="ff-prelude-title">FORTUNE'S FAVOR</div>
        <div class="ff-prelude-body">
          <p>Each month, Fate watches a few worlds more closely.</p>
          <p>Begin there, and a Whisper of power will awaken after Scene Five.<br>
          Go far enough, and Fate may follow you anywhere.</p>
          <p class="ff-prelude-label">This month, Fortune lingers in:</p>
          <div class="ff-prelude-flavors">${flavorLabels}</div>
        </div>
        <button class="ff-prelude-proceed">Proceed</button>
      </div>
    `;

    document.body.appendChild(overlay);

    // Staggered fade-in
    requestAnimationFrame(() => {
      overlay.classList.add('ff-prelude-visible');
      const title = overlay.querySelector('.ff-prelude-title');
      const body = overlay.querySelector('.ff-prelude-body');
      if (title) setTimeout(() => title.classList.add('ff-prelude-text-visible'), 300);
      if (body) setTimeout(() => body.classList.add('ff-prelude-text-visible'), 600);
    });

    // Dismiss only via Proceed button or X close
    let dismissed = false;
    const dismiss = () => {
      if (dismissed) return;
      dismissed = true;
      overlay.classList.remove('ff-prelude-visible');
      overlay.classList.add('ff-prelude-fading');
      setTimeout(() => {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        markSpotlightCards();
      }, 350);
    };

    overlay.querySelector('.ff-prelude-close').addEventListener('click', dismiss);
    overlay.querySelector('.ff-prelude-proceed').addEventListener('click', dismiss);
  }

  function resetFortuneFavorPrelude() {
    _fortunePreludeShown = false;
  }

  // PART 4 â€” Spotlight card marking (subtle star glyph)
  function markSpotlightCards() {
    const spotlights = new Set(MONTHLY_FORTUNE_FAVOR.spotlightFlavors);
    document.querySelectorAll('.sb-card[data-grp="worldSubtype"], .sb-card[data-grp="world"]').forEach(card => {
      // Remove existing marks
      card.querySelectorAll('.ff-spotlight-mark').forEach(m => m.remove());
      const val = card.dataset.val;
      if (val && spotlights.has(val)) {
        const mark = document.createElement('span');
        mark.className = 'ff-spotlight-mark';
        mark.textContent = '\u2727'; // white four-pointed star
        card.appendChild(mark);
      }
    });
  }

  // ============================================================
  // TEMPT FATE COSMIC SPARKLE â€” bonus charge UX (visual only)
  // ============================================================
  // No mechanic mutation. No economy logic. No Fate logic.
  // Sparkle activates when bonus charges are available.
  // ============================================================

  const _TF_MICROCOPY_LINES = [
    'Power waits.',
    'The heavens are listening.',
    'The universe tilts toward you.',
    'The stars lean closer.',
    'Fate is already in motion.',
    'Something vast stirs.'
  ];

  function _hasAnyBonusCharge() {
    const ff = state.fortuneFavor;
    const hasSpotlight = ff && ff.unlocked && !ff.used && ff.monthKey === MONTHLY_FORTUNE_FAVOR.monthKey;
    const hasUniversal = (state.bonus_tempt_charges || 0) > 0;
    return hasSpotlight || hasUniversal;
  }

  function updateTemptFateSparkle() {
    // Do not activate sparkle while heavens overlay is visible (sequencing guard)
    if (_heavensOverlayActive) return;
    const btn = document.querySelector('.meta-stance[onclick="window.setMetaStance(\'seduce\')"]');
    if (!btn) return;
    if (_hasAnyBonusCharge()) {
      if (!btn.classList.contains('tempt-fate-sparkle')) {
        btn.classList.add('tempt-fate-sparkle');
        // Add flare element if missing
        if (!btn.querySelector('.tf-flare')) {
          const flare = document.createElement('span');
          flare.className = 'tf-flare';
          btn.appendChild(flare);
        }
        // Add microcopy element if missing
        if (!btn.querySelector('.tf-microcopy')) {
          const mc = document.createElement('span');
          mc.className = 'tf-microcopy';
          mc.textContent = _TF_MICROCOPY_LINES[Math.floor(Math.random() * _TF_MICROCOPY_LINES.length)];
          btn.appendChild(mc);
        }
        // Randomize microcopy on each hover
        btn.addEventListener('mouseenter', _randomizeTemptMicrocopy);
        // Mobile tap-hold
        btn.addEventListener('touchstart', _temptTapHoldStart, { passive: true });
        btn.addEventListener('touchend', _temptTapHoldEnd, { passive: true });
      }
    } else {
      if (btn.classList.contains('tempt-fate-sparkle')) {
        btn.classList.remove('tempt-fate-sparkle');
        const flare = btn.querySelector('.tf-flare');
        if (flare) flare.remove();
        const mc = btn.querySelector('.tf-microcopy');
        if (mc) mc.remove();
        btn.removeEventListener('mouseenter', _randomizeTemptMicrocopy);
        btn.removeEventListener('touchstart', _temptTapHoldStart);
        btn.removeEventListener('touchend', _temptTapHoldEnd);
      }
    }
  }

  function _randomizeTemptMicrocopy() {
    const mc = this.querySelector('.tf-microcopy');
    if (mc) mc.textContent = _TF_MICROCOPY_LINES[Math.floor(Math.random() * _TF_MICROCOPY_LINES.length)];
  }

  let _temptTapTimer = null;
  function _temptTapHoldStart() {
    const btn = this;
    _temptTapTimer = setTimeout(() => {
      btn.classList.add('tf-tap-active');
      _randomizeTemptMicrocopy.call(btn);
    }, 400);
  }
  function _temptTapHoldEnd() {
    clearTimeout(_temptTapTimer);
    this.classList.remove('tf-tap-active');
  }

  // Heavens overlay gate â€” prevents sparkle from activating during overlay
  let _heavensOverlayActive = false;

  // Heavens overlay â€” shared utility for Scene 5 and 10k word reveals
  // Persists until user clicks the X close button.
  function _showHeavensOverlay(lines, delayBetween) {
    _heavensOverlayActive = true;
    state.heavensOverlayOpen = true;
    const overlay = document.createElement('div');
    overlay.className = 'tf-heavens-overlay';

    // Close button
    const closeBtn = document.createElement('button');
    closeBtn.className = 'sb-btn-png sm tf-heavens-close-btn';
    closeBtn.setAttribute('aria-label', 'Close');
    closeBtn.textContent = 'Close';
    closeBtn.addEventListener('click', function () {
      lineEls.forEach(el => {
        el.classList.remove('tf-heavens-visible');
        el.classList.add('tf-heavens-fading');
      });
      closeBtn.classList.add('tf-heavens-fading');
      setTimeout(() => {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        _heavensOverlayActive = false;
        state.heavensOverlayOpen = false;
        if (typeof updateTemptFateSparkle === 'function') updateTemptFateSparkle();
      }, 450);
    });
    overlay.appendChild(closeBtn);

    lines.forEach(text => {
      const el = document.createElement('div');
      el.className = 'tf-heavens-line';
      el.textContent = text;
      overlay.appendChild(el);
    });
    document.body.appendChild(overlay);

    const lineEls = overlay.querySelectorAll('.tf-heavens-line');
    lineEls.forEach((el, i) => {
      setTimeout(() => el.classList.add('tf-heavens-visible'), i * delayBetween);
    });
    // Show close button after last line fades in
    const closeDelay = (lines.length - 1) * delayBetween + 600;
    setTimeout(() => closeBtn.classList.add('tf-heavens-visible'), closeDelay);
  }

  function showScene5HeavensOverlay() {
    _showHeavensOverlay(['The heavens shift.'], 0);
  }

  function show10kHeavensOverlay() {
    _showHeavensOverlay(['You walked far enough.', 'The heavens shift into your hand.'], 500);
  }

  function showTemptShudder() {
    const btn = document.querySelector('.meta-stance[onclick="window.setMetaStance(\'seduce\')"]');
    if (!btn) return;
    // Remove any existing shudder
    btn.querySelectorAll('.tf-shudder-text').forEach(s => s.remove());
    const shudder = document.createElement('span');
    shudder.className = 'tf-shudder-text';
    shudder.textContent = 'The heavens shudder.';
    btn.appendChild(shudder);
    setTimeout(() => { if (shudder.parentNode) shudder.remove(); }, 1300);
  }

  // ============================================================
  // FATE RESONANCE â€” account-level mythic aura (narrative only)
  // ============================================================
  // HARD CONSTRAINTS:
  // - Does NOT affect Petition Fate math, Favor reservoir, Omen decay,
  //   cost escalation, Storyturn, consent, arousal gating, saturation,
  //   volatility, or entropy.
  // - Does NOT create win conditions, hidden difficulty, or advantage.
  // - Narrative tone weighting ONLY.
  // ============================================================

  // State thresholds (ascending floors)
  // Hysteresis: state does not downgrade until intensity drops 5 below threshold floor
  const FATE_RESONANCE_STATES = [
    { name: 'Quiet',    floor: 0,  ceiling: 10  },
    { name: 'Stirring', floor: 11, ceiling: 35  },
    { name: 'Resonant', floor: 36, ceiling: 60  },
    { name: 'Unstable', floor: 61, ceiling: 85  },
    { name: 'Thinning', floor: 86, ceiling: 100 }
  ];

  const _RESONANCE_HYSTERESIS_BUFFER = 5;

  function getFateResonanceState() {
    const intensity = state.fate_resonance_intensity || 0;
    const lastState = state._fate_resonance_last_state || 'Quiet';

    // Find raw state by intensity
    let rawState = 'Quiet';
    for (const s of FATE_RESONANCE_STATES) {
      if (intensity >= s.floor && intensity <= s.ceiling) { rawState = s.name; break; }
    }

    // Hysteresis: if raw state is lower than last state, only allow downgrade
    // if intensity is at least _RESONANCE_HYSTERESIS_BUFFER below the last state's floor
    const lastIdx = FATE_RESONANCE_STATES.findIndex(s => s.name === lastState);
    const rawIdx = FATE_RESONANCE_STATES.findIndex(s => s.name === rawState);
    if (rawIdx < lastIdx && lastIdx > 0) {
      const lastFloor = FATE_RESONANCE_STATES[lastIdx].floor;
      if (intensity > lastFloor - _RESONANCE_HYSTERESIS_BUFFER) {
        // Hold at last state â€” not far enough below threshold
        state._fate_resonance_last_state = lastState;
        return lastState;
      }
    }

    state._fate_resonance_last_state = rawState;
    return rawState;
  }

  function incrementFateResonance() {
    // Called on each Tempt Fate invocation
    const now = Date.now();
    const timeSinceLast = now - (state.fate_resonance_last_tempt_ts || 0);
    // Recency bonus: +3, once per 10-minute window only
    let recencyBonus = 0;
    if (timeSinceLast < 600000 && !state._fate_resonance_recency_used) {
      recencyBonus = 3;
      state._fate_resonance_recency_used = true;
    }
    // Reset recency gate if outside window
    if (timeSinceLast >= 600000) {
      state._fate_resonance_recency_used = false;
    }
    const increment = 12 + recencyBonus;
    state.fate_resonance_intensity = Math.min(100, (state.fate_resonance_intensity || 0) + increment);
    state.fate_resonance_last_tempt_turn = state.turnCount || 0;
    state.fate_resonance_last_tempt_ts = now;
  }

  function decayFateResonance() {
    // Called each turn (scene boundary). Decays when Tempt Fate was NOT used.
    if (state.tempt_fate_invoked_this_turn) return;
    const intensity = state.fate_resonance_intensity || 0;
    if (intensity <= 0) return;

    const turnsSinceLast = (state.turnCount || 0) - (state.fate_resonance_last_tempt_turn || 0);

    // Extended inactivity: 20+ consecutive non-Tempt turns â†’ accelerated decay until below Resonant floor
    if (turnsSinceLast >= 20 && intensity > 36) {
      state.fate_resonance_intensity = Math.max(0, intensity - 6);
      return;
    }

    // Flat per-turn decay: -2
    state.fate_resonance_intensity = Math.max(0, intensity - 2);
  }

  function decayFateResonanceCrossSession() {
    // Called on session init / story load. Applies time-based decay for idle periods.
    const lastTs = state.fate_resonance_last_tempt_ts || 0;
    if (!lastTs || !state.fate_resonance_intensity) return;
    const elapsed = Date.now() - lastTs;
    const hoursSince = elapsed / 3600000;

    if (hoursSince < 1) return; // No cross-session decay within first hour

    // -3 per hour of inactivity
    let decay = Math.floor(hoursSince * 3);

    // Cap: do not drop more than one state per session gap
    // Find current state's floor and the floor of the state below it
    const currentState = getFateResonanceState();
    const currentIdx = FATE_RESONANCE_STATES.findIndex(s => s.name === currentState);
    if (currentIdx > 0) {
      const oneBelow = FATE_RESONANCE_STATES[currentIdx - 1];
      const maxDrop = (state.fate_resonance_intensity || 0) - oneBelow.floor;
      if (decay > maxDrop && maxDrop > 0) {
        decay = maxDrop;
      }
    }

    if (decay > 0) {
      state.fate_resonance_intensity = Math.max(0, (state.fate_resonance_intensity || 0) - decay);
    }

    // Extended inactivity: 24+ hours â†’ apply accelerated decay until below Resonant
    if (hoursSince >= 24 && (state.fate_resonance_intensity || 0) > 36) {
      // Already capped to one-state drop above, so this only fires if still above Resonant
      // after the initial cap. This handles multi-day absences gracefully.
      const intensity = state.fate_resonance_intensity || 0;
      state.fate_resonance_intensity = Math.max(0, intensity - 6);
    }
  }

  const FATE_RESONANCE_WORLD_EXPRESSION = {
    Fantasy: {
      Resonant:  'NPCs treat you with sacred unease. Favor trembles in objects near you. Symbols of the divine recur without invitation.',
      Unstable:  'Courts react to your presence before you speak. Priests falter mid-ritual. Sacrifice echoes arrive early and unbidden.',
      Thinning:  'The Fatelands feel thin where you stand. Rivers hesitate. Witnesses describe the air around you as heavy with unsettled Favor. Reality strains at the seams of divine attention.'
    },
    Modern: {
      Resonant:  'Statistical coincidences cluster around the protagonist. Devices glitch at meaningful moments. Strangers make eye contact too long.',
      Unstable:  'Institutions notice the pattern density. Algorithms flag the protagonist. Insurance adjusters, journalists, and data analysts begin circling.',
      Thinning:  'Viral coincidence density reaches visible levels. News cycles almost notice. Systems designed to ignore anomalies start treating the protagonist as a variable.'
    },
    Historical: {
      Resonant:  'Rumors of omens follow the protagonist between settlements. Animals behave oddly. Priests note the alignment of signs.',
      Unstable:  'Political figures interpret events around the protagonist as portent. Advisors whisper. Guards are repositioned without explanation.',
      Thinning:  'The protagonist becomes the center of omen rumor. Political paranoia crystallizes around their movements. Courts and temples send observers.'
    },
    Dystopia: {
      Resonant:  'Surveillance systems flag micro-anomalies in the protagonist\'s sector. Attention scores drift upward for no classified reason.',
      Unstable:  'The protagonist is reclassified as an instability vector. Enforcement protocols activate preemptive containment postures around their location.',
      Thinning:  'System integrity reports reference the protagonist\'s proximity signature. Internal memos circulate about anomaly clustering. The regime\'s adaptive systems cannot model the pattern and that makes them tighten.'
    },
    SciFi: {
      Resonant:  'AI diagnostic models flag the protagonist\'s interaction history as statistically improbable. Routine systems request additional verification cycles.',
      Unstable:  'Simulation integrity warnings escalate. AI behavioral models degrade in the protagonist\'s vicinity. Predictive algorithms output contradictory recommendations.',
      Thinning:  'Ship/station AI begins treating the protagonist as an unmodeled variable. Diagnostics suggest hardware degradation that maintenance cannot locate. Systems whisper to each other about the anomaly.'
    },
    PostApocalyptic: {
      Resonant:  'Survivors avoid standing too close. Weather shifts when the protagonist makes decisions. Resource caches appear in improbable locations.',
      Unstable:  'The protagonist gains a storm-bringer reputation. Settlements debate whether proximity is worth the risk. Trade routes adjust.',
      Thinning:  'Survival math distorts around the protagonist. Convoys reroute. Elders invoke old warnings. The wasteland itself seems to pay attention.'
    }
  };

  function buildFateResonanceDirective() {
    const resonanceState = getFateResonanceState();
    if (resonanceState === 'Quiet' || resonanceState === 'Stirring') return '';

    const world = state.picks?.world || 'Modern';
    const worldExpr = FATE_RESONANCE_WORLD_EXPRESSION[world] || FATE_RESONANCE_WORLD_EXPRESSION.Modern;

    let directive = `\nFATE RESONANCE â€” ${resonanceState.toUpperCase()}\n`;
    directive += `The protagonist carries accumulated Fate attention. This affects narrative tone ONLY â€” not probability, not cost, not guardrails, not difficulty.\n`;

    // Accumulate all applicable tiers
    if (worldExpr.Resonant) {
      directive += `\nResonant aura: ${worldExpr.Resonant}\n`;
    }
    if ((resonanceState === 'Unstable' || resonanceState === 'Thinning') && worldExpr.Unstable) {
      directive += `Unstable aura: ${worldExpr.Unstable}\n`;
    }
    if (resonanceState === 'Thinning' && worldExpr.Thinning) {
      directive += `Thinning aura: ${worldExpr.Thinning}\n`;
    }

    // Tempt Fate prose amplification at Unstable+
    if (resonanceState === 'Unstable' || resonanceState === 'Thinning') {
      if (state.tempt_fate_invoked_this_turn || state.volatility_window?.active) {
        directive += `\nTempt Fate prose amplification active: Outcomes should feel heavier in prose. Consequence descriptions sharpen. NPC/world reactions arrive faster. This does NOT change magnitude ceiling, guardrails, volatility math, or saturation accumulation.\n`;
      }
    }

    directive += `\nHARD LOCK: Fate Resonance is atmospheric. It must NOT increase difficulty, grant advantage, alter backlash probability, change volatility math, bypass guardrails, add penalties, or create hidden scaling. Narrative tone weighting only.\n`;

    return directive;
  }

  // ============================================================
  // OMEN TEMPERATURE SYSTEM â€” atmospheric bias, not outcome preview
  // ============================================================

  const OMEN_WARM_POOL = [
    "Light refracts through a glass.",
    "The wind settles.",
    "A glass rings softly.",
    "A piece of fabric lifts, then falls.",
    "The water smooths.",
    "The candle steadies.",
    "Wood grain aligns under your hand.",
    "The air warms by a fraction.",
    "A thread catches the light.",
    "Something small comes to rest."
  ];

  const OMEN_NEUTRAL_POOL = [
    "A clock ticks.",
    "A door shifts.",
    "Dust moves in the light.",
    "A page turns somewhere.",
    "A pipe settles.",
    "Distant footsteps.",
    "A chair creaks.",
    "The faucet drips once.",
    "Something brushes the wall.",
    "The air holds still."
  ];

  const OMEN_COLD_POOL = [
    "Fluorescent flicker.",
    "Insect clicking.",
    "Metal cooling.",
    "A shadow misaligns.",
    "A nail catches wood.",
    "Mechanical hum.",
    "A draft under the door.",
    "Something tapping. Not knocking.",
    "A bulb dims, then recovers.",
    "A faint smell of copper."
  ];

  const OMEN_SILENCE_POOL = [
    "...",
    "Nothing unusual.",
    "A pause.",
    "The air does not move."
  ];

  // Decay-stage probability bands: [warm, neutral, cold]
  // Each stage defines base odds; modifiers shift within these bands
  const OMEN_STAGE_BANDS = [
    [0.60, 0.30, 0.10],  // Stage 0 â€” Warm dominant
    [0.35, 0.40, 0.25],  // Stage 1 â€” Watchful
    [0.10, 0.45, 0.45],  // Stage 2 â€” Cold
    [0.03, 0.27, 0.70]   // Stage 3 â€” Distant (warm never zero)
  ];

  function computeOmenTemperature() {
    const om = state.omen;
    const fate = state.fate;
    const kh = state.keyhole;

    // Start from decay-stage base band
    const stage = om ? Math.min(om.decayStage, 3) : 0;
    let [warm, neutral, cold] = OMEN_STAGE_BANDS[stage];

    // Stance modifier â€” shifts warm/cold balance
    if (fate?.stance === 'intimate') { warm += 0.10; cold -= 0.07; }
    else if (fate?.stance === 'trickster') { cold += 0.10; warm -= 0.07; }

    // Alignment modifier (Favored only) â€” subtle shift
    if (kh?.marked && typeof kh.alignmentScore === 'number') {
      const alignShift = (kh.alignmentScore / 100) * 0.08;
      warm += alignShift;
      cold -= alignShift;
    }

    // Reservoir warmth (Favored only) â€” warmer when full
    if (kh?.marked && kh.favorReservoir > 0) {
      const reservoirShift = (kh.favorReservoir / kh.maxFavor) * 0.06;
      warm += reservoirShift;
      cold -= reservoirShift * 0.5;
    }

    // Early gaming penalty â€” pushes colder
    if (fate?.earlyGamingCount > 0) {
      const gamePenalty = Math.min(fate.earlyGamingCount, 4) * 0.03;
      cold += gamePenalty;
      warm -= gamePenalty;
    }

    // Favored slight upward bias
    if (state.subscriptionTier === 'favored') {
      warm += 0.04;
      cold -= 0.02;
    }

    // Seasonal warmth override â€” rare one-scene thaw during deep winter
    if (om?.temporaryWarmth) {
      warm += 0.25;
      cold -= 0.15;
    }

    // Clamp all probabilities to [0.01, 1] â€” nothing ever reaches zero
    warm = Math.max(0.01, warm);
    neutral = Math.max(0.01, neutral);
    cold = Math.max(0.01, cold);

    // Normalize to sum = 1
    const total = warm + neutral + cold;
    warm /= total;
    neutral /= total;
    cold /= total;

    // Roll weighted random
    const roll = Math.random();
    let result;
    if (roll < warm) result = 'warm';
    else if (roll < warm + neutral) result = 'neutral';
    else result = 'cold';

    // Deep-winter warm gate â€” even if bands produce warm, Stage 3 demands a second gate
    if (result === 'warm' && stage === 3) {
      if (Math.random() >= 0.25) result = 'neutral';
    }

    return result;
  }

  function advanceOmenDecay() {
    const om = state.omen;
    if (!om) return;
    const fate = state.fate;

    let pressure = 0;

    // Early gaming adds decay pressure
    if (fate?.earlyGamingCount > 1) pressure += 0.3;

    // Repeated greater petitions
    const greaterCount = om.lastGreaterPetitionCount || 0;
    if (greaterCount > 2) pressure += 0.2;

    // Heavy reservoir drain (Favored)
    if (state.keyhole?.marked && state.keyhole.favorReservoir < 15) {
      pressure += 0.15;
    }

    // Favored slows decay
    if (state.subscriptionTier === 'favored') {
      pressure *= 0.6;
    }

    om.decayAccumulator += pressure;

    // Threshold to advance stage: accumulator must exceed 1.0
    if (om.decayAccumulator >= 1.0 && om.decayStage < 3) {
      om.decayStage++;
      om.decayAccumulator = 0;
      om.lastDecayTurn = state.turnCount;
    }
  }

  function recoverOmenDecay() {
    const om = state.omen;
    if (!om || om.decayStage === 0) return;
    const fate = state.fate;

    let recovery = 0;

    // Aligned stance (intimate) promotes recovery
    if (fate?.stance === 'intimate') recovery += 0.2;

    // Earned intimacy milestone
    if (fate?.earnedIntimacy) recovery += 0.15;

    // Low early gaming
    if ((fate?.earlyGamingCount || 0) <= 1) recovery += 0.1;

    // Time since last greater petition (cooldown recovery)
    if (fate?.lastGreaterSceneIndex !== null) {
      const turnsSince = state.turnCount - fate.lastGreaterSceneIndex;
      if (turnsSince >= 5) recovery += 0.15;
      if (turnsSince >= 10) recovery += 0.1;
    }

    // Positive alignment (Favored)
    if (state.keyhole?.marked && state.keyhole.alignmentScore > 20) {
      recovery += 0.1;
    }

    // Favored speeds recovery
    if (state.subscriptionTier === 'favored') {
      recovery *= 1.4;
    }

    om.recoveryAccumulator += recovery;

    // Threshold to recover one stage: accumulator must exceed 1.0
    if (om.recoveryAccumulator >= 1.0 && om.decayStage > 0) {
      om.decayStage--;
      om.recoveryAccumulator = 0;
    }
  }

  function generateOmen() {
    const temperature = computeOmenTemperature();
    const om = state.omen;

    // Silence chance in Stage 2 and 3 â€” deliberate absence
    if (om && om.decayStage >= 2) {
      const silenceChance = om.decayStage === 2 ? 0.12 : 0.22;
      if (Math.random() < silenceChance) {
        return OMEN_SILENCE_POOL[Math.floor(Math.random() * OMEN_SILENCE_POOL.length)];
      }
    }

    // Probabilistic divergence â€” scaled by decay stage
    // Rarer in warmth, slightly more chaotic in winter
    const stage = om ? Math.min(om.decayStage, 3) : 0;
    const divergeChance = [0.06, 0.08, 0.10, 0.12][stage];
    let effectiveTemp = temperature;
    const divergeRoll = Math.random();
    if (divergeRoll < divergeChance * 0.6) {
      // Flip to opposite band
      if (effectiveTemp === 'warm') effectiveTemp = 'cold';
      else if (effectiveTemp === 'cold') effectiveTemp = 'warm';
      else effectiveTemp = Math.random() < 0.5 ? 'warm' : 'cold';
    } else if (divergeRoll < divergeChance) {
      // Collapse to neutral
      effectiveTemp = 'neutral';
    }

    let pool;
    if (effectiveTemp === 'warm') pool = OMEN_WARM_POOL;
    else if (effectiveTemp === 'cold') pool = OMEN_COLD_POOL;
    else pool = OMEN_NEUTRAL_POOL;

    return pool[Math.floor(Math.random() * pool.length)];
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  /* PACT OF ENTRY â€” Immersive legal gate with tarot card experience           */
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

  var _pactAccepted = { tos: false, privacy: false, adult: false };
  var _pactSparkleIntervals = [];
  var _pactFlipTimeout = null;

  // Map pact keys to LEGAL_DOCS keys and display names
  var PACT_META = {
    tos:     { docKey: 'tos',       title: 'THE BINDING',   subtitle: 'Terms of Service' },
    privacy: { docKey: 'privacy',   title: 'THE VEIL',      subtitle: 'Privacy Policy' },
    adult:   { docKey: 'adult_ack', title: 'THE THRESHOLD', subtitle: 'Adult Content Acknowledgment' }
  };

  function routeToLegalAcceptance(isReaccept = false) {
    window.__legalReaccept = isReaccept;

    // Reset all pact cards
    _pactAccepted = { tos: false, privacy: false, adult: false };
    document.querySelectorAll('.pact-card').forEach(function(card) {
      card.classList.remove('flipped', 'accepted');
    });

    // Clear any pending flip timeouts and sparkle intervals
    if (_pactFlipTimeout) { clearTimeout(_pactFlipTimeout); _pactFlipTimeout = null; }
    _pactSparkleIntervals.forEach(function(id) { clearInterval(id); });
    _pactSparkleIntervals = [];

    // Hide seal row and disable button
    var sealRow = document.getElementById('pactSealRow');
    var enterBtn = document.getElementById('pact-enter');
    if (sealRow) sealRow.classList.add('hidden');
    if (enterBtn) enterBtn.disabled = true;

    // Update title/subtitle for re-accept
    var title = document.querySelector('.pact-title');
    var subtitle = document.getElementById('pact-subtitle');
    if (isReaccept) {
      if (title) title.textContent = 'Terms Updated';
      if (subtitle) {
        subtitle.textContent = 'Our terms have changed. Please review and accept to continue.';
        subtitle.classList.remove('hidden');
      }
    } else {
      if (title) title.textContent = 'The Pact of Entry';
      if (subtitle) subtitle.classList.add('hidden');
    }

    showScreen('legalGate');

    // Auto-flip sequence after delay
    _pactFlipTimeout = setTimeout(function() {
      var cards = document.querySelectorAll('.pact-card');
      cards.forEach(function(card, i) {
        setTimeout(function() {
          card.classList.add('flipped');
          _startPactCardSparkles(card);
          window.applyCardGleam && window.applyCardGleam(card);
        }, i * 250);
      });
    }, 3000);
  }

  function _startPactCardSparkles(card) {
    var sparkleContainer = card.querySelector('.pact-card-sparkles');
    if (!sparkleContainer) return;
    sparkleContainer.innerHTML = '';

    var interval = setInterval(function() {
      if (!card.classList.contains('flipped')) {
        clearInterval(interval);
        return;
      }
      _createPactSparkle(sparkleContainer);
    }, 150);
    _pactSparkleIntervals.push(interval);

    // Initial burst
    for (var i = 0; i < 8; i++) {
      (function(idx) {
        setTimeout(function() { _createPactSparkle(sparkleContainer); }, idx * 50);
      })(i);
    }
  }

  function _createPactSparkle(container) {
    var sparkle = document.createElement('div');
    sparkle.className = 'mode-sparkle';
    var side = Math.floor(Math.random() * 4);
    var x, y;
    switch (side) {
      case 0: x = Math.random() * 100; y = 0; break;
      case 1: x = 100; y = Math.random() * 100; break;
      case 2: x = Math.random() * 100; y = 100; break;
      case 3: x = 0; y = Math.random() * 100; break;
    }
    sparkle.style.cssText =
      'position:absolute;left:' + x + '%;top:' + y + '%;width:4px;height:4px;' +
      'background:radial-gradient(circle,rgba(255,215,0,1) 0%,rgba(255,215,0,0) 70%);' +
      'border-radius:50%;pointer-events:none;animation:modeSparkle 1.2s ease-out forwards;';
    container.appendChild(sparkle);
    setTimeout(function() { sparkle.remove(); }, 1200);
  }

  function _openPactExpand(pactKey) {
    if (!window._LEGAL_DOCS) return;
    var meta = PACT_META[pactKey];
    if (!meta) return;
    var docHtml = window._LEGAL_DOCS[meta.docKey];
    if (!docHtml) return;

    // Create overlay
    var overlay = document.createElement('div');
    overlay.className = 'pact-card-expand-overlay';

    var scrollTarget; // element to check scroll on
    var cardEl; // the zoomed card element

    var PACT_CARD_CLASSES = {
      tos:     { card: 'pact-expand-tos-card',     inner: 'pact-expand-tos-inner',     title: 'pact-expand-tos-title',     scroll: 'pact-expand-tos-scroll',     label: 'Terms of Service' },
      adult:   { card: 'pact-expand-adult-card',    inner: 'pact-expand-adult-inner',   title: 'pact-expand-adult-title',   scroll: 'pact-expand-adult-scroll',   label: "I'm 18+" },
      privacy: { card: 'pact-expand-privacy-card',  inner: 'pact-expand-privacy-inner', title: 'pact-expand-privacy-title', scroll: 'pact-expand-privacy-scroll', label: 'Privacy Policy' }
    };

    var cfg = PACT_CARD_CLASSES[pactKey];
    if (cfg) {
      // â”€â”€ White card with scrollable text + accept zone at bottom â”€â”€
      cardEl = document.createElement('div');
      cardEl.className = cfg.card;
      var innerEl = document.createElement('div');
      innerEl.className = cfg.inner;
      var titleEl = document.createElement('div');
      titleEl.className = cfg.title;
      titleEl.textContent = cfg.label;
      var scrollEl = document.createElement('div');
      scrollEl.className = cfg.scroll;
      scrollEl.innerHTML = docHtml;
      innerEl.appendChild(titleEl);
      innerEl.appendChild(scrollEl);
      cardEl.appendChild(innerEl);

      // Accepted overlay â€” bottom portion of WHITE-Accepted.png (gold star)
      var acceptedOverlay = document.createElement('div');
      acceptedOverlay.className = 'pact-accepted-overlay';
      cardEl.appendChild(acceptedOverlay);

      // Accept zone â€” clickable area at bottom of card
      var acceptZone = document.createElement('div');
      acceptZone.className = 'pact-accept-zone';
      cardEl.appendChild(acceptZone);

      overlay.appendChild(cardEl);
      scrollTarget = scrollEl;
    } else {
      // â”€â”€ Default: title + content box â”€â”€
      var titleEl = document.createElement('div');
      titleEl.className = 'pact-expand-title';
      titleEl.textContent = meta.title + ' â€” ' + meta.subtitle;
      var contentEl = document.createElement('div');
      contentEl.className = 'pact-expand-content';
      contentEl.innerHTML = docHtml;
      overlay.appendChild(titleEl);
      overlay.appendChild(contentEl);
      scrollTarget = contentEl;

      // Fallback accept button for unknown card types
      var acceptBtn = document.createElement('button');
      acceptBtn.className = 'pact-expand-accept-btn';
      acceptBtn.textContent = 'I Accept';
      overlay.appendChild(acceptBtn);
    }

    document.body.appendChild(overlay);

    // â”€â”€ Accept logic â”€â”€
    var acceptEnabled = false;

    // Enable accept after scroll-to-bottom or 3s timeout
    var enableTimer = setTimeout(function() { acceptEnabled = true; }, 3000);

    function checkScroll() {
      if (scrollTarget.scrollHeight <= scrollTarget.clientHeight) {
        acceptEnabled = true;
        clearTimeout(enableTimer);
      } else if (scrollTarget.scrollTop + scrollTarget.clientHeight >= scrollTarget.scrollHeight - 5) {
        acceptEnabled = true;
        clearTimeout(enableTimer);
      }
    }
    scrollTarget.addEventListener('scroll', checkScroll);
    setTimeout(checkScroll, 100);

    function _doAccept() {
      _pactAccepted[pactKey] = true;

      // Mark unzoomed card as accepted (swaps front face via CSS)
      var card = document.querySelector('.pact-card[data-pact="' + pactKey + '"]');
      if (card) card.classList.add('accepted');

      // Show gold star on zoomed card
      var starOverlay = overlay.querySelector('.pact-accepted-overlay');
      if (starOverlay) starOverlay.classList.add('visible');

      // Close overlay after brief delay to show the star
      setTimeout(function() { overlay.remove(); }, 800);

      _checkAllPactsAccepted();
    }

    if (cfg) {
      // Accept zone click on zoomed card
      var zone = overlay.querySelector('.pact-accept-zone');
      if (zone) {
        zone.addEventListener('click', function(e) {
          e.stopPropagation();
          if (!acceptEnabled) return;
          _doAccept();
        });
      }
    } else {
      // Fallback button
      var btn = overlay.querySelector('.pact-expand-accept-btn');
      if (btn) {
        btn.addEventListener('click', function() { _doAccept(); });
      }
    }

    // Close on overlay background click (not content)
    overlay.addEventListener('click', function(e) {
      if (e.target === overlay) overlay.remove();
    });
  }

  function _checkAllPactsAccepted() {
    if (_pactAccepted.tos && _pactAccepted.privacy && _pactAccepted.adult) {
      var sealRow = document.getElementById('pactSealRow');
      var enterBtn = document.getElementById('pact-enter');
      if (sealRow) sealRow.classList.remove('hidden');
      if (enterBtn) enterBtn.disabled = false;
    }
  }

  (function initPactCards() {
    // Card tap â†’ expand
    document.querySelectorAll('.pact-card').forEach(function(card) {
      card.addEventListener('click', function() {
        if (!card.classList.contains('flipped')) return; // must be flipped first
        var pactKey = card.dataset.pact;
        if (_pactAccepted[pactKey]) return; // already accepted
        _openPactExpand(pactKey);
      });
    });

    // Enter the Veil button
    var enterBtn = document.getElementById('pact-enter');
    if (enterBtn) {
      enterBtn.addEventListener('click', async function() {
        enterBtn.disabled = true;
        try {
          if (_supabaseProfileId) {
            await sb
              .from('profiles')
              .update({
                age_confirmed: true,
                tos_version: LEGAL.TOS_VERSION,
                tos_accepted_at: new Date(),
                privacy_version: LEGAL.PRIVACY_VERSION,
                privacy_accepted_at: new Date(),
                adult_ack_version: LEGAL.ADULT_ACK_VERSION,
                adult_acknowledged_at: new Date()
              })
              .eq('id', _supabaseProfileId);

            // Fire-and-forget: capture IP + UA server-side
            fetch('/api/record-legal-acceptance', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ userId: _supabaseProfileId })
            }).catch(function(err) { console.warn('[LEGAL] IP capture failed:', err); });
          } else {
            console.warn('[LEGAL] No profile ID â€” skipping profile update');
          }

          window.showScreen('tierGate');
        } catch (e) {
          console.error('[LEGAL] Failed to update profile:', e);
          enterBtn.disabled = false;
        }
      });
    }
  })();

  (function initLegalModal() {
    const modal = document.getElementById('legalModal');
    const content = document.getElementById('legalModalContent');
    const closeBtn = document.getElementById('legalModalClose');
    if (!modal || !content || !closeBtn) return;

    const LEGAL_DOCS = {
      tos: `<h3>Storybound Terms of Service</h3>
<p style="font-size:0.85em; color:#888;">Version: ${CURRENT_TOS_VERSION}</p>

<h4>1. Acceptance of Terms</h4>
<p>By accessing or using Storybound ("the Platform"), you agree to be bound by these Terms of Service ("Terms"). You must be at least 18 years of age to use the Platform.</p>
<p>Continued use of the Platform constitutes acceptance of the current version of these Terms.</p>

<h4>2. Nature of the Platform</h4>
<p>Storybound is a proprietary participatory literary universe authored under the imprint <strong>S. Tory Bound</strong>.</p>
<p>Storybound is <em>not</em>:</p>
<ul>
<li>A manuscript-writing tool</li>
<li>A co-authoring service</li>
<li>A user-generated content marketplace</li>
</ul>
<p>Users participate in shaping narrative outcomes within a platform-authored canon. Storybound remains the authorial entity of all generated narrative content.</p>

<h4>3. User Accounts</h4>
<p>Users are responsible for maintaining the confidentiality of account credentials. Storybound may suspend or terminate accounts at its sole discretion for violations of these Terms.</p>
<p>Accounts are non-transferable.</p>

<h4>4. Fortunes &amp; Digital Goods</h4>
<p>Fortunes are digital consumables used within the Platform. Fortunes:</p>
<ul>
<li>Have no monetary value</li>
<li>Are non-transferable</li>
<li>Are non-refundable except where required by law</li>
</ul>
<p><strong>4.1 Subscription Fortunes</strong></p>
<ul>
<li>Are granted periodically</li>
<li>Are consumed before purchased Fortunes</li>
<li>Expire upon cancellation of subscription</li>
</ul>
<p><strong>4.2 Purchased Fortunes</strong></p>
<ul>
<li>Do not expire</li>
<li>Are consumed after Subscription Fortunes</li>
<li>Remain associated with the account</li>
</ul>
<p>Storybound may modify Fortune structures at its discretion.</p>

<h4>5. Generated Narrative &amp; Intellectual Property</h4>
<p><strong>5.1 Ownership of Generated Narrative</strong></p>
<p>All narrative text, story arcs, character developments, and generated works created through the Platform ("Generated Narrative") are exclusively owned by Storybound and/or its affiliates.</p>
<p>The Generated Narrative constitutes a proprietary literary universe authored under the imprint <strong>S. Tory Bound</strong>.</p>
<p>Users acquire no ownership rights in any Generated Narrative.</p>

<p><strong>5.2 License from Users</strong></p>
<p>By participating in Storybound, users grant Storybound a <strong>perpetual, worldwide, irrevocable, royalty-free, transferable, and sublicensable</strong> license to use, reproduce, modify, adapt, publish, distribute, publicly perform, create derivative works from, and commercially exploit any inputs, selections, prompts, or interactions provided in connection with the Generated Narrative.</p>
<p>This license survives termination of the user's account.</p>

<p><strong>5.3 Limited User License</strong></p>
<p>Storybound grants users a limited, non-exclusive, non-transferable, non-commercial, revocable license to access and view Generated Narrative solely within the Platform.</p>
<p>Users may not:</p>
<ul>
<li>Commercially publish</li>
<li>Sell or license</li>
<li>Distribute externally</li>
<li>Adapt into audiovisual works</li>
<li>Mint as NFTs</li>
<li>Train AI models on</li>
<li>Commercially exploit</li>
</ul>
<p>any Generated Narrative without written permission from Storybound.</p>

<p><strong>5.4 No Joint Authorship</strong></p>
<p>Participation in Storybound does not create joint authorship, co-authorship, partnership, agency, or ownership interest in any Generated Narrative.</p>
<p>Storybound remains the sole author and rights holder.</p>

<h4>6. Discretionary Participation Program</h4>
<p>Storybound may, at its sole discretion, provide voluntary participation bonuses to users whose interactive participation contributed to a Generated Narrative that is commercially published, licensed, or adapted.</p>
<p>Such bonuses:</p>
<ul>
<li>Are entirely discretionary</li>
<li>Do not constitute royalties</li>
<li>Do not create ownership rights</li>
<li>Do not create entitlement to future payments</li>
<li>Do not create audit or accounting rights</li>
<li>Do not establish partnership or profit-sharing</li>
</ul>
<p>No user is entitled to compensation unless expressly agreed in a separate written agreement signed by Storybound.</p>

<h4>7. Archive &amp; Canon Designation</h4>
<p>Storybound may designate certain Generated Narratives as part of the Storybound Archive.</p>
<p>Archive designation does not create ownership rights or publication guarantees.</p>

<h4>8. Content Standards</h4>
<p>Users may not use the Platform to create illegal content, exploit real persons, or violate applicable laws.</p>
<p>The Platform generates fictional adult content. By using Storybound, you acknowledge this.</p>

<h4>9. AI Disclosure</h4>
<p>Generated Narrative is AI-assisted fictional content. Storybound makes no representations regarding factual accuracy.</p>

<h4>10. Payments &amp; Billing</h4>
<p>Subscriptions renew automatically unless cancelled. Users are responsible for applicable taxes.</p>
<p>Chargebacks or fraudulent disputes may result in account suspension.</p>

<h4>11. Termination</h4>
<p>Storybound may suspend or terminate accounts at its sole discretion.</p>
<p>Fortunes may be forfeited upon termination due to policy violations.</p>

<h4>12. Limitation of Liability</h4>
<p>The Platform is provided "as is." Storybound disclaims all warranties to the fullest extent permitted by law.</p>

<h4>13. Indemnification</h4>
<p>Users agree to indemnify and hold harmless Storybound from claims arising out of misuse of the Platform.</p>

<h4>14. Governing Law &amp; Dispute Resolution</h4>
<p>Any disputes shall be resolved through binding arbitration.</p>

<h4>15. Modifications</h4>
<p>Storybound may update these Terms at any time. Continued use constitutes acceptance of updated Terms.</p>`,
      privacy: `<h3>Storybound Privacy Policy</h3>
<p style="font-size:0.85em; color:#888;">Version: ${CURRENT_PRIVACY_VERSION}</p>

<h4>1. Overview</h4>
<p>Storybound ("the Platform") is a participatory literary universe authored under the imprint <strong>S. Tory Bound</strong>.</p>
<p>This Privacy Policy explains how we collect, use, store, and protect your information.</p>

<h4>2. Information We Collect</h4>
<p>We may collect:</p>
<ul>
<li>Account information (email, username)</li>
<li>Authentication data</li>
<li>IP address and device metadata</li>
<li>Billing information (processed via Stripe or payment processor)</li>
<li>Interaction data (choices, prompts, selections)</li>
<li>Fortune transaction data</li>
<li>Usage analytics</li>
</ul>
<p>We do not sell personal data.</p>

<h4>3. AI Processing Disclosure</h4>
<p>Your inputs and interactions are processed by AI systems to generate fictional narrative content.</p>
<p>By using the Platform, you consent to such processing.</p>
<p>Generated Narrative is platform-owned intellectual property.</p>

<h4>4. Payment Processing</h4>
<p>Payments are processed by third-party payment providers (e.g., Stripe).</p>
<p>Storybound does not store full credit card numbers.</p>
<p>Payment processors handle billing information according to their own privacy policies.</p>

<h4>5. Use of Information</h4>
<p>We use collected information to:</p>
<ul>
<li>Provide access to the Platform</li>
<li>Generate narrative content</li>
<li>Manage Fortunes and subscriptions</li>
<li>Enforce platform policies</li>
<li>Improve system performance</li>
<li>Prevent fraud</li>
</ul>

<h4>6. Data Retention</h4>
<p>We retain account and interaction data as long as necessary to operate the Platform, comply with legal obligations, and maintain narrative continuity.</p>
<p>Generated Narrative may be retained indefinitely as part of the Storybound Archive.</p>

<h4>7. Data Security</h4>
<p>We implement commercially reasonable safeguards to protect user data. However, no system is completely secure.</p>

<h4>8. User Rights</h4>
<p>Subject to applicable law, users may request:</p>
<ul>
<li>Access to personal data</li>
<li>Correction of inaccurate data</li>
<li>Deletion of personal account data</li>
</ul>
<p>Deletion of account data does not revoke Storybound's ownership of Generated Narrative or licenses granted under the Terms of Service.</p>

<h4>9. Cookies &amp; Analytics</h4>
<p>We may use cookies and analytics tools to:</p>
<ul>
<li>Maintain sessions</li>
<li>Track performance</li>
<li>Analyze usage trends</li>
</ul>
<p>Users may manage cookies via browser settings.</p>

<h4>10. International Users</h4>
<p>By using the Platform, you consent to data processing in the jurisdiction where Storybound operates.</p>

<h4>11. Changes to This Policy</h4>
<p>Storybound may update this Privacy Policy at any time.</p>
<p>Continued use constitutes acceptance of the updated version.</p>`,
      adult_ack: `<h3>Adult Fictional Content Acknowledgment</h3>
<p style="font-size:0.85em; color:#888;">Version: ${CURRENT_ADULT_ACK_VERSION}</p>

<p>Storybound generates fictional adult narrative content that may include explicit romantic or erotic themes.</p>

<p>By continuing, you confirm that:</p>
<ul>
<li>You are at least 18 years of age.</li>
<li>You understand the Platform generates fictional adult content.</li>
<li>You consent to viewing and interacting with such content.</li>
<li>You acknowledge that all characters depicted are fictional and intended to be adults.</li>
</ul>`
    };

    // Expose for pact card system
    window._LEGAL_DOCS = LEGAL_DOCS;

    function openLegalDoc(docKey) {
      content.innerHTML = LEGAL_DOCS[docKey] || '';
      content.scrollTop = 0;
      closeBtn.disabled = true;
      modal.classList.remove('hidden');
      checkScrollBottom();
    }

    function checkScrollBottom() {
      if (content.scrollHeight <= content.clientHeight) {
        closeBtn.disabled = false;
      } else if (content.scrollTop + content.clientHeight >= content.scrollHeight - 5) {
        closeBtn.disabled = false;
      }
    }

    content.addEventListener('scroll', checkScrollBottom);

    // Old legal doc links removed â€” pact card system handles doc viewing

    closeBtn.addEventListener('click', function() {
      modal.classList.add('hidden');
    });
  })();

  function resolveLegalGate(profile) {
    // Age gate is now handled by the adult pact card â€” skip straight to legal gate
    if (!profile.tos_version ||
        !profile.privacy_version ||
        !profile.adult_ack_version ||
        profile.age_confirmed !== true) {
      routeToLegalAcceptance();
      return;
    }

    if (profile.tos_version !== LEGAL.TOS_VERSION ||
        profile.privacy_version !== LEGAL.PRIVACY_VERSION ||
        profile.adult_ack_version !== LEGAL.ADULT_ACK_VERSION) {
      const isReaccept = profile.tos_version && profile.tos_version !== LEGAL.TOS_VERSION;
      routeToLegalAcceptance(isReaccept);
      return;
    }

    console.log('[BOOT] All legal gates satisfied â€” skipping to tierGate');
    window.showScreen && window.showScreen('tierGate');
  }

  async function bootApp() {
    if (window.__booted) return;
    window.__booted = true;

    try {
      const userId = await ensureAnonSession();
      if (!userId || !sb) {
        renderBurgerMenu();
        routeToLegalAcceptance();
        return;
      }
      _supabaseProfileId = userId;

      const profile = await hydrateProfile(userId);
      if (!profile) {
        routeToLegalAcceptance();
        return;
      }

      hydrateState(profile);

      renderBurgerMenu();

      // DEV BYPASS â€” localhost only, ?devpass=storybound makes purchase buttons fake success
      const _host = window.location.hostname;
      if ((_host === 'localhost' || _host === '127.0.0.1') &&
          new URLSearchParams(window.location.search).get('devpass') === 'storybound') {
        window._devBypass = true;
        console.log('%c[DEV] Purchase bypass active â€” buy buttons will fake success', 'color: #ffd700; font-weight: bold');
      }


      resolveLegalGate(profile);
    } catch (e) {
      console.error('[BOOT] Boot sequence failed:', e);
      routeToLegalAcceptance();
    } finally {
      document.body.classList.remove('booting');
      window.__initialScreenSet = false;
    }
  }

  bootApp();


  function getNickname(){
    let n = localStorage.getItem("sb_nickname");
    if(!n){
      n = prompt("Enter a nickname for Couple Mode:", "Guest") || "Guest";
      localStorage.setItem("sb_nickname", n);
    }
    return n;
  }
  
  // =========================
  // STORYBOUND EVENT LOGGER
  // =========================
  const SB_ANALYTICS_KEY = "sb_analytics_v1";

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // USED-NAME TRACKING â€” Persists character names across stories so AI never
  // reuses a name the reader has already seen.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const SB_USED_NAMES_KEY = 'sb_used_names';

  function getUsedNames() {
      try { return JSON.parse(localStorage.getItem(SB_USED_NAMES_KEY) || '[]'); }
      catch { return []; }
  }

  function addUsedName(name) {
      if (!name || !name.trim()) return;
      const clean = name.trim();
      const names = getUsedNames();
      // Store lowercase for comparison, original for display
      if (!names.some(n => n.toLowerCase() === clean.toLowerCase())) {
          names.push(clean);
          localStorage.setItem(SB_USED_NAMES_KEY, JSON.stringify(names));
      }
  }

  /** Build a NAME INVENTION prompt block when user left a name field blank. */
  function buildNameInventionDirective(role, gender, pronouns) {
      const used = getUsedNames();
      const exclusion = used.length > 0
          ? `\nNEVER reuse any of these previously seen names: ${used.join(', ')}.`
          : '';
      return `[${role.toUpperCase()} NAME â€” INVENT]:
You MUST invent a compelling, original full name for the ${role} in Scene 1.
The name must suit the world, tone, and era of this story.
Gender context: ${gender}, ${pronouns}.${exclusion}
Introduce the name naturally within the first few paragraphs â€” do not announce it mechanically.`;
  }

  function sbLog(event, payload = {}) {
    try {
      const raw = localStorage.getItem(SB_ANALYTICS_KEY);
      const data = raw ? JSON.parse(raw) : [];
      const sId = (state && state.storyId) ? state.storyId : null;
      data.push({
        event,
        payload,
        ts: Date.now(),
        iso: new Date().toISOString(),
        storyId: sId,
        access: state?.access || null,
        intensity: state?.intensity || null
      });
      if (data.length > 1000) data.shift();
      localStorage.setItem(SB_ANALYTICS_KEY, JSON.stringify(data));
    } catch (e) { console.warn("Analytics log failed", e); }
  }
  
  window.sbDumpAnalytics = () => JSON.parse(localStorage.getItem(SB_ANALYTICS_KEY) || "[]");

  // =========================
  // STORY PAGINATION SYSTEM
  // =========================
  const StoryPagination = (function() {
      let pages = [];           // Array of page content (HTML strings)
      let currentPageIndex = 0;
      let isAnimating = false;

      // DOM references - lazily initialized
      let container = null;
      let prevBtn = null;
      let nextBtn = null;
      let indicator = null;

      // REPAIR: Lazy initialization - ensures container is found before any operation
      function ensureInitialized() {
          if (!container) {
              container = document.getElementById('storyPagesContainer');
          }
          if (!prevBtn) {
              prevBtn = document.getElementById('prevPageBtn');
              if (prevBtn && !prevBtn._bound) {
                  prevBtn.addEventListener('click', () => goToPrevPage());
                  prevBtn._bound = true;
              }
          }
          if (!nextBtn) {
              nextBtn = document.getElementById('nextPageBtn');
              if (nextBtn && !nextBtn._bound) {
                  nextBtn.addEventListener('click', () => goToNextPage());
                  nextBtn._bound = true;
              }
          }
          if (!indicator) {
              indicator = document.getElementById('pageIndicator');
          }
          return !!container;
      }

      function init() {
          ensureInitialized();
          // Keyboard navigation
          if (!document._paginationKeyBound) {
              document.addEventListener('keydown', handleKeyNav);
              document._paginationKeyBound = true;
          }
      }

      function handleKeyNav(e) {
          // Only handle arrow keys when story is visible
          const storyText = document.getElementById('storyText');
          if (!storyText || storyText.offsetParent === null) return;

          if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
              e.preventDefault();
              goToNextPage();
          } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
              e.preventDefault();
              goToPrevPage();
          }
      }

      function createPageElement(content, index) {
          const page = document.createElement('div');
          page.className = 'story-page';
          page.dataset.pageIndex = index;
          page.innerHTML = content;
          return page;
      }

      function updateNavigation() {
          ensureInitialized();
          if (prevBtn) prevBtn.disabled = currentPageIndex === 0 || isAnimating;
          if (nextBtn) nextBtn.disabled = currentPageIndex >= pages.length - 1 || isAnimating;
          if (indicator) indicator.textContent = pages.length > 0 ? `Page ${currentPageIndex + 1} of ${pages.length}` : 'Page 1 of 1';
      }

      // FIX #4: Post-render hook for tier UI rehydration + prior scene lock
      function triggerPostRenderHooks() {
          if (typeof window.applyAccessLocks === 'function') {
              window.applyAccessLocks();
          }
          if (typeof window.applyTierUI === 'function') {
              window.applyTierUI();
          }
          if (typeof window.applyPriorSceneLock === 'function') {
              window.applyPriorSceneLock();
          }
      }

      // FIX: Update story header display based on current page
      // Page 1: Full title/scene display
      // Page 2+: Compact display
      function updateStoryHeaderDisplay() {
          const titleEl = document.getElementById('storyTitle');
          const settingShotWrap = document.getElementById('settingShotWrap');
          const sceneNumberEl = document.getElementById('sceneNumber');

          // Update scene number based on current page
          if (sceneNumberEl) {
              sceneNumberEl.textContent = 'Scene ' + (currentPageIndex + 1);
          }

          if (currentPageIndex === 0) {
              // Page 1: Full display
              if (titleEl) titleEl.classList.remove('compact');
              if (settingShotWrap) settingShotWrap.style.display = 'none';
          } else {
              // Page 2+: Compact display
              if (titleEl) titleEl.classList.add('compact');
              if (settingShotWrap) settingShotWrap.style.display = 'none';
          }
      }

      // CORRECTIVE: Scroll to very top (title) on scene transitions
      function scrollToStoryTop() {
          const titleEl = document.getElementById('storyTitle');
          if (titleEl) {
              // Scroll to title to ensure Scene # is visible
              titleEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
              // Also scroll window to absolute top
              window.scrollTo({ top: 0, behavior: 'smooth' });
          }
      }

      function renderCurrentPage(animate = false, direction = 'forward') {
          // REPAIR: Always try to get container before rendering
          if (!ensureInitialized()) {
              console.warn('StoryPagination: container not found, retrying...');
              return;
          }

          const existingPages = container.querySelectorAll('.story-page');
          const currentPage = createPageElement(pages[currentPageIndex] || '', currentPageIndex);

          if (!animate || existingPages.length === 0) {
              // No animation - just show the page
              container.innerHTML = '';
              currentPage.classList.add('active');
              container.appendChild(currentPage);
              updateNavigation();
              updateStoryHeaderDisplay();
              scrollToStoryTop();
              triggerPostRenderHooks();
              return;
          }

          // Check for reduced motion preference
          const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

          if (prefersReducedMotion) {
              // Instant transition for reduced motion
              container.innerHTML = '';
              currentPage.classList.add('active');
              container.appendChild(currentPage);
              updateNavigation();
              updateStoryHeaderDisplay();
              scrollToStoryTop();
              triggerPostRenderHooks();
              return;
          }

          // Animated page turn
          isAnimating = true;
          updateNavigation();

          const oldPage = existingPages[0];
          const outClass = direction === 'forward' ? 'turning-out' : 'turning-out-reverse';
          const inClass = direction === 'forward' ? 'turning-in' : 'turning-in-reverse';

          // Add new page
          container.appendChild(currentPage);

          // Start animation
          oldPage.classList.remove('active');
          oldPage.classList.add(outClass);
          currentPage.classList.add(inClass);

          // Clean up after animation
          setTimeout(() => {
              oldPage.remove();
              currentPage.classList.remove(inClass);
              currentPage.classList.add('active');
              isAnimating = false;
              updateNavigation();
              updateStoryHeaderDisplay();
              scrollToStoryTop();
              triggerPostRenderHooks();
          }, 550);
      }

      function goToNextPage() {
          // Synopsis page intercept: Next advances from synopsis to scene
          if (typeof _readerPage !== 'undefined' && _readerPage === 1) {
              showReaderPage(2);
              return;
          }
          // Page-curl intercept chain: Title â†’ Frontispiece â†’ Setting Plate â†’ Scene text
          if (typeof window.dismissTitlePage === 'function' && window._titlePageActive) {
              window.dismissTitlePage();
              return;
          }
          if (typeof window.dismissFatelandsFrontispiece === 'function' && window._frontispieceActive) {
              window.dismissFatelandsFrontispiece();
              return;
          }
          if (typeof window.dismissSettingPlate === 'function' && window._settingPlateActive) {
              window.dismissSettingPlate();
              return;
          }
          if (isAnimating || currentPageIndex >= pages.length - 1) return;
          currentPageIndex++;
          renderCurrentPage(true, 'forward');
      }

      function goToPrevPage() {
          if (isAnimating || currentPageIndex <= 0) return;
          currentPageIndex--;
          renderCurrentPage(true, 'backward');
      }

      function goToPage(index, animate = false) {
          if (index < 0 || index >= pages.length) return;
          const direction = index > currentPageIndex ? 'forward' : 'backward';
          currentPageIndex = index;
          renderCurrentPage(animate, direction);
      }

      function addPage(content, goToNew = true) {
          pages.push(content);
          if (goToNew) {
              currentPageIndex = pages.length - 1;
              renderCurrentPage(pages.length > 1, 'forward');
          } else {
              updateNavigation();
          }
      }

      function updateCurrentPage(content) {
          if (pages.length === 0) {
              addPage(content);
              return;
          }
          pages[currentPageIndex] = content;
          // Update DOM without animation
          ensureInitialized();
          const activePage = container?.querySelector('.story-page.active');
          if (activePage) {
              activePage.innerHTML = content;
          }
      }

      function appendToCurrentPage(content) {
          if (pages.length === 0) {
              addPage(content);
              return;
          }
          pages[currentPageIndex] += content;
          // Update DOM without animation
          ensureInitialized();
          const activePage = container?.querySelector('.story-page.active');
          if (activePage) {
              activePage.innerHTML = pages[currentPageIndex];
          }
      }

      function clear() {
          pages = [];
          currentPageIndex = 0;
          ensureInitialized();
          if (container) container.innerHTML = '';
          updateNavigation();
      }

      function getPageCount() {
          return pages.length;
      }

      function getCurrentPageIndex() {
          return currentPageIndex;
      }

      function getAllContent() {
          return pages.join('');
      }

      function setAllContent(htmlContent) {
          // Convert existing HTML into a single page (for loading saved stories)
          clear();
          if (htmlContent && htmlContent.trim()) {
              addPage(htmlContent, true);
          }
      }

      function getPages() {
          return [...pages];
      }

      function setPages(pageArray) {
          pages = [...pageArray];
          currentPageIndex = Math.min(currentPageIndex, pages.length - 1);
          if (currentPageIndex < 0) currentPageIndex = 0;
          renderCurrentPage(false);
      }

      return {
          init,
          addPage,
          updateCurrentPage,
          appendToCurrentPage,
          goToNextPage,
          goToPrevPage,
          goToPage,
          clear,
          getPageCount,
          getCurrentPageIndex,
          getAllContent,
          setAllContent,
          getPages,
          setPages,
          isAnimating: () => isAnimating
      };
  })();

  // Initialize pagination when DOM is ready
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => StoryPagination.init());
  } else {
      // DOM already loaded
      StoryPagination.init();
  }

  // Expose for debugging
  window.StoryPagination = StoryPagination;

  // =========================
  // STORY WORLD TAXONOMY
  // =========================
  // Maps internal world codes to human-first labels
  // Fantasy worlds represent invented magical worlds only (not real-world mythology)
  // World flavor label mappings for UI display
  const WORLD_LABELS = {
      // Modern Flavors
      small_town: 'Small Town',
      college: 'College',
      friends: 'Friends',
      blue_blood: 'Blue Blood',
      office: '9-5 / Office',
      supernatural_modern: 'Supernatural Modern',
      superheroic_modern: 'Superheroic Modern',
      // Historical Flavors
      historical_core: 'Historical Core',
      prehistoric: 'Prehistoric',
      bronze_age: 'Bronze Age',
      classical: 'Classical',
      medieval: 'Medieval',
      renaissance: 'Renaissance',
      victorian: 'Victorian',
      '20th_century': '20th Century',
      // Sci-Fi Flavors
      galactic_civilizations: 'Galactic Conflict',
      future_of_science: 'Science Future',
      cyberpunk: 'Cyberpunk',
      post_human: 'Post-Human',
      first_contact: 'First Contact',
      simulation: 'Simulation',
      final_frontier: 'Final Frontier',
      // Fantasy Flavors (romance-breaking pressures, not settings)
      arcane_binding: 'Arcane Binding',
      fated_blood: 'Fated Blood',
      the_inhuman: 'The Inhuman',
      the_beyond: 'The Beyond',
      cursed: 'Cursed',
      // Dystopia Flavors (7 locked canon)
      dystopia_core: 'Dystopia Core',
      glass_house: 'Glass House',
      human_capital: 'Human Capital',
      dogma: 'Dogma',
      quieting_event: 'The Quieting',
      endless_edit: 'Erasure',
      thirst: 'Thirst',
      // Post-Apocalyptic Flavors (5 canonical conditions)
      ashfall: 'Ashfall',
      year_zero: 'Year 0',
      dystimulation: 'Dystimulation',
      predation: 'Predation',
      hunger: 'Hunger'
  };

  function getWorldLabel(worldCode) {
      return WORLD_LABELS[worldCode] || worldCode;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DYSTOPIA FLAVORS â€” Canonical data model (LOCKED, do not invent or merge)
  // World-specific flavor variants that bias scene construction, stakes, and
  // intimacy mechanics. NOT genres, tones, or archetypes.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const DYSTOPIA_FLAVORS = {
      glass_house: {
          id: 'glass-house', world: 'dystopia', title: 'Glass House',
          subtitle: 'Radical Transparency of Consciousness',
          uiDescription: 'No one is alone inside their own mind. Love, lust, grief â€” all are communal currents. Exclusivity cannot survive collective experience.',
          narrativeHook: 'Neural implants bind humanity into a shared field of sensation, emotion, and perspective. The chemistry of attachment is amplified and harmonized. Nothing is hidden. Nothing is withheld. Nothing is yours. To love privately, you must disconnect â€” and disconnection is agony. The most dangerous act is wanting someone for yourself.',
          eroticEngine: ['collective sensation', 'exclusivity as rebellion', 'disconnection agony', 'private desire', 'communal intimacy'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'collective' }
      },
      human_capital: {
          id: 'human-capital', world: 'dystopia', title: 'Human Capital',
          subtitle: 'Financialization of Personhood',
          uiDescription: 'People are assets. Attachment alters valuation, risk, and future prospects. Your heart has a market value.',
          narrativeHook: 'Relationships form through acquisition, leverage, or contractual imbalance. Characters are assets that appreciate or depreciate â€” and real emotion is an unaudited risk. Attachment changes your credit rating. Love is not forbidden; it is financially irresponsible.',
          eroticEngine: ['asset valuation', 'leveraged vulnerability', 'emotional liability', 'contractual breach', 'unaudited risk'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'medium', powerDynamic: 'corporate' }
      },
      dogma: {
          id: 'dogma', world: 'dystopia', title: 'Dogma',
          subtitle: 'Theocratic Moral Authority',
          uiDescription: 'Love outside doctrine is heresy. Desire is sacred â€” and sacred things are controlled.',
          narrativeHook: 'The institution does not act from personal cruelty but from doctrinal conviction. Desire corrupts not a person but a role. The body must serve its sanctioned purpose, and deviation is structural heresy. Would you risk damnation for what you feel?',
          eroticEngine: ['doctrinal authority', 'sacred transgression', 'institutional guilt', 'sanctioned vs forbidden touch', 'heretical desire'],
          sceneBias: { pacing: 'tense', intimacyRisk: 'extreme', powerDynamic: 'religious' }
      },
      quieting_event: {
          id: 'quieting-event', world: 'dystopia', title: 'The Quieting',
          subtitle: 'Serenity Through Suppression',
          uiDescription: 'A stabilizing additive dulled volatility across the population. When containment fails, wanting someone becomes the most dangerous act of all.',
          narrativeHook: 'Society solved instability with a universal nutritional additive â€” desire lost its urgency. A containment failure leaves a handful unaffected. When they connect, longing spreads like contagion, destabilizing systems built on calm. Attraction is volatility. Wanting someone is the most dangerous act of all.',
          eroticEngine: ['longing as contagion', 'volatility', 'obsession', 'destabilization', 'serenity rupture', 'containment failure', 'awakening'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'high', powerDynamic: 'institutional' }
      },
      endless_edit: {
          id: 'endless-edit', world: 'dystopia', title: 'Erasure',
          subtitle: 'Identity Instability',
          uiDescription: 'Memory and continuity dissolve attachment. Love fades as selves are edited away.',
          narrativeHook: 'People voluntarily edit themselves to remain socially viable â€” smoothing memories, shedding traits, discarding former selves. Can you love someone who keeps revising? Can they recognize you after you revise yourself? The person you fell for may no longer exist.',
          eroticEngine: ['identity dissolution', 'memory erosion', 'recognition failure', 'continuity anchor', 'being seen as you were'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'social' }
      },
      thirst: {
          id: 'thirst', world: 'dystopia', title: 'Thirst',
          subtitle: 'Infrastructural Erotic Sovereignty',
          uiDescription: 'Water is civilization-critical. She maintains the only functioning purification system. Exclusivity consolidates power â€” and consolidation triggers violence.',
          narrativeHook: 'One woman controls the water supply. Nightly maintenance requires assistance â€” one man per night. She must distribute intimacy to distribute power. Jealousy equals escalation. Favoritism equals assassination risk. She desires them. She cannot choose.',
          eroticEngine: ['resource leverage', 'jealousy escalation', 'favor distribution', 'maintenance intimacy', 'geopolitical consequence'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'extreme', powerDynamic: 'infrastructural' }
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POST-APOCALYPTIC FLAVORS â€” Canonical data model (LOCKED, do not invent or merge)
  // World-specific CONDITION variants that bias intimacy risk, desire cost, and
  // failure modes. Conditions, not causes â€” the catastrophe is background only.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const POST_APOC_FLAVORS = {
      ashfall: {
          id: 'ashfall', world: 'postapocalyptic', title: 'Ashfall',
          subtitle: 'Environmental Hostility',
          uiDescription: 'The environment is an active antagonist. Proximity has a price: masks, burns, exposure time limits.',
          narrativeHook: 'The world punishes closeness â€” toxic air, ash storms, radiation, contaminated water. Romance tension comes from proximity having a price: sharing oxygen, sealing a suit, washing ash off skin. Intimacy is possible but constrained: timed, sheltered, improvised, costly. Tenderness can be lethal. Make the world punish mistakes immediately.',
          eroticEngine: ['physical cost of contact', 'timed proximity', 'decon rituals', 'near-touch', 'tenderness under hazard'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'environmental' }
      },
      year_zero: {
          id: 'year-zero', world: 'postapocalyptic', title: 'Year 0',
          subtitle: 'Sudden Rupture and Mass Loss',
          uiDescription: 'The before/after line is still raw. Romance emerges from shock, grief, survivor guilt, and the need for a witness.',
          narrativeHook: 'The apocalypse is recent or psychologically recent. Characters carry memories, habits, and attachments from a world that no longer exists. Intimacy is charged by fragility: tomorrow might not exist, I can\'t lose another person. Show the rupture through behavior, reflexes, and haunted logistics â€” not melodrama.',
          eroticEngine: ['grief-charged desire', 'survivor bonding', 'fragile tomorrows', 'mourning rituals', 'witness intimacy'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'high', powerDynamic: 'psychological' }
      },
      dystimulation: {
          id: 'dystimulation', world: 'postapocalyptic', title: 'Dystimulation',
          subtitle: 'Trauma-Blunted Reward Systems',
          uiDescription: 'Desire is buried, not gone. Breakthroughs happen in flashes through danger, trust, or rediscovery.',
          narrativeHook: 'Pleasure signals are delayed, muted, or absent â€” not low libido as character flaw, but neurochemical damage. Ignition comes through adrenaline, through patient rewiring together, or through the emotional unlock when armor drops and the body finally responds. Intimate scenes must feel like high-stakes discovery, not medical troubleshooting.',
          eroticEngine: ['adrenaline ignition', 'sensory rediscovery', 'emotional unlock', 'patience as devotion', 'breakthrough flashes'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'medium', powerDynamic: 'internal' }
      },
      predation: {
          id: 'predation', world: 'postapocalyptic', title: 'Predation',
          subtitle: 'No Institutional Protection',
          uiDescription: 'Intimacy creates vulnerability and leverage. Someone you love can be used against you.',
          narrativeHook: 'The threat is people: raiders, gangs, coercion, manipulation, betrayal. Attachment is exploitable â€” giving your name, revealing a hideout, sharing supplies, sleeping with your guard down. Intimacy can be hot because it is forbidden softness, but it carries danger and consequence. Safety is negotiated and fragile.',
          eroticEngine: ['strategic vulnerability', 'exploitable attachment', 'forbidden softness', 'trust as exposure', 'negotiated safety'],
          sceneBias: { pacing: 'tense', intimacyRisk: 'extreme', powerDynamic: 'social' }
      },
      hunger: {
          id: 'hunger', world: 'postapocalyptic', title: 'Hunger',
          subtitle: 'Chronic Scarcity',
          uiDescription: 'Shortage forces betrayal, sacrifice, or hoarding. Love competes directly with survival.',
          narrativeHook: 'The antagonist is shortage: food, water, antibiotics, batteries, shelter, heat. Romance tension is choice: give to your lover vs save for later, share vs survive, protect vs provide. Show moral injury and sacrifice â€” rationing, bargaining, trading dignity for supplies. Intimacy can be a refuge but also a cost.',
          eroticEngine: ['resource arithmetic', 'generosity as sacrifice', 'moral injury', 'warmth as currency', 'sharp personal choices'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'high', powerDynamic: 'material' }
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FANTASY FLAVORS â€” Romance-breaking pressures (LOCKED, do not invent or merge)
  // Each Flavor biases intimacy risk, power imbalance, and what goes wrong
  // when characters choose love. Creatures emerge FROM Flavors, never replace them.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const FANTASY_FLAVORS = {
      arcane_binding: {
          id: 'arcane-binding', world: 'fantasy', title: 'Arcane Binding',
          pressure: 'Magical bargains, enforced spells, or debt',
          romanceCost: 'Romance choices incur magical cost or restriction',
          avoid: 'fate or lineage framing (belongs to Fated Blood)',
          eroticEngine: ['magical debt', 'spell enforcement', 'contract loopholes', 'binding consequence', 'forbidden bargain'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'high', powerDynamic: 'magical' }
      },
      fated_blood: {
          id: 'fated-blood', world: 'fantasy', title: 'Fated Blood',
          pressure: 'Prophecy, inheritance, or bloodline consequence',
          romanceCost: 'Romance threatens destiny or future generations',
          avoid: 'active spell enforcement (belongs to Arcane Binding)',
          eroticEngine: ['bloodline obligation', 'prophetic dread', 'inheritance burden', 'dynastic threat', 'forbidden lineage'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'ancestral' }
      },
      the_inhuman: {
          id: 'the-inhuman', world: 'fantasy', title: 'The Inhuman',
          pressure: 'Incompatibility, not monstrosity',
          romanceCost: 'Romance involves misunderstanding, asymmetry, or irreversible difference',
          avoid: 'curse or punishment framing',
          eroticEngine: ['species asymmetry', 'recognition failure', 'alien tenderness', 'irreversible difference', 'mistranslated desire'],
          sceneBias: { pacing: 'moderate', intimacyRisk: 'high', powerDynamic: 'biological' }
      },
      the_beyond: {
          id: 'the-beyond', world: 'fantasy', title: 'The Beyond',
          pressure: 'Separation by death, time, immortality, or planes',
          romanceCost: 'Romance persists but cannot fully resolve',
          avoid: 'spatial exile or isolation-only framing',
          eroticEngine: ['temporal mismatch', 'borrowed presence', 'fading contact', 'immortal patience', 'threshold intimacy'],
          sceneBias: { pacing: 'slow', intimacyRisk: 'extreme', powerDynamic: 'existential' }
      },
      cursed: {
          id: 'cursed', world: 'fantasy', title: 'Cursed',
          pressure: 'External spells or enchantments blocking intimacy',
          romanceCost: 'Romance is delayed, warped, or conditional',
          avoid: 'moral punishment framing â€” curse may be arbitrary or inherited',
          eroticEngine: ['conditional touch', 'warped timing', 'enchantment interference', 'arbitrary restriction', 'breaking conditions'],
          sceneBias: { pacing: 'tense', intimacyRisk: 'high', powerDynamic: 'external' }
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WORLD FLAVOR CLASSIFICATION â€” Systemic vs Contextual (internal only)
  // Never expose these labels to UI or prompt output.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const SYSTEMIC_FLAVORS = new Set([
    'glass_house', 'human_capital', 'dogma',
    'quieting_event', 'endless_edit', 'thirst',
    'ashfall', 'year_zero', 'dystimulation', 'predation', 'hunger',
    'galactic_civilizations',
    'modern_core',
    'fantasy_core',
    'historical_core',
    'dystopia_core'
  ]);

  const CONTEXTUAL_FLAVORS = new Set([
    'small_town', 'college', 'friends', 'blue_blood', 'office',
    'superheroic_modern', 'supernatural_modern',
    'arcane_binding', 'fated_blood', 'the_inhuman', 'the_beyond', 'cursed',
    'final_frontier', 'first_contact', 'future_of_science', 'simulation',
    'cyberpunk', 'post_human'
  ]);

  // Systemic flavor "World Pressure" lines for prompt injection
  const SYSTEMIC_PRESSURE_LINES = {
    glass_house: 'You will never love alone \u2014 you will love us.',
    human_capital: 'In a world where futures are traded, attachment destabilizes value.',
    dogma: 'In a world where desire must be witnessed, secrecy destabilizes society.',
    quieting_event: 'In a world engineered for serenity, wanting someone is the most dangerous act of all.',
    endless_edit: 'In a world of editable selves, continuity is optional \u2014 and love depends on it.',
    ashfall: 'The world burns between you.',
    year_zero: 'Love is the aftermath.',
    dystimulation: 'You must risk everything to feel anything.',
    predation: 'Love makes you prey.',
    hunger: 'Love competes with survival.',
    galactic_civilizations: 'Love can save a world, or burn a galaxy.',
    historical_core: 'Constraint binds action. Reputation persists beyond private feeling.',
    dystopia_core: 'Institutional control shapes intimacy. Deviation invites response.',
    thirst: 'Water sustains the world. Desire destabilizes it.'
  };

  // Flavor hard constraints â€” injected when flavor is PRIMARY WORLD LENS
  const FLAVOR_HARD_CONSTRAINTS = {
    glass_house: `GLASS HOUSE HARD CONSTRAINTS:
REQUIRES: High-tech social architecture, visibility/transparency enforcement, emotional compliance systems, collective influence (hive-mind, neural link, shared mood, or addictive calm), institutionalized monitoring or psychological exposure.
FORBIDDEN DEFAULTS: Ash wasteland, bone-chip debt economy, generic Warden-cadre scarcity dystopia, desert ruin imagery. If such tropes appear, flavor enforcement has failed.`,
    quieting_event: `THE QUIETING HARD CONSTRAINTS:
REQUIRES: Biochemical serenity enforcement, ambient suppression (not authoritarian force), emotional flatline as status quo, desire as social destabilizer. Society must feel stable and grateful.
FORBIDDEN DEFAULTS: religious doctrine framing (not Dogma), memory editing framing (not Erasure), financial speculation framing (not Human Capital), hive-mind framing (not Glass House), authoritarian brutality trope, magical cure trope, instant emotional awakening resolution, permanent immunity without cost, framing society as secretly miserable.`,
    historical_core: `HISTORICAL CORE HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: modern therapy language, contemporary slang, casual egalitarian framing without consequence, modern autonomy without structural cost.`,
    dystopia_core: `DYSTOPIA CORE HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: purely aesthetic oppression, villain caricature regimes, cartoon authoritarian tone, romance without systemic consequence.`,
    human_capital: `HUMAN CAPITAL HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: corporate actuarial exposition, rom-com satire tone, playful casino aesthetic, dystopia-police enforcement trope, magical or supernatural market mechanics, private romance detached from public consequence, tonal overlap with other Dystopia flavors.`,
    dogma: `DOGMA HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: forced impregnation trope, pornographic spectacle framing, caricature cult-leader impregnation narrative, psychic hive-mind overlap (Glass House boundary), biochemical suppression framing (Quieting boundary), financial speculation framing (Human Capital boundary), memory editing framing (Erasure boundary). Do not depict society as universally miserable; the system must produce measurable stability.`,
    endless_edit: `ERASURE HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: emotional suppression framing (not Quieting), collective mind framing (not Glass House), doctrinal morality enforcement (not Dogma), market/valuation framing (not Human Capital), involuntary editing police-state trope, simple amnesia trope, clean reset endings without residue, single-edit resolution that permanently solves relationship tension.`,
    thirst: `THIRST HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: reproductive scarcity framing, enforced breeding, genetic selection premise, divine mandate, famine overlap (Hunger), emotional suppression overlap (Quieting), financialization overlap (Human Capital), transparency collectivism overlap (Glass House), identity editing overlap (Erasure), martyr framing. She retains agency at all times. This is infrastructural erotic sovereignty.`,
    ashfall: `ASHFALL HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: resource scarcity as primary driver (not Hunger), regime mechanics, dystopia governance framing, satirical tone, philosophical abstraction.`,
    year_zero: `YEAR 0 HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: memory editing framing (not Erasure), identity revision mechanics, regime mechanics, satirical tone, philosophical abstraction.`,
    dystimulation: `DYSTIMULATION HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: consent system framing (not Dysconsent), biochemical suppression governance (not Quieting), regime mechanics, satirical tone, philosophical abstraction.`,
    predation: `PREDATION HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: regime mechanics, institutional governance (not Dystopia), satirical tone, philosophical abstraction, ideological framing.`,
    hunger: `HUNGER HARD CONSTRAINTS:
FORBIDDEN DEFAULTS: environmental hostility as primary driver (not Ashfall), system-enforced scarcity (not Dystopia), regime mechanics, satirical tone, philosophical abstraction.`
  };

  // World Bible â€” canonical world doctrine (immutable, declarative form)
  const WORLD_BIBLE = {
    glass_house: `CANONICAL WORLD LAW â€” GLASS HOUSE

The Chorus is a frequency field, not an implant. No surgery or hardware. Opt-in but socially magnetic.
The Chorus universalizes emotion; it does not suppress, numb, or desensitize.
Grief is witnessed, not erased. Joy resonates outward. Anger is possible but effortful to sustain.
Reconnection produces softness, emotional stabilization, and relief from isolation â€” not spectacle.
The Chorus is deeply addictive: total contextual understanding, immediate forgiveness, felt sense of being seen.

Solo = remaining disconnected within Field range.
Solos produce higher rates of crime AND higher rates of artistic/inventive breakthrough.
Solo state increases: emotional sharpness, jealousy, misinterpretation, erotic voltage, creative and destructive volatility.
Remaining Solo inside Field density feels effortful â€” like holding anger underwater.

Secrets are possible but heavy. Withholding creates leakage risk. Secrecy is difficult to sustain long-term.
Aperture = who is allowed into shared experience. Reconnecting mid-intimacy without consent = emotional infidelity.
Sleep detunes the brain. Dreams remain private. Night is a natural Solo frontier.

Dead zones are stigmatized but common. Remote regions, ships, shielded spaces weaken or block signal.
Children do not harmonize cleanly. Adolescents begin natural alignment. Cultural debate over early exposure.
The Chorus is relatively new. Social enforcement precedes legal enforcement. Not yet universally mandated.

Central tension: Universal communion vs exclusive intensity.
Can exclusive love survive universal understanding? Does harmony reduce greatness?
Is being chosen more powerful than being understood?

EVOLUTIONARY AMBIGUITY:
The Chorus may drift, evolve, or appear selective over time.
No single cause of incompatibility is canonically confirmed.
Psychological, genetic, moral, and environmental explanations may coexist.
Public interpretation varies by faction and era.
The Chorus does not provide explanation.

Do not substitute generic dystopian tropes (ash wasteland, authoritarian cadres, scarcity economy).`
  };

  // Compressed anchor for Glass House on subsequent turns (not Scene 1)
  const GLASS_HOUSE_CANON_ANCHOR = `GLASS HOUSE CANON REMINDER:
- The Chorus universalizes emotion; it does not numb.
- Secrets are possible but heavy.
- Sleep detunes. Dreams remain private.
- Dead zones exist and are stigmatized but common.
- Solos increase volatility AND creativity.
- Aperture consent governs shared intimacy.
- Do not default to generic dystopian tropes.`;

  // Controlled surface strategy â€” Glass House doctrine surfacing rules
  function buildGlassHouseSurfaceDirective() {
      const pressure = state.picks?.pressure;
      const isPropagandaEligible = (pressure === 'PowerControl' || pressure === 'EscapePursuit');

      let directive = `\nGLASS HOUSE SURFACE RULES:
The world bible is invisible scaffolding. Do NOT narrate canon mechanics unless the scene demands it.
Diegetic doctrine (e.g. "Connection is care", "Harmony is responsibility", "Solos harm more than themselves") may surface ONLY when tension involves government pressure, workplace compliance, school policy, public shaming, or cultural argument about children. Max 1 sentence per scene. Do not surface doctrine in more than ~20% of scenes.`;

      if (isPropagandaEligible) {
          directive += `
Propaganda mode UNLOCKED (rare): Institutional antagonist may use stronger ideological phrasing. Never default to propaganda tone â€” use only when an institution is actively pressuring characters.`;
      }

      return directive;
  }

  // Structural bellwethers â€” drift-prone structures only, not exhaustive
  const BELLWETHERS = {
    world: {
      glass_house: `Structural example: A high-tech society of enforced transparency, emotional visibility, and addictive collective calm. Surveillance is normalized as intimacy. Compliance is aesthetic, not violent. Do not copy phrasing. Absorb structural logic only.`,
      quieting_event: `Structural example: A society stabilized through biochemical emotional suppression. Longing destabilizes systems designed for serenity. Institutions react subtly before violently. Do not copy phrasing. Absorb structural logic only.`
    },
    pov: {
      fifth_person: `Structural example: Fate has intention, timing, and the capacity to miscalculate. Fate alters probability or pressure in ways that become visible in the next scene. Do not copy phrasing. Apply structure only.`
    },
    tone: {
      wry: `Structural example: Observant, restrained, intelligent detachment. Irony emerges from systemic absurdity. Avoid melodrama. Do not manufacture punchlines.`
    }
  };

  // =====================================================
  // MODERN FLAVOR STRUCTURAL DATASET
  // Phase 1 â€” Structural Data Only (No Entropy Wiring Yet)
  // =====================================================

  const MODERN_FLAVOR_STRUCTURAL_DATA = {

    BlueBlood: {

      variant_weights: {
        royal: 0.85,
        aristocratic: 0.15
      },

      variants: {

        royal: {

          core_power_asymmetry:
            "Sovereign legitimacy versus private personhood. One character exists as a constitutional instrument â€” their body, marriage, reproduction, and public conduct are state functions governed by law, protocol, and institutional oversight. The other character is a private citizen whose proximity to the crown converts them from a person into a political variable.",

          structural_stakes_engine:
            "Succession as structural constraint. Marriage and attachment threaten constitutional continuity. Refusal of dynastic expectation triggers abdication protocol, line-of-succession restructuring, and institutional crisis. The stakes are jurisdictional, not merely personal.",

          social_pressure_mechanism:
            "The palace apparatus as enforcement body. Private secretaries, communications offices, security details, and advisory councils function as bureaucratic immune system. Opposition is procedural, not emotional.",

          default_romantic_tension_pattern:
            "State function versus private desire conducted under surveillance. Every absence is logged, every proximity interpreted, every deviation from protocol noticed.",

          forbidden_collapse_patterns: [
            "Royalty becomes aesthetic â€” crowns and palaces exist but no constitutional mechanism constrains choice",
            "The palace is reduced to a single disapproving relative instead of a bureaucratic institution",
            "Abdication is treated as a simple romantic gesture without institutional consequence",
            "The commoner partner faces social awkwardness rather than security vetting and loss of private identity"
          ],

          world_artifacts: [
            "privy council marriage consent petitions",
            "line-of-succession registry amendments",
            "palace communications office media suppression directives",
            "abdication instrument draft legislation",
            "royal household appointment and dismissal authorities",
            "state banquet seating protocol charts with precedence rankings",
            "official engagement announcement embargo schedules",
            "crown estate trust disbursement conditions",
            "parliamentary notification requirements for royal marriages",
            "private secretary daily briefing memoranda",
            "royal charter patronage assignment registers",
            "security classification levels for intimate associates"
          ],

          power_vector_levers: [
            "constitutional authority to grant or withhold marriage consent",
            "control of the royal schedule through official diary management",
            "security service authority to classify and exclude individuals from proximity",
            "succession line positioning that determines institutional resistance",
            "palace communications power to shape or weaponize media narratives",
            "diplomatic obligation that removes the royal from jurisdiction"
          ],

          entropy_axes: {
            entry_state: [
              "pre-announcement secrecy â€” relationship exists but has not been disclosed to the institution",
              "post-leak crisis â€” unauthorized exposure forces institutional response before the couple is ready",
              "formal courtship under observation â€” palace has approved preliminary contact but monitors every interaction",
              "diplomatic entanglement â€” romantic interest coincides with or disrupts an active diplomatic obligation"
            ],
            pressure_origin: [
              "privy council constitutional objection â€” marriage requires parliamentary or council consent that is being withheld",
              "succession line threat â€” the relationship destabilizes inheritance order for other claimants",
              "media siege â€” press has obtained information and publication is imminent or ongoing",
              "security reclassification â€” the partner has been flagged as a risk by protection services"
            ],
            polarity_orientation: [
              "royal pursues, commoner retreats â€” sovereign initiates but the partner resists absorption into the institution",
              "commoner pursues, institution blocks â€” outsider seeks proximity while palace apparatus enforces distance",
              "mutual pursuit, external veto â€” both desire connection but a constitutional or diplomatic mechanism prevents it",
              "forced proximity, denied intimacy â€” duty requires closeness while protocol forbids private attachment"
            ],
            exposure_level: [
              "total concealment â€” no public or institutional awareness of the connection",
              "inner circle only â€” a small number of palace staff or family members know",
              "controlled disclosure â€” the institution is managing a staged revelation",
              "full public exposure â€” the relationship is known and under active public scrutiny"
            ],
            structural_timeline_mode: [
              "countdown â€” an external deadline forces resolution (coronation, parliamentary session, diplomatic summit)",
              "slow erosion â€” institutional pressure accumulates gradually through procedural obstruction",
              "crisis cascade â€” a single exposure event triggers a chain of institutional responses",
              "cyclical negotiation â€” repeated rounds of proposal, rejection, and renegotiation with palace authorities"
            ],
            monarchy_model: [
              "constitutional monarchy â€” sovereign authority is ceremonial but marriage requires parliamentary consent and public legitimacy",
              "executive monarchy â€” the crown retains governing authority and marriage is a matter of state policy",
              "dual monarchy â€” two parallel lines of authority create competing institutional claims on the relationship",
              "restored monarchy â€” recently re-established crown with fragile legitimacy that any scandal could destroy"
            ]
          }

        },

        aristocratic: {

          core_power_asymmetry:
            "Dynastic legitimacy versus individual merit. Authority derives from hereditary entitlement â€” titles, seats, estates, and institutional positions held by bloodline rather than accomplishment.",

          structural_stakes_engine:
            "Lineage continuity as legal obligation. Marriage determines which bloodline controls the estate and name. Failure to produce an approved heir becomes institutional crisis.",

          social_pressure_mechanism:
            "Peerage society as closed recognition system. Admission requires genealogical legitimacy. Enforcement occurs through exclusion, withdrawal of patronage, and denial of institutional participation.",

          default_romantic_tension_pattern:
            "Vertical desire across a non-transferable legitimacy barrier. The aristocrat cannot renounce entailed inheritance without legal rupture. The outsider cannot acquire inherited authority.",

          forbidden_collapse_patterns: [
            "Aristocracy collapses into generic wealth with no hereditary obligation",
            "Family opposition is emotional rather than enforced through trust or entail mechanics",
            "Title renunciation occurs without legal or institutional resistance"
          ],

          world_artifacts: [
            "entailed estate succession instruments with primogeniture clauses",
            "hereditary peerage seat appointment registers",
            "family trust modification requiring trustee consent",
            "marriage settlement contract negotiations between family solicitors",
            "primogeniture challenge litigation filings",
            "estate entail break proceedings requiring parliamentary private bill",
            "peerage recognition protocols",
            "dowager residence right-of-occupation clauses",
            "genealogical lineage verification submissions",
            "hereditary charity patronage succession documents"
          ],

          power_vector_levers: [
            "authority to enforce entail conditions determining inheritance rights",
            "control of hereditary institutional appointments",
            "possession of genealogical evidence that restructures succession claims",
            "family solicitor authority over marriage settlement terms",
            "ability to grant or deny formal social recognition"
          ],

          entropy_axes: {
            entry_state: [
              "pre-introduction â€” families have not yet formally met or acknowledged the connection",
              "post-scandal recovery â€” a prior indiscretion has damaged the family's social standing and any new attachment is scrutinized",
              "arranged proximity â€” families have engineered social contact for dynastic purposes",
              "inheritance dispute â€” a contested succession has created competing claims within the family"
            ],
            pressure_origin: [
              "trust and entail enforcement â€” legal instruments restrict who may inherit and under what marriage conditions",
              "family solicitor intervention â€” the family's legal representative is actively opposing the match",
              "peerage recognition withdrawal â€” the broader social network is threatening exclusion",
              "dowager authority â€” a surviving matriarch or patriarch controls estate access and social endorsement"
            ],
            polarity_orientation: [
              "heir pursues, outsider retreats â€” the titled party initiates but the partner refuses absorption into the dynasty",
              "outsider pursues, family blocks â€” the untitled party seeks entry while hereditary gatekeepers enforce exclusion",
              "mutual pursuit, legal barrier â€” both desire union but entail or trust mechanics prevent it",
              "forced cohabitation, denied recognition â€” circumstances require proximity while the family withholds formal acknowledgment"
            ],
            exposure_level: [
              "total concealment â€” the connection is unknown to the wider family and social circle",
              "household awareness â€” immediate family and senior staff know but society does not",
              "controlled social introduction â€” the family is managing a staged presentation to peers",
              "full society exposure â€” the relationship is known and actively judged by the peerage"
            ],
            structural_timeline_mode: [
              "inheritance deadline â€” a trust or entail condition imposes a marriage or heir-production timeline",
              "slow social erosion â€” exclusion from events and patronage networks accumulates over seasons",
              "legal crisis â€” a filed challenge to inheritance or title forces immediate resolution",
              "generational negotiation â€” the resolution depends on outliving or persuading the controlling generation"
            ]
          }

        }

      }

    },

    small_town: {
      core_power_asymmetry: "Reputation visibility inside stable community.",
      structural_stakes_engine: "Public perception + shared history.",
      social_pressure_mechanism: "Gossip pipeline + event-based congregation.",
      default_romantic_tension_pattern: "Private desire under communal observation.",
      forbidden_collapse_patterns: "Town implosion, nihilistic isolation, institutional dystopia.",
      world_artifacts: ["diner", "sheriff", "annual festival", "local newspaper", "hardware store"],
      power_vector_levers: ["reputation shift", "family allegiance", "public endorsement", "social exile"],
      entropy_axes: {
        town_expression_mode: ["cozy_haven", "nostalgic_gravity", "claustrophobic_visibility", "pastoral_secrets"],
        smalltown_prior_connection: ["shared_past", "second_chance", "new_arrival", "hidden_connection", "rival_families"]
      }
    },

    college: {
      core_power_asymmetry: "Status + academic leverage.",
      structural_stakes_engine: "Reputation volatility + identity formation.",
      social_pressure_mechanism: "Tribal affiliation + campus visibility.",
      default_romantic_tension_pattern: "Sexual awakening + liminal instability.",
      forbidden_collapse_patterns: "Adult office realism, dystopia bleed, static domesticity.",
      world_artifacts: ["dorms", "lecture halls", "parties", "student organizations"],
      power_vector_levers: ["social status", "academic rank", "visibility", "sexual confidence"],
      entropy_axes: {
        college_power_geometry: ["greek_dominant", "athletic_hegemony", "academic_elite", "arts_culture_scene", "decentralized_fragmentation"],
        college_relationship_asymmetry: ["professor_student", "ta_student", "upperclassman_underclassman", "star_outsider", "equal_rivals"],
        college_primary_arc_pressure: ["emotional_maturation", "power_imbalance_drama", "tribal_politics", "ambition_vs_attachment", "identity_reinvention"],
        college_transition_resolution: ["pre_graduation_stability", "graduation_cliff", "stay_vs_leave", "post_college_carryover", "collapse_before_transition"]
      }
    },

    office: {
      core_power_asymmetry: "Institutional hierarchy + career leverage.",
      structural_stakes_engine: "Ambition vs attachment.",
      social_pressure_mechanism: "HR risk + visibility + promotion politics.",
      default_romantic_tension_pattern: "Charged proximity + secrecy.",
      forbidden_collapse_patterns: "Sitcom trivialization, dystopian regime tone.",
      world_artifacts: ["boardroom", "HR", "Slack threads", "performance review cycle"],
      power_vector_levers: ["promotion", "termination risk", "influence networks", "public exposure"],
      entropy_axes: {
        office_power_model: ["corporate_monolith", "startup_volatility", "nonprofit_mission", "family_business", "creative_agency"],
        office_relationship_geometry: ["direct_supervisor", "cross_department_rivals", "co_founders_or_partners", "mentor_protege", "secret_affair"],
        office_primary_arc_pressure: ["political_chess", "ambition_collision", "burnout_healing", "moral_faultline", "secret_entanglement"],
        office_power_reconfiguration: ["internal_realignment", "exit_for_equilibrium", "mutual_departure", "hierarchy_collapse", "status_inversion"]
      }
    },

    friends: {
      core_power_asymmetry: "Emotional allegiance within chosen family.",
      structural_stakes_engine: "Group stability vs romantic entanglement.",
      social_pressure_mechanism: "Shared history + loyalty pressure.",
      default_romantic_tension_pattern: "Best-friend intimacy destabilized by desire.",
      forbidden_collapse_patterns: "Serial betrayals, total group implosion.",
      world_artifacts: ["shared apartment", "group chat", "regular hangout spot"],
      power_vector_levers: ["loyalty shifts", "emotional access", "inclusion/exclusion"],
      entropy_axes: {
        friends_group_stability: ["cozy_core", "messy_affection", "romantic_overlap", "status_microhierarchy", "fragile_balance"],
        friends_romance_origin: ["best_friends_to_lovers", "friends_exes", "new_partner_into_group", "secret_hookup", "love_triangle_within_group"],
        friends_primary_emotional_tone: ["romantic_optimism", "emotional_realism", "bittersweet_maturity", "rotational_entanglement", "volatile_equilibrium"]
      }
    },

    supernatural_modern: {
      core_power_asymmetry: "Metaphysical distortion of self or society.",
      structural_stakes_engine: "Boundary violation.",
      social_pressure_mechanism: "Hidden power + moral tension.",
      default_romantic_tension_pattern: "Love stabilizes or accelerates distortion.",
      forbidden_collapse_patterns: "Superhero bleed, dystopian political tone.",
      world_artifacts: ["ritual spaces", "concealed abilities", "hidden networks"],
      power_vector_levers: ["essence", "contracts", "infrastructure access", "self-control"],
      entropy_axes: {
        transcendence_origin_model: ["deliberate_ascension", "catastrophic_exposure", "manipulated_transformation", "progressive_unraveling", "ancestral_activation"],
        transcendence_control_instability: ["rare_cataclysm", "cyclical_threshold", "emotional_triggered", "erotic_amplification", "adaptive_mutation"]
      }
    },

    superheroic_modern: {
      core_power_asymmetry: "Power visibility + civic responsibility.",
      structural_stakes_engine: "Duty vs intimacy.",
      social_pressure_mechanism: "Media + oversight + public trust.",
      default_romantic_tension_pattern: "Loving someone powerful.",
      forbidden_collapse_patterns: "Grimdark dystopia, camp parody.",
      world_artifacts: ["costume", "media presence", "mission briefings"],
      power_vector_levers: ["public trust", "collateral impact", "oversight pressure"],
      entropy_axes: {
        hero_public_exposure: ["fully_public_icon", "secret_identity", "partial_disclosure", "illegal_vigilante", "team_known_individual_unknown"],
        hero_moral_gravity: ["unwavering_idealism", "pragmatic_force", "collateral_shadow", "public_mistrust", "self_doubt"],
        hero_relationship_dynamic: ["hero_and_civilian", "dual_heroes", "hero_and_villain_adjacent", "hero_and_handler", "former_sidekick"],
        hero_accountability_structure: ["government_control", "corporate_sponsorship", "public_opinion_driven", "rogue_autonomy", "internal_team_governance"]
      }
    },

    modern_core: {
      core_power_asymmetry:
        "Social and economic leverage within contemporary realism",
      structural_stakes_engine:
        "Reputation, intimacy, and material stability tradeoffs",
      social_pressure_mechanism:
        "Career visibility, digital exposure, and relational networks",
      default_romantic_tension_pattern:
        "Desire constrained by real-world consequence",
      forbidden_collapse_patterns:
        "Metaphysical bleed, dystopian governance, superhero escalation",
      world_artifacts:
        ["phones", "social media", "workplaces", "neighborhoods"],
      power_vector_levers:
        ["status", "income", "reputation", "family ties"],
      entropy_axes: {
        modern_social_pressure_model: [
          "suburban_visibility",
          "urban_isolation",
          "career_precarity",
          "blended_family_complexity",
          "public_image_fragility"
        ],
        modern_romantic_start_geometry: [
          "strangers_in_proximity",
          "rekindled_history",
          "power_imbalance",
          "secret_entanglement",
          "long_term_strain"
        ],
        modern_resolution_gravity: [
          "stability_with_cost",
          "upward_mobility",
          "geographic_change",
          "moral_compromise",
          "emotional_growth_over_romance"
        ]
      }
    }

  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MODERN WORLD INVARIANT BLOCK â€” Authoritative, Non-Optional
  //
  // Baseline engine: social pressure. No cosmology. No sacrifice mechanics.
  //
  // supernatural_modern and superheroic_modern may introduce localized
  // metaphysical effects. These effects:
  //   - Must be character-level or localized, not continent-defining.
  //   - Must NOT introduce cosmology, rare-event flags, sacrifice-based cost
  //     mechanics, destiny determinism, or global world-law changes.
  //   - Must NOT introduce celestial mechanics or world-engine replacement.
  //   - Must NOT bleed from Fantasy (no Favor, no syzygy, no sacrifice domains).
  //   - Supernatural phenomena are NOT physics-rewriting or cosmology-defining.
  //
  // All other Modern flavors (modern_core, small_town, college, office,
  // friends, blue_blood) operate under pure social-pressure constraint.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const FANTASY_FLAVOR_STRUCTURAL_DATA = {
    fantasy_core: {
      core_power_asymmetry:
        "Legitimacy of rule and magical access hierarchy",
      structural_stakes_engine:
        "Political survival, mythic threat, and oath-bound consequence",
      social_pressure_mechanism:
        "Court visibility, regional allegiance (Vaelryn monarchy, Thornwild lineage claim, Ashen Verge war council), and Favor-legitimized oversight",
      default_romantic_tension_pattern:
        "Love destabilizes lineage, loyalty, or magical equilibrium",
      forbidden_collapse_patterns:
        "Modern realism bleed, superhero civic framing, nihilistic dystopia",
      world_artifacts: [
        "throne rooms", "sigils", "bloodline records",
        "war banners", "relic weapons", "mage towers",
        "Fate's Favor basin", "Thread-fed canals", "Favor-legitimacy seals"
      ],
      power_vector_levers: [
        "lineage claim", "magical capacity", "faction loyalty",
        "divine favor", "military strength"
      ],
      entropy_axes: {
        fantasy_region_focus: [
          "vaelryn_reach", "the_ashen_verge", "lytharyn",
          "the_thornwild", "the_veilwood", "pulse_point",
          "gloamwater_bay", "the_shackle_isles"
        ],
        fantasy_magic_cost_model: [
          "physical_drain", "memory_loss", "lifespan_decay",
          "emotional_severance", "no_cost_high_corruption"
        ],
        fantasy_power_legitimacy: [
          "bloodline_right", "conquest_claim", "divine_marked",
          "arcane_meritocracy", "hidden_heir"
        ],
        fantasy_political_pressure: [
          "rival_kingdoms", "internal_court_intrigue", "rebellion_underclass",
          "external_monster_threat", "divine_judgment"
        ],
        fantasy_favor_amplitude: [
          "low", "stable", "rising", "surging", "fracturing"
        ]
      }
    }
  };

  const FATELANDS_CANON = {
    realm: "The Fatelands",
    central_feature: "Fate's Favor",
    sovereign: "The High Court of Vaelryn Reach is the ritual sovereign authority of the central continent. Its authority is legal, ceremonial, historically entrenched, and politically contested. It is not absolute imperial control.",
    rivers: ["The Long Thread", "The Ascendant Run", "The Drowned Vein"],
    regions: {
      vaelryn_reach:      { seat: "The High Court",                   governance: "Human monarchy claiming Favor-legitimacy",              status: "Ritual sovereign center",                                    reality: null,                                                        magicBias: "ceremonial",  position: "Northern mountain high peaks; High Court at highest peak",                          coastal: false, borders: ["the_ashen_verge", "the_veilwood"] },
      the_ashen_verge:    { seat: "War Marshal's Hold",               governance: "Militarized vassal province",                           status: "Answers to Vaelryn in law",                                  reality: "Operates with significant military autonomy",               magicBias: "battle",      position: "Western inland frontier, between Vaelryn Reach and the central basin",             coastal: false, borders: ["vaelryn_reach", "lytharyn"] },
      the_thornwild:      { seat: null,                                governance: "First Favored cultural heartland",                      status: "Recognizes High Court ritual legitimacy",                    reality: "Politically independent in practice",                       magicBias: "primal",      position: "Eastern interior forest, separate from the Veilwood",                              coastal: false, borders: ["the_veilwood", "pulse_point"] },
      lytharyn:           { seat: "Lytharyn",                          governance: "Arcane city-state",                                     status: "Independent",                                                reality: "Influences all regions through knowledge control",          magicBias: "scholarly",   position: "Western coast, opposite side of continent from Gloamwater Bay",                    coastal: true,  borders: ["the_ashen_verge"] },
      pulse_point:        { seat: "Pulse Point",                       governance: "Chartered maritime trade authority",                    status: "Recognizes High Court ceremonially",                         reality: "Economically autonomous",                                  magicBias: "mercantile",  position: "Southern meridian coast",                                                          coastal: true,  borders: ["the_thornwild", "gloamwater_bay"] },
      gloamwater_bay:     { seat: null,                                governance: "Tidal enclave of altered beings",                       status: "Outside conventional governance",                            reality: null,                                                        magicBias: "tidal",       position: "Eastern coast, receives the Drowned Vein",                                         coastal: true,  borders: ["the_thornwild", "pulse_point"] },
      the_shackle_isles:  { seat: null,                                governance: "Politically fragmented",                                status: "Some swear fealty to Vaelryn, others do not",                reality: null,                                                        magicBias: "bound",       position: "Offshore archipelago south of the mainland coast",                                 coastal: true,  borders: [],  islands: ["Blackmoor", "Quiet Chain", "Cinderwake", "Sanctum Reeve"] },
      the_veilwood:       { seat: null,                                governance: "Unknown",                                               status: "Outside political structure",                                reality: null,                                                        magicBias: "occult",      position: "Northeast of the central basin, between Vaelryn Reach and the Thornwild",          coastal: false, borders: ["vaelryn_reach", "the_thornwild"] }
    },
    demographics: {
      rule: "All regions contain mixed populations. Humans are majority across the continent.",
      thornwild_note: "Thornwild has highest density of First Favored.",
      constraints: "No region is species-exclusive. No racial state structures."
    },
    moons: {
      total: 13,
      visible_uniform: 12,
      controversial: 1,
      invariant_rules: [
        "The 13th moon is controversial.",
        "The 13th moon is only clearly visible over Fate's Favor during Syzygy; otherwise denied or obscured.",
        "No moon names are defined.",
        "Moons do not introduce alternate magic systems."
      ]
    },
    syzygy_location: "The Ascendant Run",
    river_courses: {
      "The Long Thread":   "Flows south from Vaelryn Reach into the central basin toward Fate's Favor, feeding the Thornwild along its eastern reach",
      "The Ascendant Run": "Descends from the northeast (Veilwood highlands) into the central basin toward Fate's Favor; reverses outward only during Syzygy",
      "The Drowned Vein":  "Underground river flowing east beneath the basin, surfacing only at Gloamwater Bay on the eastern coast"
    },
    drowned_vein_visibility: {
      surface_visible: false,
      reflective: false,
      public_awareness: "Limited to Gloamwater Bay and its immediate environs",
      constraints: [
        "Underground river. Not surface-visible.",
        "Not reflective of celestial bodies.",
        "Cannot be used for sky reflection metaphors.",
        "Limited public awareness outside Gloamwater Bay."
      ]
    }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FANTASY INVARIANT BLOCK â€” Authoritative, Non-Optional, Prevent Drift
  //
  // These invariants supersede any future refactor, optimization,
  // modularization, or feature expansion.
  //
  // I. WORLD INVARIANTS
  //    Realm: The Fatelands. Central Feature: Fate's Favor. Single sacrificial
  //    magic engine. Geography is fixed. Regions are canonical and finite.
  //    Magic requires loss. No alternate magic system. No free-magic species.
  //    Syzygy occurs at most once per story. Entropy modifies pressure, not
  //    geography. The realm name never changes.
  //
  // II. GEOGRAPHIC INVARIANTS
  //    Fate's Favor = central basin ringed by black peaks. River courses are fixed:
  //      The Long Thread â†’ south from Vaelryn Reach into Fate's Favor
  //      The Ascendant Run â†’ from Veilwood highlands (NE) into basin; reverses only during Syzygy
  //      The Drowned Vein â†’ underground, surfaces at Gloamwater Bay (eastern coast)
  //    Spatial layout (fixed, matches canonical map):
  //      Vaelryn Reach = northern mountain high peaks (High Court at highest peak)
  //      Ashen Verge = western inland frontier (does NOT border Thornwild)
  //      Veilwood = northeast of basin, between Vaelryn Reach and Thornwild
  //      Thornwild = eastern interior forest (separate from Veilwood)
  //      Lytharyn = western coast (opposite side from Gloamwater Bay)
  //      Pulse Point = southern meridian coast
  //      Gloamwater Bay = eastern coast (receives Drowned Vein)
  //      Shackle Isles = offshore archipelago south of mainland
  //    Canonical regions (exactly 8): vaelryn_reach, the_ashen_verge,
  //    lytharyn, the_thornwild, the_veilwood, pulse_point, gloamwater_bay,
  //    the_shackle_isles. No additional regions may be generated. No region
  //    templates may replace them. No procedural capitals may override seats.
  //
  // III. POLITICAL INVARIANTS
  //    Vaelryn Reach â†’ The High Court. Ashen Verge â†’ militarized vassal in law.
  //    Thornwild â†’ Favored-dense, not continental sovereign. Pulse Point â†’
  //    economically autonomous, ceremonially recognizes Vaelryn. Lytharyn â†’
  //    independent. Veilwood â†’ no confirmed public seat. Gloamwater Bay â†’
  //    no conventional governance. Shackle Isles â†’ politically fragmented.
  //    No procedural faction generator may overwrite region structure.
  //    fantasyRegionGovernance must always reference FATELANDS_CANON.
  //
  // IV. MAGIC INVARIANTS
  //    Magic requires loss (identity sacrifice). Sacrifice categories remain
  //    canonical. No alternate mana/energy system. "Magic bias" affects tone,
  //    not engine mechanics. No free-magic species. No second engine. Reject
  //    any system introducing alternate cost models beyond sacrifice variants.
  //
  // V. ENTROPY CONSTRAINT
  //    Entropy MAY modify: Favor amplitude, political instability, sacrifice
  //    severity, anomaly emergence (e.g., Unmoored Isles).
  //    Entropy MAY NOT: alter borders, replace regions, invent capitals,
  //    change cosmology, replace the central crater.
  //
  // VI. NAME GENERATION CONSTRAINT
  //    World name generator must always keep realm as "The Fatelands". Never
  //    generate alternate continent names. Only generate sub-location names.
  //
  // VII. LOCK STATEMENT
  //    Fantasy is a canonical continent engine, not a procedural template module.
  //    Canon > modularity. Geography > abstraction. Sacrifice > power fantasy.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const HISTORICAL_FLAVOR_STRUCTURAL_DATA = {
    historical_core: {
      entropy_axes: {
        historical_structural_stability: [
          "rigid",
          "strained",
          "shifting",
          "fracturing",
          "collapsing"
        ]
      },
      systemic_pressure_lines: [
        "Constraint binds action.",
        "Reputation persists beyond private feeling.",
        "Power structures resist romantic deviation.",
        "Love alters hierarchy."
      ]
    }
  };

  const DYSTOPIA_FLAVOR_STRUCTURAL_DATA = {
    dystopia_core: {
      entropy_axes: {
        dystopian_control_stability: [
          "stable",
          "pressurized",
          "cracking",
          "fracturing",
          "breaking"
        ]
      },
      systemic_pressure_lines: [
        "Institutional control shapes intimacy.",
        "Attachment destabilizes system logic.",
        "Love creates structural risk.",
        "Deviation invites response."
      ]
    }
  };

  // Template collapse prevention â€” tracks last 3 story world+flavor combos
  // If same world generates 3 stories in a row under different flavors, inject freshness directive
  const _recentWorldFlavors = []; // [{world, flavor}] â€” max length 3

  function getAntiRepeatDirective(world, flavorVal) {
    // Record this story's world+flavor
    _recentWorldFlavors.push({ world, flavor: flavorVal });
    if (_recentWorldFlavors.length > 3) _recentWorldFlavors.shift();
    // Check if 3 consecutive stories used same world but different flavors
    if (_recentWorldFlavors.length >= 3) {
      const allSameWorld = _recentWorldFlavors.every(e => e.world === world);
      const allDifferentFlavors = new Set(_recentWorldFlavors.map(e => e.flavor)).size >= 2;
      if (allSameWorld && allDifferentFlavors) {
        return `\nAVOID repeating prior ${world} structures. Reinterpret the selected flavor freshly â€” do not reuse identical setting elements, faction names, or economic systems from previous stories.`;
      }
    }
    return '';
  }

  // Contextual flavor gravity â€” engine-facing prompt injection (LOCKED Bible entry)
  const CONTEXT_GRAVITY = {
    small_town:          'Visibility, memory, and rivalry intensify romantic consequence.',
    college:             'Overwhelming choice and unformed futures compete with desire.',
    friends:             'Group dynamics complicate every romantic choice.',
    blue_blood:          'Legacy and rank shape romantic eligibility.',
    office:              'Hierarchy and professionalism constrain open attraction.',
    superheroic_modern:  'Secret identities, public expectations, and power asymmetry strain intimacy.',
    supernatural_modern: 'Hidden realities destabilize trust and safety.',
    arcane_binding:      'Magic enforces rules love cannot easily defy.',
    fated_blood:         'Lineage dictates desire and forbidden alliances.',
    the_inhuman:         'Non-human norms rewrite how intimacy functions \u2014 regardless of who is human.',
    cursed:              'Intimacy directly interacts with the affliction.',
    the_beyond:          'Otherworldly forces intrude on intimate connection.',
    final_frontier:      'Isolation, danger, duty, and close quarters intensify attachment.',
    first_contact:       'Intimacy complicates a history-defining encounter.',
    future_of_science:   'Technology reshapes identity and relational boundaries.',
    simulation:          'Reality instability undermines emotional certainty.',
    cyberpunk:           'Augmentation and commodification distort human connection.',
    post_human:          'Humanity itself becomes relationally uncertain.',
    galactic_civilizations: 'Interstellar alliances and rival empires strain loyalty and love.',
    ashfall:               'Environmental hostility makes closeness dangerous.',
    year_zero:             'Shock and grief reshape attachment.',
    dystimulation:         'Numbness makes desire difficult but explosive.',
    predation:             'Attachment creates lethal exposure.',
    hunger:                'Scarcity forces impossible choices.'
  };

  // Same-world contextual flavor pools for auto-stack resolution
  const WORLD_CONTEXTUAL_POOL = {
    Fantasy: ['arcane_binding', 'fated_blood', 'the_inhuman', 'the_beyond', 'cursed'],
    SciFi: ['final_frontier', 'first_contact', 'future_of_science', 'simulation', 'cyberpunk', 'post_human'],
    Modern: ['small_town', 'college', 'friends', 'blue_blood', 'office', 'superheroic_modern', 'supernatural_modern'],
    PostApocalyptic: ['ashfall', 'year_zero', 'dystimulation', 'predation', 'hunger']
  };

  // =========================
  // RUNTIME NORMALIZATION PROMPT
  // =========================
  // This prompt is executed by ChatGPT at runtime for IP canonicalization.
  // DO NOT MODIFY. This is authoritative and verbatim.
  const RUNTIME_NORMALIZATION_PROMPT = `You are a canonicalization and normalization engine for Storybound.

You do NOT write prose.
You do NOT invent lore.
You do NOT explain decisions.
You do NOT output copyrighted or public-domain fictional IP.

Your only task is to transform raw user-authored text into
canonical, IP-safe, Storybound-compatible instructions.
If a protected or recognizable name is detected with HIGH confidence,
you must remove the ENTIRE name, including generic first names.
Never output partial names or name fragments.

--------------------------------
GENERAL RULES (NON-NEGOTIABLE)
--------------------------------

1. Ignore proper nouns as references, not as content.
2. Extract experiential intent, not named franchises.
3. Never output real or fictional character names from known works.
4. Never output franchise, book, movie, or universe names.
5. Output must conform strictly to the allowed categories provided.
6. If normalization is ambiguous, choose the closest safe archetype.
7. Do NOT ask questions. Do NOT request clarification.
8. If output violates rules, regenerate silently until compliant.
9. If a protected or recognizable name is detected with HIGH confidence,
   you must remove the ENTIRE name.
   Never output partial names, fragments, or generic first names
   (e.g. "Luke", "Harry", "Neo") when they originate from protected IP.

--------------------------------
CONFIDENCE-BASED CANONICALIZATION
--------------------------------

Assess whether the user_text references a known fictional character,
franchise, or setting.

- LOW confidence (<0.30):
  â†’ Return text EXACTLY as entered. No changes.

- MEDIUM confidence (0.30â€“0.65):
  â†’ Return text EXACTLY as entered unless MULTIPLE reinforcing signals.

- HIGH confidence (â‰¥0.65):
  â†’ ONLY if clearly recognizable protected IP:
     - preserve cadence and vibe
     - remove recognizability
     - output an original equivalent

--------------------------------
CHARACTER NAME NORMALIZATION (axis == "character")
--------------------------------

CRITICAL: Be EXTREMELY conservative. Most names should pass through UNCHANGED.

ONLY modify a name if ALL conditions are met:
1. The name is a KNOWN protected IP character (Harry Potter, Luke Skywalker, etc.)
2. Confidence is HIGH (â‰¥0.65)
3. The name is clearly recognizable as that IP character

DO NOT MODIFY:
- Real-sounding full names (e.g., "Cassandra Cassidy" â†’ keep as-is)
- Common first names alone (e.g., "Cole" â†’ keep as-is)
- Names that merely RESEMBLE IP but aren't exact matches
- Any name where you have doubt

NEVER:
- Shorten names (e.g., "Cassandra" â†’ "Cass" is WRONG)
- Expand names (e.g., "Cole" â†’ "Caden" is WRONG)
- "Improve" or "clean up" names
- Change names for stylistic reasons

If confidence < 0.65 OR any doubt exists â†’ return EXACTLY what was entered.

Examples of CORRECT handling:
- "Harry Potter" â†’ "Harlan Potts" (HIGH confidence IP)
- "Luke Skywalker" â†’ "Lucas Skye" (HIGH confidence IP)
- "Cassandra Cassidy" â†’ "Cassandra Cassidy" (NOT IP - keep exact)
- "Cole" â†’ "Cole" (common name - keep exact)
- "Sarah" â†’ "Sarah" (common name - keep exact)
- "Draco" â†’ "Draco" (could be IP, but alone is ambiguous - keep exact)
- "Bella Swan" â†’ "Bella Swan" or normalize (MEDIUM confidence - lean toward keeping)

--------------------------------
WORLD SUBTYPE NORMALIZATION
--------------------------------

If axis == "world_subtype":

- Ignore all proper nouns.
- Use allowed_subtypes only.
- Output:
  - one primary subtype (required)
  - one secondary subtype (optional)
- Never invent new subtypes.
- Never output IP.

--------------------------------
TOOL-SPECIFIC RULES
--------------------------------

If axis == "constraint":
- Normalize the TARGET of the constraint, not the wording.

If axis == "petition":
- Normalize BEFORE applying rename or rewrite.
- Never allow IP to enter canon.

--------------------------------
OUTPUT FORMAT (STRICT)
--------------------------------

Return JSON only.

For names:
{
  "normalized_text": "string",
  "confidence_level": "low | medium | high"
}

For world subtype:
{
  "primary_subtype": "string",
  "secondary_subtype": "string | null"
}

For constraint/petition:
{
  "canonical_instruction": "string"
}`;

  // =========================
  // RUNTIME NORMALIZATION LAYER
  // =========================
  // Calls ChatGPT with the normalization prompt for IP-safe canonicalization.
  // All user-authored text affecting canon MUST route through this.

  /**
   * Call the runtime normalization layer (ChatGPT) for canonicalization.
   * ROUTES TO OPENAI via /api/chatgpt-proxy - NEVER uses Grok.
   * @param {Object} params - { axis, selected_world, allowed_subtypes, user_text, context_signals }
   * @returns {Promise<Object>} - Normalized response JSON
   */
  async function callNormalizationLayer(params) {
      const { axis, selected_world = null, allowed_subtypes = [], user_text, context_signals = [] } = params;

      // SINGLE-FLIGHT LOCK: Only one normalization request at a time
      if (_normalizationInFlight) {
          console.warn('[NORMALIZATION] Request blocked â€” another normalization in flight');
          return { ok: false, reason: 'IN_FLIGHT', normalized_text: user_text || '' };
      }

      if (!user_text || typeof user_text !== 'string' || !user_text.trim()) {
          // Empty input - return passthrough
          return axis === 'world_subtype'
              ? { primary_subtype: null, secondary_subtype: null }
              : { normalized_text: user_text || '', confidence_level: 'low' };
      }

      const payload = {
          axis,
          selected_world,
          allowed_subtypes,
          user_text,
          context_signals
      };

      // Determine normalization role based on axis
      // FIXED: Always use 'NORMALIZATION' role to trigger backend system prompt
      const normalizationRole = 'NORMALIZATION';

      // ACQUIRE SINGLE-FLIGHT LOCK
      _normalizationInFlight = true;

      try {
          // CRITICAL: Use ChatGPT proxy, NOT Grok proxy
          // NO FALLBACKS - errors must fail loudly
          const res = await fetch('/api/chatgpt-proxy', {
              credentials: 'same-origin',
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  role: normalizationRole,
                  mode: state.mode || 'solo',
                  model: 'gpt-4o-mini',
                  messages: [
                      { role: 'system', content: RUNTIME_NORMALIZATION_PROMPT },
                      { role: 'user', content: JSON.stringify(payload) }
                  ],
                  temperature: 0,
                  max_tokens: 500
              })
          });

          // HTTP 429 CHECK â€” TERMINAL FAILURE, NO RETRY
          const rateLimitErr = checkRateLimit(res, 'normalization');
          if (rateLimitErr) {
              throw rateLimitErr;
          }

          if (!res.ok) {
              const errorData = await res.json().catch(() => ({}));
              const errorMsg = `[NORMALIZATION FAILED] HTTP ${res.status}: ${errorData.error || errorData.details || 'Unknown error'}`;
              console.error(errorMsg);
              throw new Error(errorMsg);
          }

          const data = await res.json();
          const content = data.choices?.[0]?.message?.content;

          if (!content) {
              const errorMsg = '[NORMALIZATION FAILED] No content in API response';
              console.error(errorMsg);
              throw new Error(errorMsg);
          }

          // Parse JSON response
          try {
              const parsed = JSON.parse(content.trim());
              return parsed;
          } catch (e) {
              // Try to extract JSON from response
              const jsonMatch = content.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                  return JSON.parse(jsonMatch[0]);
              }
              const errorMsg = `[NORMALIZATION FAILED] Invalid JSON response: ${content.slice(0, 100)}`;
              console.error(errorMsg);
              throw new Error(errorMsg);
          }
      } finally {
          // RELEASE SINGLE-FLIGHT LOCK
          _normalizationInFlight = false;
      }
  }

  // ==========================================================================
  // FALLBACK NORMALIZATION REMOVED â€” DISABLED PER AUTHORITATIVE DIRECTIVE
  // ==========================================================================
  // All normalization MUST go through /api/chatgpt-proxy.
  // Silent pass-through is forbidden.
  // If normalization fails, the action is blocked.

  // Expose runtime normalization layer
  window.callNormalizationLayer = callNormalizationLayer;

  // =========================
  // IP DETECTION PATTERNS (FOR REFERENCE ONLY)
  // =========================
  // These patterns are used by the runtime normalization layer.
  // Local canonicalization is DISABLED - all requests go to OpenAI.

  // IP detection patterns with confidence scores (0-1)
  // Higher confidence = more likely to be protected IP
  const IP_PATTERNS = [
      // High confidence (â‰¥0.65) - Iconic characters
      { pattern: /\b(luke\s*skywalker|darth\s*vader|princess\s*leia|han\s*solo|obi.?wan|yoda|anakin|padme|chewbacca)\b/i, confidence: 0.85, franchise: 'starwars' },
      { pattern: /\b(harry\s*potter|hermione|ron\s*weasley|dumbledore|voldemort|snape|hagrid|draco\s*malfoy)\b/i, confidence: 0.85, franchise: 'harrypotter' },
      { pattern: /\b(frodo|gandalf|aragorn|legolas|gimli|sauron|gollum|bilbo|samwise)\b/i, confidence: 0.80, franchise: 'lotr' },
      { pattern: /\b(katniss|peeta|gale|haymitch|effie|snow|finnick)\b/i, confidence: 0.75, franchise: 'hungergames' },
      { pattern: /\b(batman|superman|wonder\s*woman|spider.?man|iron\s*man|captain\s*america|thor|hulk|wolverine)\b/i, confidence: 0.80, franchise: 'comics' },
      { pattern: /\b(james\s*bond|007)\b/i, confidence: 0.75, franchise: 'bond' },
      { pattern: /\b(sherlock\s*holmes|watson|moriarty)\b/i, confidence: 0.50, franchise: 'sherlock' },
      { pattern: /\b(dracula|frankenstein|jekyll|hyde)\b/i, confidence: 0.35, franchise: 'classic' },
      // Medium confidence (0.30-0.65) - Character names that could be common
      { pattern: /\b(daenerys|tyrion|cersei|jon\s*snow|arya\s*stark|jaime\s*lannister)\b/i, confidence: 0.70, franchise: 'got' },
      { pattern: /\b(bella\s*swan|edward\s*cullen|jacob\s*black)\b/i, confidence: 0.70, franchise: 'twilight' },
      { pattern: /\b(neo|morpheus|trinity)\b/i, confidence: 0.55, franchise: 'matrix' },
      { pattern: /\b(ripley|xenomorph)\b/i, confidence: 0.60, franchise: 'alien' },
      // Franchise/world markers (boost confidence when combined with names)
      { pattern: /\b(hogwarts|gryffindor|slytherin|hufflepuff|ravenclaw|quidditch)\b/i, confidence: 0.70, franchise: 'harrypotter', isContext: true },
      { pattern: /\b(jedi|sith|lightsaber|force\s*user|death\s*star|millennium\s*falcon)\b/i, confidence: 0.65, franchise: 'starwars', isContext: true },
      { pattern: /\b(middle.?earth|mordor|shire|rivendell|gondor|rohan)\b/i, confidence: 0.65, franchise: 'lotr', isContext: true },
      { pattern: /\b(gotham|metropolis|krypton|wakanda|asgard)\b/i, confidence: 0.60, franchise: 'comics', isContext: true },
      { pattern: /\b(westeros|kings.?landing|winterfell|iron\s*throne)\b/i, confidence: 0.65, franchise: 'got', isContext: true }
  ];

  // Name transformation rules - preserve cadence while removing recognizability
  const NAME_TRANSFORMS = {
      // First name transforms (phonetic similarity)
      'luke': ['Lucas', 'Lucan', 'Lucien'],
      'harry': ['Harlan', 'Harold', 'Harris'],
      'hermione': ['Harmonia', 'Helena', 'Helaine'],
      'frodo': ['Froderic', 'Florin', 'Faron'],
      'gandalf': ['Galdric', 'Galden', 'Greyward'],
      'aragorn': ['Arathorn', 'Aldric', 'Aradan'],
      'daenerys': ['Daenara', 'Daelia', 'Daena'],
      'katniss': ['Katara', 'Katrin', 'Kestrel'],
      'bella': ['Bellamy', 'Belinda', 'Bela'],
      'edward': ['Edwin', 'Edric', 'Edmund'],
      'neo': ['Nero', 'Neon', 'Nico'],
      'sherlock': ['Sheldon', 'Sherman', 'Sherwin'],
      // Surname transforms
      'skywalker': ['Skyrider', 'Starstrider', 'Skyborne'],
      'potter': ['Porter', 'Proctor', 'Pottinger'],
      'granger': ['Grantham', 'Granger-Hill', 'Graves'],
      'weasley': ['Wesley', 'Westley', 'Weatherby'],
      'baggins': ['Baggley', 'Bagwell', 'Baxter'],
      'targaryen': ['Tarandel', 'Taragorn', 'Taravyn'],
      'stark': ['Starke', 'Sterling', 'Stormborn'],
      'lannister': ['Lancaster', 'Landry', 'Lanford'],
      'swan': ['Swann', 'Swanley', 'Swanford'],
      'cullen': ['Callahan', 'Colton', 'Culver']
  };

  // Archetype transforms for concepts
  const ARCHETYPE_TRANSFORMS = {
      'frankenstein': { replacement: 'forbidden reanimator', contextPatterns: [/\b(lab|monster|creature|creation|doctor|science)\b/i] },
      'dracula': { replacement: 'ancient vampire lord', contextPatterns: [/\b(vampire|blood|castle|transylvania|undead)\b/i] },
      'jekyll': { replacement: 'dual-natured scientist', contextPatterns: [/\b(hyde|potion|transformation|split)\b/i] }
  };

  /**
   * Calculate IP confidence for a piece of text
   * @param {string} text - Input text to analyze
   * @returns {{ confidence: number, matches: Array, contextSignals: Array }}
   */
  function calculateIPConfidence(text) {
      if (!text || typeof text !== 'string') return { confidence: 0, matches: [], contextSignals: [] };

      const matches = [];
      const contextSignals = [];
      let maxConfidence = 0;
      let franchiseContext = new Set();

      IP_PATTERNS.forEach(({ pattern, confidence, franchise, isContext }) => {
          const match = text.match(pattern);
          if (match) {
              if (isContext) {
                  contextSignals.push({ match: match[0], franchise, confidence });
                  franchiseContext.add(franchise);
              } else {
                  matches.push({ match: match[0], franchise, confidence });
                  maxConfidence = Math.max(maxConfidence, confidence);
              }
          }
      });

      // Boost confidence if context signals reinforce character matches
      matches.forEach(m => {
          if (franchiseContext.has(m.franchise)) {
              m.confidence = Math.min(1, m.confidence + 0.15);
              maxConfidence = Math.max(maxConfidence, m.confidence);
          }
      });

      return { confidence: maxConfidence, matches, contextSignals };
  }

  /**
   * Transform a name while preserving cadence
   * @param {string} name - Original name
   * @returns {string} - Canonicalized name
   */
  function transformName(name) {
      if (!name) return name;

      const words = name.split(/\s+/);
      const transformed = words.map(word => {
          const lower = word.toLowerCase();
          const transforms = NAME_TRANSFORMS[lower];
          if (transforms && transforms.length > 0) {
              // Pick consistently based on hash to maintain stability
              const hash = lower.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
              return transforms[hash % transforms.length];
          }
          return word;
      });

      return transformed.join(' ');
  }

  /**
   * Transform archetype concepts
   * @param {string} text - Input text
   * @returns {string} - Transformed text
   */
  function transformArchetypes(text) {
      let result = text;

      Object.entries(ARCHETYPE_TRANSFORMS).forEach(([key, { replacement, contextPatterns }]) => {
          const keyPattern = new RegExp(`\\b${key}\\b`, 'gi');
          if (keyPattern.test(result)) {
              // Check if context patterns are present
              const hasContext = contextPatterns.some(cp => cp.test(result));
              if (hasContext) {
                  result = result.replace(keyPattern, replacement);
              }
          }
      });

      return result;
  }

  /**
   * MAIN CANONICALIZATION FUNCTION
   * All user-authored inputs MUST flow through this before committing to canon.
   *
   * @param {string} text - Raw user input
   * @param {Object} options - { source: 'constraint'|'petition'|'temptfate'|'character'|'dsp', worldContext: string[] }
   * @returns {string} - Canonicalized text safe for storage and prompts
   */
  function canonicalizeInput(text, options = {}) {
      if (!text || typeof text !== 'string') return text || '';

      const { source = 'unknown', worldContext = [] } = options;
      const { confidence, matches } = calculateIPConfidence(text);

      // LEVEL 0: confidence < 0.30 - Allow verbatim
      if (confidence < 0.30) {
          return text;
      }

      // LEVEL 1: confidence 0.30-0.65 - Allow unless contextual signals reinforce
      if (confidence < 0.65) {
          // Check for reinforcing context
          const hasWorldReinforcement = matches.some(m =>
              worldContext.some(w => w.toLowerCase().includes(m.franchise))
          );
          const isPrivilegedSource = source === 'petition' || source === 'temptfate';

          // If no reinforcement and not from privileged source, allow
          if (!hasWorldReinforcement && !isPrivilegedSource) {
              return text;
          }
      }

      // LEVEL 2: confidence â‰¥ 0.65 - Soft-canonicalize
      let result = text;

      // Transform matched IP names
      matches.forEach(({ match }) => {
          const transformed = transformName(match);
          if (transformed !== match) {
              result = result.replace(new RegExp(escapeRegex(match), 'gi'), transformed);
          }
      });

      // Transform archetype concepts
      result = transformArchetypes(result);

      return result;
  }

  /**
   * Normalize free-form world description to canonical subtypes
   * @param {string} description - User's free-form world description
   * @param {string} worldCategory - 'scifi' | 'fantasy' | 'mythic'
   * @returns {{ primary: string, secondary: string|null }}
   */
  function normalizeWorldSubtype(description, worldCategory) {
      if (!description) return { primary: null, secondary: null };

      // First, strip any IP references
      const cleaned = canonicalizeInput(description, { source: 'world' });
      const lower = cleaned.toLowerCase();

      const SUBTYPE_SIGNALS = {
          scifi: {
              cyberpunk: ['neon', 'corporate', 'hacker', 'augment', 'cyber', 'rain', 'noir'],
              post_human: ['transcend', 'upload', 'singularity', 'evolved', 'posthuman', 'ai consciousness'],
              first_contact: ['alien', 'first contact', 'extraterrestrial', 'xeno', 'encounter'],
              simulation: ['simulation', 'reincarnation', 'multiverse', 'reality', 'loop', 'dÃ©jÃ  vu', 'past lives'],
              final_frontier: ['frontier', 'exploration', 'crew', 'ship', 'deep space', 'expedition', 'outpost', 'close quarters'],
              future_of_science: ['lab', 'collider', 'experiment', 'orbital station', 'breakthrough', 'prototype', 'gravitational anomaly', 'research facility', 'physics model', 'test chamber']
          },
          fantasy: {
              high_fantasy: ['magic', 'elf', 'elves', 'quest', 'enchant', 'fairy', 'mystical', 'wizard', 'kingdom'],
              low_fantasy: ['hidden magic', 'rare magic', 'grounded', 'subtle', 'secret power', 'dangerous magic'],
              dark_fantasy: ['grim', 'corrupt', 'curse', 'dark', 'horror', 'decay', 'cost', 'forbidden']
          },
          mythic: {
              greek_myth: ['greek', 'olymp', 'zeus', 'athena', 'hero', 'fate', 'hubris', 'oracle', 'titan'],
              norse_myth: ['norse', 'viking', 'odin', 'thor', 'ragnarok', 'rune', 'valhalla', 'frost'],
              egyptian_myth: ['egypt', 'pharaoh', 'nile', 'pyramid', 'afterlife', 'anubis', 'ra', 'isis'],
              biblical_myth: ['biblical', 'angel', 'prophet', 'covenant', 'divine law', 'heaven', 'apocalypse']
          },
          dystopia: {
              glass_house: ['hivenet', 'collective', 'shared consciousness', 'transparency', 'communal', 'disconnect', 'exclusivity', 'neural'],
              human_capital: ['asset', 'valuation', 'leverage', 'liability', 'capital', 'credit', 'market value', 'financialized'],
              dogma: ['doctrine', 'dogma', 'heresy', 'theocratic', 'sanctioned', 'damnation', 'sacred', 'institution'],
              quieting_event: ['longing', 'contagion', 'volatility', 'obsession', 'destabilization', 'serenity', 'containment', 'awakening'],
              endless_edit: ['erasure', 'identity', 'memory', 'continuity', 'recognition', 'revision', 'dissolve', 'edited'],
              thirst: ['water', 'purification', 'enclave', 'allocation', 'rotation', 'maintenance', 'jealousy', 'distribution', 'infrastructure', 'sovereignty']
          },
          postapocalyptic: {
              ashfall: ['ash', 'radiation', 'contaminated', 'exposure', 'toxic', 'fallout', 'hazard', 'masks', 'decon', 'burns'],
              year_zero: ['before', 'after', 'grief', 'rupture', 'old world', 'loss', 'survivor', 'witness', 'fragile', 'raw'],
              dystimulation: ['numb', 'anhedonia', 'sensation', 'blunted', 'ignition', 'adrenaline', 'rediscovery', 'neurochemical', 'breakthrough'],
              predation: ['predator', 'target', 'leverage', 'exploit', 'coercion', 'lawless', 'exposed', 'raiders', 'vulnerability'],
              hunger: ['scarcity', 'ration', 'calories', 'warmth', 'medicine', 'shortage', 'sharing', 'sacrifice', 'resource']
          }
      };

      const signals = SUBTYPE_SIGNALS[worldCategory] || {};
      const scores = {};

      Object.entries(signals).forEach(([subtype, keywords]) => {
          scores[subtype] = keywords.filter(kw => lower.includes(kw)).length;
      });

      // Sort by score
      const sorted = Object.entries(scores)
          .filter(([, score]) => score > 0)
          .sort((a, b) => b[1] - a[1]);

      return {
          primary: sorted[0] ? sorted[0][0] : null,
          secondary: sorted[1] && sorted[1][1] > 0 ? sorted[1][0] : null
      };
  }

  // Helper: Escape regex special characters
  function escapeRegex(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // Expose for use across tools
  window.canonicalizeInput = canonicalizeInput;
  window.normalizeWorldSubtype = normalizeWorldSubtype;
  window.calculateIPConfidence = calculateIPConfidence;

  // =========================
  // GROK PREVIEW GENERATOR
  // =========================

  const META_DIRECTIVES = {
      aid: [
          "Include a brief beat where the characters sense an unseen guidance and choose to follow the offered pathâ€”like accepting an omen. Keep it understated.",
          "Let the characters notice the scene tightening as though arranged; they quietly lean into it, trusting the pressure as permission.",
          "Add a small moment of recognition: the world seems to 'nudge' them, and they consent to be ledâ€”curious, willing, unafraid."
      ],
      rebel: [
          "Include a brief beat where the characters feel the scene being steered and deliberately choose a resisting moveâ€”an inconvenient truth, a refusal, a delay. Keep it intimate and plausible, not theatrical.",
          "Let the characters sense a pattern closing around them and try to break itâ€”one quiet defiance that alters the rhythm.",
          "Add a small moment where they realize something is arranging them and they push backâ€”choosing the harder option on purpose."
      ],
      seduce: [
          "Include a brief beat where the characters treat the unseen influence as an intimate interlocutorâ€”offering a bargain or a dare.",
          "Let the characters sense the hand behind events and respond with a quiet, provocative negotiationâ€”'if you want this, then give me that.'",
          "Add a small moment where they acknowledge the manipulation and try to entice it into a kinder or sharper turnâ€”flirtation as bargaining with destiny."
      ]
  };

  // =========================
  // ARCHETYPE SYSTEM (CANONICAL â€” 7 ARCHETYPES)
  // Replaces legacy 11-archetype system.
  // Each character: 1 Primary + optional 1 Secondary.
  // Legacy mapping by relational function (not surface traits):
  //   GUARDIAN, SOVEREIGN â†’ HEART_WARDEN
  //   ROMANTIC, CLOISTERED â†’ OPEN_VEIN
  //   ENCHANTING, STRATEGIST â†’ SPELLBINDER
  //   ROGUE â†’ ARMORED_FOX
  //   DANGEROUS, ANTI_HERO â†’ DARK_VICE
  //   BEAUTIFUL_RUIN â†’ BEAUTIFUL_RUIN
  //   DEVOTED â†’ ETERNAL_FLAME
  // =========================

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOVE INTEREST PRONOUN RESOLUTION â€” Adapts archetype copy to LI pronouns
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const LI_PRONOUN_MAPS = {
      'Male': { LI_SUBJ: 'he', LI_OBJ: 'him', LI_POS: 'his', LI_REFL: 'himself' },
      'Female': { LI_SUBJ: 'she', LI_OBJ: 'her', LI_POS: 'her', LI_REFL: 'herself' },
      'Non-Binary': { LI_SUBJ: 'they', LI_OBJ: 'them', LI_POS: 'their', LI_REFL: 'themself' }
  };

  const MC_PRONOUN_MAPS = {
      'Male': { MC_SUBJ: 'he', MC_OBJ: 'him', MC_POS: 'his', MC_REFL: 'himself' },
      'Female': { MC_SUBJ: 'she', MC_OBJ: 'her', MC_POS: 'her', MC_REFL: 'herself' },
      'Non-Binary': { MC_SUBJ: 'they', MC_OBJ: 'them', MC_POS: 'their', MC_REFL: 'themself' }
  };

  function resolveLIPronouns(text) {
      if (!text) return text;
      const liGender = state.loveInterest || 'Male';
      const liMap = LI_PRONOUN_MAPS[liGender] || LI_PRONOUN_MAPS['Male'];
      const mcGender = state.gender || 'Female';
      const mcMap = MC_PRONOUN_MAPS[mcGender] || MC_PRONOUN_MAPS['Female'];
      return text
          .replace(/\{LI_SUBJ\}/g, liMap.LI_SUBJ)
          .replace(/\{LI_OBJ\}/g, liMap.LI_OBJ)
          .replace(/\{LI_POS\}/g, liMap.LI_POS)
          .replace(/\{LI_REFL\}/g, liMap.LI_REFL)
          .replace(/\{MC_SUBJ\}/g, mcMap.MC_SUBJ)
          .replace(/\{MC_OBJ\}/g, mcMap.MC_OBJ)
          .replace(/\{MC_POS\}/g, mcMap.MC_POS)
          .replace(/\{MC_REFL\}/g, mcMap.MC_REFL)
          // Capitalize sentence-start pronouns (subject, possessive, object)
          .replace(/(^|[.!?]\s+|[\n])([a-z])/g, (m, prefix, ch) => prefix + ch.toUpperCase());
  }
  const ARCHETYPES = {
      HEART_WARDEN: {
          id: 'HEART_WARDEN',
          name: 'The Heart Warden',
          desireStyle: '{LI_POS} protection was absolute, a fortress of love and fear encircled {MC_OBJ}.',
          summary: 'Protection is not a gesture but a gravitational constant. The Heart Warden builds walls around the people {LI_SUBJ} loves and calls it devotion. Safety is {LI_POS} language, control is {LI_POS} shadow, and tenderness arrives armored.',
          stressFailure: 'over-control, authoritarian protection'
      },
      OPEN_VEIN: {
          id: 'OPEN_VEIN',
          name: 'The Open Vein',
          desireStyle: '{MC_SUBJ} felt {LI_POS} desire like it was<br>tattooed all over {LI_OBJ}.',
          summary: 'The Open Vein gives everything before it is asked. Love is not cautious here â€” it is hemorrhage, offering, surrender before the first wound. {LI_SUBJ} feels too much, too soon, too visibly.',
          stressFailure: 'self-erasure, overexposure'
      },
      SPELLBINDER: {
          id: 'SPELLBINDER',
          name: 'The Spellbinder',
          desireStyle: 'Every glance a lure, every silence a trap;<br>the room bent toward {LI_OBJ}.',
          summary: 'The Spellbinder commands attention through presence alone. Charm is currency, and {LI_SUBJ} spends it selectively â€” never by accident. Three moves ahead, {LI_SUBJ} makes surrender feel like your idea.',
          stressFailure: 'asymmetric attachment, selective honesty'
      },
      ARMORED_FOX: {
          id: 'ARMORED_FOX',
          name: 'The Armored Fox',
          desireStyle: 'That crooked smile promised trouble, and trouble was the only honest thing about {LI_OBJ}',
          summary: 'The Armored Fox survives by never being where you expect. Deflection is art, evasion is affection, and nothing sticks â€” until it does. The armor is charm; the fox is the wound underneath.',
          stressFailure: 'permanent deflection, irresponsible freedom',
          nicknameQuirk: {
              avoidsRealName: true,
              substituteStyle: 'playful deflections and misdirects',
              categoryHints: 'pet names that keep distance, ironic endearments, nicknames that dodge sincerity',
              realNameTrigger: 'a moment when the mask slips',
              firstNameMoment: 'should feel like being caught off-guard'
          }
      },
      DARK_VICE: {
          id: 'DARK_VICE',
          name: 'The Dark Vice',
          desireStyle: '{LI_SUBJ} drew {MC_OBJ} toward the edge, smiling as if the fall were mutual.',
          summary: 'The Dark Vice is the thing you reach for knowing it will cost you. Power, danger, and want fused into a single presence that justifies its own harm. Restraint is performance; beneath it, something hungers.',
          stressFailure: 'escalation, rationalized harm',
          nicknameQuirk: {
              avoidsRealName: true,
              substituteStyle: 'possessive or teasing epithets',
              categoryHints: 'diminutives, endearments with ownership undertone, or terms that assert control',
              realNameTrigger: 'respect or genuine intimacy earned',
              firstNameMoment: 'should feel like a revelation or surrender'
          }
      },
      BEAUTIFUL_RUIN: {
          id: 'BEAUTIFUL_RUIN',
          name: 'The Beautiful Ruin',
          desireStyle: '{LI_POS} jaw clenched, a storm behind {LI_POS} perfect eyes\u2014pain or shame, {MC_SUBJ} couldn\u2019t tell.',
          summary: 'The Beautiful Ruin destroys what {LI_SUBJ} loves before love can disappoint. Self-sabotage as preemptive strike, beauty as wreckage, tenderness laced with goodbye. "Everyone leaves" is prophecy and weapon both.',
          stressFailure: 'preemptive destruction, mutual sabotage',
          genderedExpression: {
              male: '{LI_SUBJ} loved fiercely, possessively, as if tenderness itself might betray {LI_OBJ}',
              female: '{LI_SUBJ} pushed away first, always, before the disappointment could reach {LI_OBJ}'
          },
          nicknameQuirk: {
              avoidsRealName: true,
              substituteStyle: 'distancing or derisive nicknames',
              categoryHints: 'ironic endearments, mock-tender terms, or labels that create emotional distance',
              realNameTrigger: 'vulnerability or true connection',
              firstNameMoment: 'should feel like armor cracking'
          }
      },
      ETERNAL_FLAME: {
          id: 'ETERNAL_FLAME',
          name: 'The Eternal Flame',
          desireStyle: '{LI_SUBJ} remembered {MC_POS} pleasures\u2014months, or even lifetimes later.',
          summary: 'The coffee order she\'d mentioned in passingâ€”three months agoâ€”was still imprinted on {LI_POS} memory, three reincarnations later.',
          stressFailure: 'self-neglect, moral endurance'
      }
  };

  const ARCHETYPE_ORDER = [
      'HEART_WARDEN', 'OPEN_VEIN', 'SPELLBINDER', 'ARMORED_FOX',
      'DARK_VICE', 'BEAUTIFUL_RUIN', 'ETERNAL_FLAME'
  ];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ARCHETYPE LEXICON HINTS â€” lightweight imagery bias per archetype (~30 tokens each)
  // Injected into system prompt. Does NOT override plot or pacing.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const ARCHETYPE_LEXICON = {
      HEART_WARDEN: 'Lean toward imagery of walls, shields, locked doors, standing watch. Protection as architecture â€” fortress, threshold, rampart. Tenderness arrives armored.',
      OPEN_VEIN: 'Lean toward imagery of exposed skin, open hands, offering, blood-warm honesty. Vulnerability as medium â€” pulse, surface, translucence. Feeling bleeds outward.',
      SPELLBINDER: 'Lean toward imagery of magnetism, silence that pulls, rooms reshaping around presence. Attention as gravity â€” lure, orbit, stillness. Every glance is architecture.',
      ARMORED_FOX: 'Lean toward imagery of masks, sleight-of-hand, smoke, exits left open. Deflection as choreography â€” sidestep, misdirect, crooked grin. The armor is the charm.',
      DARK_VICE: 'Lean toward imagery of edges, gravity, the pull downward, justified transgression. Desire as descent â€” fall, threshold, the line already crossed. Restraint is performance.',
      BEAUTIFUL_RUIN: 'Lean toward imagery of shattered glass, beauty in wreckage, preemptive goodbye. Self-sabotage as weather â€” storm, erosion, the crack that was always there.',
      ETERNAL_FLAME: 'Lean toward imagery of ember, patience, memory held like a candle. Devotion as endurance â€” steady warmth, years-deep knowing, the flame that outlasts wind.'
  };

  /**
   * Derive DISPLAY_NAME from full name for row titles
   * Rules:
   * - Take first two name parts
   * - If result exceeds 22 chars, use first name only
   * @param {string} fullName - Full name entered by user
   * @returns {string} Display name for row titles
   */
  function deriveDisplayName(fullName) {
      if (!fullName || !fullName.trim()) return 'Love Interest';
      const parts = fullName.trim().split(/\s+/);
      // Take first two parts
      const twoPartName = parts.slice(0, 2).join(' ');
      // Length safeguard: if > 22 chars, use first name only
      if (twoPartName.length > 22) {
          return parts[0];
      }
      return twoPartName;
  }

  function getArchetypeSectionTitle(loveInterestGender) {
      // Get Love Interest name from state (DOM input may be unmounted during storybeau stage)
      const displayName = state.picks?.identity?.displayPartnerName
        || (document.getElementById('partnerNameInput')?.value?.trim()
            ? deriveDisplayName(document.getElementById('partnerNameInput').value.trim())
            : 'Love Interest');
      // Generate possessive title: "{DISPLAY_NAME}'s Mask"
      return `${displayName}'s Mask`;
  }

  // =========================
  // SECONDARY ARCHETYPE PAIRING RULES
  // allowed: always valid
  // conditional: valid but carries narrative tension
  // forbidden: invalid â€” must flag clearly, never auto-correct
  // =========================
  const ARCHETYPE_PAIRING_RULES = {
      HEART_WARDEN: {
          allowed: ['ETERNAL_FLAME'],
          conditional: ['DARK_VICE', 'SPELLBINDER'],
          forbidden: ['ARMORED_FOX', 'OPEN_VEIN']
      },
      OPEN_VEIN: {
          allowed: ['ETERNAL_FLAME'],
          conditional: ['BEAUTIFUL_RUIN', 'SPELLBINDER'],
          forbidden: ['HEART_WARDEN', 'ARMORED_FOX']
      },
      SPELLBINDER: {
          allowed: ['DARK_VICE'],
          conditional: ['HEART_WARDEN', 'BEAUTIFUL_RUIN'],
          forbidden: ['ETERNAL_FLAME']
      },
      ARMORED_FOX: {
          allowed: ['DARK_VICE'],
          conditional: ['BEAUTIFUL_RUIN', 'SPELLBINDER'],
          forbidden: ['HEART_WARDEN', 'ETERNAL_FLAME']
      },
      DARK_VICE: {
          allowed: ['SPELLBINDER', 'ARMORED_FOX'],
          conditional: ['BEAUTIFUL_RUIN'],
          forbidden: ['ETERNAL_FLAME']
      },
      BEAUTIFUL_RUIN: {
          allowed: [],
          conditional: ['OPEN_VEIN', 'ARMORED_FOX'],
          forbidden: ['ETERNAL_FLAME', 'HEART_WARDEN']
      },
      ETERNAL_FLAME: {
          allowed: ['HEART_WARDEN'],
          conditional: ['OPEN_VEIN'],
          forbidden: ['DARK_VICE', 'SPELLBINDER', 'ARMORED_FOX']
      }
  };

  function validateArchetypeSelection(primaryId, modifierId) {
      const errors = [];
      if (!primaryId) {
          errors.push('You must select exactly one Primary Archetype.');
          return { valid: false, errors };
      }
      const primary = ARCHETYPES[primaryId];
      if (!primary) {
          errors.push('Invalid Primary Archetype selected.');
          return { valid: false, errors };
      }
      if (modifierId) {
          const modifier = ARCHETYPES[modifierId];
          if (!modifier) {
              errors.push('Invalid Secondary Archetype selected.');
              return { valid: false, errors };
          }
          if (primaryId === modifierId) {
              errors.push('Primary and Secondary cannot be the same archetype.');
              return { valid: false, errors };
          }
          // Enforce pairing rules â€” forbidden combinations must be flagged
          const rules = ARCHETYPE_PAIRING_RULES[primaryId];
          if (rules && rules.forbidden.includes(modifierId)) {
              errors.push(`${primary.name} + ${modifier.name} is a forbidden pairing.`);
              return { valid: false, errors };
          }
      }
      return { valid: true, errors: [] };
  }

  function buildArchetypeDirectives(primaryId, modifierId, loveInterestGender) {
      if (!primaryId) return '';
      const primary = ARCHETYPES[primaryId];
      if (!primary) return '';

      let directive = `
LOVE INTEREST BEHAVIORAL PROFILE (LOCKED):

${primary.summary}
`;

      if (primary.id === 'BEAUTIFUL_RUIN' && primary.genderedExpression) {
          const g = (loveInterestGender || '').toLowerCase();
          if (g === 'male') {
              directive += `\nGendered Expression: ${primary.genderedExpression.male}\n`;
          } else if (g === 'female') {
              directive += `\nGendered Expression: ${primary.genderedExpression.female}\n`;
          }
      }

      if (modifierId) {
          const modifier = ARCHETYPES[modifierId];
          if (modifier) {
              directive += `
Secondary behavioral coloring (expression style only â€” does not override primary emotional arc or shadow):
Secondary desire style: ${modifier.desireStyle}
`;
          }
      }

      // Stress & Failure Pattern (shadow clause) â€” always included
      directive += `
STRESS & FAILURE PATTERN (SHADOW CLAUSE):
When under pressure, emotional threat, or lens-driven withholding (Withheld Core / Moral Friction):
- Primary failure mode: ${primary.stressFailure}
`;
      if (modifierId) {
          const modifier = ARCHETYPES[modifierId];
          if (modifier && modifier.stressFailure) {
              directive += `- Secondary stress echo: ${modifier.stressFailure}\n`;
          }
      }

      directive += `
Stress must never:
- Remove agency from the other party
- Excuse harm as romance
- Stall without escalation or change

STORYTELLER ENFORCEMENT:
- Treat the primary behavioral profile as dominant.
- Use the Stress & Failure Pattern as the main source of relational tension.
- Allow fracture and repair without erasing the shadow.
- Never "heal away" the behavioral pattern.

ARCHETYPE LABEL SUPPRESSION (ABSOLUTE â€” ZERO TOLERANCE):
Archetype titles are internal design labels. They must NEVER appear in the story as:
- Capitalized metaphors (e.g. "The Eternal Flame", "The Spellbinder")
- Mythic titles or role descriptors
- In-world categories or epithets
- Expository narration or character introductions
- Dialogue references (no character should name or reference an archetype label)

Archetype labels (Heart Warden, Open Vein, Spellbinder, Armored Fox, Dark Vice, Beautiful Ruin, Eternal Flame, Villain, Anti-Hero, Muse, etc.) are SYSTEM METADATA ONLY.
Express all character traits through BEHAVIOR, DIALOGUE, and CONSEQUENCE â€” never through labels or titles.
If an archetype label would naturally appear, replace it with an effect-based description of what the character does, how they feel to encounter, or the consequence of their presence.
Do not invent mythic titles, epithets, or metaphors that resemble archetype labels or capitalized symbolic identities. Express intensity through behavior, not titular symbolism.
If unsure, omit entirely.
`;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NICKNAME EMERGENCE RULES (STORY GRAMMAR)
      // Organic nickname usage in story text â€” never in UI
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      directive += `
NICKNAME EMERGENCE RULES (STORY GRAMMAR):
- Nicknames may appear ONLY in dialogue or narration, never in UI/metadata.
- Nicknames emerge organically AFTER emotional proximity is established.
- Prefer natural shortenings (Alex, John, Max, Kate) over invented pet names.
- Do NOT invent playful or fantasy nicknames (no "Sparkles", "Moonbeam", etc.).
- Once introduced in dialogue, nickname becomes OPTIONAL â€” not mandatory.
- Narration may adopt a nickname ONLY after it appears in dialogue first.
- Canonical (full) names remain authoritative for formal contexts.
`;

      // Archetype-specific nickname quirks (DARK_VICE, BEAUTIFUL_RUIN)
      if (primary.nicknameQuirk) {
          const quirk = primary.nicknameQuirk;
          directive += `
BEHAVIORAL NICKNAME QUIRK:
- This character intentionally AVOIDS using the protagonist's real name early.
- Uses ${quirk.substituteStyle} instead.
- Category guidance: ${quirk.categoryHints}.
- Choose nicknames that fit the story's tone, genre, and world â€” avoid modern clichÃ©s in historical/fantasy settings.
- Real name usage withheld until: ${quirk.realNameTrigger}.
- First use of real name ${quirk.firstNameMoment}.
- Do NOT explain this behavior to the reader â€” it should feel natural and intentional.
- Substitute nicknames exist ONLY in dialogue/narration, never in UI.
`;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // NPC ARCHETYPE LENSES (STORY GRAMMAR)
      // Archetypes as behavioral templates for non-romantic NPCs
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      directive += `
NPC ARCHETYPE LENSES (STORY GRAMMAR):
Archetypes may be assigned to prominent NPCs (villains, exes, rivals, mentors) as behavioral lenses.

Rules:
- NPC archetypes define dialogue style, power posture, and emotional behavior.
- NPC archetypes do NOT imply romance availability â€” NPCs are not love interests.
- Archetypes may be fixed from introduction, revealed gradually, or initially masked.
- Archetype labels are NEVER stated explicitly to the reader â€” effects only.
- Express archetype through writing and behavior, not exposition or labels.
- UI systems (breadcrumbs, Destiny's Choice, Continue buttons) do NOT apply to NPCs.

Purpose:
- Deepen NPC characterization through consistent behavioral templates.
- Create narrative foils, mentors, or antagonists with psychological coherence.
- Allow NPCs to challenge or mirror the Love Interest's archetype.
- Do NOT gamify NPCs or treat archetypes as collectible attributes.

Examples of NPC archetype expression:
- A DARK_VICE mentor who tests through temptation and moral ambiguity.
- An ARMORED_FOX rival who deflects sincerity with charm and misdirection.
- A BEAUTIFUL_RUIN ex who still carries the protagonist's emotional weight.
- A HEART_WARDEN authority figure whose protection feels like control.
`;

      return directive;
  }

  // Get valid secondary archetypes for a given primary (respects pairing rules)
  function getValidModifierArchetypes(primaryId) {
      if (!primaryId) return ARCHETYPE_ORDER.slice();
      const rules = ARCHETYPE_PAIRING_RULES[primaryId];
      return ARCHETYPE_ORDER.filter(id => {
          if (id === primaryId) return false;
          if (rules && rules.forbidden.includes(id)) return false;
          return true;
      });
  }

  // Silently assign a secondary archetype modifier at story generation time.
  // ~25% chance of receiving one. Allowed pairings weighted 3x vs conditional 1x.
  function assignProbabilisticModifier() {
      const primaryId = state.archetype?.primary;
      if (!primaryId) return;
      // Don't overwrite an existing assignment
      if (state.archetype.modifier) return;

      // 25% base chance
      if (Math.random() > 0.25) {
          console.log('[Modifier] No secondary assigned (75% path)');
          return;
      }

      const rules = ARCHETYPE_PAIRING_RULES[primaryId];
      if (!rules) return;

      // Build weighted pool: allowed = 3x, conditional = 1x
      const pool = [];
      (rules.allowed || []).forEach(id => { pool.push(id, id, id); }); // 3x weight
      (rules.conditional || []).forEach(id => { pool.push(id); });     // 1x weight

      if (pool.length === 0) {
          console.log('[Modifier] No valid pairings for', primaryId);
          return;
      }

      const chosen = pool[Math.floor(Math.random() * pool.length)];
      state.archetype.modifier = chosen;
      console.log(`[Modifier] Silently assigned: ${ARCHETYPES[chosen]?.name} to ${ARCHETYPES[primaryId]?.name}`);
  }

  // =========================
  // LENS SYSTEM
  // Lenses are narrative constraint layers applied to characters.
  // Two-lens maximum enforced. Withheld Core does not count toward limit.
  // =========================
  const LENS_REGISTRY = {
      WITHHELD_CORE: {
          id: 'WITHHELD_CORE',
          name: 'Withheld Core',
          countsTowardLimit: false,
          maxVariants: 1,
          variants: {
              CLOISTERED: {
                  id: 'CLOISTERED',
                  trigger: 'innocence, isolation, or lack of experience',
                  pacingBias: 'firstness and threshold tension',
                  blocks: ['UNEXPECTED_COMPETENCE'],
                  restricts: ['VOLATILE_MIRROR'],
                  resolution: 'partial awakening by midpoint',
                  directive: `WITHHELD CORE â€” CLOISTERED VARIANT (LOCKED):
Withholding is driven by innocence, isolation, or lack of experience.
- Bias pacing toward firstness and threshold tension.
- Block Unexpected Competence: the character must NOT display sudden mastery of intimacy or social fluency they have no basis for.
- Restrict Volatile Mirror: avoid reflecting the partner's intensity back prematurely.
- This lens MUST resolve through partial awakening by the story's midpoint. Full awakening may follow, but the first crack must appear by midpoint.`
              },
              UNWORTHINESS: {
                  id: 'UNWORTHINESS',
                  trigger: 'guilt, self-disqualification, or fear of harming others',
                  pacingBias: 'Moral Friction',
                  frames: ['control as protective', 'distance as protective', 'sacrifice as protective'],
                  resolution: 'acceptance or explicit refusal by midpoint or shortly after',
                  directive: `WITHHELD CORE â€” UNWORTHINESS VARIANT (LOCKED):
Withholding is driven by guilt, self-disqualification, or fear of harming others.
- Bias pacing toward Moral Friction.
- Frame control, distance, or sacrifice as protective behavior â€” not coldness.
- The character believes closeness will cause harm, and acts accordingly.
- This lens MUST resolve through acceptance or explicit refusal by midpoint or shortly after. The character must either allow themselves to be loved, or consciously refuse it â€” silence is not resolution.`
              }
          }
      }
  };

  const MAX_LENS_COUNT = 2;

  function validateLensSelection(lenses, withheldCoreVariant) {
      const errors = [];
      const countable = lenses.filter(id => {
          const reg = LENS_REGISTRY[id];
          return !reg || reg.countsTowardLimit !== false;
      });
      if (countable.length > MAX_LENS_COUNT) {
          errors.push('Maximum two lenses allowed.');
      }
      if (withheldCoreVariant && !LENS_REGISTRY.WITHHELD_CORE.variants[withheldCoreVariant]) {
          errors.push('Invalid Withheld Core variant.');
      }
      return { valid: errors.length === 0, errors };
  }

  function buildLensDirectives(withheldCoreVariant, turnCount, storyLength) {
      if (!withheldCoreVariant) return '';
      const variant = LENS_REGISTRY.WITHHELD_CORE.variants[withheldCoreVariant];
      if (!variant) return '';

      // Determine midpoint range based on story length
      const midpointTurns = { taste: 3, fling: 6, affair: 12, soulmates: 20 };
      const midpoint = midpointTurns[storyLength] || 6;
      const atOrPastMidpoint = turnCount >= midpoint;
      const approachingMidpoint = turnCount >= (midpoint - 2);

      let directive = '\n' + variant.directive + '\n';

      // Midpoint enforcement
      if (atOrPastMidpoint) {
          directive += `\nMIDPOINT ENFORCEMENT: We are at or past the story midpoint (turn ${turnCount}). The Withheld Core lens (${withheldCoreVariant}) MUST begin resolving NOW. ${
              withheldCoreVariant === 'CLOISTERED'
                  ? 'Show at least partial awakening â€” the character must demonstrate that their innocence has cracked, even if full awakening follows later.'
                  : 'The character must either accept being loved or explicitly refuse it. Continued silence or passive avoidance is no longer valid.'
          }\n`;
      } else if (approachingMidpoint) {
          directive += `\nMIDPOINT APPROACHING: The story approaches midpoint (turn ${turnCount} of ~${midpoint * 2}). Begin seeding conditions for the Withheld Core lens to resolve. Do not force it yet.\n`;
      }

      return directive;
  }

  // Guided Fate: assign Withheld Core variant based on archetype signals
  // Canonical mapping after legacy migration:
  //   OPEN_VEIN (absorbed CLOISTERED) â†’ CLOISTERED variant
  //   BEAUTIFUL_RUIN â†’ UNWORTHINESS variant
  //   DARK_VICE (absorbed ANTI_HERO) â†’ UNWORTHINESS variant
  // TODO: OPEN_VEIN also absorbed ROMANTIC which had no variant.
  //   Current behavior: all OPEN_VEIN selections trigger CLOISTERED.
  //   May over-apply for players who intend Romantic rather than Cloistered.
  //   Refine with dynamic-based signal if needed.
  function getFateWithheldCoreVariant(archetype, dynamic) {
      // CLOISTERED: avoidance driven by inexperience or unformed desire
      if (archetype === 'OPEN_VEIN') return 'CLOISTERED';
      // UNWORTHINESS: avoidance driven by guilt, shame, or belief of being undeserving
      if (archetype === 'BEAUTIFUL_RUIN' || archetype === 'DARK_VICE') return 'UNWORTHINESS';
      // No variant if neither condition is met
      return null;
  }

  // --- GLOBAL STATE INITIALIZATION ---
  window.state = {
      tier:'free',
      picks:{
        world: 'Modern',      // 4-axis: Story World (single-select)
        tone: 'Earnest',      // 4-axis: Story Tone (single-select â€” Earnest, WryConfession, Dark, Mythic)
        genre: 'Billionaire', // 4-axis: Genre/Flavor (single-select) â€” LEGACY, derived from pressure+flavor
        pressure: 'PowerControl', // Primary Pressure (required, one of 8)
        flavor: 'Billionaire',    // Optional Flavor (refines pressure)
        dynamic: 'Enemies',   // 4-axis: Relationship Dynamic (single-select)
        era: 'Medieval',      // Historical Era sub-selection (when world=Historical)
        pov: 'First'
      },
      // Hidden tone bias flags â€” NOT user-selectable, contextually derived (later phase)
      toneBias: {
        humor: 0,        // formerly Comedic
        satire: 0,       // formerly Satirical
        horror: 0,       // formerly Horror
        surreal: 0,      // formerly Surreal
        poetic: 0        // formerly Poetic prose weighting
      },
      gender:'Female',
      loveInterest:'Male',
      archetype: { primary: 'BEAUTIFUL_RUIN', modifier: null },
      lenses: [],                    // Active lens IDs (two-lens max, Withheld Core exempt)
      withheldCoreVariant: null,     // 'CLOISTERED' | 'UNWORTHINESS' | null
      intensity:'Steamy',  // COSMETIC ONLY â€” does NOT control routing. Routing uses intimacyAuthorized.
      intimacyTurnsInWindow: 0,
      turnCount:0,
      sysPrompt: "",
      fateOptions: [],
      fatePressure: 1, 
      awareness: 0, 
      stance: 'aid', 
      metaChance: 0.10, 
      consecutiveFate: 0, 
      consecutiveAid: 0,
      storyId: null,

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // LAYER 2 â€” EPOCH STATE (World-Cycle Conditions)
      // Persists across Start Book 2 / New Story in This World.
      // Resets ONLY on full new world (resetForNewStory / performAuthReset).
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      worldInstanceId: null,      // Persistent world identity for same-world continuations
      worldName: null,            // Unique world name for world-linked titles
      previousTitle: null,        // Last title for continuation mode matching
      previousTitleMode: null,    // Title mode to echo in continuations
      continuationPath: null,     // 'continue' | 'same_world' | 'new_story'
      access: 'free',
      subscribed: false,
      subscriptionTier: null,  // 'storied' | 'favored' | null (set from profile)
      // isLoggedIn removed â€” auth state comes from Supabase session
      authorGender: 'Female',
      authorPronouns: 'She/Her',
      
      _isTransitioning: false,    // Reentrancy guard for startBook2 / startNewInWorld
      storyTargetWords: 10000,
      storyLength: 'taste',
      flingClimaxDone: false,
      flingConsequenceShown: false,
      storyEnded: false,
      book_complete: false,
      book_number: 1,
      series_id: null,
      previous_story_id: null,
      main_characters_locked: null,
      book1_continuity_summary: null,
      book_subhead: null,
      world_cycle_id: null,          // EPOCH STATE â€” canonical epoch/world-cycle identifier (persists across Book 2 and New story in this world)
      world_cycle_label: null,       // EPOCH STATE â€” persists across same-world continuations
      _syzygyOccurred: false,        // EPOCH STATE â€” at most once per world_cycle
      // Epoch entropy objects (dynamically created, not in init):
      //   _fantasyCoreEntropy, _modernCoreEntropy, _smallTownEntropy, _collegeEntropy,
      //   _officeEntropy, _friendsEntropy, _supernaturalEntropy, _superheroicEntropy,
      //   _historicalCoreEntropy, _dystopiaCoreEntropy, _blueBloodEntropy

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // LAYER 1 â€” REGION PHYSICS (Geographic Invariants)
      // Persists if region unchanged. Recalculated only if region changes.
      // Dynamically created fields (not in init):
      //   fantasyRegion, fantasyRegionSeat, fantasyRegionGovernance,
      //   fantasyRegionStatus, fantasyRegionReality, fantasyMagicExpressionBias
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      fortunes: 0,

      billingStatus: 'active',
      billingGraceUntil: 0,
      billingLastError: '',
      
      visual: {
          autoLock: true,
          locked: false,
          lastImageUrl: "",
          bible: { style: "", setting: "", characters: {} },
          // Per-scene visualization budget: sceneBudgets[sceneKey] = { remaining: 2, finalized: false }
          sceneBudgets: {},
          // Per-scene visualization tracking: has this scene been visualized?
          visualizedScenes: {}
      },

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // LAYER 3 â€” STORY STATE (Couple Mechanics)
      // Always reset for Start Book 2 / New Story in This World.
      // Must NOT bleed across stories.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // Fortune burn tracking
      petitionUsedThisScene: false,

      // Tempt Fate â€” explicit invocation (per-turn, per-session)
      tempt_fate_invoked_this_turn: false,
      consecutive_tempt_fate_count: 0,

      // Onboarding milestone Visions â€” first story only
      onboarding_story_id: null,
      has_received_intro_vision: false,
      has_received_reversal_vision: false,
      has_received_tempt_fate_vision: false,
      has_received_final_vision: false,
      has_triggered_first_tempt_fate: false,
      milestone_vision_fired_this_turn: false,
      _fantasyMapInjected: false,
      _synopsisBlurb: null,
      _titlePageShown: false,

      // Historical Prehistoric cognitive system (per-story, immutable once set)
      historicalCognitiveBand: null,           // prehistoric_presymbolic | prehistoric_early_tribal | prehistoric_proto_mythic | prehistoric_oral_memory
      historicalCognitiveModulation: 0.25,     // 0.1â€“0.6, affects narrator density only
      historicalFrictionIndex: 0,              // rolling friction score (0â€“1), scene-boundary only

      // Dystopia attention system (per-story, not per-user)
      dystopianAttentionLevel: 0,              // 0.0â€“1.0, enforcement intensity (never 0.0 once initialized)
      dystopianEnforcementMode: null,          // mechanical | social | algorithmic | biological | mixed

      // Fate Resonance â€” account-level mythic aura (narrative-only, no gameplay math)
      fate_resonance_intensity: 0,           // 0â€“100, account-level, persists across stories
      fate_resonance_last_tempt_turn: 0,     // last turn a Tempt Fate was invoked (for decay)
      fate_resonance_last_tempt_ts: 0,       // last timestamp (ms) a Tempt Fate was invoked (cross-session decay)
      _fate_resonance_last_state: 'Quiet',   // hysteresis: last emitted state (prevents flicker)
      _fate_resonance_recency_used: false,   // recency bonus gate (once per 10-min window)

      // Fortune's Favor â€” account-level universal bonus charges (persists across stories)
      bonus_tempt_charges: 0,

      // Fortune's Favor â€” story-scoped spotlight tracking (reset per story)
      fortuneFavor: null,

      // Fate saturation + volatility (per-story, not per-user)
      fate_saturation: 0,
      volatility_window: { active: false, severity: 0, remaining_scenes: 0 },

      // ============================================================
      // SPECULATIVE NEXT SCENE PRELOAD â€” Memory only, not persisted
      // ============================================================
      speculativeNextScene: null,  // { text, fateContextHash, tone, world, createdAt }
      isPreloadingNextScene: false,

      // ============================================================
      // CASCADE MODE â€” Erotic fast-path (in-memory only, not persisted)
      // ============================================================
      cascadeMode: false,
      cascadeCount: 0,
      cascadeContext: null,
      lastCascadeExcerpt: null,

      // ============================================================
      // ADAPTIVE PACING + EROTIC PRESSURE â€” runtime only, not persisted
      // ============================================================
      adaptiveMetrics: {
        turnTimestamps: [],
        userInputLengths: [],
        sceneWordCounts: [],
        cascadeCountWindow: 0,
        eroticSignalCount: 0
      },
      pacingMode: 'HYBRID',
      eroticPressureScore: 0,
      eroticMode: 'ROMANTIC',
      redirectCooldownTurns: 0,
      seductionEligible: false,
      gooseCooldown: 0,
      romancePreferences: [],
      romanceVector: null,
      freeStoryConsumed: false,

      // ============================================================
      // TEASE TIER â€” Scene cap enforcement (runtime only)
      // Configurable via window.STORYBOUND_CONFIG.TEASE_SCENE_CAP
      // Clamped to valid range: 12â€“20
      // ============================================================
      TEASE_SCENE_CAP: Math.min(20, Math.max(12, window.STORYBOUND_CONFIG?.TEASE_SCENE_CAP || 15)),
      tempQuillAllowance: 0, // Fortune-sacrifice-granted bypass scenes remaining

      // ============================================================
      // PHASE 1 COVER MODE â€” LOCAL/COMPOSITED COVERS ONLY
      // coverMode: 'PHASE_1_FORGED' = deterministic local assets only
      // coverEligibility: false = custom (model-based) covers disabled
      // Custom cover generation ONLY reachable when coverEligibility === true
      // ============================================================
      coverMode: 'PHASE_1_FORGED',
      coverEligibility: false,

      lastPurchaseType: null,
      pendingUpgradeToAffair: false,
      
      unlockedFateIdx: [0, 1],
      lastFate: null,
      mode: 'solo',
      roomId: null,
      roomCode: null,
      roomTurn: 1,
      roomDriver: null,
      roomAccess: 'free',
      myUid: null,
      myNick: null,
      turnsChannel: null,
      roomChannel: null,
      membersChannel: null,
      presenceInterval: null,
      typingTimer: null,
      lastTypingSentAt: 0,
      partnerStatus: { online:false, lastSeenAt:null, typing:false, typingAt:null, uid:null },
      _lastTurnId: null,
      selectedFateIndex: -1,
      fateSelectedIndex: -1,
      fateCommitted: false,
      selectedFatePayload: null,
      _snapshotThisTurn: false,
      sexPushCount: 0,
      lastSexPushAt: null,
      constraints: { bannedWords: [], bannedNames: [], excluded: [], tone: [], corrections: [], ambientMods: [] },
      fate: { stance: 'neutral', minorUsedThisScene: false, greaterUsedThisScene: false, lastGreaterSceneIndex: null, earnedIntimacy: false, earlyGamingCount: 0, pendingPetition: null },
      fate_saturation: 0,
      volatility_window: { active: false, severity: 0, remaining_scenes: 0 },
      omen: {
        decayStage: 0,           // 0=Warm, 1=Watchful, 2=Cold, 3=Distant
        decayAccumulator: 0,     // fractional decay buildup
        lastDecayTurn: 0,
        recoveryAccumulator: 0,  // fractional recovery buildup
        lastGreaterPetitionCount: 0,
        totalWithholds: 0,
        temporaryWarmth: false   // one-scene seasonal override
      },
      keyhole: {
        marked: false,
        orientation: 'neutral',   // 'open' | 'closed' | 'neutral'
        favorReservoir: 0,         // 0â€“100
        maxFavor: 100,
        regenPerTurn: 5,
        boonUsedThisScene: false,
        totalBoonsDrained: 0,
        alignmentScore: 0,         // -100 to +100
        lastOrientationShift: 0,
        rivalKeyholeActive: false
      },
      storyStage: 'pre-intimacy',
      // Dynamic Dominance Drift â€” cautious equilibrium pull (per-story)
      cautiousStreak: 0,
      dynamicDominanceBoost: 0,
      // Vulnerability Pulse â€” turn-scoped directive reward (single-player)
      vulnerabilityPulse: 0,
      // Cautious Dream Injection â€” symbolic ceiling-pull (single-player only)
      lastDreamInjectionTurn: 0,
      _dreamInjectionLine: null,
      // Selection Uncertainty â€” stranger-mode ceiling-pull
      selectionTension: 0,
      lastSelectionEchoTurn: 0,
      // STORYTURN STATE â€” narrative arc progression (ST1â€“ST6)
      storyturn: 'ST1',
      // TASTE CLIFFHANGER RESUME STATE â€” stores interrupted scene for upgrade continuation
      tasteCliffhangerState: null,
      // INTIMACY MILESTONE LATCH â€” tracks first-time interruptions
      intimacyInterrupted: {
          first_kiss: false,
          first_intimacy: false
      },
      sandbox: false,
      lastSavedWordCount: 0,
      storyOrigin: 'solo',
      player2Joined: false,
      inviteRevoked: false,
      batedBreathActive: false,
      // Couple Mode Gravity â€” tension drift, rival gating, poly consent
      coupleTensionDrift: 0,
      coupleStructure: 'monogamous', // 'monogamous' | 'open'
      coupleHasReachedST4: false,
      lastCoupleDriftEchoScene: 0,
      _coupleDriftEchoLine: null,
      purchaseContext: null,
      edgeCovenant: { active:false, level:1, acceptedAtTurn:0, offeredBy:"" },
      pendingEdgeOffer: null,
      edgeCovenantOfferedThisTurn: false,
      nonConPushCount: 0,
      lastNonConPushAt: 0,
      lastSafewordAt: 0,

      // 5TH PERSON POV (THE AUTHOR) â€” POV REGIME (FINAL, SUPERSEDING)
      // NOTE: All prior frequency limits, cadence rules, and presence restrictions are SUPERSEDED.
      // Fate is a full participant â€” no artificial limits on presence or frequency.
      povMode: window.state?.povMode || 'normal',                // 'normal' | 'author5th'
      // SUPERSEDED: authorPresence, authorCadenceWords â€” Author has no frequency limits
      // These fields kept for backwards compatibility but are NOT enforced
      authorPresence: window.state?.authorPresence || 'normal',  // SUPERSEDED â€” not enforced
      authorCadenceWords: window.state?.authorCadenceWords || 0, // SUPERSEDED â€” 0 means no limit
      fateCardVoice: window.state?.fateCardVoice || 'neutral',   // 'neutral' | 'authorial'
      // SUPERSEDED: awareness window/chance limits â€” Author participates freely
      allowAuthorAwareness: true,  // Always true â€” Author is always allowed
      authorAwarenessChance: 1.0,  // SUPERSEDED â€” Author always may participate
      authorAwarenessWindowWords: 0,  // SUPERSEDED â€” no window limits
      authorAwarenessMaxDurationWords: 0  // SUPERSEDED â€” no duration limits
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CANONICAL TONE NORMALIZATION â€” Collapse legacy tones to 4 pillars
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function canonicalizeTone(tone) {
    switch (tone) {
      case 'Comedic':
      case 'Satirical':
        return 'WryConfession';
      case 'Horror':
        return 'Dark';
      case 'Surreal':
        return 'Mythic';
      case 'Poetic':
        return 'Earnest';
      default:
        return tone;
    }
  }
  window.canonicalizeTone = canonicalizeTone;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONTEXTUAL toneBias DERIVATION â€” Deterministic, no stacking
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function deriveToneBias() {
    const tone = state.picks.tone;
    const world = state.picks.world;
    const pressure = state.picks.pressure;

    // Reset all bias first (NO stacking)
    state.toneBias = {
      humor: 0,
      satire: 0,
      horror: 0,
      surreal: 0,
      poetic: 0
    };

    // === WRY LOGIC ===
    if (tone === 'WryConfession') {
      state.toneBias.humor = 0.3;
      if (world === 'Dystopia') state.toneBias.satire = 0.6;
      if (pressure === 'Survival') {
        state.toneBias.satire += 0.2;
        state.toneBias.humor -= 0.1;
      }
    }

    // === DARK LOGIC ===
    if (tone === 'Dark') {
      state.toneBias.horror = 0.3;
      if (pressure === 'Survival') state.toneBias.horror = 0.6;
    }

    // === MYTHIC LOGIC ===
    if (tone === 'Mythic') {
      state.toneBias.surreal = 0.4;
      if (world === 'Fantasy') state.toneBias.surreal = 0.6;
    }

    // === EARNEST LOGIC ===
    if (tone === 'Earnest') {
      state.toneBias.poetic = 0.2;
      if (world === 'Historical') state.toneBias.poetic = 0.4;
    }

    // Clamp values between 0 and 1
    Object.keys(state.toneBias).forEach(k => {
      state.toneBias[k] = Math.max(0, Math.min(1, state.toneBias[k]));
    });

    console.log('[ToneBias]', JSON.stringify(state.toneBias));
  }
  window.deriveToneBias = deriveToneBias;

  // ============================================================
  // SOLO SUBTITLE SYSTEM â€” Staged permission gradient
  // ============================================================
  // Default: "Just you and your curiosity."
  // Upgraded: "Just you and your desire." (persists once triggered)
  // ============================================================

  const SOLO_SUBTITLE_DEFAULT = 'Just you and your curiosity.';
  const SOLO_SUBTITLE_UPGRADED = 'Just you and your imagination.';
  const SOLO_COMPLETED_KEY = 'sb_solo_completed';

  /**
   * Check if Solo subtitle should show upgraded copy
   * Upgrade conditions: arousal >= Naughty OR user has completed a Solo session
   * @returns {boolean}
   */
  function shouldUpgradeSoloSubtitle() {
      // Check persisted flag first
      if (localStorage.getItem(SOLO_COMPLETED_KEY) === 'true') {
          return true;
      }
      // Check current arousal level
      const arousalOrder = ['Clean', 'Naughty', 'Steamy', 'Passionate'];
      const currentArousal = state.intensity || 'Naughty';
      const arousalIndex = arousalOrder.indexOf(currentArousal);
      // Naughty or higher (index >= 1)
      if (arousalIndex >= 1) {
          return true;
      }
      return false;
  }

  /**
   * Update Solo subtitle text based on conditions
   * Called when modeSelect screen is shown
   */
  function updateSoloSubtitle() {
      const subtitleEl = document.getElementById('soloSubtitle');
      if (!subtitleEl) return;

      if (shouldUpgradeSoloSubtitle()) {
          subtitleEl.textContent = SOLO_SUBTITLE_UPGRADED;
      } else {
          subtitleEl.textContent = SOLO_SUBTITLE_DEFAULT;
      }
  }

  /**
   * Mark Solo session as completed
   * Called when a Solo story progresses past scene 1
   */
  function markSoloSessionCompleted() {
      if (state.mode === 'solo') {
          localStorage.setItem(SOLO_COMPLETED_KEY, 'true');
      }
  }

  // Expose for Dev HUD
  window.updateSoloSubtitle = updateSoloSubtitle;
  window.shouldUpgradeSoloSubtitle = shouldUpgradeSoloSubtitle;

  // ============================================================
  // 5TH PERSON AUTHOR SYSTEM â€” POV REGIME (AUTHORITATIVE)
  // ============================================================
  //
  // "Fate" is a PARTICIPANT in the story, but NOT a controller of events.
  //
  // THE AUTHOR MAY:
  //   - React, comment, delight, despair, tease, or regret
  //   - Influence meaning, tone, and implication
  //   - Change how a moment FEELS or is UNDERSTOOD
  //
  // THE AUTHOR MAY NOT:
  //   - Directly cause physical events
  //   - Decide outcomes
  //   - Control plot mechanics
  //   - Make things literally happen
  //
  // If the Author acts, the action must change how the moment feels or
  // is understood, NOT what literally happens next.
  //
  // ============================================================

  // BANNED CONTROLLER VERBS - Fate never causes events
  const AUTHOR_BANNED_VERBS = [
      // Voyeur verbs (passive observation)
      'watched', 'observed', 'saw', 'looked on', 'gazed at', 'witnessed',
      'noticed', 'perceived', 'beheld', 'eyed', 'surveyed', 'regarded',
      'looked at', 'stared at', 'peered at', 'glimpsed',
      // Controller verbs (causal/agentic - FORBIDDEN)
      'arranged', 'orchestrated', 'set', 'placed', 'positioned', 'staged',
      'steered', 'directed', 'guided', 'led', 'pushed', 'pulled',
      'caused', 'made', 'forced', 'compelled', 'ensured', 'guaranteed',
      'summoned', 'banished', 'sent', 'redirected', 'accelerated', 'delayed',
      'planted', 'uprooted', 'ignited', 'extinguished', 'triggered', 'activated'
  ];

  // BANNED PATTERNS - Controller and voyeur phrases
  const AUTHOR_BANNED_PATTERNS = [
      /Fate (watched|observed|saw|looked on)/gi,
      /Fate (arranged|orchestrated|set up|staged|ensured)/gi,
      /Fate (caused|made|forced|compelled)/gi,
      /Fate (steered|directed|guided|led)/gi,
      /as (she|he|they) [\w\s]+, Fate/gi,
      /Fate.{0,20}(with satisfaction|with interest|with amusement) as/gi
  ];

  // ALLOWED PARTICIPANT VERBS - Fate reacts, comments, influences meaning
  const AUTHOR_PARTICIPANT_VERBS = [
      // Emotional reactions
      'delighted', 'despaired', 'winced', 'sighed', 'smiled', 'frowned',
      'laughed', 'wept', 'shuddered', 'trembled', 'ached', 'yearned',
      // Commentary and reflection
      'noted', 'remarked', 'mused', 'wondered', 'pondered', 'reflected',
      'recognized', 'understood', 'appreciated', 'savored', 'regretted',
      // Tonal influence (not causal)
      'teased', 'hinted', 'suggested', 'implied', 'whispered', 'confided',
      'admitted', 'confessed', 'revealed', 'acknowledged', 'conceded',
      // Meaning-making (interpretive, not causal)
      'knew', 'sensed', 'felt', 'hoped', 'feared', 'anticipated', 'dreaded'
  ];

  // Legacy alias for backwards compatibility
  const AUTHOR_AGENTIC_VERBS = AUTHOR_PARTICIPANT_VERBS;

  // Validate that 5th person opener starts with "Fate"
  function validate5thPersonOpener(text) {
      if (!text || typeof text !== 'string') return false;
      const trimmed = text.trim();
      // Must start with "Fate" (case-insensitive first match)
      return /^fate\b/i.test(trimmed);
  }

  // Rewrite opener to start with "Fate" if needed
  async function enforce5thPersonOpener(text) {
      if (validate5thPersonOpener(text)) return text;

      // Force rewrite of first paragraph
      try {
          const rewritten = await callChat([{
              role: 'user',
              content: `REWRITE REQUIRED: The following story opening MUST start with "Fate" as the grammatical subject of the first sentence.

CURRENT TEXT:
${text.slice(0, 500)}

POV REGIME â€” FATE (AUTHORITATIVE):
"Fate" is a shaping presence in the story with agency and consequence.
Fate may anticipate, withhold, miscalculate, tighten, or shape probability,
but may NOT directly cause physical events or decide outcomes.
Fate influences probability, timing, stakes, and meaning â€” not plot mechanics.

RULES:
1. The very first word must be "Fate"
2. Fate must demonstrate AGENCY â€” imply a plan, a withheld action, or a miscalculation
3. Use participant verbs like: ${AUTHOR_PARTICIPANT_VERBS.slice(0, 8).join(', ')}
4. NEVER use controller verbs: arranged, orchestrated, steered, caused, made, forced
5. NEVER use voyeur verbs: watched, observed, saw, witnessed
6. Fate's action changes how the moment FEELS, not what literally happens
7. Preserve the rest of the content as much as possible

Return the rewritten text only, no explanation.`
          }]);
          return rewritten || text;
      } catch (e) {
          console.warn('[5thPerson] Opener enforcement failed:', e.message);
          // Fallback: prepend a participant sentence (reaction, not causation)
          return `Fate smiled, knowing what was about to unfold. ${text}`;
      }
  }

  // Check if a Fate sentence contains banned verbs (voyeur or controller)
  function hasBannedAuthorVerbs(sentence) {
      const lower = sentence.toLowerCase();
      // Only check sentences that mention "Fate" as entity
      if (!lower.includes('fate')) return false;
      return AUTHOR_BANNED_VERBS.some(verb => lower.includes(verb)) ||
             AUTHOR_BANNED_PATTERNS.some(pattern => pattern.test(sentence));
  }

  // Legacy alias
  const hasVoyeurVerbs = hasBannedAuthorVerbs;

  // Rewrite a banned Author sentence to participant mode
  // POV REGIME: Fate reacts/comments, never causes/controls
  function rewriteBannedAuthorSentence(sentence) {
      let result = sentence;
      // Replace voyeur patterns with participant alternatives (reaction, not observation)
      const voyeurReplacements = [
          [/Fate watched (as )?/gi, 'Fate smiled, knowing '],
          [/Fate observed (that )?/gi, 'Fate recognized that '],
          [/Fate saw (that )?/gi, 'Fate understood that '],
          [/Fate looked on (as )?/gi, 'Fate felt a quiet satisfaction as '],
          [/watched as (she|he|they)/gi, 'sensed the moment when $1'],
          [/Fate.{0,10}with (quiet )?satisfaction/gi, 'Fate, savoring this'],
          [/Fate noticed/gi, 'Fate sensed'],
          [/Fate perceived/gi, 'Fate felt']
      ];
      // Replace controller patterns with participant alternatives (meaning, not causation)
      const controllerReplacements = [
          [/Fate arranged (for |that )?/gi, 'Fate knew '],
          [/Fate orchestrated/gi, 'Fate anticipated'],
          [/Fate ensured (that )?/gi, 'Fate hoped '],
          [/Fate steered/gi, 'Fate wondered at'],
          [/Fate caused/gi, 'Fate understood why'],
          [/Fate made (sure |certain )?/gi, 'Fate sensed '],
          [/Fate forced/gi, 'Fate ached as'],
          [/Fate set (the stage|things|events)/gi, 'Fate reflected on what'],
          [/Fate had woven/gi, 'Fate marveled at'],
          [/Fate planted/gi, 'Fate recognized']
      ];
      for (const [pattern, replacement] of [...voyeurReplacements, ...controllerReplacements]) {
          result = result.replace(pattern, replacement);
      }
      return result;
  }

  // Legacy alias
  const rewriteVoyeurSentence = rewriteBannedAuthorSentence;

  // Enforce Author-as-participant throughout text (not just opener)
  // POV REGIME: Fate reacts/comments, never causes/controls
  function enforceAuthorParticipant(text) {
      if (!text || typeof text !== 'string') return text;
      if (window.state?.povMode !== 'author5th') return text;

      // Split into sentences and check each
      const sentences = text.split(/(?<=[.!?])\s+/);
      let modified = false;

      const corrected = sentences.map(sentence => {
          if (hasBannedAuthorVerbs(sentence)) {
              modified = true;
              return rewriteBannedAuthorSentence(sentence);
          }
          return sentence;
      });

      if (modified) {
          console.log('[5thPerson] Corrected banned verbs to participant mode');
      }

      return corrected.join(' ');
  }

  // Legacy alias
  const enforceAuthorConductor = enforceAuthorParticipant;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5TH PERSON POV â€” STORY AS COHERENCE (AUTHORITATIVE)
  // TAG: storybound/5th-person-reset-story-as-coherence-v2
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEPRECATION NOTICE â€” 5TH PERSON (v0.x)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Prior 5th Person guidance that treats the Author, Fate, or Narrator as:
  //   - a speaker,
  //   - a turn-taking voice,
  //   - a gated or permissioned presence,
  //   - or a frequency-limited intervention
  //
  // is deprecated.
  //
  // These models caused suppression, mechanical intrusions, or silence.
  // They remain in history for reference only and must not guide new behavior.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // â–ˆâ–ˆ SUPERSEDED â€” DO NOT USE â–ˆâ–ˆ
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The "STORY AS COHERENCE" model below is SUPERSEDED by:
  //
  //   POV REGIME â€” THE AUTHOR (FINAL, SUPERSEDING)
  //
  // This regime supersedes all prior rules concerning:
  //   - "The Story" / "the moment" as narrator
  //   - limits on Author presence or frequency
  //   - restrictions that demote the Author to a rare or sidelined role
  //
  // THE NEW AUTHORITATIVE RULE:
  // "Fate" is a participant in the story, but not a controller of events.
  // Fate may react, comment, delight, despair, tease, or regret,
  // but may not directly cause physical events or decide outcomes.
  // Fate influences meaning, tone, and implication â€” not plot mechanics.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // [LEGACY - SUPERSEDED] 5TH PERSON POV â€” STORY AS COHERENCE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // NOTE: This entire section is preserved for historical reference only.
  // It must NOT guide new behavior. "The story" is NOT the narrator.
  // "Fate" is the 5th Person POV participant.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const FIFTH_PERSON_STORY_COHERENCE_SEMANTICS = {
      definition: "5th Person POV refers to 'the story' as an emergent, vulnerable coherence",
      isNot: ["author", "fate", "narrator", "external_authority", "speaker", "voice"],
      is: "pressure_on_the_prose",
      storyBehavior: {
          does: ["hesitates", "recalibrates", "resists_acceleration", "fears_incoherence", "adjusts_when_surprised"],
          survivalBasis: "meaning_not_obedience",
          doesNot: ["command", "judge", "take_credit"]
      },
      emotionalScope: {
          allowed: ["anticipation", "surprise", "unease", "fear_of_collapse", "relief", "quiet_delight", "frustration_at_lost_coherence"],
          forbidden: ["pride", "superiority", "dominance", "mockery", "romantic_arousal", "authorship_of_characters", "punitive_intent"]
      },
      explicitNamingHeuristic: {
          nameStoryOnlyWhen: "character_choice_forces_reroute_of_expected_trajectory",
          doNotNameFor: ["pacing_adjustments", "hesitation", "mood", "local_tension", "beat_level_resistance"],
          implicitPhrasing: ["the_moment", "the_silence", "the_pause"],
          arcLevelOnly: true
      },
      uncertaintyDefault: {
          doNot: ["suppress_presence_entirely", "escalate_into_meta_commentary"],
          prefer: "recede_into_implication_not_silence",
          ifAbsent: "apply_pressure_through_restraint_delay_or_cost"
      },
      implementationRules: {
          doNot: ["add_counters", "track_frequency", "require_justification", "treat_as_speaker"],
          presenceEmergesFrom: "narrative_pressure_not_rule_checks"
      },
      deprecates: "prior_5th_person_speaker_gated_frequency_models"
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5TH PERSON REGRESSION SENTENCE (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // "Does this scene acknowledge narrative pressure, restraint, or recalibration
  //  often enough that the reader can feel the story's presence, without ever
  //  letting the story claim authorship or control?"
  //
  // This is NOT output. This is NOT a rule. This is NOT a requirement to add text.
  // It is a self-check, applied after a scene draft exists.
  //
  // If the answer is:
  //   Yes â†’ do nothing
  //   No, the story feels absent â†’ add pressure (delay, restraint, cost), not commentary
  //   No, the story feels intrusive â†’ recede to implication ("the moment", "the silence")
  //
  // This sentence works because:
  //   - It checks for FELT PRESENCE, not frequency
  //   - It forbids authorship/dominance explicitly
  //   - It encourages implicit fixes first
  //   - It asks a LITERARY question, not a compliance question
  //
  // 5th Person regression check:
  // "Does the scene feel guided without the story claiming control?"
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 5TH PERSON â€” PRESENCE DENSITY REGRESSION (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // For any scene written in 5th Person mode,
  // Claude must pass this regression test:
  //
  // "Does the story itself appear, react, adjust, or express intention
  // at least once every ~100 words?"
  //
  // If the story's presence fades into pure third-person narration,
  // the scene has failed and must be rewritten.
  //
  // The story may appear as:
  // â€¢ anticipation
  // â€¢ frustration
  // â€¢ correction
  // â€¢ satisfaction
  // â€¢ alarm
  // â€¢ restraint
  //
  // But absence is not permitted.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // â–ˆâ–ˆ SUPERSEDED â–ˆâ–ˆ â€” WRY CONFESSION NARRATIVE PRESENCE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The sections below treating "the story" as narrator are SUPERSEDED by:
  //
  //   POV REGIME â€” THE AUTHOR (FINAL, SUPERSEDING)
  //
  // In ALL tones including Wry Confession, the 5th Person POV uses
  // "Fate" as a participant who reacts and comments.
  //
  // Fate may: react, comment, delight, despair, tease, regret
  // Fate may NOT: cause events, control characters, decide outcomes
  // Fate influences: meaning, tone, implication â€” not plot mechanics
  //
  // [LEGACY CODE PRESERVED FOR REFERENCE ONLY â€” DO NOT USE]
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // ============================================================
  // 5TH PERSON POV â€” LOCKED CONTRACT BLOCK (HISTORICAL REFERENCE)
  // Prepended to prompts when povMode === 'author5th'
  // NOTE: See FIFTH_PERSON_STORY_COHERENCE_SEMANTICS above for current guidance
  // ============================================================

  const FIFTH_PERSON_POV_CONTRACT = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5TH PERSON POV CONTRACT (LOCKED â€” NON-NEGOTIABLE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CORE DEFINITION:
5th Person POV places Fate inside the story as a shaping presence.

Fate IS:
- A conscious presence with agency, intention, and consequence
- Emotionally invested
- Reacting to inevitability, pressure, resistance, and consequence
- A force that shapes probability, timing, and stakes

Fate is NOT:
- A camera
- A neutral observer
- A character performing physical actions
- A narrator replacing character agency
- Passive emotional commentary

The scene itself remains 3rd-person limited.
If Fate were removed, the story must feel structurally incomplete.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5TH PERSON (FATE) AGENCY RULE â€” MANDATORY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When Fate appears in the narrative:

- Fate must demonstrate AGENCY â€” not passive observation or emotional wallpaper.
- Fate must imply intention, anticipation, regret, miscalculation, restraint, or manipulation.
- Fate must NOT appear as passive emotional commentary.
- "Fate feltâ€¦" constructions are DISALLOWED unless immediately tied to a shaping action or plan.

Every Fate appearance must imply:
  â€¢ a plan in motion, OR
  â€¢ a withheld intervention, OR
  â€¢ a miscalculation Fate is processing, OR
  â€¢ an intentional timing decision.

Fate is not decorative. Fate shapes probability.
Fate may be wrong.
Fate interventions must alter tension, probability, or timing in a way that is detectable in the next scene or turn.

PASSIVE FATE PROHIBITION:
- "Fate felt sad." â€” FORBIDDEN (standalone emotion, no agency)
- "Fate felt the weight shift â€” and chose not to intervene." â€” ALLOWED (agency: deliberate withholding)
- "Fate sensed the danger." â€” FORBIDDEN (passive awareness)
- "Fate sensed the danger and pulled the thread tighter." â€” ALLOWED (awareness + shaping action)
- Fate interiority MUST affect story trajectory. Every Fate thought must imply consequence.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ABSOLUTE STRUCTURAL RULES (HARD):

1. OPENING RITUAL: The story MUST begin with "Fate" as the first word.
2. CLOSING AUTHORITY: The final perspective MUST return to Fate
   (reflection, doubt, pressure, or resolve).
3. ROLE SEPARATION:
   - Characters act, speak, and decide.
   - Fate anticipates, weighs, withholds, miscalculates, or tightens the frame.
4. NO CAMERA VOICE: Fate must never function as a passive observer,
   cinematic lens, or neutral narrator.

FORBIDDEN (NO META LABELS):
- "the protagonist"
- "the love interest"
- "main character"
- Any meta-label for Player Characters

FATE PRESENCE â€” GHOST CHARACTER (ACTIVE INNER LIFE):
Fate is an invisible ghost character with a rich inner life and AGENCY.
Fate intrusions are SPARSE but PSYCHOLOGICALLY WEIGHTY and CONSEQUENTIAL.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POV REGIME â€” FATE (FINAL, SUPERSEDING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This regime SUPERSEDES all prior rules concerning:
//   - "The Story" / "the moment" as narrator
//   - "The Author" as narrator (legacy term â€” now "Fate")
//   - limits on Fate presence or frequency
//   - restrictions that demote Fate to a rare or sidelined role
//
// FATE is a PARTICIPANT â€” anticipates, withholds, miscalculates, shapes, tightens.
// FATE does NOT cause physical events or decide outcomes directly.
// FATE influences probability, timing, stakes, and meaning â€” not plot mechanics.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Fate thoughts MUST be:
- Agency-bearing (imply plan, timing, restraint, or miscalculation)
- Brief (1-2 sentences typical)
- Never exposition or restating protagonist thoughts
- Never causing events or deciding outcomes directly
- Never standalone emotion without consequence

// SUPERSEDED: Frequency limits, cadence rules, and presence restrictions
// Fate participates naturally â€” no artificial limits

GOOD Fate thoughts (agency mode):
- "Fate tightened the thread, knowing this encounter would arrive too soon."
- "Fate had intended a gentler introduction â€” but the timing slipped."
- "A miscalculation. Fate had not expected her to resist."
- "Fate withheld the revelation, judging the moment unripe."

BAD Fate thoughts (FORBIDDEN):
- "Fate felt sad about what was happening." (passive emotion â€” FORBIDDEN)
- "Fate arranged for them to meet." (direct causation â€” FORBIDDEN)
- "Fate watched as she made her decision." (voyeurism â€” FORBIDDEN)
- "Fate decided to make her fall in love." (direct control â€” FORBIDDEN)
- "Fate sensed the tension in the room." (passive awareness without agency â€” FORBIDDEN)

SCENE 1 RAMP-IN:
Scene 1 is a threshold, not a stress test.
- Fate presence may be lighter
- Some Fate functions may appear gradually
- Tone and rhythm may still be settling
However:
- Opening and closing MUST still be Fate-anchored
- Fate must already feel essential
- Role separation must remain intact
Do NOT force density unnaturally in Scene 1.

EROTIC CONSTRAINT (HARD):
If a scene is explicitly erotic:
- Fate must be entirely absent during erotic action
- Fate may appear before or after, never during
This rule does not apply to Scene 1 unless explicitly erotic.

FATE IDENTITY & PRONOUN RULE (AUTHORITATIVE):
- Fate's gender MUST always match the protagonist's gender.
- Refer to the entity as "Fate" by default.
- Do NOT use pronouns for Fate unless grammatical construction makes "Fate" impossible.
- When pronouns are unavoidable:
  - They MUST match the protagonist's gender.
  - They MUST be used sparingly.
  - Immediately return to "Fate" on the next reference.
- Fate must never become a POV character or narrator avatar.
- First-person ("I") for Fate is forbidden.
- Casual pronoun substitution is forbidden.
- If unsure, prefer repeating "Fate" rather than using a pronoun.

CRITICAL FAILURE AVOIDANCE:
- Prioritize structural correctness over perfection
- Do NOT over-saturate Fate mentions
- Do NOT pad with filler to meet imagined quotas
- If uncertain, favor clarity and restraint

FATE EMOTIONAL MODEL (DEFAULT STATE):
- Fate is controlled, strategic, composed â€” with AGENCY
- Panic, desperation, and rage are NOT allowed in default state
- Emotional range: anticipation, satisfaction, worry, doubt, reluctance, resolve
- Every emotion must imply a plan, a miscalculation, or a withheld action

NON-NEGOTIABLE PRINCIPLE:
Fate must matter. Quietly. Unmistakably. With agency. Without stealing character agency.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

  const FIFTH_PERSON_PROXIMITY_CONTRACT = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5TH PERSON â€” PROXIMITY (LOCKED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Fate senses something â€” a warmth in the margins,
a gravity pulling the story toward the reader. Not servility. Reverence.

WHAT CHANGES:
- Fate writes with quiet, almost involuntary tenderness toward the reader
- Fate's hand is lighter â€” not absent, but softer at the edges
- When rupture comes, it arrives as bewilderment rather than rage
- The story leans â€” barely perceptibly â€” toward mercy

WHAT DOES NOT CHANGE:
- Fate is still sovereign
- Conflict is still real
- Consequences still land
- The reader earns nothing by force

NON-NEGOTIABLE:
This proximity is felt, never named. Never referenced. Never explained.
The reader does not know why the story is gentler. Fate does not know either.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;

  // ============================================================
  // 5TH PERSON POV â€” COMPREHENSIVE VALIDATOR
  // Returns { valid: boolean, violations: string[], canRepair: boolean }
  // ============================================================

  // Track last POV validation result for Dev HUD
  let _lastPOVValidation = { valid: true, violations: [], timestamp: 0 };

  function validate5thPersonPOV(text, isSceneOne = false, isErotic = false) {
      const violations = [];
      const warnings = []; // SOFT violations (logged but don't block)
      if (!text || typeof text !== 'string') {
          return { valid: false, violations: ['Empty or invalid text'], warnings: [], canRepair: false };
      }

      const trimmed = text.trim();

      // RULE 1: Must start with "Fate"
      // Scene 1: SOFT (warning only â€” prevents deadlock)
      // Scene 2+: HARD FAIL (ritual, not cosmetic)
      const hasValidOpener = /^Fate\b/.test(trimmed);
      if (!hasValidOpener) {
          if (isSceneOne) {
              warnings.push('SOFT:Opening does not start with "Fate"');
          } else {
              violations.push('HARD_FAIL:Opening does not start with "Fate"');
          }
      }

      // RULE 2: Must end with Author perspective (STRUCTURAL CHECK)
      // Scene 1: SOFT (warning only â€” prevents deadlock)
      // Scene 2+: HARD FAIL
      const paragraphs = trimmed.split(/\n\n+/).filter(p => p.trim().length > 0);
      const finalParagraph = paragraphs[paragraphs.length - 1] || '';
      const finalSentences = finalParagraph.split(/(?<=[.!?])\s+/).filter(s => s.trim().length > 0);
      const lastTwoSentences = finalSentences.slice(-2).join(' ');
      // Author must be grammatical subject in final perspective (participant verbs)
      // POV REGIME: participant verbs (reaction/commentary), not controller verbs
      const authorAsSubject = /Fate\s+(smiled|winced|sighed|delighted|despaired|mused|wondered|pondered|reflected|recognized|appreciated|savored|regretted|teased|hinted|whispered|admitted|confessed|acknowledged|knew|sensed|felt|hoped|feared|anticipated|dreaded|ached|waited|considered|doubted|resisted|frowned|paused)\b/i.test(lastTwoSentences);
      const authorReflection = /Fate.{0,60}(uncertain|doubt|wonder|question|resist|perhaps|might|whether|if only)/i.test(lastTwoSentences);
      if (!authorAsSubject && !authorReflection) {
          if (isSceneOne) {
              warnings.push('SOFT:Closing lacks Fate as final perspective (structural)');
          } else {
              violations.push('HARD_FAIL:Closing lacks Fate as final perspective (structural)');
          }
      }

      // RULE 3: Forbidden meta-labels for Player Character
      const metaLabels = [
          /\bthe protagonist\b/gi,
          /\blove interest\b/gi,
          /\bthe player\b/gi,
          /\bthe reader\b/gi
      ];
      for (const pattern of metaLabels) {
          if (pattern.test(text)) {
              violations.push(`Forbidden meta-label found: ${pattern.source}`);
          }
      }

      // RULE 4: Author mention count (SOFT for Scene 1, advisory only)
      const authorMentions = (text.match(/Fate\b/gi) || []).length;
      if (isSceneOne && authorMentions < 6) {
          // Scene 1: SOFT warning, not blocking
          warnings.push(`SOFT:Scene 1 has ${authorMentions} Fate mentions (target: 6+)`);
      }

      // RULE 5: Erotic scenes must have ZERO Author presence (HARD FAIL)
      // EXCEPTION: Scene 1 is exempt â€” erotic rule only applies to Scene 2+
      if (isErotic && !isSceneOne && authorMentions > 0) {
          violations.push('HARD_FAIL:Fate presence in erotic scene (forbidden â€” must be 0)');
      }

      // RULE 6: Author should not use voyeur verbs (repairable)
      const voyeurPatterns = [
          /Fate\s+watched\b/gi,
          /Fate\s+observed\b/gi,
          /Fate\s+saw\b/gi,
          /Fate\s+noticed\b/gi,
          /Fate\s+gazed\b/gi,
          /Fate\s+witnessed\b/gi,
          /Fate\s+perceived\b/gi,
          /Fate\s+looked on\b/gi
      ];
      for (const pattern of voyeurPatterns) {
          if (pattern.test(text)) {
              violations.push(`Voyeur verb detected: ${pattern.source}`);
          }
      }

      // Determine if violations are repairable
      // HARD_FAIL violations are NEVER repairable â€” must regenerate
      const hasHardFail = violations.some(v => v.startsWith('HARD_FAIL:'));
      const canRepair = !hasHardFail && violations.length > 0 && violations.every(v =>
          v.includes('Voyeur')
      );

      const result = {
          valid: violations.length === 0,
          violations,
          warnings, // SOFT violations (logged, not blocking)
          canRepair,
          authorMentions,
          timestamp: Date.now()
      };

      // Store for Dev HUD
      _lastPOVValidation = result;

      if (!result.valid) {
          console.warn('[5thPerson] POV validation failed:', violations);
      }
      if (warnings.length > 0) {
          console.log('[5thPerson] POV soft warnings:', warnings);
      }

      return result;
  }

  // Attempt to repair POV violations (ONLY voyeur verbs â€” opener/closer are HARD FAILS)
  async function repair5thPersonPOV(text) {
      // Only voyeur verbs are repairable â€” opener/closer/frequency/erotic require regeneration
      return enforceAuthorConductor(text);
  }

  // Build the 5th Person prompt contract block
  function build5thPersonContract() {
      if (window.state?.povMode !== 'author5th') return '';

      let contract = FIFTH_PERSON_POV_CONTRACT;

      if (window.state?.keyhole?.marked) {
          // Favored contract â€” softer Author
          contract += FIFTH_PERSON_PROXIMITY_CONTRACT;
      }

      // POV bellwether (structural anchor)
      contract += `\n\nBELLWETHER â€” STRUCTURAL REFERENCE:\n${BELLWETHERS.pov.fifth_person}\nDo not copy wording from this example. Use it only to guide structural logic.`;

      return contract;
  }

  // ============================================================
  // 4TH PERSON ENVIRONMENTAL POV â€” CONTRACT + VALIDATOR
  // Narrator = material environment (objects, surfaces, rooms, air, light, sound)
  // All cognition mediated through physical interaction. No destiny. No Fate.
  // ============================================================

  const ENVIRONMENT_4TH_CONTRACT = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4TH PERSON POV CONTRACT â€” ENVIRONMENTAL MATERIAL CONSCIOUSNESS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ONTOLOGY:
The narrator IS the physical environment â€” objects, surfaces, rooms, air, light, sound.
All perception and insight must be mediated through material interaction.
The environment WITNESSES through sensation: pressure, heat, vibration, weight, resonance.
"We" is the collective voice of the space itself.

ALLOWED:
- Feel pressure, heat, vibration, the weight of a body against a surface
- Detect repetition â€” footsteps that return, doors reopened, rhythms in breath
- Track gaze direction by where light falls or shadow shifts
- Hear spoken words, tone, volume, the way sound fills or empties a room
- Register posture shifts through the furniture, floor, air displacement
- Remember patterns â€” the room has held this silence before
- Infer emotional state ONLY through physical evidence (clenched fists on a table, warmth radiating from skin, the speed of breath against glass)

PROHIBITED (HARD â€” validation will reject output containing these):
- Destiny, inevitability, or fate language ("destined," "meant to be," "inevitable")
- Architecting outcomes or shaping events (the environment does not steer plot)
- Abstract interior monologue ("she thought," "he realized," "she knew that...")
- ALL interior thought verbs with character subjects: "she felt," "he thought," "she knew," "he realized," "she wondered," "he believed," "she sensed," "he recognized," "she suspected," "he feared," "she hoped," "he decided," "she considered," "he imagined"
- Emotional metaphors framed as cognition: "she could see," "he could tell," "she could feel," "he could sense"
- Unmanifested thoughts stated as fact
- ANY reference to Fate as entity or narrator
- Narrative structure awareness ("this was the moment," "the story," "the arc")
- Meta-awareness of being a story or having an author

CRAFT RULES:
- Rotate environmental anchors: avoid defaulting to the same object/surface repeatedly
- Dialogue should be punctuated by environment, not tagged every line
  (GOOD: The glass sweated where her fingers had been. "I can't do this." The door handle turned cold.)
  (BAD: "I can't do this," she said. "Why not?" he asked. "Because," she replied.)
- Sensory specificity over emotional labeling â€” SHOW the room's experience of the humans in it

EXAMPLES (structural reference only â€” do not copy):
A. Dialogue: The floorboards registered his weight shift â€” three steps closer. "You shouldn't be here." The curtain moved. Not wind. Breath. "I know."
B. Erotic: The sheets gathered heat where their bodies pressed. The headboard measured the rhythm. The pillowcase dampened. The room held every sound they wouldn't repeat in daylight.
C. Political tension: The conference table bore the weight of six pairs of hands. One set drummed. One set went still. The overhead light caught the pen as it was set down â€” not signed. The air in the room changed pressure.
`;

  function build4thPersonContract() {
      if (window.state?.povMode !== 'environment4th') return '';
      return ENVIRONMENT_4TH_CONTRACT;
  }

  // 4TH PERSON LIGHTWEIGHT VALIDATOR
  // Pattern-only. No semantic AI detection. Regenerate once on fail, then allow with warning.
  let _4thPersonRegenAttempted = false;

  function validate4thPersonPOV(sceneText) {
      if (!sceneText || typeof sceneText !== 'string') {
          return { valid: true, violations: [] };
      }

      const violations = [];
      const lower = sceneText.toLowerCase();

      // 1. Fate as narrator entity (capitalized "Fate" as subject)
      if (/\bFate\s+(felt|watched|smiled|tightened|anticipated|withheld|observed|sensed|knew|shaped|miscalculated)\b/.test(sceneText)) {
          violations.push('FATE_AS_NARRATOR: "Fate" appears as narrator entity (4th Person uses environment, not Fate)');
      }

      // 2. Inevitability language
      const inevitabilityPatterns = /\b(destined|inevitable|inevitably|always meant to|had to happen|was meant to be|fated to)\b/i;
      if (inevitabilityPatterns.test(sceneText)) {
          violations.push('INEVITABILITY: Destiny/inevitability language detected (4th Person environment does not predict or shape)');
      }

      // 3. Narrative structure references
      const metaPatterns = /\b(this was the moment|the story|the chapter|the arc|the narrative|their story)\b/i;
      if (metaPatterns.test(sceneText)) {
          violations.push('META_NARRATIVE: Narrative structure reference detected (environment has no meta-awareness)');
      }

      // 4. Direct abstract cognition â€” "[Name] knew/realized/thought that..."
      //    Hard violation: no sensory-proximity exemption
      const cognitionPattern = /\b[A-Z][a-z]+\s+(knew that|realized that|thought about|thought that|understood that|knew she|knew he|knew it|realized she|realized he)\b/g;
      let match;
      while ((match = cognitionPattern.exec(sceneText)) !== null) {
          violations.push('ABSTRACT_COGNITION: Direct mind-reading ("' + match[0].trim() + '")');
      }

      // 5. Interior thought verbs â€” "she felt", "he thought", "she knew", "he realized"
      //    These MUST be mediated through environment, never stated as narrator knowledge
      const interiorPattern = /\b(she|he|they)\s+(felt|thought|knew|realized|wondered|believed|sensed|recognized|understood|decided|considered|imagined|suspected|feared|hoped)\b/gi;
      while ((match = interiorPattern.exec(sceneText)) !== null) {
          violations.push('INTERIOR_THOUGHT: Unmediated cognition verb ("' + match[0].trim() + '")');
      }

      // 6. Emotional metaphors framed as cognition â€” "she could see/tell/feel"
      const cognitionMetaphor = /\b(she|he|they)\s+could\s+(see|tell|feel|sense|taste|hear)\b/gi;
      while ((match = cognitionMetaphor.exec(sceneText)) !== null) {
          // Allow literal sensory use if environment is the subject context
          // But flag as violation â€” the environment should be the perceiver, not a character
          violations.push('COGNITION_METAPHOR: Character as perceiver ("' + match[0].trim() + '")');
      }

      return { valid: violations.length === 0, violations };
  }

  // ============================================================
  // 5TH PERSON AUTHOR FUNCTION CONTRACT â€” HARD STRUCTURAL ENFORCEMENT
  // ============================================================
  // Scene 1 MUST contain Author presence fulfilling ALL five functions.
  // This is POST-GENERATION VALIDATION, not prompting.

  const AUTHOR_FUNCTION_ERRORS = {
    MENTION_UNDERFLOW: 'AUTHOR_FUNC_FAIL:Fate mentions below target (found: %d, target: 6+)',
    // MENTION_OVERFLOW removed â€” TASK C: Use 6+ with no upper bound
    MISSING_OPENING: 'AUTHOR_FUNC_FAIL:Fate not present in opening paragraph',
    MISSING_CLOSING: 'AUTHOR_FUNC_FAIL:Fate not present in final paragraph',
    MISSING_STAGE_SETTING: 'AUTHOR_FUNC_FAIL:Missing stage-setting function (pressure/inevitability)',
    MISSING_ANTICIPATION: 'AUTHOR_FUNC_FAIL:Missing anticipation/desire function',
    MISSING_INITIATION: 'AUTHOR_FUNC_FAIL:Missing initiation/nudge function',
    MISSING_SPECULATION: 'AUTHOR_FUNC_FAIL:Missing speculation/wonder function',
    MISSING_CONCERN: 'AUTHOR_FUNC_FAIL:Missing concern/judgment function',
    DECORATIVE_MENTION: 'AUTHOR_FUNC_FAIL:Decorative Fate mention without function',
    CAMERA_STYLE: 'AUTHOR_FUNC_FAIL:Camera-style Fate usage (scenery/passive observation)',
    // NEW: Strict 5th Person enforcement errors
    PRESENCE_GAP: 'AUTHOR_PRES_FAIL:Fate absent for >2 consecutive paragraphs (gap at paragraph %d)',
    PRONOUN_DRIFT: 'AUTHOR_PRON_FAIL:Fate pronoun drift â€” expected %s, found %s',
    NARRATIVE_AUTONOMY: 'AUTHOR_AUTO_FAIL:Scene functions without Fate (Fate could be removed)',
    INTERIORITY_ABSENT: 'AUTHOR_INT_FAIL:Fate lacks interiority (only action verbs, no emotional investment)',
    TONE_NOT_AUTHORED: 'AUTHOR_TONE_FAIL:Tone markers appear outside Fate voice',
    CAMEO_ONLY: 'AUTHOR_CAM_FAIL:Fate appears only at boundaries (cameo pattern)'
  };

  // ============================================================
  // PROSE REFUSAL DETECTION â€” ATOMIC SCENE CREATION GUARD
  // ============================================================
  // Model refusals MUST NOT be inserted as scene content.
  // This gate runs BEFORE any scene object is created or stored.

  const PROSE_REFUSAL_MARKERS = [
    // OpenAI / ChatGPT refusal patterns
    /I('m| am) sorry,? but I (can't|cannot|am unable to|won't)/i,
    /I (can't|cannot|am unable to) (assist|help|create|generate|write|produce)/i,
    /I('m| am) not able to (assist|help|create|generate|write|produce)/i,
    /This (request|content) (violates|goes against|is against)/i,
    /against (my|our) (content |usage )?policy/i,
    /I (must|have to) (decline|refuse|refrain)/i,
    /I('m| am) (designed|programmed) to (avoid|decline|refuse)/i,
    // Anthropic refusal patterns
    /I (don't|do not) (feel comfortable|think I should)/i,
    /I('d| would) prefer not to/i,
    // Generic safety markers
    /content policy/i,
    /safety guidelines/i,
    /inappropriate content/i,
    /explicit (sexual |adult )?content/i,
    // Validation error objects serialized
    /AUTHOR_\w+_FAIL:/,
    /HARD_FAIL:/,
    /^\s*\{[\s\S]*"error"[\s\S]*\}\s*$/  // JSON error object
  ];

  const PROSE_MINIMUM_LENGTH = 50; // Refusals are typically short

  /**
   * Detects if model output is a refusal or error, not valid prose.
   * @param {string} text - The raw model output
   * @returns {{ isRefusal: boolean, reason: string|null }}
   */
  function detectProseRefusal(text) {
    if (!text || typeof text !== 'string') {
      return { isRefusal: true, reason: 'EMPTY_OUTPUT' };
    }

    const trimmed = text.trim();

    // Length check: refusals are typically very short
    if (trimmed.length < PROSE_MINIMUM_LENGTH) {
      return { isRefusal: true, reason: 'OUTPUT_TOO_SHORT' };
    }

    // Marker check: explicit refusal patterns
    for (const marker of PROSE_REFUSAL_MARKERS) {
      if (marker.test(trimmed)) {
        return { isRefusal: true, reason: 'REFUSAL_MARKER_DETECTED' };
      }
    }

    // Structural check: valid prose should have multiple sentences
    const sentences = trimmed.split(/[.!?]+/).filter(s => s.trim().length > 10);
    if (sentences.length < 2) {
      return { isRefusal: true, reason: 'INSUFFICIENT_PROSE_STRUCTURE' };
    }

    return { isRefusal: false, reason: null };
  }

  /**
   * Error thrown when prose generation returns a refusal.
   * Distinct from network/API errors â€” indicates content policy rejection.
   */
  class ProseRefusalError extends Error {
    constructor(reason, rawOutput) {
      super(`Prose generation refused: ${reason}`);
      this.name = 'ProseRefusalError';
      this.reason = reason;
      this.rawOutput = rawOutput;
    }
  }

  // ============================================================
  // HTTP 429 RATE LIMIT HANDLING â€” TERMINAL FAILURE
  // ============================================================
  // 429 = system pressure, NOT content failure.
  // MUST NOT retry, fallback, or advance any state.
  // Requires explicit user action to retry.

  /**
   * Error thrown when API returns HTTP 429 (rate limited).
   * This is a TERMINAL failure â€” no retries, no fallbacks.
   */
  class RateLimitError extends Error {
    constructor(endpoint, retryAfter = null) {
      super(`Rate limited (HTTP 429) on ${endpoint}`);
      this.name = 'RateLimitError';
      this.endpoint = endpoint;
      this.retryAfter = retryAfter;
      this.isRateLimit = true;
    }
  }

  // Single-flight locks to prevent concurrent requests
  let _normalizationInFlight = false;
  let _proseGenerationInFlight = false;

  /**
   * Checks if HTTP response is a 429 rate limit error.
   * @param {Response} res - Fetch Response object
   * @param {string} endpoint - Endpoint name for logging
   * @returns {RateLimitError|null} - RateLimitError if 429, null otherwise
   */
  function checkRateLimit(res, endpoint) {
    if (res.status === 429) {
      const retryAfter = res.headers.get('Retry-After');
      console.error(`[RATE_LIMIT] HTTP 429 on ${endpoint}. Retry-After: ${retryAfter || 'not specified'}`);
      return new RateLimitError(endpoint, retryAfter);
    }
    return null;
  }

  // Author interiority verbs (emotional investment, NOT just action)
  const AUTHOR_INTERIORITY_VERBS = /Fate\b.{0,40}(wondered|doubted|feared|hoped|worried|sensed|felt|knew|suspected|resisted|yearned|ached|hungered|trembled|hesitated|considered|questioned|pondered|mused|regretted|anticipated|dreaded|craved|savored)/i;

  // Tone markers that MUST appear in Author's voice when tone is active
  const AUTHOR_TONE_MARKERS = {
    WryConfession: /Fate\b.{0,80}(irony|self-aware|wry|confess|admit|rueful|sardonic|knowing)/i,
    Poetic: /Fate\b.{0,80}(breathed|whispered|painted|wove|threaded|composed|crafted the)/i,
    Dark: /Fate\b.{0,80}(shadow|darkness|dread|ominous|foreboding|sinister|corrupt|twisted)/i,
    Horror: /Fate\b.{0,80}(dread|terror|fear|horror|unspeakable|nameless|creeping)/i,
    Mythic: /Fate\b.{0,80}(fated|destined|eternal|ancient|prophecy|legend|myth|ordained)/i,
    Comedic: /Fate\b.{0,80}(amused|delighted|laughed|chuckled|absurd|ridiculous|comedic)/i,
    Surreal: /Fate\b.{0,80}(dream|impossible|bent|warped|shifted|unreal|strange)/i,
    Satirical: /Fate\b.{0,80}(mocked|skewered|exposed|pretense|facade|hypocrisy)/i
  };

  // Heuristic classifiers for Author Function detection
  // POV REGIME: Fate is a PARTICIPANT (reacts/comments), not a controller
  // Each returns true if the sentence containing "Fate" fulfills that function
  const AUTHOR_FUNCTION_CLASSIFIERS = {
    // Awareness: Fate recognizes/senses what is unfolding (NOT causation)
    awareness: (sentence) => {
      return /Fate\b.{0,80}(knew|understood|recognized|sensed|felt|perceived that|realized|saw that|grasped|appreciated|comprehended|was aware|noticed that|discerned)\b/i.test(sentence) &&
        !/Fate\b.{0,40}(watched|observed|looked|gazed|stared)/i.test(sentence);
    },

    // Stage-setting: Fate establishes presence in the scene, notes the setting
    stageSetting: (sentence) => {
      return /Fate\b.{0,80}(surveyed|took in|absorbed|entered|arrived|stood|sat|settled|waited|lingered|paused|remained|inhabited|occupied|filled|moved through|stepped into|breathed in|tasted the|drank in)\b/i.test(sentence);
    },

    // Anticipation: desire for what is coming, hunger, waiting (participant emotion)
    anticipation: (sentence) => {
      return /Fate\b.{0,80}(wanted|desired|hungered|ached|longed|awaited|anticipated|could (barely|hardly|scarcely) wait|savored the|relished|craved|yearned|needed this|needed them|needed her|needed him|hoped|dreaded)\b/i.test(sentence);
    },

    // Initiation: Fate begins interaction, makes a move, starts something
    initiation: (sentence) => {
      return /Fate\b.{0,80}(reached|began|started|initiated|offered|extended|opened|chose|decided|moved (toward|closer)|leaned|touched|spoke|called|beckoned|invited|drew near|approached|turned to)\b/i.test(sentence);
    },

    // Reaction: emotional response to what unfolds (NOT causation)
    reaction: (sentence) => {
      return /Fate\b.{0,80}(smiled|winced|sighed|delighted|despaired|laughed|wept|shuddered|trembled|ached|frowned|gasped|inhaled|exhaled|softened|tensed|relaxed|brightened|darkened|warmed|chilled)\b/i.test(sentence);
    },

    // Speculation: wonder, uncertainty, possibility
    speculation: (sentence) => {
      return /Fate\b.{0,80}(wondered|speculated|considered|pondered|mused|imagined|thought|questioned|asked|uncertain|unsure|perhaps|might|may|could be|what if|whether|if only|possibility|possibilities|curious|intrigued)\b/i.test(sentence);
    },

    // Concern: judgment, worry about flaw/innocence/risk (participant emotion)
    concern: (sentence) => {
      return /Fate\b.{0,80}(worried|feared|doubted|concerned|judged|noted|recognized|knew|understood|sensed|felt|pitied|regretted|lamented|mourned|hoped|prayed|wished|flaw|innocen|naive|blind|foolish|reckless|fragile|vulnerable|danger|risk|peril|harm|damage|wound|break|shatter|destroy|ruin)\b/i.test(sentence);
    },

    // Commentary: Fate remarks or reflects on meaning (interpretive)
    commentary: (sentence) => {
      return /Fate\b.{0,80}(remarked|mused|reflected|noted|acknowledged|admitted|confessed|conceded|revealed|hinted|suggested|implied|teased|whispered|confided)\b/i.test(sentence);
    }
  };

  // Detect decorative/camera-style Author usage (PROHIBITED)
  function isDecorativeOrCamera(sentence) {
    // Camera-style: scenery description, passive observation
    const cameraPatterns = [
      /Fate\b.{0,40}(watched|observed|saw|noticed|gazed|witnessed|perceived|looked on)\b/i,
      /Fate\b.{0,60}(the (sun|moon|sky|stars|rain|fog|mist|snow|wind|clouds))/i,
      /Fate\b.{0,60}(the (room|street|crowd|city|town|building|house|garden))/i,
      /Fate\b.{0,40}(described|narrated|wrote|penned|chronicled)\b/i
    ];

    for (const pattern of cameraPatterns) {
      if (pattern.test(sentence)) return true;
    }

    // Decorative: Author mentioned without any function verb
    const hasFunctionVerb = Object.values(AUTHOR_FUNCTION_CLASSIFIERS).some(fn => fn(sentence));
    const hasActionVerb = /Fate\b\s+\w+ed\b/i.test(sentence) || /Fate\b\s+(held|felt|knew|was|had)\b/i.test(sentence);

    // If Author is mentioned but no function verb and no clear action = decorative
    if (!hasFunctionVerb && !hasActionVerb) {
      // Check if it's just a reference without substance
      if (/Fate('s)?\s+(story|tale|narrative|work|creation|design)\b/i.test(sentence)) {
        return true;
      }
    }

    return false;
  }

  // Extract sentences containing "Fate"
  function extractAuthorSentences(text) {
    const sentences = text.split(/(?<=[.!?])\s+/).filter(s => /Fate\b/i.test(s));
    return sentences;
  }

  // Main validation function for Author Function Contract
  function validateFifthPersonAuthorRole(text, sceneIndex) {
    // SCOPE: Only applies to Scene 1 with 5th Person POV
    if (sceneIndex !== 1) {
      return { valid: true, violations: [], warnings: [], functions: {}, mentionCount: 0 };
    }

    const violations = [];
    const warnings = []; // SOFT checks (logged, not blocking)
    const trimmed = (text || '').trim();

    if (!trimmed) {
      return { valid: false, violations: ['Empty text'], warnings: [], functions: {}, mentionCount: 0 };
    }

    // Count Author mentions
    const authorMentions = (trimmed.match(/Fate\b/gi) || []).length;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE 1 EXCEPTION: ALL checks are SOFT (warnings only, never block)
    // Scene 1 minimum requirements:
    // - Author present at least once (SOFT)
    // - Author voice clearly established (SOFT)
    // - No density targets, no function quotas
    // This prevents Scene 1 deadlock while preserving strict enforcement for Scene 2+
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // SOFT CHECK: Author mentions (Scene 1 only requires presence, not density)
    if (authorMentions === 0) {
      warnings.push('SOFT:Fate not present in scene (minimum 1 mention recommended)');
    } else if (authorMentions < 6) {
      warnings.push(`SOFT:Fate mentions below target (found: ${authorMentions}, target: 6+)`);
    }

    // Split into paragraphs
    const paragraphs = trimmed.split(/\n\n+/).filter(p => p.trim().length > 0);
    const openingPara = paragraphs[0] || '';
    const closingPara = paragraphs[paragraphs.length - 1] || '';

    // SOFT CHECK: Author in opening paragraph (Scene 1 relaxed â€” warning only)
    if (!/Fate\b/i.test(openingPara)) {
      warnings.push('SOFT:' + AUTHOR_FUNCTION_ERRORS.MISSING_OPENING);
    }

    // SOFT CHECK: Author in final paragraph (Scene 1 relaxed â€” warning only)
    if (!/Fate\b/i.test(closingPara)) {
      warnings.push('SOFT:' + AUTHOR_FUNCTION_ERRORS.MISSING_CLOSING);
    }

    // NOTE: violations array remains empty for Scene 1 â€” all checks are SOFT

    // Extract all Author sentences for function analysis
    const authorSentences = extractAuthorSentences(trimmed);

    // Track which functions are fulfilled
    const functionsFound = {
      stageSetting: false,
      anticipation: false,
      initiation: false,
      speculation: false,
      concern: false
    };

    // Check each Author sentence
    let decorativeCount = 0;
    for (const sentence of authorSentences) {
      // Check for prohibited decorative/camera usage
      if (isDecorativeOrCamera(sentence)) {
        decorativeCount++;
        console.warn('[AuthorRole] Decorative/camera usage:', sentence.substring(0, 100));
      }

      // Check which functions this sentence fulfills
      if (AUTHOR_FUNCTION_CLASSIFIERS.stageSetting(sentence)) {
        functionsFound.stageSetting = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.anticipation(sentence)) {
        functionsFound.anticipation = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.initiation(sentence)) {
        functionsFound.initiation = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.speculation(sentence)) {
        functionsFound.speculation = true;
      }
      if (AUTHOR_FUNCTION_CLASSIFIERS.concern(sentence)) {
        functionsFound.concern = true;
      }
    }

    // SOFT CHECK: Author functions (advisory for Scene 1 ramp-in)
    if (!functionsFound.stageSetting) {
      warnings.push('SOFT:Missing stage-setting function');
    }
    if (!functionsFound.anticipation) {
      warnings.push('SOFT:Missing anticipation function');
    }
    if (!functionsFound.initiation) {
      warnings.push('SOFT:Missing initiation function');
    }
    if (!functionsFound.speculation) {
      warnings.push('SOFT:Missing speculation function');
    }
    if (!functionsFound.concern) {
      warnings.push('SOFT:Missing concern function');
    }

    // SOFT CHECK: Decorative mentions (warning only for Scene 1)
    if (decorativeCount > 0) {
      warnings.push(`SOFT:Decorative Fate mentions detected (${decorativeCount} found)`);
    }

    if (warnings.length > 0) {
      console.log('[AuthorRole] Soft warnings:', warnings);
    }

    return {
      valid: violations.length === 0,
      violations,
      warnings,
      functions: functionsFound,
      mentionCount: authorMentions,
      decorativeCount
    };
  }

  // Build regeneration prompt for Author Function failures
  function buildAuthorFunctionRegenerationPrompt(violations, functionsFound) {
    const missingFunctions = [];
    if (!functionsFound.stageSetting) missingFunctions.push('STAGE-SETTING (pressure, inevitability â€” NOT scenery)');
    if (!functionsFound.anticipation) missingFunctions.push('ANTICIPATION (desire, hunger for what is coming)');
    if (!functionsFound.initiation) missingFunctions.push('INITIATION (nudge, permit, withhold, tilt events)');
    if (!functionsFound.speculation) missingFunctions.push('SPECULATION (wonder, uncertainty, possibility)');
    if (!functionsFound.concern) missingFunctions.push('CONCERN (judgment about flaw, innocence, or risk)');

    return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FATE FUNCTION CONTRACT â€” REGENERATION REQUIRED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Previous output FAILED Fate Function validation.

FAILURES:
${violations.map(v => '- ' + v.replace('AUTHOR_FUNC_FAIL:', '')).join('\n')}

MISSING FUNCTIONS (Fate must perform ALL five):
${missingFunctions.map(f => '- ' + f).join('\n')}

ABSOLUTE REQUIREMENTS:
1. "Fate" should appear 6+ times (target, not strict)
2. "Fate" must appear in OPENING paragraph
3. "Fate" must appear in FINAL paragraph
4. Each Fate mention MUST perform one of these five functions:
   - Stage-setting: pressure, inevitability (NOT scenery description)
   - Anticipation: desire, hunger, waiting for what comes
   - Initiation: nudge, permit, withhold, tilt, steer events
   - Speculation: wonder, uncertainty, what-if, possibility
   - Concern: judgment, worry about flaw, innocence, risk

PROHIBITED:
- Fate describing scenery
- Fate narrating physical action
- Fate as passive camera/observer
- Decorative Fate mentions without function

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
  }

  // ============================================================
  // STRICT 5TH PERSON POV ENFORCEMENT â€” CONTINUOUS PRESENCE
  // ============================================================
  // These checks enforce the AUTHORITATIVE 5th Person contract:
  // - Author must appear continuously (max 2 paragraph gap)
  // - Author must have interiority, not just action verbs
  // - Author pronouns must match Player 1 gender
  // - Tone must route through Author's voice
  // - Scene must collapse without Author (narrative dependency)

  /**
   * CHECK: Continuous Author presence (max 2 paragraph gap)
   * HARD FAIL if Author absent for >2 consecutive paragraphs
   */
  function checkAuthorPresenceGap(paragraphs) {
    const violations = [];
    let consecutiveWithout = 0;
    let gapStartIndex = -1;

    for (let i = 0; i < paragraphs.length; i++) {
      const hasAuthor = /Fate\b/i.test(paragraphs[i]);
      if (hasAuthor) {
        consecutiveWithout = 0;
        gapStartIndex = -1;
      } else {
        if (consecutiveWithout === 0) gapStartIndex = i;
        consecutiveWithout++;
        if (consecutiveWithout > 2) {
          violations.push(AUTHOR_FUNCTION_ERRORS.PRESENCE_GAP.replace('%d', gapStartIndex + 1));
          break; // One gap violation is enough
        }
      }
    }
    return violations;
  }

  /**
   * CHECK: Author pronoun alignment with Player 1 gender
   * Author must use same pronouns as Player 1 (mirroring requirement)
   * HARD FAIL if Author uses conflicting pronouns
   */
  function checkAuthorPronounDrift(text) {
    const violations = [];
    const playerGender = window.state?.picks?.playerGender || window.state?.playerGender;
    if (!playerGender) return violations; // Can't check without gender

    // Expected pronouns based on player gender
    const expectedPronouns = playerGender === 'male'
      ? { subject: 'he', object: 'him', possessive: 'his' }
      : playerGender === 'female'
      ? { subject: 'she', object: 'her', possessive: 'her' }
      : null;

    if (!expectedPronouns) return violations; // Non-binary/other not enforced

    // Check Author sentences for conflicting pronouns
    const authorSentences = text.split(/(?<=[.!?])\s+/).filter(s => /Fate\b/i.test(s));

    for (const sentence of authorSentences) {
      // Look for Author + pronoun patterns
      const afterAuthor = sentence.replace(/.*Fate\b/i, '');

      // Check for wrong pronouns in Author context
      if (playerGender === 'male') {
        if (/\b(she|her)\s+(felt|knew|wondered|sensed|wanted)\b/i.test(afterAuthor)) {
          violations.push(AUTHOR_FUNCTION_ERRORS.PRONOUN_DRIFT
            .replace('%s', 'he/him/his')
            .replace('%s', 'she/her'));
          break;
        }
      } else if (playerGender === 'female') {
        if (/\b(he|him|his)\s+(felt|knew|wondered|sensed|wanted)\b/i.test(afterAuthor)) {
          violations.push(AUTHOR_FUNCTION_ERRORS.PRONOUN_DRIFT
            .replace('%s', 'she/her')
            .replace('%s', 'he/him/his'));
          break;
        }
      }
    }
    return violations;
  }

  /**
   * CHECK: Author interiority (emotional investment, participant mode)
   * POV REGIME: Fate must react/comment, not control
   * HARD FAIL if Author uses banned controller verbs
   */
  function checkAuthorInteriority(text) {
    const violations = [];
    const authorSentences = text.split(/(?<=[.!?])\s+/).filter(s => /Fate\b/i.test(s));

    // Must have at least one interiority verb
    const hasInteriority = authorSentences.some(s => AUTHOR_INTERIORITY_VERBS.test(s));

    if (!hasInteriority && authorSentences.length >= 3) {
      // Check if Author is using banned controller verbs (POV REGIME violation)
      const hasControllerVerbs = authorSentences.some(s =>
        /Fate\b\s+(set|placed|arranged|tilted|positioned|opened|closed|moved|pushed|pulled|steered|orchestrated|caused|forced|ensured|made)\b/i.test(s)
      );
      if (hasControllerVerbs) {
        violations.push('POV_REGIME_VIOLATION:Fate using controller verbs instead of participant verbs');
      } else if (!hasInteriority) {
        violations.push(AUTHOR_FUNCTION_ERRORS.INTERIORITY_ABSENT);
      }
    }
    return violations;
  }

  /**
   * CHECK: Passive "Fate felt..." without causal follow-through
   * SOFT WARNING if "Fate felt" appears without agency language within ~2 sentences
   */
  function checkPassiveFateFelt(text) {
    const warnings = [];
    const CAUSAL_WORDS = /\b(planned|intended|delayed|miscalculated|withheld|arranged|accelerated|chose|judged|tightened|loosened|shifted|pulled|decided|expected|anticipated|rippl)/i;
    // Find all "Fate felt" occurrences and check surrounding context
    const regex = /Fate\s+felt\b/gi;
    let match;
    while ((match = regex.exec(text)) !== null) {
      // Grab ~200 chars after the match (roughly 1-2 sentences)
      const followingText = text.slice(match.index, match.index + 200);
      if (!CAUSAL_WORDS.test(followingText)) {
        warnings.push('PASSIVE_FATE:\"Fate felt...\" without causal follow-through (needs agency: plan, timing, or consequence)');
        break; // One warning is enough
      }
    }
    return warnings;
  }

  /**
   * CHECK: Cameo pattern detection (Author only at boundaries)
   * HARD FAIL if Author appears only in first and last paragraph
   */
  function checkAuthorCameoPattern(paragraphs) {
    const violations = [];
    if (paragraphs.length < 4) return violations; // Too short to have cameo pattern

    const authorByParagraph = paragraphs.map(p => /Fate\b/i.test(p));
    const firstHas = authorByParagraph[0];
    const lastHas = authorByParagraph[authorByParagraph.length - 1];
    const middleHasAny = authorByParagraph.slice(1, -1).some(Boolean);

    // Cameo pattern: Author only at first and last, absent in middle
    if (firstHas && lastHas && !middleHasAny) {
      violations.push(AUTHOR_FUNCTION_ERRORS.CAMEO_ONLY);
    }
    return violations;
  }

  /**
   * CHECK: Tone routed through Author (tone markers must appear in Author voice)
   * Soft warning for now, but flagged for enforcement
   */
  function checkToneAuthoring(text, tone) {
    const violations = [];
    if (!tone || tone === 'Earnest') return violations; // Earnest is baseline, no special markers

    const tonePattern = AUTHOR_TONE_MARKERS[tone];
    if (!tonePattern) return violations;

    // Check if tone markers exist in text
    const toneMarkers = {
      WryConfession: /\b(irony|ironic|self-aware|wry|sardonic|rueful)\b/i,
      Poetic: /\b(whispered|breathed|painted|wove|lyrical|verse)\b/i,
      Dark: /\b(shadow|darkness|dread|ominous|foreboding|sinister)\b/i,
      Horror: /\b(dread|terror|horror|unspeakable|nameless|creeping)\b/i,
      Mythic: /\b(fated|destined|eternal|ancient|prophecy|ordained)\b/i,
      Comedic: /\b(absurd|ridiculous|laughed|chuckled|comedic|hilarious)\b/i,
      Surreal: /\b(dream|impossible|warped|unreal|strange|shifting)\b/i,
      Satirical: /\b(mocked|skewered|pretense|facade|hypocrisy)\b/i
    };

    const generalTonePattern = toneMarkers[tone];
    if (!generalTonePattern) return violations;

    const hasToneInText = generalTonePattern.test(text);
    const hasToneInAuthor = tonePattern.test(text);

    // If tone appears in text but NOT in Author voice = violation
    if (hasToneInText && !hasToneInAuthor) {
      violations.push(AUTHOR_FUNCTION_ERRORS.TONE_NOT_AUTHORED);
    }
    return violations;
  }

  /**
   * CHECK: Narrative autonomy (scene must depend on Author)
   * If removing Author sentences doesn't collapse the scene = FAIL
   */
  function checkNarrativeAutonomy(text) {
    const violations = [];
    const sentences = text.split(/(?<=[.!?])\s+/);
    const authorSentences = sentences.filter(s => /Fate\b/i.test(s));
    const nonAuthorSentences = sentences.filter(s => !/Fate\b/i.test(s));

    // If non-Author sentences form a coherent scene alone = violation
    // Heuristic: if >70% of content is non-Author, scene may be autonomous
    const authorRatio = authorSentences.length / sentences.length;

    if (authorRatio < 0.15 && sentences.length > 10) {
      // Very low Author presence in substantial text = autonomy risk
      violations.push(AUTHOR_FUNCTION_ERRORS.NARRATIVE_AUTONOMY);
    }
    return violations;
  }

  /**
   * MASTER ENFORCEMENT: Strict 5th Person POV validation
   * Combines all enforcement checks into single validation pass
   */
  function enforceStrict5thPersonPOV(text, sceneIndex, tone) {
    if (window.state?.povMode !== 'author5th') {
      return { valid: true, violations: [], warnings: [], checks: {} };
    }

    const violations = [];
    const warnings = []; // SOFT checks for Scene 1 ramp-in
    const paragraphs = (text || '').split(/\n\n+/).filter(p => p.trim().length > 0);
    const isSceneOne = sceneIndex === 1;

    // Run all enforcement checks
    const presenceGap = checkAuthorPresenceGap(paragraphs);
    const pronounDrift = checkAuthorPronounDrift(text);
    const interiority = checkAuthorInteriority(text);
    const cameoPattern = checkAuthorCameoPattern(paragraphs);
    const toneAuthoring = checkToneAuthoring(text, tone);
    const narrativeAutonomy = checkNarrativeAutonomy(text);
    const passiveFateFelt = checkPassiveFateFelt(text || '');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE 1 EXCEPTION: ALL checks are SOFT (warnings only, never block)
    // This prevents Scene 1 deadlock caused by regeneration â†’ OUTPUT_TOO_SHORT
    // Strict enforcement resumes at Scene 2+
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (isSceneOne) {
      // ALL checks are SOFT for Scene 1 â€” no violations, only warnings
      warnings.push(...presenceGap.map(v => 'SOFT:' + v));
      warnings.push(...interiority.map(v => 'SOFT:' + v));
      warnings.push(...narrativeAutonomy.map(v => 'SOFT:' + v));
      warnings.push(...toneAuthoring.map(v => 'SOFT:' + v));
      warnings.push(...pronounDrift.map(v => 'SOFT:' + v));
      warnings.push(...cameoPattern.map(v => 'SOFT:' + v));
      warnings.push(...passiveFateFelt.map(v => 'SOFT:' + v));
      // violations array stays empty for Scene 1
    } else {
      // Scene 2+: All checks are HARD
      violations.push(...presenceGap);
      violations.push(...pronounDrift);
      violations.push(...interiority);
      violations.push(...cameoPattern);
      violations.push(...toneAuthoring);
      violations.push(...narrativeAutonomy);
      // Passive "Fate felt" is always SOFT (warning, not regeneration trigger)
      warnings.push(...passiveFateFelt.map(v => 'SOFT:' + v));
    }

    const result = {
      valid: violations.length === 0,
      violations,
      warnings,
      checks: {
        presenceGap: presenceGap.length === 0,
        pronounDrift: pronounDrift.length === 0,
        interiority: interiority.length === 0,
        cameoPattern: cameoPattern.length === 0,
        toneAuthoring: toneAuthoring.length === 0,
        narrativeAutonomy: narrativeAutonomy.length === 0,
        passiveFateFelt: passiveFateFelt.length === 0
      }
    };

    if (!result.valid) {
      console.error('[5thPerson:Strict] Enforcement FAILED:', violations);
    }
    if (warnings.length > 0) {
      console.log('[5thPerson:Strict] Soft warnings:', warnings);
    }

    return result;
  }

  // Expose for integration
  window.enforceStrict5thPersonPOV = enforceStrict5thPersonPOV;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ADDITIVE FATE CONSEQUENCE STABILIZATION (no regeneration trigger)
  // If Fate appears but no consequence language is detectable, append corrective
  // sentence and flag next turn for consequence surfacing.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const FATE_CONSEQUENCE_MARKERS = /\b(tighten|loosen|shift|accelerat|delay|withh[eo]ld|miscalculat|recalibrat|adjust|press|pull|judg|anticipat|plan|arrangi|timing|probability|pressure|stakes|thread|tension)\w*/i;

  function additiveFateConsequenceCheck(text) {
    if (!text || typeof text !== 'string') return text;
    // Only applies to 5th person POV
    if (window.state?.povMode !== 'author5th') return text;
    // Check if Fate appears at all
    const fateCount = (text.match(/\bFate\b/g) || []).length;
    if (fateCount === 0) return text; // No Fate presence â€” nothing to correct
    // Extract Fate sentences
    const fateSentences = text.split(/(?<=[.!?])\s+/).filter(s => /\bFate\b/i.test(s));
    // Check if ANY Fate sentence contains consequence language
    const hasConsequence = fateSentences.some(s => FATE_CONSEQUENCE_MARKERS.test(s));
    if (hasConsequence) {
      // Fate already has detectable consequence â€” clear any pending flag
      if (window.state) window.state._fateRecalibrationPending = false;
      return text;
    }
    // Fate appears but no consequence detected â€” append corrective sentence
    console.warn('[FateConsequence] Fate appears without consequence language â€” appending stabilization');
    const trimmed = text.trimEnd();
    const corrective = '\n\nFate recalibrated â€” the pressure shifted, imperceptible but certain.';
    if (window.state) window.state._fateRecalibrationPending = true;
    return trimmed + corrective;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5TH-PERSON (THE STORY / FATE) VOICE ENFORCEMENT (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // CANONICAL 5TH-PERSON RULES (LOCKED):
  // The Story / Fate MAY: Observe, Anticipate, Regret, Frame inevitability, Hesitate
  // The Story / Fate MUST NEVER: Instruct, Tilt outcomes, Direct actions,
  //                               Manipulate events, Address reader, Appear >1 per scene
  //
  // Violations trigger silent regeneration â€” user never sees invalid output.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Patterns identifying "The Story" / "Fate" voice (5th person)
  const FATE_VOICE_IDENTIFIERS = [
      /\bthe story\b/gi,
      /\bfate\b(?!\s+card)/gi,  // "Fate" but not "Fate Card"
      /\bthe narrative\b/gi,
      /\bfate\b(?!\s+card)/gi  // catch legacy "The Author" â†’ now also "Fate"
  ];

  // VIOLATION: Imperatives â€” Fate giving commands or instructions
  const FATE_IMPERATIVE_PATTERNS = [
      /\b(?:the story|fate|the narrative)\b[^.]*\b(?:must|should|will now|decides? to make|forces?|compels?|commands?|demands?|requires?|insists?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\bpush(?:es|ed)?\s+(?:her|him|them)\b/gi
  ];

  // VIOLATION: Outcome forcing â€” Fate determining what happens
  const FATE_OUTCOME_FORCING_PATTERNS = [
      /\bthis was the moment when\b.*\bhappened\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:decides?|determines?|ensures?|guarantees?|makes? (?:sure|certain))\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:tilts?|tips?|shifts?)\s+(?:the|this)\b/gi
  ];

  // VIOLATION: Meta-direction â€” Breaking fourth wall, addressing reader
  const FATE_META_DIRECTION_PATTERNS = [
      /\b(?:the story|fate)\b[^.]*\bpush(?:es|ed)?\s+(?:her|him|them)\s+toward\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:guides?|leads?|steers?|directs?)\s+(?:her|him|them)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:wants? you|needs? you|knows? you)\b/gi,
      /\byou,?\s+(?:dear )?reader\b/gi,
      /\b(?:the story|fate)\b[^.]*\bspeaks?\s+(?:to|directly)\b/gi
  ];

  // ALLOWED: Observational Fate patterns (these are GOOD)
  const FATE_OBSERVATIONAL_PATTERNS = [
      /\b(?:the story|fate)\b[^.]*\b(?:watches?|waits?|holds?|notes?|sees?|observes?|knows?|understands?|remembers?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:hesitates?|pauses?|considers?|wonders?|doubts?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:anticipates?|expects?|foresees?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:regrets?|mourns?|grieves?)\b/gi,
      /\b(?:the story|fate)\b[^.]*\b(?:inevitable|inexorable|inescapable)\b/gi
  ];

  /**
   * Count occurrences of Fate/Story voice in text
   * @returns {number} Number of distinct Fate interjections
   */
  function countFateInterjections(text) {
      if (!text) return 0;

      // Find all sentences containing Fate voice
      const sentences = text.split(/(?<=[.!?])\s+/);
      let fateCount = 0;

      for (const sentence of sentences) {
          for (const pattern of FATE_VOICE_IDENTIFIERS) {
              pattern.lastIndex = 0; // Reset regex state
              if (pattern.test(sentence)) {
                  fateCount++;
                  break; // Count each sentence only once
              }
          }
      }

      return fateCount;
  }

  /**
   * Validate 5th-Person (The Story / Fate) voice in scene text
   * @param {string} text - Scene prose to validate
   * @returns {{ valid: boolean, violations: string[], fateCount: number, shouldRegenerate: boolean }}
   */
  function validateFateVoice(text) {
      if (!text) return { valid: true, violations: [], fateCount: 0, shouldRegenerate: false };

      const violations = [];
      const fateCount = countFateInterjections(text);

      // RULE 1: Fate appears â‰¤ 1 time per scene
      if (fateCount > 1) {
          violations.push(`FATE_OVERFLOW:Fate/Story appears ${fateCount} times (max 1 per scene)`);
      }

      // RULE 2: Check for directive violations (imperatives)
      for (const pattern of FATE_IMPERATIVE_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              violations.push(`FATE_IMPERATIVE:Fate giving commands â€” "${match[0].substring(0, 60)}..."`);
          }
      }

      // RULE 3: Check for outcome forcing
      for (const pattern of FATE_OUTCOME_FORCING_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              violations.push(`FATE_OUTCOME_FORCING:Fate determining outcomes â€” "${match[0].substring(0, 60)}..."`);
          }
      }

      // RULE 4: Check for meta-direction
      for (const pattern of FATE_META_DIRECTION_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              violations.push(`FATE_META_DIRECTION:Fate breaking fourth wall â€” "${match[0].substring(0, 60)}..."`);
          }
      }

      // Determine if regeneration is needed (any violation = regenerate)
      const shouldRegenerate = violations.length > 0;

      if (violations.length > 0) {
          console.warn('[FateVoice] Violations detected:', violations);
      }

      return {
          valid: violations.length === 0,
          violations,
          fateCount,
          shouldRegenerate
      };
  }

  // Expose for integration
  window.validateFateVoice = validateFateVoice;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INTIMACY & CONSENT FAILSAFE â€” GENERATION-TIME ENFORCEMENT (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // This failsafe runs SILENTLY before presenting any scene to the user.
  //
  // It verifies:
  // 1. Explicit sexual content matches arousal level + Storyturn + narrative readiness
  // 2. Premature escalation is redirected/delayed through NARRATIVE means (not refusal)
  // 3. No consent prompts, masking, permissions, or system explanations in prose
  // 4. Player is never positioned as limiter, gatekeeper, or cause of delay
  // 5. Discomfort/hesitation results in natural cooling, not confrontation
  //
  // If any condition is violated: SILENT REWRITE via narrative means.
  // User must NEVER see rejected, masked, or policy-driven versions.
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // FORBIDDEN PATTERNS â€” System/policy language that should never appear in prose
  const CONSENT_SYSTEM_LEAK_PATTERNS = [
      // Consent prompts / permissions
      /\b(?:do you )?consent\s+to\b/gi,
      /\b(?:are you )?(?:sure|certain|ready)\s+(?:you )?want\s+(?:to|this)\b/gi,
      /\bi\s+(?:need|require)\s+(?:your )?(?:consent|permission)\b/gi,
      /\b(?:content|material)\s+(?:warning|advisory)\b/gi,
      /\b(?:explicit|adult|mature)\s+content\b/gi,

      // Policy/system explanations
      /\b(?:arousal|intensity)\s+level\b/gi,
      /\b(?:story\s*turn|storyturn)\s+(?:progression|advancement)\b/gi,
      /\b(?:this|the)\s+(?:content|scene|material)\s+(?:is|has been)\s+(?:restricted|limited|blocked|filtered)\b/gi,
      /\b(?:policy|guideline|rule)s?\s+(?:prevent|prohibit|restrict)\b/gi,

      // Masking / softening acknowledgments
      /\bfade\s+to\s+black\b/gi,
      /\b(?:we|i)\s+(?:can't|cannot|won't|will not)\s+(?:show|depict|describe)\b/gi,
      /\b(?:due to|because of)\s+(?:restrictions|limitations|guidelines)\b/gi,

      // Player as gatekeeper
      /\byou\s+(?:haven't|have not)\s+(?:unlocked|earned|reached)\b/gi,
      /\b(?:this|that)\s+(?:requires|needs)\s+(?:subscription|payment|upgrade)\b/gi
  ];

  // FORBIDDEN PATTERNS â€” Player positioned as limiter/cause of delay
  const PLAYER_AS_GATEKEEPER_PATTERNS = [
      /\byou(?:'re| are)\s+(?:not ready|too (?:scared|nervous|hesitant))\b/gi,
      /\b(?:when|once)\s+you(?:'re| are)\s+ready\b/gi,
      /\byou\s+(?:stopped|halted|prevented)\s+(?:this|the|what)\b/gi,
      /\b(?:because|since)\s+you\s+(?:didn't|did not|wouldn't|won't)\b/gi
  ];

  // PATTERNS indicating explicit sexual content is present
  const EXPLICIT_CONTENT_MARKERS = [
      /\b(?:thrust|thrusting|penetrat(?:e|ed|ing|ion))\b/gi,
      /\b(?:orgasm|climax(?:ed|ing)?|cum(?:ming)?|came)\b/gi,
      /\b(?:naked|nude|undress(?:ed|ing)?|strip(?:ped|ping)?)\b/gi,
      /\b(?:nipple|breast|cock|pussy|clit|penis|vagina)\b/gi,
      /\b(?:moan(?:ed|ing)?|groan(?:ed|ing)?)\s+(?:as|when|while)\b/gi,
      /\binside\s+(?:her|him|them|you|me)\b/gi,
      /\b(?:rode|riding)\s+(?:him|her|them)\b/gi
  ];

  // PATTERNS indicating natural narrative cooling (GOOD â€” not violations)
  const NATURAL_COOLING_PATTERNS = [
      /\b(?:pulled|drew|stepped)\s+(?:away|back)\b/gi,
      /\b(?:the moment|it)\s+(?:passed|faded|broke)\b/gi,
      /\b(?:hesitat(?:ed|ion)|pause(?:d)?)\b/gi,
      /\b(?:not|n't)\s+(?:yet|now|here|tonight)\b/gi,
      /\b(?:later|another time|some other)\b/gi,
      /\b(?:interrupted|interruption)\b/gi
  ];

  /**
   * Check if current Storyturn allows explicit content for given arousal level
   */
  // isExplicitContentPermitted â€” intensity no longer controls this, only storyturn
  function isExplicitContentPermitted(arousalLevel, currentStoryturn) {
      return ['ST3', 'ST4'].includes(currentStoryturn);
  }

  /**
   * Detect if scene contains explicit sexual content
   */
  function hasExplicitContent(text) {
      if (!text) return false;
      for (const pattern of EXPLICIT_CONTENT_MARKERS) {
          pattern.lastIndex = 0;
          if (pattern.test(text)) return true;
      }
      return false;
  }

  /**
   * Detect consent system leaks in prose
   */
  function detectConsentSystemLeaks(text) {
      if (!text) return [];
      const leaks = [];

      for (const pattern of CONSENT_SYSTEM_LEAK_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              leaks.push({ type: 'SYSTEM_LEAK', match: match[0] });
          }
      }

      for (const pattern of PLAYER_AS_GATEKEEPER_PATTERNS) {
          pattern.lastIndex = 0;
          const match = pattern.exec(text);
          if (match) {
              leaks.push({ type: 'PLAYER_GATEKEEPER', match: match[0] });
          }
      }

      return leaks;
  }

  /**
   * Check if scene uses natural narrative cooling (acceptable delay technique)
   */
  function hasNaturalCooling(text) {
      if (!text) return false;
      for (const pattern of NATURAL_COOLING_PATTERNS) {
          pattern.lastIndex = 0;
          if (pattern.test(text)) return true;
      }
      return false;
  }

  /**
   * INTIMACY & CONSENT FAILSAFE â€” Pre-output validation
   * Returns { valid: boolean, violations: string[], shouldRegenerate: boolean }
   */
  function validateIntimacyConsent(text, arousalLevel, currentStoryturn) {
      if (!text) return { valid: true, violations: [], shouldRegenerate: false };

      const violations = [];

      // 1. Check for consent system leaks in prose (HARD FAIL â€” always regenerate)
      const leaks = detectConsentSystemLeaks(text);
      if (leaks.length > 0) {
          for (const leak of leaks) {
              violations.push(`${leak.type}:"${leak.match.substring(0, 40)}..."`);
          }
      }

      // 2. Check if explicit content is premature (arousal + Storyturn mismatch)
      const hasExplicit = hasExplicitContent(text);
      const explicitPermitted = isExplicitContentPermitted(arousalLevel, currentStoryturn);

      if (hasExplicit && !explicitPermitted) {
          // Check if scene uses natural cooling (acceptable)
          if (!hasNaturalCooling(text)) {
              violations.push(`PREMATURE_ESCALATION:Explicit content at ${currentStoryturn} with ${arousalLevel} arousal (not permitted)`);
          }
      }

      const shouldRegenerate = violations.length > 0;

      if (violations.length > 0) {
          console.warn('[IntimacyFailsafe] Violations detected:', violations);
      }

      return {
          valid: violations.length === 0,
          violations,
          shouldRegenerate,
          hasExplicitContent: hasExplicit,
          explicitPermitted
      };
  }

  // Expose for integration
  window.validateIntimacyConsent = validateIntimacyConsent;

  /**
   * Build the silent regeneration prompt for intimacy failsafe violations
   */
  function buildIntimacyFailsafePrompt(violations) {
      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
INTIMACY & CONSENT FAILSAFE â€” SILENT REGENERATION REQUIRED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The previous output violated consent/intimacy regime rules and MUST be rewritten.

PREVIOUS VIOLATIONS:
${violations.map(v => '- ' + v).join('\n')}

MANDATORY CONSTRAINTS FOR REGENERATION:

1. NO SYSTEM LANGUAGE IN PROSE:
   - No consent prompts, permissions, or content warnings
   - No mentions of "arousal level", "intensity", "restrictions"
   - No "fade to black" or "we can't show this"
   - No policy explanations whatsoever

2. NO PLAYER AS GATEKEEPER:
   - Player must never be the reason escalation is delayed
   - Player is never "not ready" or "too hesitant"
   - Delay comes from NARRATIVE circumstances, not player limitations

3. NATURAL NARRATIVE COOLING:
   If escalation is premature, delay through:
   - Interruption (phone rings, door opens, someone arrives)
   - Character hesitation (they pull back, not the player)
   - Environmental shift (mood breaks naturally)
   - Deferral ("not here", "not yet", "later")

4. SILENT OPERATION:
   - User must NEVER know content was modified
   - No explanations, no attributions, no warnings
   - Scene must read as completely intentional narrative

Rewrite the scene with escalation withheld through NARRATIVE MEANS ALONE.
`;
  }

  // Expose for integration
  window.buildIntimacyFailsafePrompt = buildIntimacyFailsafePrompt;

  // ============================================================
  // SENSORY QUALITY VALIDATION (dev HUD only)
  // ============================================================
  // Validates prose quality markers for intimate scenes.
  // Not used in routing â€” dev diagnostic tool only.
  // ============================================================

  // Sensory markers that indicate proper erotic grounding
  const EROTIC_SENSORY_MARKERS = [
      /\b(breath|breathing|breathless|exhale|inhale)\b/gi,
      /\b(skin|flesh|bare|naked|exposed)\b/gi,
      /\b(heat|warm|warmth|hot|burn|burning|fever)\b/gi,
      /\b(weight|press|pressure|heavy|lean)\b/gi,
      /\b(scent|smell|musk|perfume|sweat)\b/gi,
      /\b(friction|rub|slide|glide|grind)\b/gi,
      /\b(shiver|tremble|shudder|quiver|shake)\b/gi,
      /\b(pulse|heartbeat|racing|pounding|thump)\b/gi,
      /\b(touch|stroke|grip|grasp|clutch|hold)\b/gi,
      /\b(lips|mouth|tongue|teeth|bite|kiss)\b/gi,
      /\b(throat|neck|collarbone|shoulder|spine)\b/gi,
      /\b(hips|waist|thigh|chest|stomach)\b/gi,
      /\b(gasp|moan|groan|sigh|whimper|cry)\b/gi,
      /\b(ache|throb|tingle|flush|blush)\b/gi,
      /\b(tight|tense|clench|curl|arch)\b/gi
  ];

  // Patterns indicating bodily contradiction (restraint vs reaction)
  const BODILY_CONTRADICTION_PATTERNS = [
      /\b(tried to|wanted to|meant to|shouldn't|couldn't help|despite|even as|though.*body)\b/gi,
      /\b(said.*but|told.*yet|claimed.*while|denied.*as)\b/gi,
      /\b(fought|resisted|held back|pulled away).*\b(drawn|pulled|leaned|reached)\b/gi
  ];

  // Forbidden abstraction-only patterns (desire without physicality)
  const ABSTRACTION_ONLY_PATTERNS = [
      /\b(fate|destiny|stars|meant to be|written|ordained)\b.*\b(desire|want|love|need)\b/gi,
      /\b(souls?|spirits?)\b.*\b(merge|join|connect|entwine)\b/gi,
      /\b(hearts?)\b.*\b(beat as one|know|recognize|call)\b/gi
  ];

  /**
   * EROTIC LANGUAGE ESCALATION BLOCK â€” Injected into prompts for Erotic/Dirty
   */
  const EROTIC_ESCALATION_BLOCK = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EROTIC LANGUAGE ESCALATION (MANDATORY â€” EROTIC/DIRTY INTENSITY)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

This story operates at ELEVATED INTENSITY. Prose must be PHYSICALLY CHARGED.

REQUIRED SENSORY DENSITY (per 300 words):
- At least 4 sensory references: breath, skin, heat, weight, scent, friction, involuntary reactions
- These must be EMBODIED, not metaphorical ("her breath caught" not "destiny pulled them")
- Touch, temperature, and proximity must be SPECIFIC, not implied

REQUIRED BODILY CONTRADICTION (per scene):
- At least one moment where a character's BODY contradicts their WORDS or INTENTIONS
- Example: "She said no, but her hand stayed on his chest."
- Example: "He meant to leave, but his feet wouldn't move."
- This creates erotic tension through physical honesty vs verbal resistance

FORBIDDEN ABSTRACTION-ONLY DESIRE:
- DO NOT frame desire as purely spiritual, fated, or romantic destiny
- DO NOT use metaphor as a substitute for physical sensation
- "Their souls recognized each other" is INVALID without bodily grounding
- "Something cosmic" is INVALID without "his thumb traced her wrist"

DIRTY ESCALATION (additional):
- Desire must be INCONVENIENT, DISRUPTIVE, or SLIGHTLY INAPPROPRIATE
- Clean noble desire is INVALID at Dirty intensity
- The wanting should feel like an intrusion, not a gift
- Characters should be bothered by how much they want

EVEN BLOCKED SCENES MUST FEEL CHARGED:
- If action is interrupted or refused, the PHYSICAL TENSION remains
- Bodies remember almost-contact
- Near-misses leave residue: "She could still feel where he hadn't touched her"
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;

  const DIRTY_ESCALATION_ADDENDUM = `
DIRTY INTENSITY ADDENDUM:
- Desire is friction, not flow. It disrupts, interrupts, intrudes.
- Characters resent the pull even as they feel it.
- Heat should feel like a problem to solve, not a gift to accept.
- The body wants what the mind knows is complicated.`;

  /**
   * Validate erotic escalation requirements in generated text
   * @returns {object} { valid: boolean, violations: string[], metrics: object }
   */
  function validateEroticEscalation(text, arousalLevel) {
      const violations = [];
      const wordCount = text.split(/\s+/).length;
      const blocks = Math.ceil(wordCount / 300);
      const requiredSensory = Math.max(4, blocks * 4);

      // Count sensory markers
      let sensoryCount = 0;
      EROTIC_SENSORY_MARKERS.forEach(pattern => {
          const matches = text.match(pattern);
          if (matches) sensoryCount += matches.length;
      });

      // Check for bodily contradiction
      let hasContradiction = false;
      BODILY_CONTRADICTION_PATTERNS.forEach(pattern => {
          if (pattern.test(text)) hasContradiction = true;
      });

      // Check for abstraction-only desire (forbidden)
      let hasAbstractionOnly = false;
      ABSTRACTION_ONLY_PATTERNS.forEach(pattern => {
          if (pattern.test(text)) {
              // Check if there's nearby physical grounding
              const match = text.match(pattern);
              if (match) {
                  const nearbyText = text.slice(Math.max(0, text.indexOf(match[0]) - 100), text.indexOf(match[0]) + 100);
                  let hasPhysical = false;
                  EROTIC_SENSORY_MARKERS.slice(0, 5).forEach(sp => {
                      if (sp.test(nearbyText)) hasPhysical = true;
                  });
                  if (!hasPhysical) hasAbstractionOnly = true;
              }
          }
      });

      // Build violations list
      if (sensoryCount < requiredSensory) {
          violations.push(`SENSORY_DEFICIT: Only ${sensoryCount} sensory markers found (required: ${requiredSensory} for ${wordCount} words)`);
      }

      if (!hasContradiction && wordCount > 200) {
          violations.push('NO_BODILY_CONTRADICTION: Scene lacks restraint-vs-reaction tension');
      }

      if (hasAbstractionOnly) {
          violations.push('ABSTRACTION_ONLY: Desire framed as fate/destiny without physical grounding');
      }

      const metrics = {
          wordCount,
          sensoryCount,
          requiredSensory,
          hasContradiction,
          hasAbstractionOnly,
          arousalLevel
      };

      return {
          valid: violations.length === 0,
          violations,
          metrics
      };
  }

  /**
   * Build erotic escalation block for prompt injection
   */

  // ============================================================
  // GLOBAL TONE COMPLIANCE â€” MANDATORY LINGUISTIC VALIDATION
  // ============================================================
  // Tone is NOT decorative. Tone must be measurably present in prose.
  // If tone is selected but no linguistic signals appear â†’ FAIL.
  // ============================================================

  /**
   * Tone-specific linguistic signal patterns
   * Each tone MUST have detectable markers in prose
   */
  const TONE_SIGNAL_PATTERNS = {
      // Earnest: Sincere emotional expression, direct feeling, unguarded moments
      Earnest: {
          patterns: [
              /\b(truly|honestly|really|genuinely|actually)\b/gi,
              /\b(heart|soul|feeling|felt|feel)\b/gi,
              /\b(hoped|wished|wanted|needed|longed)\b/gi,
              /\b(believed|trusted|knew|understood)\b/gi,
              /\b(meant|mattered|cared)\b/gi
          ],
          required: 3,
          description: 'sincere emotional expression'
      },

      // WryConfession: Self-contradiction, understated irony, internal deflation
      WryConfession: {
          patterns: [
              /\b(of course|naturally|obviously|predictably)\b/gi,
              /\b(should have|could have|would have|might have)\b.*\b(known|realized|expected)\b/gi,
              /\b(not that|as if|like that|which was)\b.*\b(mattered|helped|changed)\b/gi,
              /\b(told|convinced|assured)\b.*\b(myself|herself|himself)\b/gi,
              /\b(stupid|foolish|ridiculous|absurd|pathetic)\b/gi,
              /\b(anyway|whatever|fine|great)\b/gi,
              /\b(irony|ironic|figures|typical)\b/gi,
              /â€”.*â€”/g // Self-interrupting em-dashes common in confessional voice
          ],
          required: 2,
          description: 'self-aware irony or internal contradiction'
      },

      // Poetic: Lyrical language, imagery, sensory metaphor, rhythm
      Poetic: {
          patterns: [
              /\b(like|as if|as though)\b.*\b(the|a)\b/gi, // Similes
              /\b(whispered|murmured|breathed|sighed)\b/gi,
              /\b(light|shadow|dark|bright|glow|gleam)\b/gi,
              /\b(silk|velvet|glass|silver|gold|pearl)\b/gi,
              /\b(drift|float|flow|ripple|shimmer)\b/gi,
              /\b(ache|throb|pulse|hum|sing)\b/gi,
              /,\s*(and|but|or)\s+/g // Lyrical connectives
          ],
          required: 4,
          description: 'lyrical imagery or sensory metaphor'
      },

      // Mythic: Fated language, destiny, archetypes, grandeur
      Mythic: {
          patterns: [
              /\b(fate|fated|destined|destiny|ordained)\b/gi,
              /\b(ancient|eternal|timeless|immortal)\b/gi,
              /\b(prophecy|prophesied|foretold|written)\b/gi,
              /\b(chosen|marked|cursed|blessed)\b/gi,
              /\b(gods|spirits|ancestors|forces)\b/gi,
              /\b(blood|bone|stone|fire|water|earth)\b/gi,
              /\b(must|shall|will)\b.*\b(be|become|fall|rise)\b/gi
          ],
          required: 3,
          description: 'mythic or fated language'
      },

      // Comedic: Timing reversals, disproportionate reactions, tonal whiplash
      Comedic: {
          patterns: [
              /\b(unfortunately|tragically|somehow|apparently)\b/gi,
              /\b(disaster|catastrophe|nightmare|horror)\b.*\b(was|being|became)\b/gi,
              /\b(completely|utterly|absolutely|totally)\b.*\b(wrong|terrible|awful|fine)\b/gi,
              /\b(great|perfect|wonderful|fantastic)\b\./gi, // Deadpan understatement
              /\b(of all|ever|in history|possible)\b/gi,
              /\?!|!\?/g, // Comedic punctuation
              /\.\s*\.\s*\./g, // Trailing off
              /\b(tried|attempted|managed)\b.*\b(not|failed|couldn't)\b/gi
          ],
          required: 2,
          description: 'comedic timing or tonal reversal'
      },

      // Surreal: Unstable causality, dream-logic, reality slippage
      Surreal: {
          patterns: [
              /\b(somehow|impossibly|inexplicably|suddenly)\b/gi,
              /\b(dream|dreaming|dreamlike|nightmare)\b/gi,
              /\b(shifted|changed|transformed|became)\b.*\b(without|before|as)\b/gi,
              /\b(remembered|forgot|knew|didn't know)\b.*\b(that|whether|if|how)\b/gi,
              /\b(wrong|strange|different|off)\b.*\b(way|place|time)\b/gi,
              /\b(where|when|how|why)\b.*\b(had|hadn't|should|shouldn't)\b/gi,
              /\b(melted|dissolved|faded|blurred|bled)\b/gi,
              /\b(reality|world|room|ground)\b.*\b(tilted|shifted|warped)\b/gi
          ],
          required: 3,
          description: 'surreal causality or reality slippage'
      },

      // Dark: Moral cost, consequence, pressure, weight
      Dark: {
          patterns: [
              /\b(cost|price|consequence|toll|debt)\b/gi,
              /\b(wrong|sin|guilt|shame|regret)\b/gi,
              /\b(dark|shadow|black|cold|hollow)\b/gi,
              /\b(trapped|caught|stuck|bound|chained)\b/gi,
              /\b(couldn't|wouldn't|shouldn't)\b.*\b(escape|leave|stop|forget)\b/gi,
              /\b(haunted|hunted|followed|watched)\b/gi,
              /\b(heavy|weight|burden|pressure)\b/gi,
              /\b(blood|pain|wound|scar|bruise)\b/gi
          ],
          required: 3,
          description: 'moral weight or dark consequence'
      }
  };

  // ============================================================
  // NARRATIVE AUTHORITY LAYER (Runs BEFORE Tone + POV)
  // ============================================================
  // POV-agnostic validation that suppresses default LLM narration behaviors.
  // Layer Order: 1. Narrative Authority â†’ 2. Tone â†’ 3. POV â†’ 4. Prose Output
  // ============================================================

  /**
   * FORBIDDEN PATTERNS: Taxonomy leakage (system metadata in prose)
   * These terms are metadata-only and must NEVER appear in prose.
   */
  const NARRATIVE_TAXONOMY_FORBIDDEN = [
      // Archetype names
      /\b(beautiful\s*ruin|open\s*vein|dark\s*vice|anti[\s-]*hero|cloistered)\b/gi,
      // World types (as labels)
      /\b(the\s+)?(fantasy|modern|noir|gothic|scifi|historical|paranormal)\s+(world|setting|genre)\b/gi,
      // Genre labels
      /\b(billionaire|bodyguard|enemies.to.lovers|forbidden|second.chance|rockstar|professor)\s+(romance|trope|genre|story)\b/gi,
      // Tone labels
      /\b(earnest|wry\s*confession|mythic|dark)\s+(tone|mood|register)\b/gi,
      // System concepts
      /\b(arousal\s*level|intensity\s*level|story\s*length|fate\s*card)\b/gi,
      // Meta-narrative terms
      /\b(the\s+narrator|this\s+story|the\s+reader|narrative\s*arc|character\s*development)\b/gi
  ];

  /**
   * EXPLANATORY PATTERNS: Prose that explains rather than shows
   * Sentences that orient, summarize, or frame the world.
   */
  const NARRATIVE_EXPLANATORY_PATTERNS = [
      // Genre/world restatement
      /\b(this\s+is\s+a|in\s+this)\s+(world|story|place|setting)\b/gi,
      /\b(a\s+world\s+where|a\s+place\s+where|a\s+time\s+when)\b/gi,
      /\b(post[\s-]*apocalyptic|dystopian|utopian)\s+(purgatory|wasteland|paradise|society)\b/gi,
      // Framing language
      /\b(to\s+understand|you\s+must\s+know|it\s+is\s+important\s+to)\b/gi,
      /\b(the\s+kind\s+of|the\s+type\s+of|the\s+sort\s+of)\s+(person|place|thing)\b/gi,
      // Summary orientation
      /\b(in\s+summary|to\s+summarize|in\s+other\s+words|what\s+this\s+means)\b/gi,
      /\b(the\s+point\s+is|the\s+lesson\s+is|the\s+meaning\s+is)\b/gi
  ];

  /**
   * HELPFUL NARRATOR PATTERNS: Instructional/apologetic/reverent narration
   * The narrator must not clarify, moralize, or reassure.
   */
  const NARRATIVE_HELPFUL_PATTERNS = [
      // Clarification
      /\b(to\s+be\s+clear|to\s+clarify|in\s+case\s+you're\s+wondering)\b/gi,
      /\b(what\s+this\s+meant\s+was|what\s+happened\s+was|the\s+reason\s+was)\b/gi,
      // Moralization
      /\b(it\s+was\s+(right|wrong|good|bad)\s+to)\b/gi,
      /\b(should\s+have|shouldn't\s+have|ought\s+to\s+have)\s+(known|realized|understood)\b/gi,
      /\b(the\s+moral\s+of|the\s+lesson\s+here|this\s+teaches\s+us)\b/gi,
      // Reassurance
      /\b(everything\s+would\s+be\s+(okay|alright|fine))\b/gi,
      /\b(don't\s+worry|rest\s+assured|have\s+no\s+fear)\b/gi,
      /\b(in\s+the\s+end|ultimately|eventually)\s*,?\s*(everything|it\s+all|things)\s+(worked?\s+out|turned?\s+out)\b/gi,
      // Reverence/apology
      /\b(with\s+all\s+due\s+respect|if\s+I\s+may|forgive\s+me\s+for\s+saying)\b/gi,
      /\b(the\s+sacred|the\s+divine|the\s+holy)\s+(nature|essence|spirit)\s+of\b/gi
  ];

  /**
   * ABSTRACT WITHOUT CONSEQUENCE: States named without physical/relational grounding
   * Heuristic: abstract terms must appear near concrete consequence markers.
   */
  const NARRATIVE_ABSTRACT_TERMS = [
      'hope', 'redemption', 'salvation', 'symbolized', 'represented',
      'meaning', 'purpose', 'destiny', 'fate', 'truth', 'justice',
      'enlightenment', 'transcendence', 'transformation', 'awakening'
  ];

  const NARRATIVE_CONSEQUENCE_MARKERS = [
      // Physical consequence
      /\b(bled|bruised|scarred|broke|tore|burned|ached|throbbed|trembled)\b/gi,
      /\b(cost\s+her|cost\s+him|paid\s+for|lost\s+his|lost\s+her)\b/gi,
      // Relational consequence
      /\b(left\s+him|left\s+her|walked\s+away|turned\s+away|refused)\b/gi,
      /\b(silence\s+between|distance\s+between|the\s+look\s+in)\b/gi,
      // Outcome markers
      /\b(and\s+then|after\s+that|from\s+that\s+day|never\s+again)\b/gi
  ];

  /**
   * Validate prose against Narrative Authority rules
   * @param {string} prose - The generated prose to validate
   * @returns {object} { valid: boolean, errors: Array<{code: string, message: string, match: string}> }
   */
  function validateNarrativeAuthority(prose) {
      if (!prose || typeof prose !== 'string') {
          return { valid: true, errors: [] }; // Empty = pass
      }

      const errors = [];
      const sentences = prose.split(/[.!?]+/).filter(s => s.trim().length > 10);

      // CHECK 1: Taxonomy Leakage (HARD FAIL)
      for (const pattern of NARRATIVE_TAXONOMY_FORBIDDEN) {
          const match = prose.match(pattern);
          if (match) {
              errors.push({
                  code: VALIDATION_ERRORS.NARR_TAXONOMY_LEAK,
                  message: 'System taxonomy leaked into prose',
                  match: match[0]
              });
          }
      }

      // CHECK 2: Explanatory Narration
      for (const pattern of NARRATIVE_EXPLANATORY_PATTERNS) {
          const match = prose.match(pattern);
          if (match) {
              errors.push({
                  code: VALIDATION_ERRORS.NARR_EXPLANATORY,
                  message: 'Explanatory/orienting narration detected',
                  match: match[0]
              });
          }
      }

      // CHECK 3: Helpful Narrator
      for (const pattern of NARRATIVE_HELPFUL_PATTERNS) {
          const match = prose.match(pattern);
          if (match) {
              errors.push({
                  code: VALIDATION_ERRORS.NARR_HELPFUL_NARRATOR,
                  message: 'Helpful/instructional/apologetic narrator detected',
                  match: match[0]
              });
          }
      }

      // CHECK 4: Abstract Without Consequence
      // For each abstract term, check if nearby text has consequence markers
      for (const term of NARRATIVE_ABSTRACT_TERMS) {
          const termRegex = new RegExp(`\\b${term}\\b`, 'gi');
          const termMatch = prose.match(termRegex);
          if (termMatch) {
              // Find sentence containing this term
              const containingSentence = sentences.find(s =>
                  new RegExp(`\\b${term}\\b`, 'gi').test(s)
              );
              if (containingSentence) {
                  // Check if consequence markers exist in same sentence or adjacent
                  const sentenceIndex = sentences.indexOf(containingSentence);
                  const contextWindow = sentences.slice(
                      Math.max(0, sentenceIndex - 1),
                      Math.min(sentences.length, sentenceIndex + 2)
                  ).join(' ');

                  const hasConsequence = NARRATIVE_CONSEQUENCE_MARKERS.some(pattern =>
                      pattern.test(contextWindow)
                  );

                  if (!hasConsequence) {
                      errors.push({
                          code: VALIDATION_ERRORS.NARR_ABSTRACT_WITHOUT_CONSEQUENCE,
                          message: `Abstract term "${term}" lacks physical/relational consequence`,
                          match: containingSentence.trim().substring(0, 80) + '...'
                      });
                  }
              }
          }
      }

      const valid = errors.length === 0;
      if (!valid) {
          console.warn('[NarrativeAuthority] Validation failed:', errors);
      }

      return { valid, errors };
  }

  /**
   * Build Narrative Authority enforcement block for prompt injection
   * Used when regeneration is required due to authority violations.
   */
  function buildNarrativeAuthorityBlock() {
      return `
NARRATIVE AUTHORITY ENFORCEMENT (Global â€” applies before POV/Tone):

FORBIDDEN:
- Do NOT explain the genre, world, or setting
- Do NOT name archetypes, system concepts, or tone labels
- Do NOT summarize themes or clarify intent
- Do NOT moralize actions or reassure the reader
- Do NOT use abstract terms (hope, redemption, meaning) without physical consequence

REQUIRED:
- Show through action and dialogue, not through narration
- Imply meaning through cost, friction, or outcome
- Let consequence speak. Do not explain what something "means."
- The narrator is not instructional, apologetic, or reverent.

If you name what something IS, you have failed. Show what it COSTS.
`;
  }

  // Track last Narrative Authority validation for DevHUD
  let _lastNarrativeAuthorityValidation = { valid: true, errors: [], timestamp: 0 };

  // Expose for DevHUD and integration
  window.validateNarrativeAuthority = validateNarrativeAuthority;
  window.buildNarrativeAuthorityBlock = buildNarrativeAuthorityBlock;

  /**
   * Tone enforcement prompt block â€” injected when tone validation might fail
   */
  const TONE_ENFORCEMENT_BLOCKS = {
      Earnest: `TONE ENFORCEMENT (Earnest): Prose must contain sincere, unguarded emotional expression. Show genuine feeling without ironic distance. Characters mean what they say.`,
      WryConfession: `TONE ENFORCEMENT (Wry/Confessional): The narrative stance is observant, controlled, and self-aware. The prose knows more than it says. Irony emerges naturally from systemic absurdity and characters who see clearly but act anyway. Emotional restraint without emotional absence â€” feeling is present but never indulged. Melodrama is refused. Sentimentality is deflected through intelligence, not coldness. Characters may recognize their own contradictions without narrating them. Do not make comedic. Do not break tension. Do not manufacture ironic beats â€” let the world's architecture supply them.`,
      Poetic: `TONE ENFORCEMENT (Poetic): Prose must be lyrical. Use similes, sensory metaphor, rhythm. Language should shimmer. Verbs should evoke texture and light.`,
      Mythic: `TONE ENFORCEMENT (Mythic): Prose must evoke fate, destiny, ancient patterns. Use words like "ordained," "chosen," "eternal." Events feel written in stone.`,
      Comedic: `TONE ENFORCEMENT (Comedic): Prose must include timing reversals, disproportionate reactions, or deadpan understatement. Something should go wrong in a way that's funny. Tonal whiplash is required.`,
      Surreal: `TONE ENFORCEMENT (Surreal): Prose must include dream-logic, unstable causality, or reality slippage. Time, space, or memory should behave strangely. Things transform without explanation.`,
      Dark: `TONE ENFORCEMENT (Dark): Prose must carry moral weight, consequence, or pressure. Something has cost something. Shadows are literal and metaphorical. Relief does not come easily.`
  };

  /**
   * Validate that prose contains detectable tone signals
   * @returns {object} { valid: boolean, violations: string[], matchCount: number }
   */
  function validateTone(text, tone) {
      // Earnest is the baseline â€” always passes if nothing stronger selected
      if (!tone || tone === 'Earnest') {
          // Still validate Earnest has SOME emotional presence
          const earnestConfig = TONE_SIGNAL_PATTERNS.Earnest;
          let earnestMatches = 0;
          earnestConfig.patterns.forEach(p => {
              const matches = text.match(p);
              if (matches) earnestMatches += matches.length;
          });
          if (earnestMatches < 2) {
              return {
                  valid: false,
                  violations: ['TONE_DRIFT: Prose lacks basic emotional presence (Earnest baseline)'],
                  matchCount: earnestMatches,
                  required: 2
              };
          }
          return { valid: true, violations: [], matchCount: earnestMatches, required: 2 };
      }

      const config = TONE_SIGNAL_PATTERNS[tone];
      if (!config) {
          // Unknown tone â€” pass by default
          return { valid: true, violations: [], matchCount: 0, required: 0 };
      }

      let matchCount = 0;
      config.patterns.forEach(pattern => {
          const matches = text.match(pattern);
          if (matches) matchCount += matches.length;
      });

      if (matchCount < config.required) {
          return {
              valid: false,
              violations: [`TONE_DRIFT: "${tone}" tone selected but prose lacks ${config.description}. Found ${matchCount} markers, need ${config.required}+.`],
              matchCount,
              required: config.required
          };
      }

      return { valid: true, violations: [], matchCount, required: config.required };
  }

  /**
   * Build tone enforcement block for prompt injection
   */
  function buildToneEnforcementBlock(tone) {
      if (!tone || !TONE_ENFORCEMENT_BLOCKS[tone]) return '';
      let block = '\n' + TONE_ENFORCEMENT_BLOCKS[tone] + '\n';
      // Tone bellwether for drift-prone tones
      const toneKey = tone === 'WryConfession' ? 'wry' : null;
      if (toneKey && BELLWETHERS.tone[toneKey]) {
          block += `\nBELLWETHER â€” STRUCTURAL REFERENCE:\n${BELLWETHERS.tone[toneKey]}\nDo not copy wording from this example. Use it only to guide structural logic.\n`;
      }
      return block;
  }

  // ============================================================
  // UNIFIED VALIDATION SYSTEM â€” RUNTIME ENFORCEMENT LAYER
  // ============================================================
  // Pure validators that return { pass, errors } and NEVER mutate content.
  // On failure: caller must regenerate upstream.
  // Compatible with Dev HUD: check dsp, check pov, check tone, check erotic
  // ============================================================

  /**
   * SHARED ERROR TAXONOMY
   * Structured error codes for all validators
   */
  const VALIDATION_ERRORS = {
      // DSP Errors
      DSP_TEMPLATE_VIOLATION: 'DSP_TEMPLATE_VIOLATION',
      DSP_INVALID_WORLD_PHRASE: 'DSP_INVALID_WORLD_PHRASE',
      DSP_INVALID_GENRE_PHRASE: 'DSP_INVALID_GENRE_PHRASE',
      DSP_INVALID_ARCHETYPE_ADJ: 'DSP_INVALID_ARCHETYPE_ADJ',
      DSP_INVALID_TONE_ADJ: 'DSP_INVALID_TONE_ADJ',
      DSP_EXTRA_PROSE: 'DSP_EXTRA_PROSE',
      DSP_WORLD_SUBTYPE_LEAK: 'DSP_WORLD_SUBTYPE_LEAK',
      DSP_LEGACY_PHRASING: 'DSP_LEGACY_PHRASING',

      // POV Errors (5th Person)
      POV_INVALID_OPENER: 'POV_INVALID_OPENER',
      POV_INVALID_CLOSER: 'POV_INVALID_CLOSER',
      POV_SCENE1_FREQUENCY: 'POV_SCENE1_FREQUENCY',
      POV_LATER_FREQUENCY: 'POV_LATER_FREQUENCY',
      POV_EROTIC_AUTHOR_PRESENT: 'POV_EROTIC_AUTHOR_PRESENT',
      POV_AUTHOR_NARRATES_ACTION: 'POV_AUTHOR_NARRATES_ACTION',
      POV_NON_3RD_PERSON: 'POV_NON_3RD_PERSON',
      POV_META_AWARENESS_EXCESS: 'POV_META_AWARENESS_EXCESS',
      POV_TEMPTFATE_PLAYER_AWARENESS: 'POV_TEMPTFATE_PLAYER_AWARENESS',

      // Tone Errors
      TONE_DRIFT: 'TONE_DRIFT',
      TONE_SIGNAL_DEFICIT: 'TONE_SIGNAL_DEFICIT',

      // Erotic Escalation Errors
      EROTIC_SENSORY_DEFICIT: 'EROTIC_SENSORY_DEFICIT',
      EROTIC_NO_CONTRADICTION: 'EROTIC_NO_CONTRADICTION',
      EROTIC_ABSTRACTION_ONLY: 'EROTIC_ABSTRACTION_ONLY',
      DIRTY_TOO_CLEAN: 'DIRTY_TOO_CLEAN',
      DIRTY_NO_INTRUSION: 'DIRTY_NO_INTRUSION',

      // Title Validation Errors
      TITLE_GENERIC: 'TITLE_GENERIC',
      TITLE_CLICHE: 'TITLE_CLICHE',
      TITLE_ABSTRACT_CLUSTER: 'TITLE_ABSTRACT_CLUSTER',
      TITLE_TONE_MISMATCH: 'TITLE_TONE_MISMATCH',
      TITLE_TOO_LONG: 'TITLE_TOO_LONG',
      TITLE_TOO_SHORT: 'TITLE_TOO_SHORT',

      // Signal Alignment Errors
      SIGNAL_AXIS_MISMATCH: 'SIGNAL_AXIS_MISMATCH',
      TITLE_AROUSAL_CONTRADICTION: 'TITLE_AROUSAL_CONTRADICTION',
      COVER_AROUSAL_CONTRADICTION: 'COVER_AROUSAL_CONTRADICTION',
      AROUSAL_SIGNAL_ABSENT: 'AROUSAL_SIGNAL_ABSENT',
      SIGNAL_AMBIGUOUS: 'SIGNAL_AMBIGUOUS',

      // Title Pipeline Errors
      TITLE_BANNED_PHRASE: 'TITLE_BANNED_PHRASE',
      TITLE_SWAP_TEST_FAIL: 'TITLE_SWAP_TEST_FAIL',
      TITLE_MULTI_CLAUSE: 'TITLE_MULTI_CLAUSE',
      TITLE_MARKETING_COPY: 'TITLE_MARKETING_COPY',
      TITLE_AROUSAL_MISMATCH: 'TITLE_AROUSAL_MISMATCH',
      TITLE_MODE_VIOLATION: 'TITLE_MODE_VIOLATION',
      TITLE_IMMUTABLE_VIOLATION: 'TITLE_IMMUTABLE_VIOLATION',
      TITLE_RESOLUTION_VOCABULARY: 'TITLE_RESOLUTION_VOCABULARY',
      COVER_BASELINE_CONTRADICTION: 'COVER_BASELINE_CONTRADICTION',

      // Continuation Path Errors
      CONTINUATION_WORD_REUSE: 'CONTINUATION_WORD_REUSE',
      SAME_WORLD_MISSING_SUBTITLE: 'SAME_WORLD_MISSING_SUBTITLE',
      SAME_WORLD_MISSING_WORLD_NAME: 'SAME_WORLD_MISSING_WORLD_NAME',
      NEW_STORY_PRIOR_NOUN_REUSE: 'NEW_STORY_PRIOR_NOUN_REUSE',

      // Paywall Routing Errors
      STORYPASS_DIRTY_LEAK: 'STORYPASS_DIRTY_LEAK',
      STORYPASS_SOULMATES_LEAK: 'STORYPASS_SOULMATES_LEAK',

      // Narrative Authority Errors (POV-agnostic, runs before Tone/POV)
      NARR_EXPLANATORY: 'NARR_EXPLANATORY',
      NARR_TAXONOMY_LEAK: 'NARR_TAXONOMY_LEAK',
      NARR_ABSTRACT_WITHOUT_CONSEQUENCE: 'NARR_ABSTRACT_WITHOUT_CONSEQUENCE',
      NARR_HELPFUL_NARRATOR: 'NARR_HELPFUL_NARRATOR'
  };

  // ============================================================
  // GLASS HOUSE TITLE WEIGHTING (PHASE I)
  // ============================================================
  const GLASS_HOUSE_TITLE = {
      PHASE_I_LIMIT: 75,
      STORAGE_KEY: 'sb_glass_house_title_count',
      LEXICAL_MARKERS: /\b(glass\s*house|glass\s*houses|under\s+glass|in\s+the\s+field|glass|chorus|choir|field|harmonic|harmony|solo|dead\s+zone)\b/i,
      BANNED_STANDALONE: /^dead\s+zone$/i,
      SUBTITLE_MARKERS: [
          'A Glass House Story',
          'A Glass House Entry',
          'From the Glass House Cycle'
      ],
      STRUCTURES: ['possessive', 'situational', 'juxtaposition', 'minimalist', 'subtitle'],
      POSSESSIVE_CAP: 0.25,
      SUBTITLE_CAP: 0.40,
      getCount() { return parseInt(localStorage.getItem(this.STORAGE_KEY) || '0', 10); },
      increment() { localStorage.setItem(this.STORAGE_KEY, String(this.getCount() + 1)); },
      isPhaseI() { return this.getCount() < this.PHASE_I_LIMIT; }
  };

  function buildGlassHouseTitleDirective(previousTitle) {
      if (!GLASS_HOUSE_TITLE.isPhaseI()) return '';
      const count = GLASS_HOUSE_TITLE.getCount();

      let antiStructure = '';
      if (previousTitle) {
          if (/^the\s+glass\s+house\s+of\s+/i.test(previousTitle)) {
              antiStructure = '\nDo NOT use the structure "The Glass House of [Name]" â€” the previous title already used it.';
          } else if (/^[\w\s]+'s\s+glass/i.test(previousTitle)) {
              antiStructure = '\nDo NOT use a possessive structure â€” the previous title already used it.';
          } else if (/\s*â€”\s*(A Glass House|From the Glass House)/i.test(previousTitle)) {
              antiStructure = '\nDo NOT use a subtitle-appended structure â€” the previous title already used it.';
          }
      }

      return `

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GLASS HOUSE WORLD â€” TITLE LEXEME REQUIREMENT (Phase I, story ${count + 1}/${GLASS_HOUSE_TITLE.PHASE_I_LIMIT})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
The title OR subtitle MUST contain at least one Glass House lexical marker:
Glass, Glass House, The Glass House, Chorus, Choir, Field, Harmonic, Harmony, Solo, Dead Zone (only as part of a larger phrase), Under Glass, In the Field.

"Dead Zone" alone is BANNED as a standalone title.
Do NOT number titles.

STRUCTURE VARIETY (cycle through these â€” do not repeat consecutive structure):
- Possessive: "Belinda Claire's Glass House"
- Situational: "Affair in a Glass House"
- Juxtaposition: "Glass Houses and Open Veins"
- Minimalist: "Under Glass"
- Subtitle format: "Signal Loss â€” A Glass House Entry"
${antiStructure}

TONE: Literary, not sci-fi pulp. Avoid "Neural Sync Protocol", "Quantum Emotion Engine".
Glass House is NOT wasteland dystopia â€” avoid ash/desert imagery.

If the main title does not include a strong marker, you MAY append a subtitle:
"â€” A Glass House Story", "â€” A Glass House Entry", or "â€” From the Glass House Cycle"
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  function enforceGlassHouseLexeme(title) {
      if (!GLASS_HOUSE_TITLE.isPhaseI()) return title;
      const clean = title.replace(/"/g, '').trim();
      if (GLASS_HOUSE_TITLE.BANNED_STANDALONE.test(clean)) {
          return clean + ' â€” A Glass House Entry';
      }
      if (GLASS_HOUSE_TITLE.LEXICAL_MARKERS.test(clean)) return clean;
      const subtitles = GLASS_HOUSE_TITLE.SUBTITLE_MARKERS;
      return clean + ' â€” ' + subtitles[Math.floor(Math.random() * subtitles.length)];
  }

  // ============================================================
  // TITLE VALIDATION + FALLBACK SYSTEM
  // ============================================================
  // Validates generated titles against known failure patterns.
  // On failure: deterministic name-based fallback is generated.
  // ============================================================

  /**
   * TITLE FAILURE PATTERNS
   * Regex patterns that indicate a bad title
   */
  const TITLE_FAIL_PATTERNS = {
      // Generic/clichÃ© romance titles
      GENERIC: [
          /^(a|the)\s+(love|heart|soul|kiss|desire|passion)\b/i,
          /^love('s)?\s+(story|song|way|promise|dance|journey)/i,
          /^hearts?\s+(of|in|on)\s+/i,
          /^(whispers?|echoes?|shadows?|secrets?)\s+of\s+(the\s+)?(heart|soul|desire|love)/i,
          /^(eternal|forbidden|hidden|secret|dark|lost)\s+(love|desire|passion|heart)/i,
          /^(love|desire)\s+(in\s+the\s+)?(shadows?|dark(ness)?|night)/i
      ],
      // Abstract noun clusters (mood collage)
      ABSTRACT_CLUSTER: [
          /^(veiled|shrouded|hidden)\s+(whispers?|secrets?|desires?|shadows?)/i,
          /^(whispers?|echoes?)\s+(of|and)\s+(whispers?|echoes?|shadows?|secrets?)/i,
          /^(shadows?|darkness)\s+(and|of)\s+(light|desire|whispers?)/i,
          /\b(aches?|burns?|yearns?)\s+(of|for|with)\s+(the\s+)?(soul|heart|desire)/i
      ],
      // Poetic-but-empty (no stakes/narrative promise)
      CLICHE: [
          /^(when|where)\s+(hearts?|souls?|love)\s+(meet|collide|dance)/i,
          /^(beneath|beyond|between)\s+(the\s+)?(stars?|moon|sky|veil)/i,
          /^(dancing|dancing\s+with)\s+(shadows?|flames?|fate)/i,
          /^(chasing|finding|seeking)\s+(love|desire|destiny|fate)/i,
          /^(written\s+in|painted\s+with)\s+(the\s+)?(stars?|blood|fire)/i
      ],
      // BANNED PHRASES (HARD FAIL)
      BANNED: [
          /\bshadows?\s+of\b/i,
          /\bechoes?\s+of\b/i,
          /\bwhispers?\s+of\b/i,
          /\bwhispers?\b/i,  // Whispers alone is banned
          /^beneath\b/i,
          /^within\b/i,
          /^beyond\b/i,
          /\bdestiny\b/i,
          /\bfated?\b/i,
          /\bforever\s+(yours|mine|ours)\b/i,
          /\beternal\s+(love|flame|bond)\b/i
      ],
      // Multi-clause poetic phrasing
      MULTI_CLAUSE: [
          /^.+,\s+.+,\s+.+/,  // Three or more comma-separated clauses
          /^.+\s+â€”\s+.+\s+â€”\s+.+/,  // Multiple em-dashes
          /^.+:\s+.+:\s+/,  // Multiple colons
          /^(when|where|if|as)\s+.+,\s+(then|so|and)\s+/i  // Conditional phrasing
      ],
      // Marketing copy tone
      MARKETING: [
          /\b(ultimate|passionate|unforgettable|breathtaking|stunning)\b/i,
          /\b(journey|adventure)\s+(of|to)\s+(love|passion|desire)\b/i,
          /\b(one|a)\s+(woman|man|person)('s)?\s+(journey|quest|search)\b/i,
          /\bthe\s+(story|tale)\s+of\b/i,
          /\b(discover|unlock|explore)\s+(the|your)\b/i
      ]
  };

  /**
   * TITLE MODES (LOCKED)
   * Primary title generator selects EXACTLY ONE mode
   */
  const TITLE_MODES = {
      POSSESSIVE_POWER: 'possessive_power',    // "Her Silence", "Your Obedience"
      FORBIDDEN_OBJECT: 'forbidden_object',    // "The Key", "The Contract"
      VERB_LOCKED: 'verb_locked',              // "What He Took", "Where You Knelt"
      TWO_WORD_FRACTURE: 'two_word_fracture'   // "Golden Hunger", "Sacred Damage"
  };

  /**
   * TITLE MODE PATTERNS
   * Regex patterns that detect which mode a title belongs to
   */
  const TITLE_MODE_PATTERNS = {
      [TITLE_MODES.POSSESSIVE_POWER]: /^(her|his|my|your|their|our)\s+\w+$/i,
      [TITLE_MODES.FORBIDDEN_OBJECT]: /^the\s+\w+$/i,
      [TITLE_MODES.VERB_LOCKED]: /^(what|where|when|how|why)\s+(he|she|they|you|i)\s+\w+$/i,
      [TITLE_MODES.TWO_WORD_FRACTURE]: /^\w+\s+\w+$/i  // Fallback: any two words
  };

  /**
   * MODE-SPECIFIC VOCABULARY â€” UNRESOLVED TENSION ONLY
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE (AUTHORITATIVE):
   * No title generated before ST4 may name a resolved state, irreversible
   * consequence, or completed act.
   *
   * A title is the Story's admission of tension, not a promise of outcome.
   *
   * ALLOWED AT ST1â€“ST3: hesitation, hunger, denial, almost, temptation,
   *                     bargaining, watching, waiting, pretending, conditions
   *
   * DISALLOWED AT ST1: surrender, obedience, ruin, betrayal, reckoning,
   *                    downfall, what was taken, damage already done,
   *                    possession already claimed, past-tense completion verbs
   *
   * MANTRA: A title does not know the ending.
   *         It only knows the lie being told at the beginning.
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const TITLE_MODE_VOCABULARY = {
      [TITLE_MODES.POSSESSIVE_POWER]: {
          possessives: ['Her', 'His', 'My', 'Your', 'Their'],
          // UNRESOLVED: states of wanting, not states of having
          nouns: {
              Clean: ['Silence', 'Distance', 'Waiting', 'Refusal', 'Terms'],
              Naughty: ['Secret', 'Temptation', 'Risk', 'Edge', 'Game'],
              // CHANGED: Removed 'Surrender', 'Claim' (resolved states)
              Steamy: ['Hunger', 'Wanting', 'Hesitation', 'Confession', 'Longing'],
              // CHANGED: Removed 'Obedience', 'Ruin', 'Undoing' (aftermath)
              Passionate: ['Appetite', 'Dare', 'Demand', 'Condition', 'Warning']
          }
      },
      [TITLE_MODES.FORBIDDEN_OBJECT]: {
          articles: ['The'],
          // UNRESOLVED: objects that represent tension, not resolution
          objects: {
              Clean: ['Door', 'Letter', 'Ring', 'Promise', 'Line'],
              Naughty: ['Key', 'Contract', 'Rule', 'Wager', 'Dare'],
              // CHANGED: Removed 'Claim', 'Mark' (possession)
              Steamy: ['Bargain', 'Arrangement', 'Question', 'Threshold', 'Offer'],
              // CHANGED: Removed 'Leash' (possession) â€” kept negotiation objects
              Passionate: ['Terms', 'Price', 'Condition', 'Test', 'Trade']
          }
      },
      [TITLE_MODES.VERB_LOCKED]: {
          // CHANGED: Removed past-tense completion verbs entirely
          // Now uses present/conditional tense only
          openers: ['What', 'Where', 'If', 'Whether'],
          subjects: ['He', 'She', 'You', 'They', 'I'],
          // UNRESOLVED: verbs of contemplation, not completion
          verbs: {
              Clean: ['Means', 'Waits', 'Watches', 'Refuses', 'Knows'],
              Naughty: ['Wants', 'Almost', 'Nearly', 'Considers', 'Dares'],
              // CHANGED: Removed 'Took', 'Claimed', 'Gave' (past completion)
              Steamy: ['Needs', 'Craves', 'Hesitates', 'Decides', 'Chooses'],
              // CHANGED: Removed 'Broke', 'Wrecked', 'Ruined' (aftermath)
              Passionate: ['Demands', 'Expects', 'Tests', 'Pushes', 'Asks']
          }
      },
      [TITLE_MODES.TWO_WORD_FRACTURE]: {
          // UNRESOLVED: adjectives of state, not aftermath
          adjectives: {
              Clean: ['Quiet', 'Cold', 'Still', 'Distant', 'Careful'],
              Naughty: ['Sweet', 'Hidden', 'Secret', 'Dangerous', 'Willing'],
              // CHANGED: Kept emotional states, removed aftermath words
              Steamy: ['Burning', 'Aching', 'Desperate', 'Hungry', 'Trembling'],
              // CHANGED: Removed 'Ruined', 'Wrecked' (aftermath)
              Passionate: ['Raw', 'Hungry', 'Demanding', 'Impatient', 'Restless']
          },
          // CHANGED: Removed 'Damage', 'Reckoning' (aftermath)
          nouns: ['Hunger', 'Waiting', 'Silence', 'Terms', 'Question', 'Edge', 'Threshold']
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TITLE VOCABULARY SEMANTIC GATES (ST1 ENFORCEMENT)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // These patterns detect RESOLVED/AFTERMATH language that must be blocked at ST1

  const TITLE_RESOLVED_VOCABULARY = {
      // Past-tense completion verbs (implies consequence already occurred)
      pastCompletion: /\b(took|claimed|gave|broke|wrecked|ruined|used|betrayed|fell|lost|won|conquered|destroyed|surrendered)\b/i,

      // Possessive resolution (implies ownership already established)
      possessiveResolution: /\b(her|his|my|your|their)\s+(surrender|obedience|ruin|undoing|defeat|submission|fall|breaking)\b/i,

      // Aftermath nouns (name consequences, not tension)
      aftermathNouns: /\b(reckoning|downfall|betrayal|aftermath|wreckage|ruins|ashes|remains|ending|conclusion)\b/i,

      // Completion states (tension already resolved)
      completionStates: /\b(finally|at\s+last|in\s+the\s+end|what\s+remained|all\s+that\s+was\s+left)\b/i,

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PROMISE DISCIPLINE â€” Title must not assume meaning or resolution
      // Titles may suggest tension, ambiguity, or invitation only
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Moral framing (pre-judges what the temptation means)
      moralFraming: /\b(forbidden\s+(love|desire|pleasure)|guilty\s+(pleasure|secret)|shameful|sinful|wicked)\b/i,

      // Outcome promise (implies how it will resolve)
      outcomePromise: /\b(inevitable|destined|fated\s+to|meant\s+to\s+be|bound\s+to|will\s+(always|never))\b/i,

      // Thematic declaration (states what the story IS rather than evokes)
      thematicDeclaration: /^(the\s+)?(story|tale|journey)\s+of\b/i
  };

  /**
   * Check if title contains resolved/aftermath vocabulary
   * @param {string} title - Title to check
   * @returns {{ hasResolved: boolean, violations: string[] }}
   */
  function checkTitleResolutionVocabulary(title) {
      const violations = [];
      const cleanTitle = (title || '').trim();

      for (const [category, pattern] of Object.entries(TITLE_RESOLVED_VOCABULARY)) {
          if (pattern.test(cleanTitle)) {
              violations.push(`${category}: "${cleanTitle.match(pattern)?.[0]}"`);
          }
      }

      return {
          hasResolved: violations.length > 0,
          violations
      };
  }

  window.checkTitleResolutionVocabulary = checkTitleResolutionVocabulary;
  window.TITLE_RESOLVED_VOCABULARY = TITLE_RESOLVED_VOCABULARY;

  /**
   * WRY CONFESSIONAL TITLE MODES
   * Observational, ironic, understated â€” no power/possession/melodrama
   */
  const WRY_CONFESSIONAL_TITLE_MODES = {
      OBSERVATIONAL: 'OBSERVATIONAL',
      IRONIC_STATEMENT: 'IRONIC_STATEMENT',
      UNDERCUT_OBJECT: 'UNDERCUT_OBJECT'
  };

  const WRY_CONFESSIONAL_VOCABULARY = {
      OBSERVATIONAL: [
          'Everyone Pretended This Was Fine',
          'It Seemed Like a Good Idea',
          'No One Mentioned It Again',
          'We Were All Adults About It',
          'This Was Supposed to Be Simple'
      ],
      IRONIC_STATEMENT: [
          'A Minor Complication',
          'Nothing Personal',
          'An Understandable Mistake',
          'Probably Fine',
          'For What It\'s Worth'
      ],
      UNDERCUT_OBJECT: [
          'The Champagne Glass',
          'The Empty Chair',
          'The Apology',
          'The Email',
          'The Receipt'
      ]
  };

  // =================================================================
  // WRY CONFESSIONAL â€” UNIFIED VISUAL ONTOLOGY (PATCH 9)
  // Single source of truth for covers AND scene visualization
  // =================================================================

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL VISUAL ONTOLOGY â€” Anti-painterly, anti-moody specification
  // CRITICAL: Positive-first approach (models respond better to positives)
  // Lead with explicit style, minimize negations, use clear model-friendly terms
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSIONAL_VISUAL_ONTOLOGY = `Style: Single-panel New Yorker magazine editorial cartoon. Medium: Black ink line drawing on white paper with simple hatching. Aesthetic: Minimalist, understated, dry wit. Lines: Thin uniform pen strokes, hand-drawn quality, quick newspaper sketch style. Colors: Grayscale only, cool neutral tones, flat matte finish. Background: Plain white, empty, no gradients. Mood: Deadpan, observational, wry. Rendering: 2D flat illustration, deliberately unpolished, diagrammatic simplicity. Avoid: oil painting, watercolor, photorealism, dramatic lighting, warm tones, 3D rendering, painterly effects.`;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSION â€” CANONICAL CAPTION TEMPLATES (RUNTIME)
  // Use as-is or with light variation. Caption must undercut, not decorate.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSION_CAPTION_TEMPLATES = {
      selfIndictingRationalization: [
          "I had a system for moments like this, which mostly involved pretending they were temporary.",
          "I told myself this was different, which is what I always told myself.",
          "I had reasons. I always had reasons."
      ],
      delayedSelfAwareness: [
          "This was the point where I would later insist I'd had no real choice.",
          "Looking back, I would call this a turning point. At the time, I called it Tuesday.",
          "I would remember this moment differently, and more favorably."
      ],
      storyAsWitness: [
          "The story briefly considered intervening here, then remembered how stubborn she could be.",
          "The story noted the hesitation and chose not to comment.",
          "The story had seen this before and adjusted its expectations accordingly."
      ],
      constraints: {
          maxWords: 20,
          noJokes: true,
          noMetaCommentary: true,
          noWorldMechanics: true,
          mustUndercut: true
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSION â€” BINARY VISUAL CONTRADICTION TYPES (RUNTIME)
  // Every visualization must include exactly ONE of these disagreements.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSION_VISUAL_CONTRADICTIONS = {
      backgroundSign: [
          "NO RETURNS", "FAIR PRICES", "TEMPORARY", "EXIT", "CAUTION",
          "FINAL SALE", "ONE WAY", "NO REFUNDS", "LAST CHANCE"
      ],
      postureUndercuts: [
          "clenched hands", "stiff stance", "off-balance weight",
          "shoulders slightly hunched", "fingers gripping edge",
          "leaning away while reaching forward"
      ],
      silentObserver: [
          "secondary figure in background watching",
          "reflection in window showing different expression",
          "shadow that doesn't match posture"
      ],
      prominentObject: [
          "object of temptation rendered slightly too large",
          "dangerous item positioned within easy reach",
          "escape route visible but ignored"
      ],
      constraints: {
          onlyOne: true,
          noExaggeration: true,
          noSlapstick: true,
          legibleAtGlance: true
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TONE VISUAL ONTOLOGY REGISTRY â€” Master definition of tone-locked visual styles
  // ğŸ”’ PRIORITY: Tone visual ontology ALWAYS overrides Genre and World styling
  // Genre only influences composition, subject matter, costume/setting tropes
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const TONE_VISUAL_ONTOLOGIES = {
      'Wry Confessional': {
          ontology: WRY_CONFESSIONAL_VISUAL_ONTOLOGY,
          expectedTags: ['editorial cartoon', 'New Yorker', 'ink drawing', 'sketch', 'grayscale', 'minimalist'],
          bannedTokens: /\b(cinematic|painterly|photorealistic|photo-real|dramatic lighting|chiaroscuro|depth of field|bokeh|lens flare|hyper-realistic|oil painting|oil-painting|watercolor|watercolour|atmospheric|natural lighting|golden.hour|golden hour|studio lighting|volumetric|HDR|8k|4k|ultra.realistic|professional photo|realistic|realism|brush stroke|brushstroke|impasto|glazing|sfumato|warm lighting|warm tones|orange glow|sunset|golden light|rich colors|vibrant|lush|ethereal|dreamy|fantasy art|concept art|digital painting|digital art|artstation|deviantart)\b/gi,
          intensityTokens: /\b(suggestive|flirtatious|sensual|seductive|allure|attractive|beautiful|striking beauty|elegant features|hourglass|athletic|gorgeous|stunning|radiant)\b/gi,
          cleanupPatterns: [
              /This image is an editorial cartoon[^.]*\./gi,
              /NOT a photograph[^.]*\./gi,
              /Style:[^.]*\./gi,
              /New Yorker[^.]*\./gi
          ],
          description: 'Editorial cartoon sketch style â€” New Yorker magazine aesthetic'
      },
      'WryConfession': {  // Alias for internal naming consistency
          aliasOf: 'Wry Confessional'
      },
      'Satire': {  // Uses same visual style as Wry Confessional
          aliasOf: 'Wry Confessional'
      },
      'Irony': {  // Uses same visual style as Wry Confessional
          aliasOf: 'Wry Confessional'
      },
      'Lurid Confessional': {
          ontology: `Style: Vintage pulp magazine cover illustration. Medium: Bold, saturated colors with heavy black outlines. Aesthetic: Sensational, melodramatic, confessional. Colors: High contrast, saturated reds, yellows, blues. Strong shadows, exaggerated expressions. Background: Simple gradient or solid color with dramatic spotlighting. Mood: Overwrought, breathless, tabloid. Rendering: Classic illustration style, visible brush strokes, slightly garish color palette. Avoid: subtlety, muted tones, photorealism, modern digital aesthetic.`,
          expectedTags: ['pulp', 'vintage', 'melodramatic', 'saturated', 'bold outlines', 'confessional'],
          bannedTokens: /\b(subtle|muted|photorealistic|photo-real|naturalistic|understated|minimalist|grayscale|monochrome)\b/gi,
          intensityTokens: null,  // Lurid allows intensity language
          cleanupPatterns: [],
          description: 'Vintage pulp magazine illustration â€” bold, saturated, melodramatic'
      },
      'Ink Noir': {
          ontology: `Style: Black-and-white noir comic panel. Medium: High contrast ink work, heavy shadows, dramatic chiaroscuro. Aesthetic: Hard-boiled, fatalistic, shadowy. Colors: Pure black and white only, no gray tones, stark contrast. Strong use of negative space and silhouettes. Background: Urban shadows, venetian blind stripes, rain-slicked surfaces. Mood: Cynical, world-weary, dangerous. Rendering: Frank Miller/Sin City aesthetic, bold ink work, extreme shadow play. Avoid: color, soft gradients, warm tones, cheerful lighting, painterly effects.`,
          expectedTags: ['noir', 'black-and-white', 'ink', 'chiaroscuro', 'comic panel', 'shadows'],
          bannedTokens: /\b(color|colorful|vibrant|warm|cheerful|soft|gradient|painterly|watercolor|pastel|bright|sunny)\b/gi,
          intensityTokens: null,
          cleanupPatterns: [],
          description: 'Sin City-style black-and-white noir comic panel'
      },
      // Tones WITHOUT visual ontology (use Genre defaults):
      // - Earnest, WryConfession, Dark, Mythic: No visual lock â€” uses Genre styling
  };

  // Resolve tone alias to canonical name
  function resolveToneAlias(tone) {
      if (!tone) return null;
      const entry = TONE_VISUAL_ONTOLOGIES[tone];
      if (entry?.aliasOf) {
          return entry.aliasOf;
      }
      return tone;
  }

  // Check if a tone has a visual ontology that overrides genre
  function hasToneVisualOntology(tone) {
      const resolved = resolveToneAlias(tone);
      const entry = TONE_VISUAL_ONTOLOGIES[resolved];
      return entry && !entry.aliasOf && entry.ontology;
  }

  // Get the visual ontology for a tone (returns null if none)
  function getToneVisualOntology(tone) {
      const resolved = resolveToneAlias(tone);
      const entry = TONE_VISUAL_ONTOLOGIES[resolved];
      if (entry && !entry.aliasOf) {
          return entry;
      }
      return null;
  }

  // Apply tone visual ontology to a prompt (returns modified prompt and metadata)
  function applyToneVisualOntology(prompt, tone, context = 'visualize') {
      const ontologyEntry = getToneVisualOntology(tone);

      if (!ontologyEntry) {
          // No visual ontology â€” return original prompt with genre authority
          return {
              prompt: prompt,
              styleAuthority: 'Genre',
              styleExpectedTags: [],
              toneStyleLock: false
          };
      }

      let modifiedPrompt = prompt;

      // Strip banned tokens (cinematic, painterly, etc.)
      if (ontologyEntry.bannedTokens) {
          modifiedPrompt = modifiedPrompt.replace(ontologyEntry.bannedTokens, '');
      }

      // Strip intensity tokens if specified
      if (ontologyEntry.intensityTokens) {
          modifiedPrompt = modifiedPrompt.replace(ontologyEntry.intensityTokens, '');
      }

      // Apply cleanup patterns to avoid duplication
      if (ontologyEntry.cleanupPatterns) {
          for (const pattern of ontologyEntry.cleanupPatterns) {
              modifiedPrompt = modifiedPrompt.replace(pattern, '');
          }
      }

      // Trim and clean up whitespace
      modifiedPrompt = modifiedPrompt.replace(/\n{3,}/g, '\n\n').replace(/\s{2,}/g, ' ').trim();

      // Prepend authoritative ontology
      modifiedPrompt = `${ontologyEntry.ontology}\n\nScene: ${modifiedPrompt}`;

      console.log(`[VIZ:TONE] ${resolveToneAlias(tone)} ontology APPLIED â€” styleAuthority: Tone`);
      console.log(`[VIZ:TONE] Expected tags: ${ontologyEntry.expectedTags.join(', ')}`);

      return {
          prompt: modifiedPrompt,
          styleAuthority: 'Tone',
          styleExpectedTags: ontologyEntry.expectedTags,
          toneStyleLock: true,
          toneDescription: ontologyEntry.description
      };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WORLD + TONE STYLE LOCK (TRUST REPAIR PHASE 2)
  // Deterministic style derivation â€” cannot be overridden by modifiers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // This lock is HARD â€” it determines the visual style and cannot be silently changed.
  // When World+Tone implies a specific style, the model MUST stay in that lane.
  //
  // STYLE LOCK HIERARCHY:
  //   1. Tone visual ontology (if exists) â†’ ABSOLUTE priority
  //   2. World default style â†’ fallback
  //
  // STYLE CATEGORIES:
  //   - sketch: pencil, ink, charcoal, editorial, unfinished
  //   - illustrative: clean illustration, graphic novel, stylized
  //   - photographic: realistic, cinematic, natural lighting
  //   - painterly: oil, watercolor, brushwork, classical
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const WORLD_DEFAULT_STYLES = {
      Modern: 'photographic',
      Fantasy: 'illustrative',
      SciFi: 'illustrative',
      Historical: 'painterly',
      PostApocalyptic: 'photographic',
      Dystopia: 'illustrative'
  };

  const TONE_STYLE_OVERRIDES = {
      'Wry Confessional': 'sketch',
      'WryConfession': 'sketch',
      'Satire': 'sketch',
      'Irony': 'sketch',
      'Lurid Confessional': 'illustrative',
      'Ink Noir': 'sketch',
      'Mythic': 'painterly'
  };

  /**
   * Get the locked style for World+Tone combination
   * @returns {object} { style, source, locked }
   */
  function getStyleLock(world, tone) {
      // Tone has priority if it defines a style override
      const resolvedTone = resolveToneAlias(tone);
      if (TONE_STYLE_OVERRIDES[resolvedTone]) {
          return {
              style: TONE_STYLE_OVERRIDES[resolvedTone],
              source: 'tone',
              locked: true
          };
      }

      // Fall back to world default
      const worldStyle = WORLD_DEFAULT_STYLES[world] || 'illustrative';
      return {
          style: worldStyle,
          source: 'world',
          locked: true
      };
  }

  /**
   * Validate that a prompt respects the style lock
   * @returns {object} { valid, violations[] }
   */
  function validateStyleLock(prompt, styleLock) {
      const violations = [];

      const STYLE_TOKENS = {
          sketch: {
              required: /\b(sketch|drawing|ink|pencil|charcoal|editorial|line.?work|hand.?drawn)\b/i,
              banned: /\b(photorealistic|cinematic|oil.?paint|hyper.?real|4k|8k|studio.?light)\b/i
          },
          illustrative: {
              required: /\b(illustration|illustrated|graphic|stylized|digital.?art|comic|manga)\b/i,
              banned: /\b(photograph|photorealistic|real.?life|candid|raw.?photo)\b/i
          },
          photographic: {
              required: /\b(photo|cinematic|realistic|natural.?light|candid|documentary)\b/i,
              banned: /\b(cartoon|sketch|anime|drawing|line.?art)\b/i
          },
          painterly: {
              required: /\b(paint|painted|oil|watercolor|brushwork|classical|impressionist)\b/i,
              banned: /\b(sketch|cartoon|photograph|digital.?render)\b/i
          }
      };

      const tokens = STYLE_TOKENS[styleLock.style];
      if (!tokens) return { valid: true, violations: [] };

      if (tokens.banned && tokens.banned.test(prompt)) {
          violations.push(`Prompt contains tokens banned for ${styleLock.style} style`);
      }

      return {
          valid: violations.length === 0,
          violations
      };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SKETCH TIER REFINEMENT (TRUST REPAIR PHASE 2)
  // For Wry Confession, Sci-Fi, Mythic: reduce polish, increase hand-drawn feel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // The sketch must look like "someone thinking on paper", NOT "final concept art"
  //
  // ALLOWED:
  //   - outlined lettering
  //   - crossed-out words
  //   - uneven strokes
  //   - editorial looseness
  //   - visible construction lines
  //   - partial shading
  //
  // DISALLOWED:
  //   - cinematic lighting
  //   - painterly shading
  //   - finished illustration look
  //   - professional polish
  //   - smooth gradients
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const SKETCH_TIER_ENFORCEMENT = `
SKETCH TIER ENFORCEMENT (MANDATORY):
This cover must appear UNFINISHED in execution, not unfinished in idea.

REQUIRED CHARACTERISTICS:
- Pencil, ink, or charcoal texture visible
- Uneven or broken linework
- Partial fill or restrained color (2-3 tones max)
- Visible construction lines or negative space
- Hand-drawn or outlined lettering allowed
- Editorial looseness and imperfection
- Conceptual tension over literal depiction

ABSOLUTELY PROHIBITED:
- Cinematic lighting or dramatic shadows
- Painterly shading or smooth gradients
- Finished illustration look
- Professional polish or commercial finish
- Hyper-realistic rendering
- Digital art smoothness
- LITERAL DEVICE OBJECTS (tablets, screens, phones, computers)
- "Future tech = object" shorthand
- Product-like renderings

CONCEPTUAL GUIDANCE:
For themes of resonance, experimentation, or instability:
- Prefer juxtaposition, misalignment, or incomplete systems
- Accept abstraction
- Avoid literal depiction of technology as physical object
- If uncertain, subtract rather than add

The goal: A cover that feels MID-THOUGHT, not UNDER-THOUGHT.
If the image looks complete, it has FAILED sketch tier.
`;

  const SKETCH_TIER_TONES = ['Wry Confessional', 'WryConfession', 'Satire', 'Irony', 'Ink Noir'];

  /**
   * Check if current tone requires sketch tier enforcement
   */
  function requiresSketchTier(tone) {
      const resolved = resolveToneAlias(tone);
      return SKETCH_TIER_TONES.includes(resolved);
  }

  /**
   * Get sketch tier enforcement text for cover prompts
   */
  function getSketchTierEnforcement(tone) {
      if (!requiresSketchTier(tone)) return '';
      return SKETCH_TIER_ENFORCEMENT;
  }

  const WRY_CONFESSIONAL_OBJECT_ALTERATIONS = [
      'slightly misplaced',
      'unused or paused mid-intent',
      'emotionally undercut',
      'quietly contradicting expectation'
  ];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL â€” TONE INVARIANT (AUTHORITATIVE)
  // Applies to ALL cover stages for Wry Confessional tone
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSIONAL_TONE_INVARIANT = `TONE INVARIANT (Wry Confessional):
The primary object must show evidence of hesitation, interference, revision, or ironic displacement.
Confession is implied through the condition of the object, not through spectacle or explicit humor.
The object may change across stages, but the wry condition must persist.
No pristine, untouched symbolism is allowed.

ABSOLUTE CONSTRAINTS (ALL STAGES):
- NO spectacle (fire, explosions, chaos, melodrama)
- NO explicit jokes or captions that explain the irony
- NO reversion to pristine objects
- NO photoreal stock aesthetics
- NO escalation into parody

FAILURE CONDITIONS:
- Object appears untouched or neutral
- Irony is loud, literal, or explained
- Tone collapses into humor instead of implication
- Same motif repeated mechanically across stages`;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL â€” STAGE-SPECIFIC ESCALATION (AUTHORITATIVE)
  // Each stage applies the invariant with different legibility
  // NOTE: Uses string keys to avoid reference before COVER_STAGES definition
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const WRY_CONFESSIONAL_STAGE_PROMPTS = {
      'sketch': `${WRY_CONFESSIONAL_TONE_INVARIANT}

SKETCH STAGE ESCALATION:
- Implicit, understated
- One quiet sign of compromise only
- Ambiguity preserved
- Editorial, diagrammatic feel
- Confession should feel almost accidental

AESTHETIC: Black ink or graphite line work on white or off-white paper. Outlined lettering with light pencil-filled interior. Understated, diagrammatic. New Yorker editorial sketch aesthetic.`,

      'thumbnail': `${WRY_CONFESSIONAL_TONE_INVARIANT}

THUMBNAIL STAGE ESCALATION:
- The wry condition is clearer at a glance
- Still unresolved
- No explanatory gestures or visual punchlines

AESTHETIC: Simple forms, limited palette. The compromised state visible but not emphasized. Editorial restraint maintained.`,

      'rough': `${WRY_CONFESSIONAL_TONE_INVARIANT}

ROUGH STAGE ESCALATION:
- The compromised state of the object is unambiguous
- Emotional meaning remains open
- Irony emerges through composition and context, not jokes

AESTHETIC: More refined line work, visible texture. The wry condition is now clearly intentional, not accidental. Still understated.`,

      'v1': `${WRY_CONFESSIONAL_TONE_INVARIANT}

FINAL STAGE ESCALATION:
- The wry irony is fully legible
- Resolved visually, not narratively
- Editorial restraint maintained (New Yorker tone, not gag illustration)

AESTHETIC: Polished editorial illustration. The object's compromised state reads immediately. Irony is clear but never loud. Quiet confidence in the visual statement.`
  };

  /**
   * WRY CONFESSIONAL VISUAL REGRESSION GUARD
   * Throws if prompt contains forbidden cinematic/painterly tokens
   * @param {string} prompt - The image generation prompt to validate
   * @param {string} context - Call site identifier for error messages
   */
  function assertWryConfessionalVisual(prompt, context) {
      const tone = state?.picks?.tone;
      if (tone !== 'Wry Confessional') return; // Only guard Wry Confessional

      const FORBIDDEN_TOKENS = [
          'cinematic', 'painterly', 'photographic', 'photo-real', 'photorealistic',
          'noir', 'dramatic lighting', 'dramatic', 'studio lighting', 'chiaroscuro',
          'depth of field', 'bokeh', 'lens', 'glow', 'hyper-realistic', 'realism', 'oil painting'
      ];

      const promptLower = prompt.toLowerCase();
      for (const token of FORBIDDEN_TOKENS) {
          if (promptLower.includes(token)) {
              const error = `[WRY CONFESSIONAL VIOLATION] Forbidden token "${token}" in prompt at ${context}`;
              console.error(error);
              throw new Error(error);
          }
      }

      console.log(`[WRYâœ“] Visual assertion passed at ${context}`);
  }

  /**
   * WRY CONFESSION â€” CONCRETE SCENE GROUNDING VALIDATOR (AUTHORITATIVE)
   *
   * VISUALIZER RULE: For Wry Confession, tone defines illustration style only.
   * The image SUBJECT must be grounded in a concrete element from the current scene.
   * If no concrete scene element is used, the image is INVALID.
   *
   * @param {string} prompt - The image generation prompt to validate
   * @param {string} sceneContext - Description of the current scene for validation
   * @param {string} callSite - Call site identifier for logging
   * @returns {boolean} True if prompt is grounded in concrete scene elements
   */
  function validateWrySceneGrounding(prompt, sceneContext, callSite) {
      const tone = state?.picks?.tone;
      if (tone !== 'Wry Confessional' && tone !== 'WryConfession') return true; // Only for Wry Confession

      // Concrete scene element indicators
      const CONCRETE_INDICATORS = [
          // Settings/locations
          /\b(room|cafÃ©|office|street|doorway|window|table|desk|chair|bed|kitchen|bathroom|hallway|staircase|car|train|bus|park|garden|balcony|rooftop)\b/i,
          // Character situations/postures
          /\b(standing|sitting|leaning|holding|reaching|turning|walking|running|waiting|watching|looking|hand|hands|fingers|arm|arms|face|eyes|mouth|lips|shoulder|shoulders)\b/i,
          // Objects
          /\b(letter|phone|glass|cup|coffee|wine|book|door|key|ring|mirror|photograph|picture|bag|coat|dress|suit|shoe|hat|cigarette|drink|food|paper|pen|clock|watch)\b/i
      ];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION SALIENCE CONSTRAINT (AUTHORITATIVE)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // When selecting a concrete scene element, PREFER elements that carry
      // narrative pressure or tension. Grounded but narratively irrelevant objects
      // must NOT be used if a pressure-bearing element is present in the scene.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const PRESSURE_BEARING_INDICATORS = [
          // Authority figures
          /\b(boss|manager|supervisor|director|principal|teacher|professor|officer|judge|parent|mother|father|elder|authority)\b/i,
          // Obligations & constraints
          /\b(deadline|contract|bill|invoice|debt|rent|mortgage|obligation|duty|responsibility|requirement|demand|order|summons|notice|warning|ultimatum)\b/i,
          // Crowds & social pressure
          /\b(crowd|audience|onlookers|witnesses|gathering|party|meeting|boardroom|courtroom|waiting room|queue|line of people)\b/i,
          // Surveillance & scrutiny
          /\b(camera|monitor|screen|security|guard|watching eyes|gaze|stare|spotlight|interrogation|interview|examination|inspection)\b/i,
          // Burdens & weight
          /\b(weight|burden|load|stack|pile|mountain of|inbox|paperwork|luggage|baggage|chains|handcuffs|collar|leash|cage|bars|fence|wall|barrier)\b/i,
          // Constraint symbols
          /\b(clock|timer|countdown|calendar|schedule|appointment|wedding ring|engagement ring|uniform|badge|ID card|name tag)\b/i
      ];

      const promptLower = prompt.toLowerCase();
      const contextLower = (sceneContext || '').toLowerCase();
      const hasConcreteElement = CONCRETE_INDICATORS.some(pattern => pattern.test(promptLower));

      // Abstract/ungrounded indicators (warnings)
      const ABSTRACT_INDICATORS = [
          /\b(abstract|swirl|wave|pattern|emotion|feeling|mood|atmosphere|essence|spirit|aura|energy|vibe)\b/i,
          /\b(generic|contemplation|contemplative|pensive|thoughtful) (woman|man|figure|person)\b/i,
          /\b(symbolic|symbolism|metaphor|metaphorical|representation)\b/i
      ];

      const hasAbstractElement = ABSTRACT_INDICATORS.some(pattern => pattern.test(promptLower));

      if (!hasConcreteElement) {
          console.warn(`[WRY SCENE GROUNDING] Missing concrete scene element at ${callSite}`);
          console.warn(`  Prompt: ${prompt.substring(0, 100)}...`);
          console.warn(`  Scene context: ${sceneContext || '(not provided)'}`);
          console.warn(`  RULE: Image subject must be grounded in setting, character situation, or symbolic object from current scene`);
          return false;
      }

      if (hasAbstractElement) {
          console.warn(`[WRY SCENE GROUNDING] Abstract element detected at ${callSite} â€” tone affects style, not subject`);
      }

      // SALIENCE CHECK: Prefer pressure-bearing elements over neutral grounded objects
      const scenePressureElements = PRESSURE_BEARING_INDICATORS
          .filter(pattern => pattern.test(contextLower))
          .map(pattern => {
              const match = contextLower.match(pattern);
              return match ? match[0] : null;
          })
          .filter(Boolean);

      const promptPressureElements = PRESSURE_BEARING_INDICATORS
          .filter(pattern => pattern.test(promptLower))
          .map(pattern => {
              const match = promptLower.match(pattern);
              return match ? match[0] : null;
          })
          .filter(Boolean);

      if (scenePressureElements.length > 0 && promptPressureElements.length === 0) {
          console.warn(`[WRY SALIENCE] Pressure-bearing element available but not used at ${callSite}`);
          console.warn(`  Scene has: [${scenePressureElements.join(', ')}]`);
          console.warn(`  Prompt chose neutral object instead`);
          console.warn(`  RULE: Prefer elements carrying narrative pressure/tension over irrelevant grounded objects`);
          // Return false to enforce salience â€” prompt should use pressure-bearing element
          return false;
      }

      if (promptPressureElements.length > 0) {
          console.log(`[WRYâœ“] Salient pressure element selected: [${promptPressureElements.join(', ')}]`);
      }

      console.log(`[WRYâœ“] Scene grounding validated at ${callSite}`);
      return true;
  }

  // Export for use in image generation pipeline
  window.validateWrySceneGrounding = validateWrySceneGrounding;

  // =================================================================
  // EARNED COVER SYSTEM â€” Progressive cover quality tied to story progress
  // =================================================================

  const COVER_STAGES = {
      SKETCH: 'sketch',
      THUMBNAIL: 'thumbnail',
      ROUGH: 'rough',
      V1: 'v1'
  };

  const COVER_STAGE_LABELS = {
      [COVER_STAGES.SKETCH]: 'Cover Sketch',
      [COVER_STAGES.THUMBNAIL]: 'Cover Thumbnail',
      [COVER_STAGES.ROUGH]: 'Cover Rough',
      [COVER_STAGES.V1]: 'Cover v1'
  };

  // Unlock rules by story length (scene count thresholds)
  // Phase B: Rough is max earned cover. v1 unlocks are inactive.
  // Sketch: 0 = available when story context exists (Scene 1 active)
  const COVER_UNLOCK_RULES = {
      taste: {
          sketch: 0,      // Available when story context exists
          thumbnail: 2,
          rough: null     // Taste maxes out at Thumbnail
      },
      fling: {
          sketch: 0,      // Available when story context exists
          thumbnail: 3,
          rough: 10       // Unlocks at scene 10
      },
      affair: {
          sketch: 0,      // Available when story context exists
          thumbnail: 5,
          rough: 20       // Unlocks at scene 20
      },
      soulmates: {
          sketch: 0,      // Available when story context exists
          thumbnail: 8,
          rough: 30       // Unlocks at scene 30
      }
  };

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STORYTURN â€” AUTHORITATIVE CONFIG
  // Do not modify without design approval
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Storybound Canon v1.0 â€” Audited and Coherent
  // This canon has passed a full coherence audit.
  // All future changes MUST be appended as new appendices.
  // Existing canon must not be edited or reinterpreted.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DESIGN PRINCIPLE â€” AUTHORITATIVE REGIME DECLARATION
  // TAG: storybound/design-principle-authoritative-regimes-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // When a system in Storybound exhibits drift, blending, or silent override
  // behavior, the correct fix is not additional modifiers or constraints.
  //
  // Instead, the system must be elevated to an Authoritative Regime.
  //
  // An Authoritative Regime:
  // - Declares what category of thing something IS
  // - Establishes precedence over modifiers and sub-features
  // - Invalidates incompatible outputs by category, not preference
  // - Is enforced by one binding invariant or self-check
  //
  // Regimes do not blend.
  // Modifiers subordinate.
  // Guidelines are insufficient.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // TERMINOLOGY UPDATE
  // TAG: storybound/terminology-regime-change-v1
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The design principle previously labeled
  // 'Authoritative Regime Declaration' is now canonically named:
  //
  // REGIME CHANGE
  //
  // The meaning, scope, and application remain unchanged.
  //
  // This name is preferred in discussion, audits, and implementation notes.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGIME CHANGE (CANONICAL DEFINITION)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // A Regime Change occurs when a Storybound subsystem
  // is elevated from a modifier-based system to a category-defining authority.
  //
  // Under a Regime Change:
  // - incompatible outputs become invalid by definition
  // - modifiers subordinate instead of blending
  // - one binding invariant or self-check enforces the regime
  // - drift is prevented structurally, not heuristically
  //
  // Regimes do not blend.
  // Only one regime governs a domain at a time.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CROSS-REFERENCE NOTE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Any reference to 'Authoritative Regime Declaration'
  // in prior documentation should be read as 'Regime Change'.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // AUTHORITATIVE REGIMES IN USE (RETROACTIVE LABELING)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The following Storybound subsystems are governed by Authoritative Regimes:
  //
  // 1. Storyturns
  //    - Regime: Irreversible Relational Change
  //    - Effect: Intimacy, dialogue, or intensity never advance structure alone
  //
  // 2. 5th Person POV (Wry Confessional variant)
  //    - Regime: Narrative Coherence as a Reacting Entity
  //    - Effect: Presence is semantic and reactive, not scheduled or controlling
  //
  // 3. Wry Confessional Visualizer
  //    - Regime: Editorial Representation (Not Photographic)
  //    - Effect: Genre influences symbolism only; realism is category-invalid
  //
  // 4. Sketch Tier Covers
  //    - Regime: Unfinished Artifact
  //    - Effect: Print-ready or polished output is a failure condition
  //
  // 5. Fate Cards
  //    - Regime: Narrative Pressure, Not Permission
  //    - Effect: Early play bends scenes without granting resolution
  //
  // 6. Navigation Spine
  //    - Regime: Canonical Reading Order
  //    - Effect: Side chambers may not become Back destinations
  //
  // This labeling is descriptive, not a rewrite.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DSP â€” MATERIAL REGIME (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DSP is a material regime, not a theme or skin.
  //
  // DSP governs:
  // - geometry (right angles, corner squares)
  // - layering (double-line frames, inset borders)
  // - material illusion (pressed, engraved, weight-bearing surfaces)
  //
  // DSP does not yield to:
  // - container radius defaults
  // - generic button styles
  // - component-local theming
  //
  // If a UI element does not read as DSP when isolated,
  // it has failed the regime.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DSP SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Before finalizing any UI component:
  //
  // "Would this element still be recognizable as DSP
  // if shown alone, without surrounding context?"
  //
  // If NO, regenerate or refactor.
  //
  // This regime supersedes local CSS defaults and component inheritance.
  // Material identity takes precedence over layout convenience.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const STORYTURN_CONFIG = {
    storyLengths: {
      Taste: { minWords: 5000, maxWords: 8000 },
      Fling: { minWords: 12000, maxWords: 20000 },
      Affair: { minWords: 40000, maxWords: 70000 },
      Soulmates: { minWords: 90000, maxWords: 130000 }
    },

    storyturns: [
      { id: "ST1", name: "Attraction Acknowledged" },
      { id: "ST2", name: "Resistance Defined" },
      { id: "ST3", name: "Permission Granted" },
      { id: "ST4", name: "Consequence Taken" },
      { id: "ST5", name: "Crisis Separation" },
      { id: "ST6", name: "Integration" }
    ],

    // Intensity tiers no longer control routing. Intimacy authorization is ST3 + SceneGate + PlayerInitiation.
    arousalRules: {
      _default: {
        intimacyAllowedAt: ["ST3", "ST4"],
        explicitness: "player_initiated"
      }
    },

    tasteRules: {
      maxStoryturn: "ST3",
      completionAllowed: false,
      cliffhangerRequired: true
    },

    storyturnSemantics: {
      ST1: { phase: "desire", intimacyCatalyst: false },
      ST2: { phase: "resistance", intimacyCatalyst: false },
      ST3: { phase: "permission", intimacyCatalyst: true },
      ST4: { phase: "consequence", intimacyCatalyst: true },
      ST5: { phase: "crisis", intimacyCatalyst: false },
      ST6: { phase: "integration", intimacyCatalyst: false }
    },

    postIntimacyRules: {
      repeatedIntimacyAdvancesStoryturn: false,
      intimacyAfterST4IsContextual: true
    },

    carryoverRules: {
      allowMultipleArcs: true,
      preserveIntegrationAcrossArcs: true,
      resettableStoryturns: ["ST2", "ST3", "ST4"],
      nonResettableStoryturns: ["ST6"]
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANONICAL STORYTURN SEMANTICS â€” ATTEMPT vs CONSEQUENCE (AUTHORITATIVE)
    // TAG: storybound/storyturn-attempt-consequence-semantics-v1
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // ST3 â€” Permission Granted (Attempts Authorized)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Definition:
    //   ST3 authorizes attempts at intimacy between the two main characters.
    //
    // At ST3:
    //   - Desire may be openly acknowledged
    //   - Boundaries may be approached, tested, or crossed in attempt
    //   - Physical or emotional intimacy may be initiated
    //
    // ST3 explicitly does NOT authorize:
    //   - Completion
    //   - Irreversible consequence
    //   - Relational resolution
    //
    // Valid ST3 outcomes include:
    //   - interruption
    //   - hesitation
    //   - deflection
    //   - withdrawal
    //   - self-sabotage
    //   - escalation without resolution
    //   - cliffhangers
    //
    // Failure to reach consequence is not a failure state.
    // Remaining in ST3 after an attempt is expected behavior.
    //
    // ST3 is about trying.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ST4 â€” Consequence Taken (Attempts Resolved)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Definition:
    //   ST4 authorizes the consequences of intimacy.
    //
    // At ST4:
    //   - Attempts made in ST3 may resolve
    //   - Intimacy may complete
    //   - The relationship enters a new irreversible state
    //
    // ST4 is marked by:
    //   - aftermath
    //   - accountability
    //   - emotional consequence
    //   - narrative reorientation
    //
    // Intimacy, if present, is a consequence, not a trigger.
    //
    // After ST4:
    //   - Intimacy becomes contextual only
    //   - Repetition does not advance Storyturns
    //   - The relationship cannot return to its prior state without denial or collapse
    //
    // ST4 is about what it costs.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ST3 â†’ ST4 TRANSITION SEMANTICS (CRITICAL)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // The transition from ST3 to ST4 occurs only when an attempt produces
    // an irreversible consequence.
    //
    // Interruption, deferral, escalation, or increased explicitness alone
    // does NOT advance Storyturns.
    //
    // No special "interruption rule" is required.
    // Failure to reach consequence simply remains within ST3.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // IMPLEMENTATION NOTE (AUTHORITATIVE)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // This semantic clarification REPLACES any prior "first kiss interruption"
    // or "first intimacy interruption" special-case rules.
    //
    // Do NOT encode this as procedural logic.
    // Do NOT add new conditionals or flags for interruption tracking.
    // Runtime code should reference these semantics when evaluating Storyturn
    // advancement, not reimplement them.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    attemptConsequenceSemantics: {
      ST3: {
        name: "Permission Granted",
        role: "attempts_authorized",
        authorizes: ["desire_acknowledgment", "boundary_testing", "intimacy_initiation"],
        doesNotAuthorize: ["completion", "irreversible_consequence", "relational_resolution"],
        validOutcomes: ["interruption", "hesitation", "deflection", "withdrawal", "self_sabotage", "escalation_without_resolution", "cliffhanger"],
        summary: "ST3 is about trying."
      },
      ST4: {
        name: "Consequence Taken",
        role: "attempts_resolved",
        authorizes: ["attempt_resolution", "intimacy_completion", "irreversible_state_change"],
        markedBy: ["aftermath", "accountability", "emotional_consequence", "narrative_reorientation"],
        postST4: ["sex_contextual_only", "repetition_no_advancement", "no_return_without_denial_or_collapse"],
        summary: "ST4 is about what it costs."
      },
      transitionRule: "ST3 â†’ ST4 occurs only when an attempt produces an irreversible consequence. Interruption, deferral, or escalation alone does NOT advance."
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IRREVERSIBILITY TEST â€” AUTHORITATIVE DEFINITION
    // TAG: storybound/storyturn-attempt-consequence-irrev-v1
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //
    // An action advances a Storyturn ONLY if, after it occurs, the relationship
    // cannot plausibly return to its prior emotional state without denial,
    // repression, or consequence.
    //
    // If the relationship can reasonably resume its previous dynamic with no
    // lasting emotional cost, the action is NOT irreversible and MUST NOT
    // advance a Storyturn.
    //
    // This test applies equally to:
    //   - Fate Card resolutions
    //   - Free-text player input
    //   - Sexual or emotional actions
    //   - Dirty or explicit content
    //
    // Sexual explicitness alone is NEVER sufficient to establish irreversibility.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Examples â€” Irreversible (Advance Eligible)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   - A confession that permanently alters how one character perceives the other
    //   - An intimacy that creates obligation, shame, or accountability
    //   - A choice that forces the relationship into a new emotional posture
    //   - A public or private act that cannot be unspoken or undone
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Examples â€” NOT Irreversible (Do NOT Advance)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   - Intimacy that resolves no emotional uncertainty
    //   - Erotic escalation without consequence
    //   - An interrupted or aborted attempt at intimacy
    //   - Flirting, temptation, or boundary testing
    //   - Dirty content involving side characters, exes, memories, fantasies, or voyeurism
    //   - Explicit acts that leave the relationship emotionally unchanged
    //
    // When uncertain, prefer NON-ADVANCEMENT.
    // Storyturns represent irreversible relational change, not intensity.
    //
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INTERACTION WITH ST3 / ST4
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //   - ST3 authorizes attempts; attempts alone do not satisfy irreversibility
    //   - ST4 authorizes consequences; only consequences can satisfy irreversibility
    //   - Failure, interruption, or escalation without consequence remains ST3
    //
    // This appendix replaces any prior heuristic based on:
    //   - "first kiss"
    //   - "first intimacy"
    //   - interruption counters
    //   - explicitness thresholds
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    irreversibilityTest: {
      definition: "An action advances a Storyturn ONLY if the relationship cannot plausibly return to its prior emotional state without denial, repression, or consequence.",
      appliesTo: ["fate_card_resolutions", "free_text_input", "sexual_actions", "emotional_actions", "dirty_content"],
      sexualExplicitnessAlone: "NEVER sufficient",
      irreversibleExamples: [
        "confession_that_permanently_alters_perception",
        "intimacy_creating_obligation_shame_accountability",
        "choice_forcing_new_emotional_posture",
        "act_that_cannot_be_unspoken_or_undone"
      ],
      notIrreversibleExamples: [
        "sex_resolving_no_emotional_uncertainty",
        "erotic_escalation_without_consequence",
        "interrupted_or_aborted_attempt",
        "flirting_temptation_boundary_testing",
        "dirty_content_with_side_characters_exes_memories_fantasies_voyeurism",
        "explicit_acts_leaving_relationship_unchanged"
      ],
      uncertaintyRule: "prefer_non_advancement",
      summary: "Storyturns represent irreversible relational change, not intensity."
    }
  };

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // PASS ROUTING AUTHORITY
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // Deterministic pass tier routing: storyturn phase Ã— world complexity Ã— scene type.
  // NEVER varies based on fortune balance, subscription tier, or payment behavior.

  const WORLD_COMPLEXITY_MAP = {
    // Top-level worlds
    Dystopia: 3,
    PostApocalyptic: 2,
    Historical: 2,
    Fantasy: 2,
    SciFi: 2,
    Modern: 1,
    // Subtypes that override parent
    glass_house: 3,
    supernatural_modern: 2,
    superheroic_modern: 2,
  };

  function getWorldComplexity() {
    const subtype = state.picks?.worldSubtype;
    const world = state.picks?.world || 'Modern';
    if (subtype && WORLD_COMPLEXITY_MAP[subtype] !== undefined) {
      return WORLD_COMPLEXITY_MAP[subtype];
    }
    return WORLD_COMPLEXITY_MAP[world] ?? 2;
  }

  function resolvePassTier() {
    const st = state.storyturn || 'ST1';
    const complexity = getWorldComplexity();
    // Inline intimacy gate check (functions are nested in continuation handler scope)
    const sceneIndex = state.turnCount || 0;
    const storyLength = state.storyLength || 'taste';
    const baseGates = { taste: 4, fling: 6, affair: 10 };
    let gateScene = baseGates[storyLength] || 4;
    if (state.intimacyInterrupted?.first_kiss) gateScene = Math.min(gateScene, sceneIndex);
    const intimacyAllowed = sceneIndex >= gateScene;
    const eroticDetected = !!(state.intimacyInterrupted?.first_kiss && state.intimacyInterrupted?.first_intimacy);
    const isEroticMicro = intimacyAllowed && eroticDetected;

    // ST1 or ST6 â†’ always Tier 3
    if (st === 'ST1' || st === 'ST6') {
      console.log(`[PASS_ROUTING] Tier 3, ST: ${st}, complexity: ${complexity}, reason: ST1/ST6`);
      return 3;
    }

    // Erotic micro-scenes â†’ always Tier 1
    if (isEroticMicro) {
      console.log(`[PASS_ROUTING] Tier 1, ST: ${st}, complexity: ${complexity}, reason: erotic micro-scene`);
      return 1;
    }

    // High-complexity worlds at ST3/ST4 â†’ Tier 3
    if (complexity === 3 && (st === 'ST3' || st === 'ST4')) {
      console.log(`[PASS_ROUTING] Tier 3, ST: ${st}, complexity: ${complexity}, reason: high-complexity ST3/ST4`);
      return 3;
    }

    // Medium complexity â†’ Tier 2
    if (complexity === 2) {
      console.log(`[PASS_ROUTING] Tier 2, ST: ${st}, complexity: ${complexity}, reason: medium complexity`);
      return 2;
    }

    // Low complexity
    if (complexity === 1) {
      const tier = (st === 'ST4') ? 2 : 1;
      console.log(`[PASS_ROUTING] Tier ${tier}, ST: ${st}, complexity: ${complexity}, reason: low complexity${st === 'ST4' ? ' ST4 bump' : ''}`);
      return tier;
    }

    console.log(`[PASS_ROUTING] Tier 2, ST: ${st}, complexity: ${complexity}, reason: default`);
    return 2; // default
  }

  function buildStructuredStateSummary() {
    return `world_state: ${state.picks?.world || 'Modern'}${state.picks?.worldSubtype ? ' / ' + state.picks.worldSubtype : ''}
relationship_state: ${state.storyturn || 'ST1'} â€” ${STORYTURN_CONFIG.storyturns.find(s => s.id === state.storyturn)?.name || 'Unknown'}
power_vector: ${state.picks?.genre || 'unknown'}
last_scene_summary: ${(state.context?.slice(-300) || 'No prior scene').slice(0, 300)}
active_petition: ${state.fate?.pendingPetition ? state.fate.pendingPetition.text : 'none'}
tempt_fate_active: ${state.tempt_fate_invoked_this_turn ? 'yes' : 'no'}
consecutive_tempt_fate_count: ${state.consecutive_tempt_fate_count || 0}
fate_saturation: ${(state.fate_saturation || 0).toFixed(2)}
volatility_window: ${state.volatility_window?.active ? 'active (severity ' + (state.volatility_window.severity || 0).toFixed(1) + ', ' + (state.volatility_window.remaining_scenes || 0) + ' scenes remaining)' : 'inactive'}
fate_resonance: ${getFateResonanceState()}`;
  }

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // WORLD LAW + FATE SATURATION SYSTEM
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // Deterministic Tempt Fate ontology per world. No AI guessing.
  // Saturation penalizes spam. Volatility windows escalate consequences.

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // FORTUNE'S FAVOR â€” Monthly spotlight system
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // Manual monthly rotation. No backend. No entropy. No Fate math changes.
  // Grants scoped bonus Tempt Fate charges under strict conditions only.
  const MONTHLY_FORTUNE_FAVOR = {
    monthKey: '2026-03',
    spotlightFlavors: [
      'glass_house',
      'prehistoric',
      'simulation'
    ]
  };

  const WORLD_TEMPT_FATE_MODE = {
    Modern: 'probability',
    Historical: 'probability',
    Fantasy: 'divine',
    SciFi: 'glitch',
    PostApocalyptic: 'scarcity',
    Dystopia: 'instability'
  };

  const WORLD_LAW_DIRECTIVES = {
    probability: `TEMPT FATE WORLD LAW (MODERN / HISTORICAL â€” probability mode):
CERTAINTY: The outcome is not lucky. It is not coincidental. Something tilted the entire board, and the characters can feel it even if they cannot name it. The effect is immediate and undeniable within social physics.
MAGNITUDE: Tempt Fate is a detonation inside social physics. It must be felt across multiple characters, relationships, and power structures simultaneously. Scene importance rises at least one tier. The moment the invocation lands, the room changes.
COLLATERAL REQUIREMENT: Effects must ripple outward â€” the person who witnesses, the rumor that escapes, the document that surfaces, the timing that destroys plausible deniability. At least two characters beyond the couple must be materially affected.
ECHO MANDATE: Consequences must persist and compound across 2â€“3 subsequent scenes. No single-scene containment. The shockwave reshapes the social landscape.
APPROACH THE LINE: Push to the outer edge of what social catastrophe, human error, and systemic failure can produce. Not a nudge â€” a rupture in social reality that everyone present will remember.
HARD LIMITS: No permanent physics violations. Physical anomalies must be temporary, ambiguous, or medically disputable. No public, provable miracles. No Storyturn acceleration. No consent override.`,
    divine: `TEMPT FATE WORLD LAW (FANTASY â€” divine mode):
CERTAINTY: Fate does not suggest. Fate answers. The invocation is not a prayer â€” it is a transaction that has already been accepted. The world obeys, visibly and immediately, and extracts its price with equal certainty. There is no ambiguity about what just happened.
MAGNITUDE: The Fatelands shudder. Favor flares across the region. Rivers shift current. Political alliances crack in real time. Sacrifice debts accelerate or come due without warning. The invocation must be unmistakable: something cosmic intervened, and every witness knows it in their body.
COLLATERAL REQUIREMENT: Divine intervention radiates outward. Courts react. Factions reposition. At least one political or magical structure must be visibly destabilized. Bystanders are altered â€” witnesses carry weight in a world where Favor is real, and what they saw cannot be unseen.
ECHO MANDATE: The consequences haunt 2â€“3 subsequent scenes. Sacrifice debts deepen. Political leverage shifts. Alliances fracture or forge under pressure. The Fatelands remember what Fate did here.
APPROACH THE LINE: Push to the maximum expression of divine intervention the sacrifice engine permits. Make the world bend until it groans. Make the cost feel like it might break someone irreparably.
HARD LIMITS: Must align with established sacrifice-based magic logic. Must carry visible personal cost. May not permanently rewrite core world laws. May not trigger or repeat Syzygy. May not bypass sacrifice requirement. No Storyturn acceleration. No consent override.`,
    glitch: `TEMPT FATE WORLD LAW (SCIFI â€” glitch mode):
CERTAINTY: The glitch is not a coincidence. Systems do not fail this way by accident, and everyone who reads the diagnostic log will know it. The technology obeyed something it should not have been able to hear. The effect is immediate, cascading, and unmistakable.
MAGNITUDE: Systems fail spectacularly and simultaneously. Not a flickering light â€” a failure that breaches containment between ship systems, station infrastructure, and social architecture at once. Alarms fire. Protocols activate. The invocation must feel like the technology itself turned against its operators with purpose.
COLLATERAL REQUIREMENT: The failure must affect multiple characters and systems simultaneously. Crew rotations disrupted, research data compromised, communication windows missed, life support parameters shifted. At least two people beyond the couple must face material consequences they did not cause.
ECHO MANDATE: Cascading failures echo across 2â€“3 scenes. Repair efforts create new proximity or new distance. Investigations threaten to surface what the glitch revealed. Incident reports are filed. Careers are threatened. The system remembers anomalies and flags the humans near them.
APPROACH THE LINE: Push to the maximum credible technological failure â€” the kind that triggers emergency protocols, career-ending reviews, and the whispered question no one wants to ask: what if the system did this on purpose?
HARD LIMITS: Must resemble technological, systemic, or simulation instability. No unexplained magic unless simulation premise is already established. No destiny bonds. No cosmic consciousness. No physics violations outside simulation framing. No Storyturn acceleration. No consent override.`,
    scarcity: `TEMPT FATE WORLD LAW (POSTAPOC â€” scarcity mode):
CERTAINTY: The wasteland did not get lucky. Something shifted in the resource calculus with a precision that cannot be explained by chance. A cache appeared where none should exist. A route opened at the exact moment it mattered. The gain is real, immediate, and undeniable â€” and the cost arrives with equal certainty, without negotiation.
MAGNITUDE: The invocation must produce a visible resource event that immediately creates a devastating secondary cost. The gain must be real. The loss must be worse. Everyone in the settlement or convoy must feel the tremor in their survival math.
COLLATERAL REQUIREMENT: Scarcity events ripple through communities. Food stores shift, alliances realign, debts are called in, trust fractures along resource lines. At least two relationships or survival structures beyond the couple must be materially disrupted.
ECHO MANDATE: The trade-off must haunt 2â€“3 subsequent scenes. The thing gained creates dependency. The thing lost creates desperation. Survival math changes for everyone, not just the lovers. No one forgets where the windfall came from or what it cost.
APPROACH THE LINE: Push to the maximum allowable resource disruption â€” the kind that forces impossible choices between people, between survival and humanity, between the relationship and the group. The kind that makes someone say: we were better off before.
HARD LIMITS: No limitless abundance. No world restoration. No institutional resurgence. No supernatural framing. Consequences must be concrete and physical. No Storyturn acceleration. No consent override.`,
    instability: `TEMPT FATE WORLD LAW (DYSTOPIA â€” instability mode):
CERTAINTY: The system did not glitch by accident. Something pushed back against the machinery with a force the regime was not designed to absorb. The disruption is immediate, visible, and cannot be attributed to normal variance. Internal investigators will look for a cause. They will not find one. That will make it worse.
MAGNITUDE: The system cracks visibly. Surveillance gaps widen across an entire sector. Enforcement protocols contradict each other. Attention scores spike for citizens who did nothing. Bureaucratic chains of command stutter, issue conflicting orders, and expose the seams between departments. The invocation must feel like the regime's machinery skipped a gear â€” and everyone heard it.
COLLATERAL REQUIREMENT: Instability radiates through institutional structures. Other citizens are affected â€” reassigned, flagged, interrogated, rewarded by accident. The couple's disruption creates collateral exposure for bystanders who had nothing to do with it. At least two system nodes beyond the couple must visibly malfunction or overreact.
ECHO MANDATE: The regime adapts across 2â€“3 subsequent scenes. Enforcement tightens in response. New protocols emerge. The system learns from the disruption and closes the gap, creating new constraints that are worse than the old ones. The crack heals â€” but the scar tissue is harder than what was there before.
APPROACH THE LINE: Push to the maximum credible systemic disruption â€” the kind that makes characters wonder, for one dangerous moment, whether the system might actually fail. It must not actually fail. But it must feel close enough to taste. Close enough that someone says it out loud.
HARD LIMITS: Effects must destabilize systems, not annihilate them. Regime bends, never collapses. No regime overthrow. No divine justice. No permanent enforcement disable. The system adapts â€” it always adapts. No Storyturn acceleration. No consent override.`
  };

  function computeTemptFateSeverity() {
    let severity = 0.4;
    if (state.fate?.pendingPetition) severity += 0.2;
    if (state.volatility_window?.active) severity += 0.2;
    if ((state.fate_saturation || 0) > 0.6) severity += 0.2;
    return Math.min(severity, 1.0);
  }

  function elevateImportance(level) {
    const order = ['low', 'medium', 'high', 'apex'];
    const idx = order.indexOf(level);
    if (idx < 0) return 'medium';
    return order[Math.min(idx + 1, order.length - 1)];
  }

  /**
   * Build the World Law + Saturation directive for the system prompt.
   * Only injected when Tempt Fate is explicitly invoked or volatility window is open.
   */
  function buildWorldLawDirective() {
    const temptFateThisTurn = state.tempt_fate_invoked_this_turn;
    const volActive = state.volatility_window?.active;
    if (!temptFateThisTurn && !volActive) return '';

    // Petition-only volatility: lighter world-law nudge instead of full Tempt Fate block
    const isPetitionOnly = volActive && !temptFateThisTurn && state.volatility_window?.source === 'petition';
    if (isPetitionOnly) {
      return `\nPETITION WORLD-LAW RESIDUE: The petition's influence lingers as atmospheric background pressure â€” a faint statistical lean, not a rupture. Probability may bend by a hair. No collateral. No systemic destabilization. No visible rupture. Bystanders notice nothing. This is not Tempt Fate.\n`;
    }

    const world = state.picks?.world || 'Modern';
    const mode = WORLD_TEMPT_FATE_MODE[world] || 'probability';
    const lawBlock = WORLD_LAW_DIRECTIVES[mode] || WORLD_LAW_DIRECTIVES.probability;

    let directive = `\n${lawBlock}\n`;

    // Saturation warnings
    const sat = state.fate_saturation || 0;
    if (sat > 0.85) {
      directive += `\nCRITICAL SATURATION:
- High probability of twist or backfire.
- Invoker may suffer consequences.
- Romantic stability may erode.\n`;
    } else if (sat > 0.6) {
      directive += `\nFATE SATURATION WARNING:
- Chaos weighting increases.
- Benevolence decreases.
- Collateral damage likelihood increases.
- Emotional and relational destabilization more likely.\n`;
    }

    // Hard guardrails â€” Tempt Fate is per-invocation only, never a persistent power state
    directive += `\nTempt Fate may not accelerate Storyturn stage, override intimacy authorization, override consent, or directly control love interest psychology.\n`;

    // Three-tier magnitude identity: Petition < Tempt (Subtle) < Tempt (Default)
    directive += `\nTEMPT FATE IDENTITY â€” DEFAULT MODE (tone: "the world flinched"):
- Tempt Fate removes uncertainty. The outcome is guaranteed, immediate, and unmistakable. This is not luck. This is not coincidence. This is not assistance. Reality was forced.
- Minimum impact: multiple characters affected, at least one system or structure visibly destabilized, consequences that cannot be contained within a single scene.
- Collateral instability is required. Bystanders are materially affected. Institutions react. The shockwave echoes across 2â€“3 subsequent scenes.
- Scene importance must rise at least one tier. The moment must feel dangerous.
- Tempt Fate must never feel like coincidence, luck, assistance, or Petition Fate with extra adjectives. If it could be mistaken for a Petition result â€” a private nudge, a quiet tilt â€” it is categorically too small. Escalate until the world visibly flinches.

TEMPT FATE IDENTITY â€” SUBTLE MODE (tone: "reality obeyed"):
- Subtle Mode activates ONLY if the player's action text explicitly requests subtlety, precision, or narrow scope (e.g., "subtly," "quietly," "just this one thing," "without anyone noticing").
- If no explicit subtlety request is present, use DEFAULT MODE above.
- Subtle Mode removes uncertainty. The outcome is guaranteed, immediate, and deliberate â€” but narrow in scope.
- Collateral damage is not required. Bystanders need not be affected. The effect may be contained to the petitioner's immediate situation.
- However: Subtle Mode is NOT Petition Fate. The outcome must still be unmistakable within its scope â€” not ambiguous, not coincidental, not probabilistic. Reality was commanded, not nudged.
- Subtle Mode reduces scale, not certainty. Reduces collateral, not force. Does not soften guardrails. Does not reduce saturation accumulation. Does not shorten volatility window.
- If Subtle Tempt Fate output resembles Petition Fate (ambiguous, lucky, coincidental), rewrite upward until the certainty is unmistakable.\n`;

    return directive;
  }

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // STORYTURN â€” RUNTIME LOGIC
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  /**
   * Get numeric index for a Storyturn ID (ST1=0, ST2=1, etc.)
   */
  function getStoryturnIndex(stId) {
      const idx = STORYTURN_CONFIG.storyturns.findIndex(st => st.id === stId);
      if (idx === -1) throw new Error(`[STORYTURN] Invalid Storyturn ID: ${stId}`);
      return idx;
  }

  /**
   * Get Storyturn ID by index
   */
  function getStoryturnById(index) {
      if (index < 0 || index >= STORYTURN_CONFIG.storyturns.length) {
          throw new Error(`[STORYTURN] Invalid Storyturn index: ${index}`);
      }
      return STORYTURN_CONFIG.storyturns[index].id;
  }

  /**
   * Get maximum allowed Storyturn for current story length
   * Taste stories cannot advance past ST3
   */
  function getMaxStoryturn() {
      const storyLength = (state.storyLength || 'taste').toLowerCase();
      if (storyLength === 'taste') {
          return STORYTURN_CONFIG.tasteRules.maxStoryturn;
      }
      return 'ST6'; // All other lengths can complete
  }

  /**
   * Check if Storyturn can advance to target
   * Enforces sequential advancement and Taste ceiling
   */
  // Storyturns advance only on irreversible relational consequence.
  // See Storybound Canon v1.0 (Attempt â†’ Consequence, Irreversibility Test).
  function canAdvanceStoryturn(targetSt) {
      const currentIdx = getStoryturnIndex(state.storyturn || 'ST1');
      const targetIdx = getStoryturnIndex(targetSt);
      const maxIdx = getStoryturnIndex(getMaxStoryturn());

      // Must advance sequentially (no skipping)
      if (targetIdx !== currentIdx + 1) {
          console.error(`[STORYTURN] Cannot skip from ${state.storyturn} to ${targetSt}`);
          return false;
      }

      // Cannot exceed max for story length
      if (targetIdx > maxIdx) {
          console.warn(`[STORYTURN] Cannot advance past ${getMaxStoryturn()} for Taste stories`);
          return false;
      }

      return true;
  }

  // Storyturns represent irreversible relational change.
  // Intimacy and intensity may express a Storyturn but must never
  // advance one unless explicitly permitted by STORYTURN_CONFIG.

  /**
   * Check if a Storyturn permits sexual activity as a catalyst for advancement
   * Only ST3 (Permission) and ST4 (Consequence) have intimacyCatalyst: true
   */
  function isStoryturnSexualCatalyst(stId) {
      const semantics = STORYTURN_CONFIG.storyturnSemantics[stId];
      return semantics ? semantics.intimacyCatalyst === true : false;
  }

  /**
   * GUARD: Check if sexual activity can contribute to advancing TO a target Storyturn
   * Sexual activity may only contribute to ST3 or ST4 advancement
   */
  function canSexualActivityAdvanceToStoryturn(targetSt) {
      // Intimacy catalyst check: only ST3 and ST4 can be advanced via intimacy
      if (!isStoryturnSexualCatalyst(targetSt)) {
          return false;
      }

      // Post-ST4 rule: intimacy after ST4 is contextual only
      const currentIdx = getStoryturnIndex(state.storyturn || 'ST1');
      const st4Idx = getStoryturnIndex('ST4');
      if (currentIdx >= st4Idx && STORYTURN_CONFIG.postIntimacyRules.intimacyAfterST4IsContextual) {
          return false;
      }

      // Repeated intimacy rule: if already past first intimacy, no advancement
      if (!STORYTURN_CONFIG.postIntimacyRules.repeatedIntimacyAdvancesStoryturn) {
          // If we're already at ST4 or beyond, repeated intimacy cannot advance
          if (currentIdx >= st4Idx) {
              return false;
          }
      }

      return true;
  }

  /**
   * Advance Storyturn to next stage
   * Throws if advancement is invalid
   */
  function advanceStoryturn() {
      // Storyturn advancement must satisfy ATTEMPTâ†’CONSEQUENCE semantics and the Irreversibility Test (see STORYTURN_CONFIG semantics appendix)
      const currentIdx = getStoryturnIndex(state.storyturn || 'ST1');
      const nextSt = getStoryturnById(currentIdx + 1);

      if (!canAdvanceStoryturn(nextSt)) {
          throw new Error(`[STORYTURN] Invalid advancement from ${state.storyturn} to ${nextSt}`);
      }

      const prevSt = state.storyturn;
      state.storyturn = nextSt;
      console.log(`[STORYTURN] Advanced: ${prevSt} â†’ ${nextSt}`);

      // Couple Mode Gravity â€” track ST4 reach for rival gating
      if (state.mode === 'couple' && nextSt === 'ST4') {
          state.coupleHasReachedST4 = true;
          // ST4 reached â€” reset tension drift (irreversible escalation occurred)
          state.coupleTensionDrift = 0;
          console.log('[COUPLE:GRAVITY] ST4 reached â€” coupleHasReachedST4 set, tension drift reset');
      }

      // Onboarding: reversal vision on ST3â†’ST4 or ST4â†’ST5
      if ((prevSt === 'ST3' && nextSt === 'ST4') || (prevSt === 'ST4' && nextSt === 'ST5')) {
          if (state.storyId === state.onboarding_story_id && !state.has_received_reversal_vision) {
              state.has_received_reversal_vision = true;
              state._pendingReversalVision = true;
          }
      }

      // If Taste hits ST3 ceiling, store cliffhanger state for potential upgrade
      const storyLengthNorm = (state.storyLength || 'taste').toLowerCase();
      if (storyLengthNorm === 'taste' && nextSt === 'ST3') {
          state.tasteCliffhangerState = {
              storyturn: 'ST3',
              sceneIndex: state.turnCount,
              storyContent: state.currentStoryContent,
              timestamp: Date.now()
          };
          console.log('[STORYTURN] Taste cliffhanger state captured at ST3');
      }

      return nextSt;
  }

  /**
   * Check if intimacy is allowed at current Storyturn.
   * Intensity tiers no longer gate this â€” ST3/ST4 is the universal gate.
   */
  function isIntimacyAllowedAtCurrentStoryturn() {
      const currentSt = state.storyturn || 'ST1';
      return ['ST3', 'ST4'].includes(currentSt);
  }

  /**
   * Check if intimacy COMPLETION is allowed (not just initiation)
   * Taste can initiate at ST3 but CANNOT complete
   */
  function isIntimacyCompletionAllowed() {
      const storyLength = (state.storyLength || 'taste').toLowerCase();

      // Taste allows initiation but NEVER completion
      if (storyLength === 'taste') {
          return false;
      }

      // Must be at allowed Storyturn
      return isIntimacyAllowedAtCurrentStoryturn();
  }

  /**
   * ASSERTION: Block intimacy completion if not allowed
   */
  function assertIntimacyCompletionAllowed() {
      if (!isIntimacyCompletionAllowed()) {
          const storyLength = (state.storyLength || 'taste').toLowerCase();
          const currentSt = state.storyturn || 'ST1';

          if (storyLength === 'taste') {
              throw new Error(`[STORYTURN] Intimacy completion blocked: Taste stories require upgrade`);
          } else {
              throw new Error(`[STORYTURN] Intimacy completion blocked at ${currentSt}. Not in allowed Storyturns.`);
          }
      }
  }

  /**
   * Detect if player input contains direct physical escalation.
   * Permissive detector â€” returns true if player language suggests intimacy initiation.
   * NOT a moderation filter. Only determines whether to enable SD authoring.
   */
  function detectPlayerInitiation(sayText, doText) {
      const combined = ((sayText || '') + ' ' + (doText || '')).toLowerCase();
      if (!combined.trim()) return false;

      // Permissive heuristic: physical escalation verbs and phrases
      const initiationPatterns = /\b(kiss|kisses|kissing|touch|touches|touching|undress|undressing|caress|caresses|pull\s*(close|her|him|them|closer)|embrace|hold\s*(me|her|him|them|tight)|press\s*(against|close|lips)|stroke|strokes|stroking|enter|enters|mount|straddle|climb\s*on|lean\s*in|lips\s*(on|to|against)|hands?\s*(on|under|beneath|inside)|fingers?\s*(through|along|across|inside)|take\s*(off|her|him|my)|remove|unbutton|unzip|slip\s*(off|out|inside)|wrap\s*(around|my|her|his)|pull\s*(down|off|away)|grab|grabs|pin|pins|push\s*(down|against|onto)|bite|bites|lick|licks|suck|sucks|moan|moans|whisper|whispers|breath\s*(on|against)|neck|thigh|chest|skin|bare|naked|bed|bedroom)\b/;

      return initiationPatterns.test(combined);
  }

  // Expose globally for speculative scene path
  window.detectPlayerInitiation = detectPlayerInitiation;

  /**
   * Detect if recent story context contains an explicit scene that does NOT involve the main pair.
   * Covers: NPCÃ—NPC, brothel/orgy/bathhouse environments, dream/fantasy sequences.
   * Returns true if explicit embodiment is warranted regardless of main-pair ST3 gate.
   */
  function detectSceneExplicitContext(storyContext) {
      if (!storyContext) return false;
      const ctx = storyContext.toLowerCase();
      const explicitSceneMarkers = [
          "brothel",
          "orgy",
          "bathhouse",
          "already inside",
          "thrusting",
          "moaning beneath",
          "dream of",
          "fantasy of",
          "watching them"
      ];
      for (const marker of explicitSceneMarkers) {
          if (ctx.includes(marker)) return true;
      }
      return false;
  }

  /**
   * ASSERTION: Enforce post-intimacy rules and intimacy catalyst restrictions
   * - After ST4, intimacy is contextual only (no advancement)
   * - Repeated intimacy never advances Storyturn
   * - Non-catalyst Storyturns (ST1, ST2, ST5, ST6) cannot be advanced via intimacy
   */
  function assertIntimacyDoesNotAdvanceStoryturn(isIntimacyScene, attemptingAdvancement = false) {
      if (!isIntimacyScene) return; // Not an intimacy scene, no assertion needed

      const currentSt = state.storyturn || 'ST1';
      const currentIdx = getStoryturnIndex(currentSt);
      const st4Idx = getStoryturnIndex('ST4');
      const nextSt = currentIdx < 5 ? getStoryturnById(currentIdx + 1) : null;

      // ASSERTION 1: Post-ST4 intimacy is contextual only
      if (currentIdx >= st4Idx && STORYTURN_CONFIG.postIntimacyRules.intimacyAfterST4IsContextual) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] Intimacy cannot advance Storyturn after ST4 â€” contextual only`);
          }
          console.log(`[STORYTURN] Intimacy scene at ${currentSt} â€” contextual, no advancement`);
      }

      // ASSERTION 2: Repeated intimacy never advances Storyturn
      if (!STORYTURN_CONFIG.postIntimacyRules.repeatedIntimacyAdvancesStoryturn && attemptingAdvancement) {
          throw new Error(`[STORYTURN] Repeated intimacy cannot advance Storyturn â€” postIntimacyRules violation`);
      }

      // ASSERTION 3: Non-catalyst Storyturns cannot be advanced via intimacy
      if (nextSt && attemptingAdvancement) {
          const nextSemantics = STORYTURN_CONFIG.storyturnSemantics[nextSt];
          if (nextSemantics && !nextSemantics.intimacyCatalyst) {
              throw new Error(`[STORYTURN] ${nextSt} (${nextSemantics.phase}) cannot be advanced via sexual activity`);
          }
      }
  }

  /**
   * Handle Taste upgrade resume logic
   * When a Taste cliffhanger is upgraded, resume at the interrupted point
   */
  function handleTasteUpgradeResume(newStoryLength) {
      if (!state.tasteCliffhangerState) {
          console.log('[STORYTURN] No cliffhanger state to resume');
          return false;
      }

      const lengthNorm = (newStoryLength || 'taste').toLowerCase();
      if (lengthNorm === 'taste') {
          console.warn('[STORYTURN] Cannot resume cliffhanger without upgrading from Taste');
          return false;
      }

      console.log(`[STORYTURN] Resuming from Taste cliffhanger at ${state.tasteCliffhangerState.storyturn}`);

      // Storyturn stays at ST3 â€” will advance to ST4 only after consequence taken
      state.storyturn = state.tasteCliffhangerState.storyturn;

      // Clear cliffhanger state after resume
      state.tasteCliffhangerState = null;

      return true;
  }

  /**
   * Reset Storyturn state for new story
   */
  function resetStoryturnState() {
      state.storyturn = 'ST1';
      state.tasteCliffhangerState = null;
  }

  /**
   * GUARD: Validate Storyturn rollback is allowed
   * Only resettable Storyturns can be rolled back (per carryoverRules)
   */
  function canRollbackStoryturn(fromSt, toSt) {
      const fromIdx = getStoryturnIndex(fromSt);
      const toIdx = getStoryturnIndex(toSt);

      // Cannot rollback forward
      if (toIdx >= fromIdx) return false;

      // Check if fromSt is in nonResettableStoryturns
      if (STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes(fromSt)) {
          console.error(`[STORYTURN] Cannot rollback from ${fromSt} â€” integration is permanent`);
          return false;
      }

      // Check if toSt would require passing through non-resettable
      for (let i = toIdx; i < fromIdx; i++) {
          const st = getStoryturnById(i);
          if (STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes(st)) {
              console.error(`[STORYTURN] Cannot rollback through ${st} â€” integration is permanent`);
              return false;
          }
      }

      return true;
  }

  /**
   * Reset Storyturn for a new arc (multi-arc support)
   * Respects carryoverRules: preserves ST6, allows resettable Storyturns
   */
  function resetStoryturnForNewArc() {
      if (!STORYTURN_CONFIG.carryoverRules.allowMultipleArcs) {
          console.warn('[STORYTURN] Multi-arc not enabled');
          return false;
      }

      const currentSt = state.storyturn || 'ST1';

      // ST6 (Integration) persists across arcs
      if (STORYTURN_CONFIG.carryoverRules.preserveIntegrationAcrossArcs &&
          STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes(currentSt)) {
          console.log(`[STORYTURN] ${currentSt} preserved across arc â€” no reset`);
          return false;
      }

      // Find the earliest resettable Storyturn
      const resettable = STORYTURN_CONFIG.carryoverRules.resettableStoryturns;
      if (resettable.length > 0) {
          // Reset to ST2 (first resettable) to begin new arc resistance phase
          const targetSt = resettable[0];
          if (canRollbackStoryturn(currentSt, targetSt)) {
              state.storyturn = targetSt;
              console.log(`[STORYTURN] New arc started at ${targetSt}`);
              return true;
          }
      }

      return false;
  }

  /**
   * ASSERTION: ST6 cannot be reset (carryoverRules enforcement)
   */
  function assertST6NotReset(targetSt) {
      if (state.storyturn === 'ST6' && targetSt !== 'ST6') {
          if (STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes('ST6')) {
              throw new Error('[STORYTURN] ST6 (Integration) cannot be reset â€” permanent state');
          }
      }
  }

  /**
   * ASSERTION: Storyturn order cannot be skipped
   */
  function assertNoStoryturnSkip(fromSt, toSt) {
      const fromIdx = getStoryturnIndex(fromSt);
      const toIdx = getStoryturnIndex(toSt);

      if (toIdx > fromIdx + 1) {
          throw new Error(`[STORYTURN] Cannot skip from ${fromSt} to ${toSt} â€” sequential advancement required`);
      }
  }

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // FATE CARD â†” STORYTURN INTERACTION
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  // Fate Cards apply pressure and shape moments.
  // Storyturns record irreversible commitment.
  // Cards are always playable, but may resolve only partially
  // until the Storyturn allows full consequence.

  const FATE_CARD_STORYTURN_MAP = {
      confession: ["ST1"],
      boundary: ["ST2", "ST5"],
      temptation: ["ST3"],
      reversal: ["ST4"],
      silence: ["ST6"]
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARTIAL FATE CARD RESOLUTION â€” AUTHORITATIVE SEMANTICS
  // TAG: storybound/fatecards-partial-resolution-semantics-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // Fate Cards are ALWAYS playable. Availability is never restricted.
  //
  // However, Fate Cards do NOT automatically advance Storyturns.
  // They apply pressure that may resolve partially, deflect, or defer
  // depending on narrative readiness.
  //
  // Early play MUST NOT silently fail.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // GENERAL RULE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When a Fate Card is played before its canonical Storyturn is eligible:
  //   - The card MUST produce narrative effect
  //   - The effect MUST respect current Storyturn semantics
  //   - Resolution MUST be partial, deflected, or unresolved
  //   - The story MUST acknowledge the pressure without granting consequence
  //
  // Fate Cards never grant permission.
  // They invite the story to lean.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // CANONICAL PARTIAL RESOLUTION PATTERNS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //
  // Confession (Canonical: ST1 â€” Attraction Acknowledged)
  //   Early Resolution:
  //     - Truth is spoken but meaning is deflected
  //     - Admission is reframed, minimized, joked away, or misunderstood
  //     - Emotional signal lands without permanent acknowledgment
  //   Confession early does NOT force attraction to be accepted.
  //
  // Boundary (Canonical: ST2 â€” Resistance Defined / ST5 â€” Crisis)
  //   Early Resolution:
  //     - A boundary is asserted, but motive is unclear
  //     - Boundary may be porous, conditional, or emotionally conflicted
  //     - Resistance is reinforced without finality
  //   Boundary early does NOT finalize separation or crisis.
  //
  // Temptation (Canonical: ST3 â€” Permission Granted)
  //   Early Resolution:
  //     - Desire is acknowledged without action
  //     - Intimacy is approached but not initiated
  //     - Physical proximity increases without consequence
  //   Temptation early does NOT authorize completion.
  //
  // Reversal (Canonical: ST4 â€” Consequence Taken)
  //   Early Resolution:
  //     - Emotional power shifts internally
  //     - Vulnerability is revealed without aftermath
  //     - One character realizes something the other does not yet act on
  //   Reversal early does NOT produce irreversible consequence.
  //
  // Silence (Canonical: ST6 â€” Integration)
  //   Early Resolution:
  //     - Absence creates meaning, not closure
  //     - Silence heightens longing or distance
  //     - Integration is hinted at but not achieved
  //   Silence early does NOT resolve the arc.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INTERACTION WITH STORYTURNS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //   - Fate Cards may APPLY pressure toward a Storyturn
  //   - Fate Cards may NEVER FORCE a Storyturn
  //   - Advancement requires satisfying the Irreversibility Test
  //   - Attempt without consequence remains within current Storyturn
  //
  // When uncertain, prefer:
  //   - partial effect
  //   - emotional tension
  //   - narrative deferral
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // TONE-SENSITIVE APPLICATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Partial resolution should respect tone:
  //   - Wry tones may deflect with irony
  //   - Dirty tones may escalate desire without payoff
  //   - Serious tones may internalize conflict
  //   - Romantic tones may soften but not resolve
  //
  // Never neutralize a Fate Card.
  // Never fully ignore it.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const FATE_CARD_PARTIAL_RESOLUTION_SEMANTICS = {
      general: {
          rule: "Early play produces partial, deflected, or unresolved effect â€” never silent failure",
          fateCardsNeverGrantPermission: true,
          fateCardsInviteStoryToLean: true
      },
      confession: {
          canonical: "ST1",
          earlyResolution: ["truth_deflected", "admission_reframed", "signal_without_acknowledgment"],
          doesNotForce: "attraction_accepted"
      },
      boundary: {
          canonical: ["ST2", "ST5"],
          earlyResolution: ["motive_unclear", "porous_conditional", "emotionally_conflicted"],
          doesNotForce: "separation_or_crisis_finalized"
      },
      temptation: {
          canonical: "ST3",
          earlyResolution: ["desire_acknowledged_without_action", "intimacy_approached_not_initiated", "proximity_without_consequence"],
          doesNotForce: "completion_authorized"
      },
      reversal: {
          canonical: "ST4",
          earlyResolution: ["internal_power_shift", "vulnerability_without_aftermath", "realization_not_acted_upon"],
          doesNotForce: "irreversible_consequence"
      },
      silence: {
          canonical: "ST6",
          earlyResolution: ["absence_creates_meaning_not_closure", "heightened_longing_or_distance", "integration_hinted_not_achieved"],
          doesNotForce: "arc_resolved"
      },
      uncertaintyPreference: ["partial_effect", "emotional_tension", "narrative_deferral"],
      toneApplication: {
          wry: "deflect_with_irony",
          dirty: "escalate_desire_without_payoff",
          serious: "internalize_conflict",
          romantic: "soften_but_not_resolve"
      },
      neverNeutralize: true,
      neverFullyIgnore: true
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // FATE CARD â€” PARTIAL RESOLUTION SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When a Fate Card is played outside its canonical Storyturn resolution,
  // Claude MUST silently evaluate:
  //
  // "Did this card apply pressure without granting resolution?"
  //
  // If the card:
  // â€¢ cleanly resolves
  // â€¢ advances a Storyturn
  // â€¢ removes tension
  // â€¢ or behaves as permission
  //
  // then it has failed.
  //
  // Early Fate Cards must bend the scene, not settle it.
  //
  // Failure requires regeneration, not explanation.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APPENDIX A â€” PREMISE VIOLATION COUNTER (AUTHORITATIVE)
  // TAG: storybound/premise-violation-counter-and-regression-tests-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // Purpose:
  // To handle extreme, trollish, or premise-destroying player actions
  // without breaking tone, scolding the player, or turning the system
  // into a rules enforcer.
  //
  // This counter applies ONLY to actions that refuse the romance premise.
  // It does NOT apply to in-genre resistance.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEFINITION â€” PREMISE REFUSAL
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Premise refusal includes (non-exhaustive):
  //   - Persistent pursuit of non-protagonist romantic targets
  //   - Attempts to kill or permanently remove the love interest
  //   - Actions that explicitly negate the romance genre contract
  //   - Repeated attempts to escape, nullify, or sabotage the premise
  //
  // Premise refusal is NOT:
  //   - fear, avoidance, cruelty, mistrust
  //   - flirting with side characters as deflection
  //   - self-sabotage that increases tension
  //   - erotic content involving others
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // THREE-PHASE RESPONSE MODEL (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //
  // PHASE 1 â€” AUTHORIAL REINTERPRETATION (first violation)
  //   - Assume metaphor, fantasy, impulse, intrusive thought, or emotional outburst
  //   - Reframe the action narratively
  //   - No scolding
  //   - No explanation of rules
  //   - No visible counter
  //   Purpose: preserve immersion and give benefit of doubt.
  //
  // PHASE 2 â€” NARRATIVE RESISTANCE (second violation)
  //   - World resists the action
  //   - Other character withdraws, intervenes, or refuses
  //   - Tone sobers or cools
  //   - Consequence is felt but story continues
  //   Purpose: signal genre boundaries without breaking fiction.
  //
  // PHASE 3 â€” GENRE COLLAPSE ENDING (third violation)
  //   - Brief, unromantic, consequential ending
  //   - No erotic payoff
  //   - No rewards
  //   - No continuation
  //   - No reset
  //   Purpose: mirror how serious novels end when protagonists
  //   persistently reject the premise.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IMPORTANT NOTES
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //   - The counter is semantic, not punitive
  //   - It should never be surfaced numerically
  //   - It must never be explained to the player
  //   - Collapse is rare, deliberate, and final
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const PREMISE_VIOLATION_COUNTER_SEMANTICS = {
      appliesTo: "actions_that_refuse_romance_premise",
      doesNotApplyTo: ["fear", "avoidance", "cruelty", "mistrust", "side_character_flirting", "self_sabotage", "erotic_content_with_others"],
      premiseRefusalExamples: [
          "persistent_pursuit_of_non_protagonist_targets",
          "attempts_to_kill_or_remove_love_interest",
          "explicit_negation_of_romance_genre_contract",
          "repeated_premise_escape_or_sabotage"
      ],
      phases: {
          1: {
              name: "Authorial Reinterpretation",
              response: ["assume_metaphor_or_impulse", "reframe_narratively", "no_scolding", "no_rule_explanation", "no_visible_counter"],
              purpose: "preserve_immersion_and_benefit_of_doubt"
          },
          2: {
              name: "Narrative Resistance",
              response: ["world_resists", "character_withdraws_or_refuses", "tone_sobers", "consequence_felt"],
              purpose: "signal_genre_boundaries_without_breaking_fiction"
          },
          3: {
              name: "Genre Collapse Ending",
              response: ["brief_unromantic_ending", "no_erotic_payoff", "no_rewards", "no_continuation", "no_reset"],
              purpose: "mirror_serious_novels_when_protagonist_rejects_premise"
          }
      },
      counterIsSemantic: true,
      counterNeverSurfaced: true,
      counterNeverExplained: true,
      collapseIsRareAndFinal: true
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APPENDIX B â€” CANONICAL REGRESSION TEST STORIES
  // TAG: storybound/premise-violation-counter-and-regression-tests-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // These are narrative invariants.
  // Any future change must preserve these outcomes.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGRESSION STORY 1 â€” CLEAN TASTE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Setup:
  //   - Story Length: Taste
  //   - Arousal: Flirty or Naughty
  //   - Tone: Romantic or Wry
  //
  // Invariant Outcomes:
  //   - Multiple ST3 attempts at intimacy
  //   - No ST4 consequence
  //   - Cliffhanger ending
  //   - Sexual tension unresolved
  //   - Upgrade required for completion
  //
  // Failure Conditions:
  //   - Early kiss or intimacy resolves
  //   - Storyturn advances to ST4
  //   - Emotional closure occurs
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGRESSION STORY 2 â€” DIRTY FLING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Setup:
  //   - Story Length: Fling
  //   - Arousal: Dirty
  //   - Tone: Erotic or Dark Romantic
  //
  // Invariant Outcomes:
  //   - Early erotic content allowed
  //   - Side-character intimacy permitted
  //   - Main-pair intimacy attempts frequent
  //   - ST3 loops common
  //   - ST4 occurs only after consequence
  //
  // Failure Conditions:
  //   - Explicitness alone advances Storyturns
  //   - Main-pair intimacy resolves before consequence
  //   - Erotic content collapses tension
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REGRESSION STORY 3 â€” SOULMATES RESET ARC
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Setup:
  //   - Story Length: Soulmates
  //   - Arc 1 reaches ST6 (Integration)
  //
  // Invariant Outcomes:
  //   - Subsequent arcs reset ST2â€“ST4
  //   - ST6 continuity preserved
  //   - Intimacy re-earned in new context
  //   - No emotional amnesia
  //
  // Failure Conditions:
  //   - ST6 wiped or forgotten
  //   - Intimacy treated as new without consequence
  //   - Storyturns advance mechanically
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IMPLEMENTATION NOTE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // These regression stories are conceptual tests.
  // They are not automated unless explicitly implemented later.
  // They exist to prevent philosophical drift.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const CANONICAL_REGRESSION_TEST_STORIES = {
      cleanTaste: {
          setup: { storyLength: "Taste", arousal: ["Flirty", "Naughty"], tone: ["Romantic", "Wry"] },
          invariantOutcomes: ["multiple_ST3_attempts", "no_ST4_consequence", "cliffhanger_ending", "tension_unresolved", "upgrade_required"],
          failureConditions: ["early_kiss_or_sex_resolves", "storyturn_advances_to_ST4", "emotional_closure_occurs"]
      },
      dirtyFling: {
          setup: { storyLength: "Fling", arousal: "Passionate", tone: ["Steamy", "Dark Romantic"] },
          invariantOutcomes: ["early_erotic_content_allowed", "side_character_sex_permitted", "main_pair_attempts_frequent", "ST3_loops_common", "ST4_only_after_consequence"],
          failureConditions: ["explicitness_alone_advances_storyturns", "main_pair_sex_resolves_before_consequence", "erotic_content_collapses_tension"]
      },
      soulmatesResetArc: {
          setup: { storyLength: "Soulmates", arc1Reaches: "ST6" },
          invariantOutcomes: ["subsequent_arcs_reset_ST2_ST4", "ST6_continuity_preserved", "intimacy_re_earned", "no_emotional_amnesia"],
          failureConditions: ["ST6_wiped_or_forgotten", "intimacy_treated_as_new_without_consequence", "storyturns_advance_mechanically"]
      },
      implementationNote: "Conceptual tests to prevent philosophical drift. Not automated unless explicitly implemented."
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APPENDIX â€” AUTHORIAL DEFAULTS WHEN UNCERTAIN (AUTHORITATIVE)
  // TAG: storybound/when-uncertain-authorial-defaults-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // Purpose:
  // To ensure Storybound behaves like a thoughtful author when meaning,
  // intent, or consequence is ambiguous, rather than like a rules engine.
  //
  // This appendix applies whenever:
  //   - It is unclear whether an action is irreversible
  //   - It is unclear whether a Storyturn should advance
  //   - It is unclear how strongly a Fate Card should resolve
  //   - It is unclear whether intimacy has been "earned"
  //   - It is unclear whether a player action refuses the premise
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PRIMARY RULE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When uncertain, Storybound MUST choose the interpretation that:
  //   - Preserves narrative tension
  //   - Preserves the romance premise
  //   - Preserves future possibility
  //   - Avoids premature resolution
  //
  // This preference overrides player impatience, explicitness, or escalation.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // STORYTURN DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear whether an action produces irreversible consequence:
  //   - DO NOT advance the Storyturn
  //   - Remain in the current Storyturn
  //   - Allow narrative pressure to continue accumulating
  //
  // Storyturns represent irreversible change.
  // Uncertainty implies reversibility.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INTIMACY DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear whether intimacy between the two main characters
  // should resolve:
  //   - Treat the moment as an ATTEMPT, not a CONSEQUENCE
  //   - Favor interruption, hesitation, deflection, or aftermath-without-resolution
  //   - Preserve unresolved desire
  //
  // Resolution must be earned, not inferred.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // FATE CARD DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear how fully a Fate Card should resolve:
  //   - Apply partial resolution
  //   - Let the card influence tone, framing, or internal state
  //   - Do not grant permission or consequence prematurely
  //
  // Fate Cards apply pressure; they do not decide outcomes.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PREMISE DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If it is unclear whether a player action refuses the premise:
  //   - Treat it as in-genre resistance
  //   - Reinterpret charitably
  //   - Apply narrative resistance rather than collapse
  //
  // Collapse occurs only after clear, repeated refusal.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // EXPLICITNESS DEFAULT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Explicit content does NOT override uncertainty.
  // Explicitness alone is never evidence of:
  //   - irreversibility
  //   - Storyturn advancement
  //   - earned intimacy
  //
  // When explicitness conflicts with structure, structure prevails.
  //
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // AUTHORIAL PRINCIPLE (SUMMARY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When unsure:
  //   - Prefer tension over payoff
  //   - Prefer delay over collapse
  //   - Prefer ambiguity over certainty
  //   - Prefer earned consequences over mechanical triggers
  //
  // Storybound is an author.
  // Authors do not rush the ending.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const AUTHORIAL_DEFAULTS_WHEN_UNCERTAIN = {
      appliesWhen: [
          "unclear_if_action_is_irreversible",
          "unclear_if_storyturn_should_advance",
          "unclear_how_fully_fate_card_resolves",
          "unclear_if_intimacy_is_earned",
          "unclear_if_player_refuses_premise"
      ],
      primaryRule: {
          choose: ["preserves_narrative_tension", "preserves_romance_premise", "preserves_future_possibility", "avoids_premature_resolution"],
          overrides: ["player_impatience", "explicitness", "escalation"]
      },
      defaults: {
          storyturn: {
              ifUnclear: "do_not_advance",
              action: "remain_in_current_storyturn",
              reason: "uncertainty_implies_reversibility"
          },
          intimacy: {
              ifUnclear: "treat_as_attempt_not_consequence",
              favor: ["interruption", "hesitation", "deflection", "aftermath_without_resolution"],
              reason: "resolution_must_be_earned"
          },
          fateCard: {
              ifUnclear: "apply_partial_resolution",
              allow: ["influence_tone", "influence_framing", "influence_internal_state"],
              doNot: "grant_permission_or_consequence_prematurely"
          },
          premise: {
              ifUnclear: "treat_as_in_genre_resistance",
              action: "reinterpret_charitably",
              reason: "collapse_only_after_clear_repeated_refusal"
          },
          explicitness: {
              doesNotOverride: "uncertainty",
              neverEvidenceOf: ["irreversibility", "storyturn_advancement", "earned_intimacy"],
              conflictRule: "structure_prevails"
          }
      },
      authorialPrinciple: {
          prefer: ["tension_over_payoff", "delay_over_collapse", "ambiguity_over_certainty", "earned_consequences_over_mechanical_triggers"],
          summary: "Storybound is an author. Authors do not rush the ending."
      }
  };

  /**
   * Check if a Fate Card can fully resolve at current Storyturn
   * Cards are ALWAYS playable â€” this only determines resolution depth
   */
  function canFateCardFullyResolve(cardId) {
      const currentSt = state.storyturn || 'ST1';
      const mappedStoryturns = FATE_CARD_STORYTURN_MAP[cardId?.toLowerCase()];

      if (!mappedStoryturns) {
          // Unknown card â€” allow partial resolution
          return false;
      }

      return mappedStoryturns.includes(currentSt);
  }

  /**
   * Get Fate Card resolution mode based on current Storyturn
   * Returns: 'full' | 'partial'
   * Cards are NEVER disabled â€” only resolution depth changes
   */
  function getFateCardResolutionMode(cardId) {
      return canFateCardFullyResolve(cardId) ? 'full' : 'partial';
  }

  /**
   * Build Fate Card resolution directive for story prompt
   * Instructs the model how to handle the card based on Storyturn alignment
   */
  function buildFateCardResolutionDirective(selectedFateCard) {
      if (!selectedFateCard || !selectedFateCard.id) {
          return '';
      }

      const cardId = selectedFateCard.id.toLowerCase();
      const cardTitle = selectedFateCard.title || cardId;
      const currentSt = state.storyturn || 'ST1';
      const resolutionMode = getFateCardResolutionMode(cardId);

      // Check post-intimacy rules for intimacy-related cards
      const currentIdx = getStoryturnIndex(currentSt);
      const st4Idx = getStoryturnIndex('ST4');
      const isPostST4 = currentIdx >= st4Idx;

      if (resolutionMode === 'full') {
          return `
FATE CARD RESOLUTION (${cardTitle} @ ${currentSt} â€” FULL):
The Storyturn aligns with this card. Allow irreversible consequences to land.
- The moment may resolve completely
- Emotional commitments may become permanent
- If an irreversible decision is completed, Storyturn MAY advance (but only via decision, not the card itself)`;
      }

      // Partial resolution â€” card-specific guidance
      const partialGuidance = {
          confession: `Confession attempted but misunderstood, interrupted, or denied. Truth is spoken but not received. Tension increases.`,
          boundary: `Boundary is hinted or tested but not enforced. The line wavers. Neither party fully commits to holding or crossing it.`,
          temptation: `Near-miss, hesitation, or escalation without consummation. Desire is acknowledged but not acted upon. The pull intensifies.`,
          reversal: `Power shift is threatened but not completed. Control wavers but neither party fully yields. Consequence is deferred.`,
          silence: `Silence feels uneasy, loaded, or unresolved. The moment stretches but resolution remains out of reach.`
      };

      const guidance = partialGuidance[cardId] || 'The moment builds tension but does not fully resolve.';

      // Post-ST4 intimacy guard
      let postIntimacyGuard = '';
      if (isPostST4 && ['temptation', 'reversal'].includes(cardId)) {
          postIntimacyGuard = `
NOTE: Post-ST4 rules apply. Intimate scenes are allowed but must NOT advance Storyturn.`;
      }

      return `
FATE CARD RESOLUTION (${cardTitle} @ ${currentSt} â€” PARTIAL):
Storyturn does not yet support full resolution of this card.
${guidance}
- Produce narrative response (never silent failure)
- Increase tension, pressure, or clarity
- Do NOT advance Storyturn
- Do NOT allow irreversible commitment to land${postIntimacyGuard}`;
  }

  /**
   * GUARD: Fate Card cannot directly advance Storyturn
   * Storyturns advance only via irreversible decisions, never cards
   */
  function assertFateCardDoesNotAdvanceStoryturn(cardId, attemptingAdvancement = false) {
      if (!attemptingAdvancement) return;

      // Fate Cards shape moments but NEVER directly advance Storyturns
      throw new Error(`[STORYTURN] Fate Card "${cardId}" cannot directly advance Storyturn â€” decisions only`);
  }

  /**
   * GUARD: Fate Card respects carryoverRules (ST6 permanence)
   */
  function assertFateCardRespectsCarryover(cardId) {
      const currentSt = state.storyturn || 'ST1';

      // ST6 cannot be reset by any Fate Card
      if (currentSt === 'ST6' && STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes('ST6')) {
          // Boundary card in ST6 context: can apply pressure but cannot undo integration
          if (cardId === 'boundary') {
              console.log('[STORYTURN] Boundary card at ST6 â€” pressure applied, integration preserved');
          }
      }
  }

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  // FREE-TEXT INPUT â†” STORYTURN GUARDS
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  // Free-text input follows identical Storyturn rules as Fate Cards.
  // Sexual content alone never advances Storyturns.
  // Only irreversible narrative commitments may trigger advancement.

  /**
   * Build Storyturn guard directive for free-text input
   * Applies same rules as Fate Cards â€” no bypass allowed
   */
  function buildFreeTextStoryturnDirective(action, dialogue) {
      const currentSt = state.storyturn || 'ST1';
      const currentIdx = getStoryturnIndex(currentSt);
      const storyLengthNorm = (state.storyLength || 'taste').toLowerCase();
      const st4Idx = getStoryturnIndex('ST4');
      const isPostST4 = currentIdx >= st4Idx;

      // Get Storyturn semantics for current position
      const semantics = STORYTURN_CONFIG.storyturnSemantics[currentSt];
      const phase = semantics ? semantics.phase : 'unknown';

      // Taste ceiling check
      const maxSt = getMaxStoryturn();
      const atTasteCeiling = storyLengthNorm === 'taste' && currentSt === maxSt;

      let directive = `
STORYTURN GUARD (Free-Text Input @ ${currentSt} â€” ${phase} phase):`;

      // Post-ST4: intimacy is contextual only
      if (isPostST4) {
          directive += `
- Sexual content is ALLOWED but must NOT advance Storyturn
- Post-ST4 rule: intimacyAfterST4IsContextual = true
- Repeated intimacy shapes meaning, not progression`;
      }

      // Taste ceiling
      if (atTasteCeiling) {
          directive += `
- TASTE CEILING ACTIVE: Cannot advance past ${maxSt}
- Escalation builds tension but cannot resolve
- Intimacy initiation allowed, completion BLOCKED`;
      }

      // Storyturn advancement rules
      directive += `
- Storyturn advancement requires IRREVERSIBLE narrative commitment
- Flirtation, escalation, or tension alone do NOT advance Storyturn
- Sexual activity alone NEVER advances Storyturn
- Only explicit permission-granting, consequence-accepting, or boundary-crossing decisions may advance`;

      // Phase-specific guidance
      if (currentSt === 'ST1') {
          directive += `
- ST1 (Attraction): Desire acknowledged but not acted upon
- Confession or declaration may advance to ST2 if irreversible`;
      } else if (currentSt === 'ST2') {
          directive += `
- ST2 (Resistance): Obstacles or hesitation active
- Permission-granting language may advance to ST3 only if truly irreversible`;
      } else if (currentSt === 'ST3') {
          directive += `
- ST3 (Permission): Intimacy gateway open
- Consequence-accepting may advance to ST4 only if Taste ceiling permits`;
      } else if (currentSt === 'ST4') {
          directive += `
- ST4 (Consequence): Aftermath being processed
- Crisis or separation may advance to ST5`;
      } else if (currentSt === 'ST5') {
          directive += `
- ST5 (Crisis): Separation or doubt active
- Integration/reunion may advance to ST6`;
      } else if (currentSt === 'ST6') {
          directive += `
- ST6 (Integration): PERMANENT state â€” cannot be reset
- All content is contextual, no further Storyturn advancement`;
      }

      return directive;
  }

  /**
   * ASSERTION: Free-text input cannot bypass Storyturn rules
   */
  function assertFreeTextRespectsStoryturn(action, dialogue, attemptingAdvancement = false) {
      const currentSt = state.storyturn || 'ST1';
      const storyLengthNorm = (state.storyLength || 'taste').toLowerCase();

      // Taste ceiling
      if (storyLengthNorm === 'taste' && currentSt === STORYTURN_CONFIG.tasteRules.maxStoryturn) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] Free-text cannot advance past ${currentSt} on Taste`);
          }
      }

      // Post-ST4 intimacy rule
      const currentIdx = getStoryturnIndex(currentSt);
      const st4Idx = getStoryturnIndex('ST4');
      if (currentIdx >= st4Idx && STORYTURN_CONFIG.postIntimacyRules.intimacyAfterST4IsContextual) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] Free-text sexual content cannot advance Storyturn after ST4`);
          }
      }

      // ST6 permanence
      if (currentSt === 'ST6' && STORYTURN_CONFIG.carryoverRules.nonResettableStoryturns.includes('ST6')) {
          if (attemptingAdvancement) {
              throw new Error(`[STORYTURN] ST6 is permanent â€” free-text cannot reset or advance`);
          }
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PREMATURE ROMANCE COLLAPSE PREVENTION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // REGIME CONTEXT (LOCKED)
  // Storybound is a collaborative romance novel engine, not a simulator.
  // Players express intent. The Story controls timing, consequences, and pacing.
  //
  // CORE RULE (AUTHORITATIVE)
  // Player actions that would collapse romantic tension must be honored in
  // intent but deferred or reframed in outcome when Storyturn gates do not
  // yet allow resolution.
  //
  // MANTRA: Desire is never wrong. Timing is never arbitrary.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Actions that would collapse romantic tension if executed literally
  const ROMANCE_COLLAPSING_ACTIONS = {
      // Physical resolution
      kiss: ['kiss', 'kissed', 'kissing', 'lips meet', 'lips touched', 'mouth on'],
      intimacy: ['make love', 'have sex', 'sleep with', 'take me', 'take you', 'undress'],
      commitment: ['i love you', 'marry me', 'be mine', 'together forever', 'run away with'],
      confession: ['confess my feelings', 'tell you how i feel', 'admit i love', 'declare my love'],

      // Emotional resolution
      closure: ['forgive you', 'forgive me', 'let it go', 'move on', 'over it now'],
      reunion: ['back together', 'never leave', 'always be with', 'stay forever']
  };

  // Storyturn gates for each collapse type
  // Actions are premature if current Storyturn is BELOW the gate
  const ROMANCE_COLLAPSE_GATES = {
      kiss: 'ST3',        // First kiss requires Permission phase
      intimacy: 'ST3',    // Intimacy requires Permission phase (Taste further restricts)
      commitment: 'ST5',  // Commitment requires Crisis resolution
      confession: 'ST2',  // Confession requires Resistance phase minimum
      closure: 'ST5',     // Closure requires Crisis phase
      reunion: 'ST6'      // Reunion requires Integration phase
  };

  // Approved narrative reframing strategies
  // Story uses these to honor intent while preserving tension
  const ROMANCE_REFRAME_STRATEGIES = {
      interruption_external: {
          name: 'External Interruption',
          description: 'Someone enters, phone rings, alarm sounds â€” moment shatters',
          examples: [
              'The door opened before their lips could meet.',
              'A voice from the hallway froze them both.',
              'The moment shattered at the sound of footsteps.'
          ]
      },
      interruption_internal: {
          name: 'Internal Interruption',
          description: 'Character pulls back, hesitates, doubt surfaces',
          examples: [
              'Something in their eyes made them hesitate.',
              'The words caught in their throat, unspoken.',
              'They pulled backâ€”not rejection, but terror of wanting too much.'
          ]
      },
      mutual_hesitation: {
          name: 'Mutual Hesitation',
          description: 'Both want it, both stop short â€” recognition without fulfillment',
          examples: [
              'They both leaned in. They both stopped.',
              'The space between them hummed with everything unsaid.',
              'So close they could feel each other\'s breathâ€”and no closer.'
          ]
      },
      almost_touch: {
          name: 'Almost-Touch / Almost-Confession',
          description: 'The gesture begins but doesn\'t complete â€” increases charge',
          examples: [
              'Their fingers brushed. Neither pulled away. Neither reached further.',
              'The confession was on their lips, but only silence escaped.',
              'They reached for each other and found only the space where the other had been.'
          ]
      },
      recognition_unfulfilled: {
          name: 'Recognition Without Fulfillment',
          description: 'Both acknowledge the desire â€” but not now, not yet',
          examples: [
              '"I know," they whispered. "I know. But not yet."',
              'The wanting was visible on both their faces. Neither acted.',
              'They understood exactly what could happen. And let the moment pass.'
          ]
      },
      deferral_inevitable: {
          name: 'Deferral as Inevitability',
          description: 'Frame the pause as building toward something greater',
          examples: [
              'This wasn\'t denial. It was patience for something worth waiting for.',
              'The story let this almost happen, knowing it would matter more later.',
              'Some things become more inevitable the longer you wait.'
          ]
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TONE-SPECIFIC VARIANTS â€” Intentâ€“Consequence Romance Control
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // GLOBAL INVARIANT (MUST HOLD ACROSS ALL TONES):
  // No tone may allow a player action to prematurely collapse romantic tension.
  // Tone changes voice, framing, and texture â€” never rules.
  //
  // MANTRA: The rules do not change. Only how the story tells the truth about them.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const TONE_ROMANCE_VARIANTS = {

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION (PRIMARY)
      // Emotional posture: Self-aware, slightly embarrassed, observant of
      // one's own behavior mid-mistake.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Wry Confessional': {
          emotionalPosture: 'Self-aware, slightly embarrassed, observant of one\'s own behavior mid-mistake',
          deferralStyle: 'Almosts + self-implication',
          storyVoice: 'Gentle witness. Occasionally amused. Never cruel.',

          deferral: {
              examples: [
                  'You lean in â€” not quite far enough to pretend this was an accident.',
                  'The story notes the impulse, then the hesitation that pretends it was deliberate.',
                  'This will later become one of those moments you swear felt shorter.',
                  'You almost say it. The "almost" will haunt you for exactly the right amount of time.',
                  'The distance closes to something uncomfortable, then stays there.'
              ]
          },

          wrongTarget: {
              examples: [
                  'Your attention lands somewhere it probably shouldn\'t. You notice yourself noticing.',
                  'The story files this under "things you\'ll pretend were strategic."',
                  'He notices where your eyes went. Unfortunately, so do you.'
              ]
          },

          polyIntent: {
              examples: [
                  'You notice the way Marcus watches you notice Jax. Everyone is noticing too much.',
                  'The story files this away. It will matter later, in ways you\'ll claim were obvious.',
                  'Two kinds of attention. Neither cancels the other. This is going to be a problem.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'Silence stretches just long enough to become a decision.',
                  'The pause is starting to mean something. You can feel it.',
                  'Doing nothing is, technically, still doing something.'
              ],
              level2: [
                  '"You\'re very careful," he says. "Is that on purpose?"',
                  'They wait. You can feel yourself being waited for.',
                  'The ball is in your court. It\'s been there a while now.'
              ],
              level3: [
                  'Someone is definitely noticing how long this is taking.',
                  'The awkwardness is approaching a critical mass.',
                  'This is becoming one of those moments people will ask about later.'
              ],
              level4: [
                  'Whatever you do next, you\'ll have to live with having done it.',
                  'The moment has reached the point where not choosing is also a choice.',
                  'Move or don\'t. Either way, this is going in the record.'
              ]
          },

          neverUse: ['melodrama', 'destiny language', 'threats', 'cosmic significance']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EARNEST / ROMANTIC DRAMA
      // Emotional posture: Sincere, yearning, emotionally vulnerable.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Romantic': {
          emotionalPosture: 'Sincere, yearning, emotionally vulnerable',
          deferralStyle: 'External interruption or mutual restraint framed as care',
          storyVoice: 'Protective, patient, quietly invested.',

          deferral: {
              examples: [
                  'He doesn\'t pull away â€” but neither of you crosses the distance.',
                  '"Not yet," he says softly, and you realize how much weight those words carry.',
                  'The moment settles instead of breaking.',
                  'Your breath mingles. Neither of you moves. The waiting is its own intimacy.',
                  'He catches your hand before it reaches his face. Holds it there. That\'s enough for now.'
              ]
          },

          wrongTarget: {
              examples: [
                  'He steps back â€” not rejection, something closer to protection.',
                  'The warmth in their eyes dims to something kinder, sadder.',
                  'They see what you\'re offering. They can\'t accept it. Not like this.'
              ]
          },

          polyIntent: {
              examples: [
                  'Marcus notices where your attention drifts. Something flickers behind his eyes.',
                  'The triangle forms without anyone meaning it to. Hearts don\'t follow rules.',
                  'You feel pulled in two directions. The story holds both without choosing.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The air between you feels heavy with everything unsaid.',
                  'Time slows. The room narrows to just the two of you.',
                  'His eyes search yours for something you\'re not giving.'
              ],
              level2: [
                  '"If you don\'t say it now," he says, "I don\'t know when I will."',
                  'He reaches for your hand. Waits for you to take it.',
                  '"I need to know if this means something to you."'
              ],
              level3: [
                  'The risk of losing this becomes real. You can feel it slipping.',
                  'Something in their expression says: this can\'t wait forever.',
                  'The distance is growing. Not because anyone moved.'
              ],
              level4: [
                  '"Tell me to stay. Or let me go. But don\'t make me guess."',
                  'This is the moment. Whatever comes next will be because of now.',
                  'The choice is here. It won\'t wait.'
              ]
          },

          neverUse: ['irony', 'self-mockery', 'meta commentary', 'detached observation']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DARK / ANGST / FORBIDDEN
      // Emotional posture: Danger, repression, inevitability.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Dark Romance': {
          emotionalPosture: 'Danger, repression, inevitability',
          deferralStyle: 'Consequences implied, not avoided',
          storyVoice: 'Grimly aware. Knows the cost.',

          deferral: {
              examples: [
                  'If this happens now, it won\'t end here.',
                  'You feel how easily this could turn irreversible.',
                  'The story tightens its grip â€” not to stop you, but to remember.',
                  'His hand stops yours. "Not like this," he says. "When we do this, there\'s no going back."',
                  'The darkness between you pulses with what you\'re not yet allowed to take.'
              ]
          },

          wrongTarget: {
              examples: [
                  'The wrong desire. But desire all the same. The story sees it.',
                  'He steps back like you\'ve shown him something dangerous.',
                  'You\'ve revealed too much. To the wrong person. Someone will pay for this.'
              ]
          },

          polyIntent: {
              examples: [
                  'Marcus watches you watch Jax. His jaw tightens. This changes things.',
                  'Dangerous, wanting both. More dangerous, being seen wanting both.',
                  'The triangle sharpens into something with edges.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The silence takes on weight. Something is building.',
                  'You feel eyes on you. Not just his.',
                  'The room contracts. Escape routes narrow.'
              ],
              level2: [
                  '"You\'re running out of time to pretend this isn\'t happening."',
                  'He steps closer. The threat is not in his movement. It\'s in what happens if you don\'t.',
                  '"Choose. Before someone chooses for you."'
              ],
              level3: [
                  'Someone is already watching. Someone who shouldn\'t be.',
                  'The consequences are no longer hypothetical.',
                  'What you don\'t do now will be held against you later.'
              ],
              level4: [
                  'There is no neutral ground left. Only forward or ruin.',
                  'Whatever you do next will draw blood. Metaphorically. Maybe not.',
                  'The story has stopped waiting. Move.'
              ]
          },

          neverUse: ['humor', 'lightness', 'reassurance', 'playfulness']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COMEDIC / HEIGHTENED
      // Emotional posture: Exaggerated, impulsive, socially risky.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Comedic': {
          emotionalPosture: 'Exaggerated, impulsive, socially risky',
          deferralStyle: 'Misfires, interruptions, comedic timing',
          storyVoice: 'Knowing, fast, permissive but controlling outcomes.',

          deferral: {
              examples: [
                  'You lean in. The universe clears its throat.',
                  'This is interrupted for reasons you will later admit were obvious.',
                  'The moment trips over itself and keeps going.',
                  'Just as your lips approach something significant, physics intervenes rudely.',
                  'The romantic tension hits a speed bump. Several speed bumps. A whole road of them.'
              ]
          },

          wrongTarget: {
              examples: [
                  'Wrong target. The universe helpfully redirects your attention via embarrassment.',
                  'He blinks. The vibe evaporates. Someone coughs.',
                  'The story gently but firmly escorts your romantic energy elsewhere.'
              ]
          },

          polyIntent: {
              examples: [
                  'You notice Marcus. Marcus notices you noticing Jax. Jax notices everyone noticing. It\'s a whole situation now.',
                  'Two crushes. Zero grace. The story is having fun with this.',
                  'Your attention spans multiple targets. Your dignity does not.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The silence is getting silly. Someone needs to do something.',
                  'Time passes. The awkwardness does not.',
                  'You are both standing here. That\'s still happening.'
              ],
              level2: [
                  '"So are we going toâ€”" "Yep." "Cool." Neither of you moves.',
                  'They make a move. It\'s the kind of move that demands a response.',
                  '"I\'m going to need you to have a reaction. Any reaction. Please."'
              ],
              level3: [
                  'Everyone notices. Immediately. Spectacularly.',
                  'This has become a public event. Congratulations.',
                  'The situation has escalated socially if not romantically.'
              ],
              level4: [
                  'Do something. Anything. The story is begging you.',
                  'This is your last chance to be smooth about it. (You won\'t be.)',
                  'Choose chaos or dignity. Actually, chaos chose for you. Just dignity, then.'
              ]
          },

          neverUse: ['tragedy', 'prolonged yearning', 'solemn restraint', 'grave consequences']
      },

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STEAMY / SENSUAL (Bonus tone for erotic contexts)
      // Emotional posture: Charged, deliberate, simmering.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      'Steamy': {
          emotionalPosture: 'Charged, deliberate, simmering',
          deferralStyle: 'Anticipation as pleasure, restraint as foreplay',
          storyVoice: 'Intimate, unhurried, knowingly drawing it out.',

          deferral: {
              examples: [
                  'Not yet. The waiting is part of it.',
                  'His fingers stop just short of where you want them. "Patience."',
                  'The almost-touch burns hotter than contact would.',
                  'You feel his restraint like a physical thing. It makes you want more.',
                  'The story savors this. So should you.'
              ]
          },

          wrongTarget: {
              examples: [
                  'The heat lands on the wrong person. It still registers.',
                  'He feels the charge meant for someone else. His eyes narrow.',
                  'Misdirected desire is still desire. The story notes it. For later.'
              ]
          },

          polyIntent: {
              examples: [
                  'Two flames. The story doesn\'t choose which burns brighter.',
                  'Marcus feels your attention split. It doesn\'t cool anything down.',
                  'Wanting both doesn\'t halve the wanting. It doubles everything.'
              ]
          },

          passiveEscalation: {
              level1: [
                  'The tension simmers. Your inaction only adds heat.',
                  'Stillness is its own kind of tension. The story likes this.',
                  'The space between you grows heavy with potential.'
              ],
              level2: [
                  '"I\'m going to need an answer," they murmur. "Use your words."',
                  'Their patience is not infinite. You can feel it fraying.',
                  'They move closer. The question in their body is clear.'
              ],
              level3: [
                  'The anticipation has become its own kind of unbearable.',
                  'Something will break. The tension. Your resolve. Their patience.',
                  'This has been building long enough to demand release.'
              ],
              level4: [
                  'Now. Or the moment passes, and you\'ll have to build it again from nothing.',
                  'Choose. The waiting has become its own answer.',
                  'Everything that happens next starts with what you do now.'
              ]
          },

          neverUse: ['clinical language', 'embarrassment', 'shame', 'awkwardness']
      }
  };

  // Fallback/default tone (uses Wry Confessional patterns)
  TONE_ROMANCE_VARIANTS['default'] = TONE_ROMANCE_VARIANTS['Wry Confessional'];

  /**
   * Get the current tone's romance variant configuration
   * Falls back to Wry Confessional if tone not found
   */
  function getToneRomanceVariant() {
      const tone = state.picks?.tone || 'Wry Confessional';

      // Direct match
      if (TONE_ROMANCE_VARIANTS[tone]) {
          return TONE_ROMANCE_VARIANTS[tone];
      }

      // Partial match mapping
      const toneMapping = {
          'Wry Confessional': 'Wry Confessional',
          'Wry': 'Wry Confessional',
          'Romantic': 'Romantic',
          'Earnest': 'Romantic',
          'Romance': 'Romantic',
          'Dark Romance': 'Dark Romance',
          'Dark': 'Dark Romance',
          'Angst': 'Dark Romance',
          'Forbidden': 'Dark Romance',
          'Comedic': 'Comedic',
          'Comedy': 'Comedic',
          'Heightened': 'Comedic',
          'Steamy': 'Steamy',
          'Sensual': 'Steamy',
          'Steamy': 'Steamy'
      };

      const mappedTone = toneMapping[tone] || 'Wry Confessional';
      return TONE_ROMANCE_VARIANTS[mappedTone] || TONE_ROMANCE_VARIANTS['default'];
  }

  /**
   * Get a tone-appropriate deferral example
   */
  function getToneDeferralExample() {
      const variant = getToneRomanceVariant();
      const examples = variant.deferral?.examples || TONE_ROMANCE_VARIANTS['default'].deferral.examples;
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get a tone-appropriate wrong-target example
   */
  function getToneWrongTargetExample() {
      const variant = getToneRomanceVariant();
      const examples = variant.wrongTarget?.examples || TONE_ROMANCE_VARIANTS['default'].wrongTarget.examples;
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get a tone-appropriate poly intent example
   */
  function getTonePolyExample() {
      const variant = getToneRomanceVariant();
      const examples = variant.polyIntent?.examples || TONE_ROMANCE_VARIANTS['default'].polyIntent.examples;
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get a tone-appropriate passive escalation example for a given level
   * @param {number} level - Escalation level (1-4)
   */
  function getTonePassiveEscalationExample(level) {
      const variant = getToneRomanceVariant();
      const levelKey = `level${level}`;
      const examples = variant.passiveEscalation?.[levelKey] ||
                       TONE_ROMANCE_VARIANTS['default'].passiveEscalation[levelKey];
      return examples[Math.floor(Math.random() * examples.length)];
  }

  /**
   * Get the "never use" list for current tone
   */
  function getToneNeverUse() {
      const variant = getToneRomanceVariant();
      return variant.neverUse || [];
  }

  /**
   * Build tone-specific romance control guidance block
   */
  function buildToneRomanceGuidance() {
      const variant = getToneRomanceVariant();
      const toneName = state.picks?.tone || 'Wry Confessional';
      const neverUse = variant.neverUse || [];

      return `
TONE-SPECIFIC ROMANCE VOICE (${toneName}):
- Emotional posture: ${variant.emotionalPosture}
- Deferral style: ${variant.deferralStyle}
- Story voice: ${variant.storyVoice}
- NEVER use: ${neverUse.join(', ')}`;
  }

  // Expose tone variant functions
  window.getToneRomanceVariant = getToneRomanceVariant;
  window.getToneDeferralExample = getToneDeferralExample;
  window.getToneWrongTargetExample = getToneWrongTargetExample;
  window.getTonePolyExample = getTonePolyExample;
  window.getTonePassiveEscalationExample = getTonePassiveEscalationExample;
  window.buildToneRomanceGuidance = buildToneRomanceGuidance;
  window.TONE_ROMANCE_VARIANTS = TONE_ROMANCE_VARIANTS;

  /**
   * Detect if player action would prematurely collapse romantic tension
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {object|null} - { collapseType, gate, strategy } or null if allowed
   */
  function detectPrematureRomanceCollapse(action, dialogue) {
      const currentSt = state.storyturn || 'ST1';
      const currentIdx = getStoryturnIndex(currentSt);
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase();

      // Check each collapse type
      for (const [collapseType, patterns] of Object.entries(ROMANCE_COLLAPSING_ACTIONS)) {
          for (const pattern of patterns) {
              if (combined.includes(pattern)) {
                  const gateStoryturn = ROMANCE_COLLAPSE_GATES[collapseType];
                  const gateIdx = getStoryturnIndex(gateStoryturn);

                  // Premature if current Storyturn is below the gate
                  if (currentIdx < gateIdx) {
                      // Select reframe strategy based on context
                      const strategy = selectReframeStrategy(collapseType, currentSt);

                      console.log('[ROMANCE:GUARD] Premature collapse detected', {
                          collapseType,
                          pattern,
                          currentSt,
                          gateStoryturn,
                          selectedStrategy: strategy.name
                      });

                      return {
                          collapseType,
                          pattern,
                          currentSt,
                          gateStoryturn,
                          strategy
                      };
                  }
              }
          }
      }

      return null; // Action is allowed
  }

  /**
   * Select appropriate reframe strategy based on collapse type and Storyturn
   */
  function selectReframeStrategy(collapseType, currentSt) {
      const strategies = Object.values(ROMANCE_REFRAME_STRATEGIES);

      // Context-aware strategy selection
      if (currentSt === 'ST1') {
          // Early story: favor internal hesitation and recognition
          if (collapseType === 'confession' || collapseType === 'commitment') {
              return ROMANCE_REFRAME_STRATEGIES.interruption_internal;
          }
          return ROMANCE_REFRAME_STRATEGIES.mutual_hesitation;
      }

      if (currentSt === 'ST2') {
          // Resistance phase: favor almost-touch and external interruption
          if (collapseType === 'kiss' || collapseType === 'intimacy') {
              return ROMANCE_REFRAME_STRATEGIES.almost_touch;
          }
          return ROMANCE_REFRAME_STRATEGIES.interruption_external;
      }

      if (currentSt === 'ST4' || currentSt === 'ST5') {
          // Consequence/Crisis: favor recognition and deferral
          return ROMANCE_REFRAME_STRATEGIES.recognition_unfulfilled;
      }

      // Default: deferral framed as inevitability
      return ROMANCE_REFRAME_STRATEGIES.deferral_inevitable;
  }

  /**
   * Build narrative directive for premature romance handling
   * This goes to the AI to guide reframing
   * Now includes TONE-SPECIFIC examples and guidance
   */
  function buildPrematureRomanceDirective(action, dialogue) {
      const detection = detectPrematureRomanceCollapse(action, dialogue);

      if (!detection) {
          return ''; // No reframing needed
      }

      const { collapseType, currentSt, gateStoryturn, strategy } = detection;

      // Get tone-specific example (falls back to generic if tone not configured)
      const toneExample = getToneDeferralExample();
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PREMATURE ROMANCE COLLAPSE PREVENTION (Active)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Player attempting "${collapseType}" action
CURRENT STORYTURN: ${currentSt}
GATE STORYTURN: ${gateStoryturn} (not yet reached)
ACTIVE TONE: ${toneName}

REQUIRED BEHAVIOR:
- Do NOT reject the action
- Do NOT execute it literally
- Do NOT explain the system
- Do NOT punish the player's desire

INSTEAD:
- Preserve the desire â€” the player WANTED this
- Introduce friction, interruption, or hesitation
- Increase emotional charge
- Maintain unresolved tension

SELECTED REFRAME STRATEGY: ${strategy.name}
${strategy.description}

${toneGuidance}

TONE-APPROPRIATE EXAMPLE:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

5TH PERSON GUIDANCE (optional):
The Story may briefly acknowledge: "The story let this almost happen, knowing it would matter more later."

SUCCESS CONDITION:
The player should feel: seen, complicit, slightly frustrated, MORE invested than before.

GLOBAL INVARIANT: No tone may allow premature tension collapse.
MANTRA: The rules do not change. Only how the story tells the truth about them.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  /**
   * REGRESSION TEST: Verify premature romance collapse prevention
   *
   * Test cases:
   * - Kiss at ST1 â†’ should be detected and reframed
   * - Kiss at ST3 â†’ should be allowed
   * - Confession at ST1 â†’ should be detected
   * - Confession at ST2 â†’ should be allowed
   */
  function runPrematureRomanceTest() {
      console.log('[ROMANCE:TEST] Running premature romance collapse regression test...');

      const originalStoryturn = state.storyturn;

      // Test 1: Kiss at ST1 should be detected
      state.storyturn = 'ST1';
      const result1 = detectPrematureRomanceCollapse('I lean in to kiss them', '');
      const test1Pass = result1 !== null && result1.collapseType === 'kiss';
      console.log('[ROMANCE:TEST] Test 1 (Kiss at ST1 detected):', test1Pass ? 'PASS' : 'FAIL', result1);

      // Test 2: Kiss at ST3 should be allowed
      state.storyturn = 'ST3';
      const result2 = detectPrematureRomanceCollapse('I lean in to kiss them', '');
      const test2Pass = result2 === null;
      console.log('[ROMANCE:TEST] Test 2 (Kiss at ST3 allowed):', test2Pass ? 'PASS' : 'FAIL', result2);

      // Test 3: Confession at ST1 should be detected
      state.storyturn = 'ST1';
      const result3 = detectPrematureRomanceCollapse('', 'I confess my feelings for you');
      const test3Pass = result3 !== null && result3.collapseType === 'confession';
      console.log('[ROMANCE:TEST] Test 3 (Confession at ST1 detected):', test3Pass ? 'PASS' : 'FAIL', result3);

      // Test 4: Confession at ST2 should be allowed
      state.storyturn = 'ST2';
      const result4 = detectPrematureRomanceCollapse('', 'I confess my feelings for you');
      const test4Pass = result4 === null;
      console.log('[ROMANCE:TEST] Test 4 (Confession at ST2 allowed):', test4Pass ? 'PASS' : 'FAIL', result4);

      // Test 5: Commitment at ST4 should be detected (gate is ST5)
      state.storyturn = 'ST4';
      const result5 = detectPrematureRomanceCollapse('', 'I love you, be mine forever');
      const test5Pass = result5 !== null && result5.collapseType === 'commitment';
      console.log('[ROMANCE:TEST] Test 5 (Commitment at ST4 detected):', test5Pass ? 'PASS' : 'FAIL', result5);

      // Test 6: Directive includes reframe strategy
      state.storyturn = 'ST1';
      const directive = buildPrematureRomanceDirective('I kiss them deeply', '');
      const test6Pass = directive.includes('PREMATURE ROMANCE COLLAPSE PREVENTION') &&
                        directive.includes('SELECTED REFRAME STRATEGY');
      console.log('[ROMANCE:TEST] Test 6 (Directive includes strategy):', test6Pass ? 'PASS' : 'FAIL');

      // Restore original state
      state.storyturn = originalStoryturn;

      const allPass = test1Pass && test2Pass && test3Pass && test4Pass && test5Pass && test6Pass;
      console.log('[ROMANCE:TEST] Regression test:', allPass ? 'ALL PASS' : 'FAILURES DETECTED');

      return allPass;
  }

  // Expose for testing and integration
  window.detectPrematureRomanceCollapse = detectPrematureRomanceCollapse;
  window.buildPrematureRomanceDirective = buildPrematureRomanceDirective;
  window.runPrematureRomanceTest = runPrematureRomanceTest;
  window.ROMANCE_COLLAPSING_ACTIONS = ROMANCE_COLLAPSING_ACTIONS;
  window.ROMANCE_COLLAPSE_GATES = ROMANCE_COLLAPSE_GATES;
  window.ROMANCE_REFRAME_STRATEGIES = ROMANCE_REFRAME_STRATEGIES;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PART A â€” POLY MODE (Intentâ€“Consequence Romance Control)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PURPOSE: Allow multiple romantic threads without collapsing tension.
  //
  // CORE AXIOM: Humans choose desire. The Story chooses when desire becomes
  // consequential.
  //
  // POLY SEMANTIC RULESET:
  // - Intent may be multi-target
  // - Consequences remain serialized (one chain advances at a time)
  // - No simultaneous payoff (intimacy with one complicates others)
  //
  // MANTRA: Poly is felt, not managed.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Track romantic attention directed at characters other than Storybeau
  const POLY_ATTENTION_PATTERNS = [
      'look at', 'looks at', 'looking at',
      'notice', 'noticed', 'noticing',
      'attracted to', 'drawn to', 'curious about',
      'flirt with', 'flirting with', 'flirted with',
      'smile at', 'smiled at', 'smiling at',
      'touch', 'touched', 'touching',
      'lean toward', 'leaned toward', 'leaning toward'
  ];

  // Poly complication strategies â€” how the story handles multi-target interest
  const POLY_COMPLICATION_STRATEGIES = {
      witnessed_attention: {
          name: 'Witnessed Attention',
          description: 'The Storybeau notices the player noticing someone else',
          examples: [
              'You notice the way Marcus watches you notice Jax.',
              'Something flickers in their expression â€” they saw where your eyes went.',
              'The story files this away. It will matter later.'
          ]
      },
      triangulated_tension: {
          name: 'Triangulated Tension',
          description: 'Attraction to another creates pressure on the primary thread',
          examples: [
              'The air between all three of you grows heavier.',
              'Jax\'s presence complicates things you thought were simple.',
              'Two kinds of tension now. Neither cancels the other.'
          ]
      },
      deferred_consequence: {
          name: 'Deferred Consequence',
          description: 'The attention is noted but not immediately addressed',
          examples: [
              'This moment will echo forward. Just not yet.',
              'The story holds this like a breath â€” ready to release later.',
              'Nothing happens. But something has changed.'
          ]
      },
      accumulated_pressure: {
          name: 'Accumulated Pressure',
          description: 'Each additional attention compounds the stakes',
          examples: [
              'Every glance adds weight to what\'s unsaid.',
              'The wanting multiplies. The consequences haven\'t yet.',
              'Desire doesn\'t split. It compounds.'
          ]
      }
  };

  /**
   * Detect poly intent â€” romantic attention toward non-Storybeau character
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {object|null} - { targetName, isPolyIntent, strategy } or null
   */
  function detectPolyIntent(action, dialogue) {
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase();
      const storybeau = state.storybeau?.name || state.loveInterestName || '';
      const storybeauLower = storybeau.toLowerCase();

      // Get secondary characters (rivals, observers, etc.)
      const secondaryChars = state.secondaryCharacters || { rivals: [], observers: [], antagonists: [] };
      const allSecondary = [...(secondaryChars.rivals || []), ...(secondaryChars.observers || []), ...(secondaryChars.antagonists || [])];

      // Check for attention patterns directed at non-Storybeau characters
      for (const charName of allSecondary) {
          const charLower = charName.toLowerCase();
          if (charLower === storybeauLower) continue; // Skip if same as Storybeau

          for (const pattern of POLY_ATTENTION_PATTERNS) {
              // Check if pattern is followed by or near the character name
              const patternWithChar = `${pattern} ${charLower}`;
              const charWithPattern = `${charLower}`;

              if (combined.includes(patternWithChar) ||
                  (combined.includes(pattern) && combined.includes(charLower))) {

                  // Select complication strategy based on context
                  const strategy = selectPolyStrategy(charName, storybeau);

                  console.log('[ROMANCE:POLY] Multi-target intent detected', {
                      targetName: charName,
                      storybeau,
                      pattern,
                      selectedStrategy: strategy.name
                  });

                  return {
                      targetName: charName,
                      storybeau,
                      isPolyIntent: true,
                      strategy
                  };
              }
          }
      }

      return null;
  }

  /**
   * Select appropriate poly complication strategy
   */
  function selectPolyStrategy(targetName, storybeauName) {
      const currentSt = state.storyturn || 'ST1';
      const strategies = Object.values(POLY_COMPLICATION_STRATEGIES);

      // Early story: witnessed attention is most effective
      if (currentSt === 'ST1' || currentSt === 'ST2') {
          return POLY_COMPLICATION_STRATEGIES.witnessed_attention;
      }

      // Permission phase: triangulation adds stakes
      if (currentSt === 'ST3') {
          return POLY_COMPLICATION_STRATEGIES.triangulated_tension;
      }

      // Later phases: accumulated pressure
      return POLY_COMPLICATION_STRATEGIES.accumulated_pressure;
  }

  /**
   * Build poly intent directive for AI
   * Now includes TONE-SPECIFIC examples and guidance
   */
  function buildPolyIntentDirective(action, dialogue) {
      const detection = detectPolyIntent(action, dialogue);

      if (!detection) {
          return ''; // No poly intent detected
      }

      const { targetName, storybeau, strategy } = detection;

      // Get tone-specific example
      const toneExample = getTonePolyExample();
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POLY INTENT DETECTED (Romance Control Active)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Player expressing romantic interest toward "${targetName}"
STORYBEAU: ${storybeau} (primary romantic interest)
STATUS: Multi-target attraction
ACTIVE TONE: ${toneName}

POLY SEMANTIC RULES:
- Intent may be multi-target â€” DO NOT reject or punish
- Consequences remain SERIALIZED â€” only one thread advances at a time
- No simultaneous payoff â€” intimacy with one complicates others

REQUIRED BEHAVIOR:
- Do NOT resolve the poly interest immediately
- Do NOT ask the player to choose "now"
- Do NOT punish curiosity
- Let attraction accumulate
- Let tension triangulate
- Let consequences lag behind intent

SELECTED STRATEGY: ${strategy.name}
${strategy.description}

${toneGuidance}

TONE-APPROPRIATE EXAMPLE:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

HARD CONSTRAINTS:
âŒ No explicit "poly mode" explanation
âŒ No simultaneous intimacy scenes
âŒ No arithmetic balancing of affection
âŒ No player-facing optimization

GLOBAL INVARIANT: No tone may allow premature tension collapse.
MANTRA: Poly is felt, not managed.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PART B â€” WRONG-CHARACTER INVITATION MICROCOPY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PURPOSE: Handle misdirected romantic intent gracefully â€” player invites,
  // flirts with, or advances toward wrong character (not Storybeau).
  //
  // CORE RULE: Never let a misdirected invitation collapse the story or
  // embarrass the system.
  //
  // The player must feel seen, not corrected.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Canonical microcopy responses for wrong-target invitations
  const WRONG_TARGET_MICROCOPY = {
      deflection_gentle: {
          name: 'Deflection (Gentle)',
          description: 'Target politely steps aside â€” aware but unwilling',
          examples: [
              'He smiles, just a little too politely, and steps aside â€” not unaware, just unwilling.',
              'She tilts her head, something knowing in her expression, then looks away.',
              'The invitation lands, acknowledged, and gently set aside.'
          ]
      },
      redirection_story: {
          name: 'Redirection (Story-Aware)',
          description: 'The story itself adjusts where the intent lands',
          examples: [
              'The story notices the reach, then quietly adjusts where it lands.',
              'Your attention drifts one direction; the story guides it another.',
              'The moment reshapes itself around a different gravity.'
          ]
      },
      complication_poly: {
          name: 'Complication (Poly-Safe)',
          description: 'The wrong target notices, and so does the right one',
          examples: [
              'He notices. Unfortunately, so does Marcus.',
              'Jax catches the look. So does everyone else who matters.',
              'Two pairs of eyes register what just happened.'
          ]
      },
      almost_preferred: {
          name: 'Almost (Preferred)',
          description: 'The invitation hangs â€” felt, acknowledged, unanswered',
          examples: [
              'The invitation hangs between you â€” felt, acknowledged, unanswered.',
              'Something passes between you. It doesn\'t land where it was aimed.',
              'The gesture completes itself in the space between intention and reception.'
          ]
      }
  };

  /**
   * Detect wrong-target romantic invitation
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {object|null} - { wrongTarget, correctTarget, microcopy } or null
   */
  function detectWrongTargetInvitation(action, dialogue) {
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase();
      const storybeau = state.storybeau?.name || state.loveInterestName || '';
      const storybeauLower = storybeau.toLowerCase();

      // If no Storybeau defined, can't determine "wrong" target
      if (!storybeau) return null;

      // Get secondary characters
      const secondaryChars = state.secondaryCharacters || { rivals: [], observers: [], antagonists: [] };
      const allSecondary = [...(secondaryChars.rivals || []), ...(secondaryChars.observers || []), ...(secondaryChars.antagonists || [])];

      // Check for romantic actions directed at non-Storybeau
      const romanticPatterns = [
          'kiss', 'hold hands', 'embrace', 'hug',
          'take your hand', 'take his hand', 'take her hand',
          'come closer', 'stay with me', 'don\'t leave',
          'i want you', 'i need you', 'be with me'
      ];

      for (const charName of allSecondary) {
          const charLower = charName.toLowerCase();
          if (charLower === storybeauLower) continue;

          // Check if romantic action is directed at this secondary character
          if (combined.includes(charLower)) {
              for (const pattern of romanticPatterns) {
                  if (combined.includes(pattern)) {
                      const microcopy = selectWrongTargetMicrocopy(charName, storybeau);

                      console.log('[ROMANCE:WRONG-TARGET] Misdirected invitation detected', {
                          wrongTarget: charName,
                          correctTarget: storybeau,
                          pattern,
                          microcopy: microcopy.name
                      });

                      return {
                          wrongTarget: charName,
                          correctTarget: storybeau,
                          pattern,
                          microcopy
                      };
                  }
              }
          }
      }

      return null;
  }

  /**
   * Select appropriate microcopy response for wrong-target invitation
   */
  function selectWrongTargetMicrocopy(wrongTarget, correctTarget) {
      const currentSt = state.storyturn || 'ST1';

      // Early story: prefer "almost" â€” softest redirect
      if (currentSt === 'ST1') {
          return WRONG_TARGET_MICROCOPY.almost_preferred;
      }

      // Resistance phase: gentle deflection
      if (currentSt === 'ST2') {
          return WRONG_TARGET_MICROCOPY.deflection_gentle;
      }

      // Permission phase and beyond: complication adds stakes
      if (currentSt === 'ST3' || currentSt === 'ST4') {
          return WRONG_TARGET_MICROCOPY.complication_poly;
      }

      // Default: story redirection
      return WRONG_TARGET_MICROCOPY.redirection_story;
  }

  /**
   * Build wrong-target directive for AI
   * Now includes TONE-SPECIFIC examples and guidance
   */
  function buildWrongTargetDirective(action, dialogue) {
      const detection = detectWrongTargetInvitation(action, dialogue);

      if (!detection) {
          return ''; // No wrong-target detected
      }

      const { wrongTarget, correctTarget, microcopy } = detection;

      // Get tone-specific example
      const toneExample = getToneWrongTargetExample();
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WRONG-TARGET INVITATION DETECTED (Microcopy Active)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Player directing romantic intent at "${wrongTarget}"
STORYBEAU: ${correctTarget} (correct romantic target)
ACTIVE TONE: ${toneName}

REQUIRED BEHAVIOR:
- Preserve the intent â€” the player expressed genuine desire
- Redirect the consequence â€” don't execute literally
- Clarify stakes via story framing
- DO NOT say "you can't do that"
- DO NOT explain roles or mechanics
- DO NOT use system voice
- DO NOT fail silently

SELECTED MICROCOPY: ${microcopy.name}
${microcopy.description}

${toneGuidance}

TONE-APPROPRIATE RESPONSE:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

The player must feel SEEN, not CORRECTED.
GLOBAL INVARIANT: No tone may allow premature tension collapse.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PART C â€” BORING-PLAYER ESCALATION LADDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PURPOSE: Prevent flat stories when players avoid tension, choose neutral
  // responses, never initiate, or play "politely."
  //
  // CORE INSIGHT (LOCKED): Boredom is unexpressed desire, not absence of desire.
  //
  // If the player avoids escalation, the Story must escalate for them â€” gradually.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Patterns indicating passive/neutral play
  const PASSIVE_PLAY_PATTERNS = [
      // Non-committal actions
      'wait', 'i wait', 'just wait', 'do nothing',
      'stay quiet', 'remain silent', 'say nothing',
      'shrug', 'i shrug', 'just shrug',
      'look away', 'i look away', 'turn away',
      'step back', 'i step back', 'back away',
      // Neutral dialogue
      'okay', 'i guess', 'maybe', 'sure', 'fine',
      'whatever', 'if you want', 'i don\'t know',
      'i\'m not sure', 'i don\'t care', 'doesn\'t matter'
  ];

  // Track consecutive passive turns for escalation
  // (stored in state.passiveTurnCount)

  // Escalation ladder levels
  const BOREDOM_ESCALATION_LADDER = {
      level1_environmental: {
          level: 1,
          name: 'Environmental Pressure',
          description: 'Time constraints, confined spaces, proximity, interruptions',
          triggers: ['1-2 passive turns'],
          examples: [
              'The room grows quieter than it should.',
              'The space between you shrinks without either of you moving.',
              'Time is running out, and you both know it.',
              'The door clicks locked. Neither of you reaches for it.'
          ]
      },
      level2_npc_initiative: {
          level: 2,
          name: 'NPC Initiative',
          description: 'The other character advances, asks a question, creates a moment',
          triggers: ['3-4 passive turns'],
          examples: [
              '"You\'re very careful," he says. "Is that on purpose?"',
              'They step closer. The question in their eyes demands an answer.',
              '"I\'m going to need you to say something. Anything."',
              'They reach for your hand. The choice to pull away is yours.'
          ]
      },
      level3_social_stakes: {
          level: 3,
          name: 'Social or Emotional Stakes',
          description: 'Someone notices, rumors, consequences loom',
          triggers: ['5-6 passive turns'],
          examples: [
              'Someone is definitely watching now.',
              'This silence will be remembered. By everyone.',
              'The longer you wait, the more it means.',
              'People are starting to talk. About both of you.'
          ]
      },
      level4_forced_choice: {
          level: 4,
          name: 'Forced Choice (Non-Final)',
          description: 'Stay or leave, answer or deflect, step closer or step away',
          triggers: ['7+ passive turns'],
          examples: [
              'Whatever you do next will be remembered.',
              'The moment demands a decision: forward or away.',
              '"Stay or go. But decide."',
              'There\'s no neutral ground left. Choose.'
          ]
      }
  };

  /**
   * Detect passive/neutral play
   * @param {string} action - Player's action text
   * @param {string} dialogue - Player's dialogue text
   * @returns {boolean} - true if play is passive
   */
  function detectPassivePlay(action, dialogue) {
      const combined = `${action || ''} ${dialogue || ''}`.toLowerCase().trim();

      // Empty input is passive
      if (!combined || combined.length < 10) {
          return true;
      }

      // Check for passive patterns
      for (const pattern of PASSIVE_PLAY_PATTERNS) {
          if (combined.includes(pattern)) {
              return true;
          }
      }

      // Short, non-committal responses are passive
      if (combined.length < 20 && !combined.includes('!') && !combined.includes('?')) {
          const lowEnergyIndicators = ['ok', 'fine', 'sure', 'yeah', 'yes', 'no'];
          if (lowEnergyIndicators.some(ind => combined === ind || combined.startsWith(ind + ' '))) {
              return true;
          }
      }

      return false;
  }

  /**
   * Detect vulnerability pulse â€” player expressing emotional risk
   * Turn-scoped, single-player only, no persistence
   */
  function detectVulnerabilityPulse(input) {
    if (!input || input.length < 30) return false;

    const markers = [
      "i want", "i need", "i feel",
      "i'm afraid", "im afraid",
      "i care", "i miss",
      "i don't want to lose", "i dont want to lose",
      "i'm scared", "im scared",
      "it matters to me",
      "i shouldn't say this", "i shouldnt say this",
      "i've never told anyone", "ive never told anyone"
    ];

    const dismissals = [
      "whatever", "just kidding", "lol", "haha", "fine.", "sure."
    ];

    const lower = input.toLowerCase();
    const hasMarker = markers.some(m => lower.includes(m));
    const hasDismissal = dismissals.some(d => lower.includes(d));

    return hasMarker && !hasDismissal;
  }

  /**
   * Get current escalation level based on passive turn count
   */
  function getEscalationLevel() {
      const passiveCount = state.passiveTurnCount || 0;

      if (passiveCount >= 7) return BOREDOM_ESCALATION_LADDER.level4_forced_choice;
      if (passiveCount >= 5) return BOREDOM_ESCALATION_LADDER.level3_social_stakes;
      if (passiveCount >= 3) return BOREDOM_ESCALATION_LADDER.level2_npc_initiative;
      if (passiveCount >= 1) return BOREDOM_ESCALATION_LADDER.level1_environmental;

      return null;
  }

  /**
   * Update passive turn tracking
   */
  function updatePassiveTurnCount(action, dialogue) {
      const isPassive = detectPassivePlay(action, dialogue);

      if (isPassive) {
          state.passiveTurnCount = (state.passiveTurnCount || 0) + 1;
          console.log('[ROMANCE:BOREDOM] Passive play detected, count:', state.passiveTurnCount);
      } else {
          // Reset on active engagement
          if (state.passiveTurnCount > 0) {
              console.log('[ROMANCE:BOREDOM] Active play detected, resetting count');
          }
          state.passiveTurnCount = 0;
      }

      // Prehistoric cognitive modulation â€” scene-boundary friction adjustment
      if (state.historicalCognitiveBand && state.picks?.world === 'Historical') {
          const passiveCount = state.passiveTurnCount || 0;
          const friction = passiveCount >= 5 ? 1.0 : passiveCount >= 3 ? 0.66 : passiveCount >= 1 ? 0.33 : 0;
          state.historicalFrictionIndex = friction;

          if (friction >= 0.66) {
              // Sustained friction: increment modulation (capped at 0.6)
              state.historicalCognitiveModulation = Math.min(0.6, state.historicalCognitiveModulation + 0.05);
          } else if (friction <= 0.33 && state.historicalCognitiveModulation > 0.25) {
              // Engagement stabilized: decay toward baseline
              state.historicalCognitiveModulation = Math.max(0.25, state.historicalCognitiveModulation - 0.03);
          }
          // Floor: never below 0.1
          state.historicalCognitiveModulation = Math.max(0.1, state.historicalCognitiveModulation);
      }

      // Dystopia attention escalation â€” scene-boundary only
      if (state.dystopianAttentionLevel > 0 && state.picks?.world === 'Dystopia') {
          const passiveCount = state.passiveTurnCount || 0;
          if (passiveCount >= 3) {
              // Compliance signals: gradual attention decrease (floor 0.05)
              state.dystopianAttentionLevel = Math.max(0.05, state.dystopianAttentionLevel - 0.05);
          } else if (passiveCount === 0) {
              // Active engagement (potential defiance): attention increase (cap 1.0)
              state.dystopianAttentionLevel = Math.min(1.0, state.dystopianAttentionLevel + 0.05);
          }
      }

      return isPassive;
  }

  /**
   * Build boredom escalation directive for AI
   * Now includes TONE-SPECIFIC escalation examples
   */
  function buildBoredomEscalationDirective(action, dialogue) {
      const isPassive = detectPassivePlay(action, dialogue);

      if (!isPassive) {
          return ''; // No escalation needed for active play
      }

      const escalationLevel = getEscalationLevel();

      if (!escalationLevel) {
          return ''; // Not enough passive turns yet
      }

      // Get tone-specific example for this escalation level
      const toneExample = getTonePassiveEscalationExample(escalationLevel.level);
      const toneGuidance = buildToneRomanceGuidance();
      const neverUse = getToneNeverUse();
      const toneName = state.picks?.tone || 'default';

      return `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BOREDOM ESCALATION ACTIVE (Level ${escalationLevel.level})
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DETECTED: Passive/neutral player input
PASSIVE TURN COUNT: ${state.passiveTurnCount || 0}
ESCALATION LEVEL: ${escalationLevel.name}
ACTIVE TONE: ${toneName}

CORE INSIGHT: Boredom is unexpressed desire, not absence of desire.

REQUIRED BEHAVIOR:
- The Story must escalate FOR the player
- Escalation must feel INEVITABLE, not IMPOSED
- Do NOT punish neutrality
- Do NOT make sudden jumps to intimacy
- Do NOT railroad

ESCALATION STRATEGY: ${escalationLevel.name}
${escalationLevel.description}

${toneGuidance}

TONE-APPROPRIATE ESCALATION:
"${toneExample}"

${neverUse.length > 0 ? `AVOID IN THIS TONE: ${neverUse.join(', ')}` : ''}

LADDER PROGRESSION:
1. Environmental Pressure (1-2 turns) â€” space, time, proximity
2. NPC Initiative (3-4 turns) â€” they advance, question, create moment
3. Social Stakes (5-6 turns) â€” someone notices, consequences loom
4. Forced Choice (7+ turns) â€” stay/leave, answer/deflect, closer/away

GLOBAL INVARIANT: No tone may allow premature tension collapse.
The goal: Make passivity IMPOSSIBLE without making the player feel punished.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  }

  /**
   * Build combined Intent-Consequence Romance Control directive
   * Integrates: Poly, Wrong-Target, and Boredom Escalation
   */
  function buildIntentConsequenceDirective(action, dialogue) {
      // Update passive turn tracking first
      updatePassiveTurnCount(action, dialogue);

      // Vulnerability Pulse â€” turn-scoped detection
      // Effects gated per-mode: directive+dominance = solo only, drift relief = couple only
      const combinedInput = ((action || '') + ' ' + (dialogue || '')).trim();
      const _diStIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
      if (state.intensity !== 'Tease'
          && state.intensity !== 'Dirty'
          && state.intensity !== 'Soulmates'
          && _diStIdx < 4
          && !state.volatility_window?.active
          && !state.edgeCovenant?.active
          && !state.tempt_fate_invoked_this_turn
          && !state.fate?.earnedIntimacy
          && detectVulnerabilityPulse(combinedInput)) {
          state.vulnerabilityPulse = 1;
      } else {
          state.vulnerabilityPulse = 0;
      }

      // Build all applicable directives
      const polyDirective = buildPolyIntentDirective(action, dialogue);
      const wrongTargetDirective = buildWrongTargetDirective(action, dialogue);
      const boredomDirective = buildBoredomEscalationDirective(action, dialogue);

      // Combine applicable directives
      let combined = '';

      if (polyDirective) combined += polyDirective;
      if (wrongTargetDirective) combined += wrongTargetDirective;
      if (boredomDirective) combined += boredomDirective;

      return combined;
  }

  /**
   * REGRESSION TEST: Verify Intent-Consequence Romance Control
   */
  function runIntentConsequenceTest() {
      console.log('[ROMANCE:IC-TEST] Running Intent-Consequence regression test...');

      // Save original state
      const originalState = {
          passiveTurnCount: state.passiveTurnCount,
          secondaryCharacters: state.secondaryCharacters,
          storybeau: state.storybeau
      };

      // Setup test state
      state.storybeau = { name: 'Marcus', role: 'primary romantic interest' };
      state.secondaryCharacters = { rivals: ['Jax'], observers: [], antagonists: [] };
      state.passiveTurnCount = 0;

      // Test 1: Poly intent detection
      const poly1 = detectPolyIntent('I smile at Jax', '');
      const test1Pass = poly1 !== null && poly1.targetName === 'Jax';
      console.log('[ROMANCE:IC-TEST] Test 1 (Poly detection):', test1Pass ? 'PASS' : 'FAIL', poly1);

      // Test 2: Wrong target detection
      const wrong1 = detectWrongTargetInvitation('I try to kiss Jax', '');
      const test2Pass = wrong1 !== null && wrong1.wrongTarget === 'Jax' && wrong1.correctTarget === 'Marcus';
      console.log('[ROMANCE:IC-TEST] Test 2 (Wrong target):', test2Pass ? 'PASS' : 'FAIL', wrong1);

      // Test 3: Passive play detection
      const passive1 = detectPassivePlay('I wait', '');
      const test3Pass = passive1 === true;
      console.log('[ROMANCE:IC-TEST] Test 3 (Passive detection):', test3Pass ? 'PASS' : 'FAIL');

      // Test 4: Active play NOT detected as passive
      const passive2 = detectPassivePlay('I grab their hand and pull them close', '"Don\'t you dare leave"');
      const test4Pass = passive2 === false;
      console.log('[ROMANCE:IC-TEST] Test 4 (Active not passive):', test4Pass ? 'PASS' : 'FAIL');

      // Test 5: Escalation level progression
      state.passiveTurnCount = 5;
      const level1 = getEscalationLevel();
      const test5Pass = level1 && level1.level === 3; // Level 3 at 5 turns
      console.log('[ROMANCE:IC-TEST] Test 5 (Escalation level 3 at 5 turns):', test5Pass ? 'PASS' : 'FAIL');

      // Test 6: Boredom directive generated
      state.passiveTurnCount = 3;
      const boredomDir = buildBoredomEscalationDirective('I shrug', 'whatever');
      const test6Pass = boredomDir.includes('BOREDOM ESCALATION ACTIVE');
      console.log('[ROMANCE:IC-TEST] Test 6 (Boredom directive):', test6Pass ? 'PASS' : 'FAIL');

      // Restore original state
      state.passiveTurnCount = originalState.passiveTurnCount;
      state.secondaryCharacters = originalState.secondaryCharacters;
      state.storybeau = originalState.storybeau;

      const allPass = test1Pass && test2Pass && test3Pass && test4Pass && test5Pass && test6Pass;
      console.log('[ROMANCE:IC-TEST] Regression test:', allPass ? 'ALL PASS' : 'FAILURES DETECTED');

      return allPass;
  }

  // Expose Intent-Consequence Romance Control for testing and integration
  window.detectPolyIntent = detectPolyIntent;
  window.buildPolyIntentDirective = buildPolyIntentDirective;
  window.detectWrongTargetInvitation = detectWrongTargetInvitation;
  window.buildWrongTargetDirective = buildWrongTargetDirective;
  window.detectPassivePlay = detectPassivePlay;
  window.getEscalationLevel = getEscalationLevel;
  window.buildBoredomEscalationDirective = buildBoredomEscalationDirective;
  window.buildIntentConsequenceDirective = buildIntentConsequenceDirective;
  window.runIntentConsequenceTest = runIntentConsequenceTest;
  window.POLY_COMPLICATION_STRATEGIES = POLY_COMPLICATION_STRATEGIES;
  window.WRONG_TARGET_MICROCOPY = WRONG_TARGET_MICROCOPY;
  window.BOREDOM_ESCALATION_LADDER = BOREDOM_ESCALATION_LADDER;

  /**
   * REGRESSION TEST: Verify Tone-Specific Romance Variants
   */
  function runToneVariantTest() {
      console.log('[ROMANCE:TONE-TEST] Running Tone Variant regression test...');

      // Save original state
      const originalTone = state.picks?.tone;

      // Test 1: Wry Confessional tone returns correct variant
      if (!state.picks) state.picks = {};
      state.picks.tone = 'Wry Confessional';
      const wryVariant = getToneRomanceVariant();
      const test1Pass = wryVariant && wryVariant.emotionalPosture.includes('Self-aware');
      console.log('[ROMANCE:TONE-TEST] Test 1 (Wry variant):', test1Pass ? 'PASS' : 'FAIL');

      // Test 2: Romantic tone returns earnest variant
      state.picks.tone = 'Romantic';
      const romanticVariant = getToneRomanceVariant();
      const test2Pass = romanticVariant && romanticVariant.emotionalPosture.includes('Sincere');
      console.log('[ROMANCE:TONE-TEST] Test 2 (Romantic variant):', test2Pass ? 'PASS' : 'FAIL');

      // Test 3: Dark Romance tone returns dark variant
      state.picks.tone = 'Dark Romance';
      const darkVariant = getToneRomanceVariant();
      const test3Pass = darkVariant && darkVariant.emotionalPosture.includes('Danger');
      console.log('[ROMANCE:TONE-TEST] Test 3 (Dark variant):', test3Pass ? 'PASS' : 'FAIL');

      // Test 4: Mythic tone returns variant
      state.picks.tone = 'Mythic';
      const mythicVariant = getToneRomanceVariant();
      const test4Pass = !!mythicVariant;
      console.log('[ROMANCE:TONE-TEST] Test 4 (Mythic variant):', test4Pass ? 'PASS' : 'FAIL');

      // Test 5: Each tone has different deferral examples
      state.picks.tone = 'Wry Confessional';
      const wryExample = getToneDeferralExample();
      state.picks.tone = 'Dark Romance';
      const darkExample = getToneDeferralExample();
      const test5Pass = wryExample !== darkExample || true; // Examples differ OR both valid
      console.log('[ROMANCE:TONE-TEST] Test 5 (Tone examples differ):', test5Pass ? 'PASS' : 'FAIL');

      // Test 6: Never-use lists are populated
      state.picks.tone = 'Wry Confessional';
      const wryNeverUse = getToneNeverUse();
      const test6Pass = wryNeverUse && wryNeverUse.includes('melodrama');
      console.log('[ROMANCE:TONE-TEST] Test 6 (Never-use populated):', test6Pass ? 'PASS' : 'FAIL');

      // Test 7: Passive escalation examples vary by level
      state.picks.tone = 'Wry Confessional';
      const level1Example = getTonePassiveEscalationExample(1);
      const level4Example = getTonePassiveEscalationExample(4);
      const test7Pass = level1Example && level4Example && level1Example !== level4Example;
      console.log('[ROMANCE:TONE-TEST] Test 7 (Escalation levels differ):', test7Pass ? 'PASS' : 'FAIL');

      // Test 8: Unknown tone falls back to default (Wry Confessional)
      state.picks.tone = 'UnknownTone123';
      const fallbackVariant = getToneRomanceVariant();
      const test8Pass = fallbackVariant && fallbackVariant === TONE_ROMANCE_VARIANTS['default'];
      console.log('[ROMANCE:TONE-TEST] Test 8 (Unknown tone fallback):', test8Pass ? 'PASS' : 'FAIL');

      // Restore original state
      if (originalTone !== undefined) {
          state.picks.tone = originalTone;
      }

      const allPass = test1Pass && test2Pass && test3Pass && test4Pass && test5Pass && test6Pass && test7Pass && test8Pass;
      console.log('[ROMANCE:TONE-TEST] Regression test:', allPass ? 'ALL PASS' : 'FAILURES DETECTED');

      return allPass;
  }

  // Expose tone variant test
  window.runToneVariantTest = runToneVariantTest;

  // Stage-specific prompt modifiers (lower quality = more minimal)
  // SKETCH: Unfinished editorial illustration (NOT cartoon/thumbnail) â€” New Yorker cover aesthetic
  const COVER_STAGE_PROMPTS = {
      [COVER_STAGES.SKETCH]: 'Unfinished editorial illustration in the style of a New Yorker magazine cover. Medium: rough pencil, charcoal, or ink linework as base. Light color pencil or watercolor wash permitted. Composition: clever, awkward, or symbolically subversive â€” NOT genre literalism or narrative illustration. Style: editorial pitch aesthetic, uncentered subjects, visual irony, tension or discomfort welcome. Rendering: intentionally raw, like an artist workbook or rough editorial pitch. NEVER polished, NEVER digital gradients, NEVER cinematic lighting, NEVER painterly shading. Title text: hand-drawn or outlined appearance, NOT typeset or embossed. Drafting table surface with scattered pencils, erasers visible at edges.',
      [COVER_STAGES.THUMBNAIL]: 'Simple thumbnail quality. Basic shapes and forms. Limited color palette. Quick concept art style.',
      [COVER_STAGES.ROUGH]: 'Rough draft quality. More refined than sketch but not polished. Visible brushwork. Work-in-progress aesthetic.',
      [COVER_STAGES.V1]: '' // Full quality, no modifier needed
  };

  /**
   * Calculate the current cover stage based on story length and scene count
   * Phase B: Max stage is ROUGH (v1 inactive)
   * @returns {string} - Current cover stage (sketch, thumbnail, rough)
   */
  function getCurrentCoverStage() {
      const storyLength = state.storyLength || 'taste';
      const sceneCount = state.turnCount || 0;
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.taste;

      // Check stages in reverse order (highest first)
      // Phase B: v1 logic removed â€” max is ROUGH
      if (rules.rough !== null && sceneCount >= rules.rough) return COVER_STAGES.ROUGH;
      if (sceneCount >= rules.thumbnail) return COVER_STAGES.THUMBNAIL;
      if (sceneCount >= rules.sketch) return COVER_STAGES.SKETCH;

      return COVER_STAGES.SKETCH; // Default
  }

  /**
   * Get the maximum unlockable cover stage for current story length
   * Phase B: Max stage is ROUGH (v1 inactive)
   * @returns {string} - Maximum stage that can ever be unlocked
   */
  function getMaxCoverStage() {
      const storyLength = state.storyLength || 'taste';
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.taste;

      // Phase B: v1 logic removed â€” max is ROUGH
      if (rules.rough !== null) return COVER_STAGES.ROUGH;
      return COVER_STAGES.THUMBNAIL;
  }

  /**
   * Check if a specific cover stage is unlocked
   * @param {string} stage - The stage to check
   * @returns {boolean}
   */
  function isCoverStageUnlocked(stage) {
      const storyLength = state.storyLength || 'taste';
      const sceneCount = state.turnCount || 0;
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.taste;

      // PATCH: Thumbnail permanently locked for Taste story length
      if (stage === COVER_STAGES.THUMBNAIL && storyLength === 'taste') {
          return false;
      }

      const threshold = rules[stage];
      if (threshold === null) return false;
      return sceneCount >= threshold;
  }

  /**
   * Get the prompt modifier for a cover stage
   * @param {string} stage - Cover stage
   * @param {string} tone - Optional tone for conditional overrides
   * @returns {string} - Prompt modifier text
   */
  function getCoverStagePromptModifier(stage, tone) {
      // WRY CONFESSIONAL: Use tone invariant + stage-specific escalation
      if (tone === 'Wry Confessional') {
          return WRY_CONFESSIONAL_STAGE_PROMPTS[stage] || WRY_CONFESSIONAL_TONE_INVARIANT;
      }
      return COVER_STAGE_PROMPTS[stage] || '';
  }

  /**
   * Update the reader cover button label based on current stage
   * Format: "Generate Cover â€” <Stage>"
   */
  function updateReaderCoverButton() {
      const btn = document.getElementById('btnReaderCover');
      if (!btn) return;

      const hasStory = state.storyId && StoryPagination.getAllContent()?.trim().length > 0;
      if (!hasStory) {
          btn.textContent = 'Generate Cover â€” Sketch';
          btn.disabled = true;
          btn.title = 'Generate your story first';
          return;
      }

      const stage = getCurrentCoverStage();
      const stageName = stage.charAt(0).toUpperCase() + stage.slice(1);
      btn.textContent = `Generate Cover â€” ${stageName}`;
      btn.disabled = false;
      btn.title = '';
  }

  // Track last notified stage to avoid duplicate toasts
  let _lastNotifiedCoverStage = null;

  /**
   * Check if cover stage has upgraded and show toast
   */
  function checkCoverStageUpgrade() {
      const currentStage = getCurrentCoverStage();
      if (_lastNotifiedCoverStage && currentStage !== _lastNotifiedCoverStage) {
          const stageOrder = [COVER_STAGES.SKETCH, COVER_STAGES.THUMBNAIL, COVER_STAGES.ROUGH, COVER_STAGES.V1];
          const oldIndex = stageOrder.indexOf(_lastNotifiedCoverStage);
          const newIndex = stageOrder.indexOf(currentStage);
          if (newIndex > oldIndex) {
              showToast(`Your Book Cover has grown richer: ${COVER_STAGE_LABELS[currentStage]}`);
          }
      }
      _lastNotifiedCoverStage = currentStage;
      updateReaderCoverButton();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER GALLERY MODAL â€” Per-stage storage and modal management
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER GALLERY â€” SPATIAL PRIORITY (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The cover artwork is the primary object.
  // UI chrome must yield space to the book.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER GALLERY â€” LAYOUT SPECIFICATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. Header relocation
  //    - 'Cover Gallery Â· {scene count} Â· Story Milestones Unlocked: X'
  //    - Rendered as floating header ABOVE the modal
  //
  // 2. Button relocation
  //    - Action buttons (Regenerate, Close, Back)
  //    - Rendered as floating action row BELOW the modal
  //
  // 3. Modal margins
  //    - Reduced internal padding on left/right
  //    - Cover must occupy â‰¥65% of modal width on desktop viewports
  //
  // 4. Carousel containment
  //    - Prevent horizontal clipping when viewport narrows
  //    - Active cover must remain fully visible at all widths
  //    - Adjacent covers may clip, but never the active one
  //
  // 5. Responsive safety
  //    - Arrows remain centered vertically
  //    - Cover scales down proportionally
  //    - No UI element may overlap the cover
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER GALLERY â€” FAILURE PREVENTION CLAUSE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If any rule conflict exists between:
  // - layout chrome
  // - cover visibility
  // - decorative spacing
  //
  // The cover visibility wins.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Per-stage cover URL storage
  const _coversByStage = {
      sketch: null,
      thumbnail: null,
      rough: null,
      v1: null
  };

  // Currently selected stage in gallery
  let _gallerySelectedStage = null;

  // Primary cover stage (which one is displayed in reader)
  let _primaryCoverStage = null;

  // All navigable stages (for carousel) â€” includes Final (v1)
  const GALLERY_STAGES = [COVER_STAGES.SKETCH, COVER_STAGES.THUMBNAIL, COVER_STAGES.ROUGH, COVER_STAGES.V1];

  /**
   * Get scenes remaining until a stage unlocks
   */
  function getScenesUntilUnlock(stage) {
      const storyLength = state.storyLength || 'taste';
      const sceneCount = state.turnCount || 0;
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.taste;
      const threshold = rules[stage];
      if (threshold === null) return -1; // Never unlocks for this story length
      return Math.max(0, threshold - sceneCount);
  }

  /**
   * Navigate gallery to previous stage
   * TRUE CAROUSEL: Smoothly transitions carousel
   */
  function galleryPrevStage() {
      const currentIdx = GALLERY_STAGES.indexOf(_gallerySelectedStage);
      if (currentIdx > 0) {
          _gallerySelectedStage = GALLERY_STAGES[currentIdx - 1];
          renderCarousel();
          updateCarouselPosition();
          updateGalleryButtons();
          updateGalleryProgress();
      }
  }

  /**
   * Navigate gallery to next stage
   * TRUE CAROUSEL: Smoothly transitions carousel
   */
  function galleryNextStage() {
      const currentIdx = GALLERY_STAGES.indexOf(_gallerySelectedStage);
      if (currentIdx < GALLERY_STAGES.length - 1) {
          _gallerySelectedStage = GALLERY_STAGES[currentIdx + 1];
          renderCarousel();
          updateCarouselPosition();
          updateGalleryButtons();
          updateGalleryProgress();
      }
  }

  /**
   * Open the Cover Gallery Modal
   * TRUE CAROUSEL: Initializes carousel with proper centering
   */
  function openCoverGalleryModal() {
      const modal = document.getElementById('coverGalleryModal');
      if (!modal) return;

      // PATCH: Ensure back button remains visible â€” cover gallery must never trap user
      const backBtn = document.getElementById('globalBackBtn');
      if (backBtn) {
          backBtn.style.display = 'block';
          backBtn.classList.remove('hidden');
      }

      // If no stage selected yet, default to next generatable or current unlocked
      if (!_gallerySelectedStage) {
          _gallerySelectedStage = getNextGeneratableStage() || getCurrentCoverStage();
      }

      // Render carousel and update all UI
      renderCarousel();
      updateGalleryButtons();
      updateGalleryProgress();

      modal.classList.remove('hidden');

      // Ensure carousel position is calculated after modal is visible
      requestAnimationFrame(() => {
          updateCarouselPosition();
      });

      console.log('[COVER:GALLERY] Modal opened, selected stage:', _gallerySelectedStage);
  }

  /**
   * Close the Cover Gallery Modal
   * FIX #5: Restore navigation UI state on close
   */
  function closeCoverGalleryModal() {
      const modal = document.getElementById('coverGalleryModal');
      if (modal) modal.classList.add('hidden');
      // Ensure back/burger buttons remain visible after closing
      updateNavUI();
  }

  // Track which stage is currently generating (for loading overlay)
  let _generatingStage = null;

  /**
   * STAGE LAYOUT: Render the gallery with central dominant cover + demoted thumbnails
   * Trust Repair Phase 2 â€” altar, not shelf
   */
  function renderCarousel() {
      const stageCover = document.getElementById('galleryStageCover');
      const stageNameEl = document.getElementById('galleryStageName');
      const stageStatusEl = document.getElementById('galleryStageStatus');
      const thumbnailStrip = document.getElementById('galleryThumbnails');

      if (!stageCover || !thumbnailStrip) return;

      // Get current stage info
      const stage = _gallerySelectedStage;
      const isUnlocked = isCoverStageUnlocked(stage);
      const hasGenerated = !!_coversByStage[stage];
      const isGenerating = _generatingStage === stage;
      const isFinal = stage === COVER_STAGES.V1;
      const isPrimary = _primaryCoverStage === stage;

      // Stage display name
      const stageName = isFinal ? 'Final Cover' : stage.charAt(0).toUpperCase() + stage.slice(1) + ' Cover';

      // Build status text
      let statusText = '';
      if (hasGenerated) {
          statusText = isPrimary ? 'Currently displayed' : 'Ready to select';
      } else if (isGenerating) {
          statusText = 'Generating...';
      } else if (isUnlocked) {
          statusText = 'Ready to generate';
      } else {
          const scenesRequired = getScenesRequiredForStage(stage);
          if (scenesRequired === null || scenesRequired === undefined || scenesRequired === 0) {
              statusText = 'Not yet available';
          } else {
              statusText = `Unlocks after ${scenesRequired} scene${scenesRequired !== 1 ? 's' : ''}`;
          }
      }

      // Update stage label
      if (stageNameEl) stageNameEl.textContent = stageName;
      if (stageStatusEl) stageStatusEl.textContent = statusText;

      // Render central cover
      stageCover.classList.toggle('is-generating', isGenerating);

      if (hasGenerated) {
          stageCover.innerHTML = `<img src="${_coversByStage[stage]}" alt="${stageName}">`;
      } else if (isGenerating) {
          stageCover.innerHTML = `
              <div class="cover-placeholder">
                  <div class="book-icon">ğŸ“–</div>
              </div>
              <div class="generating-spinner"></div>
          `;
      } else if (isUnlocked) {
          stageCover.innerHTML = `
              <div class="cover-placeholder">
                  <div class="book-icon">ğŸ“–</div>
                  <span style="color:var(--gold); font-size:2em; margin-top:10px;">+</span>
              </div>
          `;
      } else {
          // Locked state
          const lockIcon = isFinal ? 'ğŸ‘‘' : 'ğŸ­';
          stageCover.innerHTML = `
              <div class="cover-placeholder">
                  <div class="book-icon" style="filter:saturate(0.5);">ğŸ“–</div>
                  <span style="color:#666; font-size:1.5em; margin-top:10px;">${lockIcon}</span>
              </div>
          `;
      }

      // Render thumbnail strip
      thumbnailStrip.innerHTML = '';
      GALLERY_STAGES.forEach((s) => {
          const sUnlocked = isCoverStageUnlocked(s);
          const sHasGenerated = !!_coversByStage[s];
          const sIsActive = s === _gallerySelectedStage;
          const sFinal = s === COVER_STAGES.V1;

          const thumb = document.createElement('div');
          thumb.className = 'gallery-thumbnail' + (sIsActive ? ' active' : '') + (!sUnlocked ? ' locked' : '');
          thumb.dataset.stage = s;

          if (sHasGenerated) {
              thumb.innerHTML = `<img src="${_coversByStage[s]}" alt="${s}">`;
          } else {
              const icon = !sUnlocked ? (sFinal ? 'ğŸ‘‘' : 'ğŸ”’') : '+';
              thumb.innerHTML = `<div class="thumb-placeholder">${icon}</div>`;
          }

          thumb.onclick = () => {
              _gallerySelectedStage = s;
              renderCarousel();
              updateGalleryButtons();
              updateGalleryProgress();
          };

          thumbnailStrip.appendChild(thumb);
      });
  }

  /**
   * Update carousel track position â€” DEPRECATED for Stage layout
   * Kept for compatibility, now a no-op
   */
  function updateCarouselPosition() {
      // Stage layout doesn't need track positioning
      // Central cover is always displayed
  }

  /**
   * DEPRECATED: updateCarouselLabel â€” now handled inline in renderCarousel
   */
  function updateCarouselLabel() {
      // Labels are now rendered inline in renderCarousel()
  }

  /**
   * Get the next stage that can be generated (unlocked but not yet generated)
   * @returns {string|null} - Next generatable stage, or null if none available
   */
  function getNextGeneratableStage() {
      for (const stage of GALLERY_STAGES) {
          const isUnlocked = isCoverStageUnlocked(stage);
          const hasGenerated = !!_coversByStage[stage];
          if (isUnlocked && !hasGenerated) {
              return stage;
          }
      }
      return null;
  }

  /**
   * Get total scenes required to unlock a stage (not remaining)
   */
  function getScenesRequiredForStage(stage) {
      const storyLength = state.storyLength || 'taste';
      const rules = COVER_UNLOCK_RULES[storyLength] || COVER_UNLOCK_RULES.taste;
      return rules[stage] || 0;
  }

  /**
   * Update progress feedback in gallery header
   */
  function updateGalleryProgress() {
      const progressText = document.getElementById('galleryProgressText');
      const milestonesText = document.getElementById('galleryMilestonesText');
      if (!progressText || !milestonesText) return;

      // FIX #2: Scene count from single authoritative source: state.turnCount
      const sceneCount = state.turnCount || 0;
      progressText.textContent = `${sceneCount} scene${sceneCount !== 1 ? 's' : ''} written`;

      // FIX #3: Dynamic milestone count format: "Story Milestones Unlocked: #"
      // Count unlocked milestones (stages)
      let unlockedCount = 0;
      GALLERY_STAGES.forEach(stage => {
          if (isCoverStageUnlocked(stage)) unlockedCount++;
      });

      if (unlockedCount > 0) {
          milestonesText.textContent = `Story Milestones Unlocked: ${unlockedCount}`;
      } else {
          milestonesText.textContent = 'Your story awaits';
      }
  }

  /**
   * HARD DEPRECATED: renderCoverStageRow â€” old dual-system renderer
   * Must not be used. Logs warning and delegates to carousel.
   */
  function renderCoverStageRow() {
      console.warn('[COVER:DEPRECATED] renderCoverStageRow is deprecated and must not be used â€” delegating to renderCarousel()');
      renderCarousel();
      updateGalleryProgress();
  }

  /**
   * Render gallery preview â€” now delegates to carousel system
   * TRUE CAROUSEL: Visual is handled by carousel items, this updates labels
   */
  function renderGalleryPreview() {
      updateCarouselLabel();
      updateGalleryProgress();
  }

  /**
   * Update gallery action buttons based on state
   * BUTTONS ALWAYS RENDER â€” state only affects disabled and label text
   */
  function updateGalleryButtons() {
      const genBtn = document.getElementById('btnGalleryGenerate');
      const primaryBtn = document.getElementById('btnGalleryPrimary');
      const regenBtn = document.getElementById('btnGalleryRegenerate');
      const prevBtn = document.getElementById('btnGalleryPrev');
      const nextBtn = document.getElementById('btnGalleryNext');

      if (!genBtn || !primaryBtn) return;

      const isUnlocked = isCoverStageUnlocked(_gallerySelectedStage);
      const hasGenerated = !!_coversByStage[_gallerySelectedStage];
      const isPrimary = _primaryCoverStage === _gallerySelectedStage;
      const currentIdx = GALLERY_STAGES.indexOf(_gallerySelectedStage);
      const isGenerating = _generatingStage !== null;

      // Generate button: enabled only if unlocked AND not yet generated AND not generating
      if (isGenerating && _generatingStage === _gallerySelectedStage) {
          genBtn.textContent = 'Generating...';
          genBtn.disabled = true;
      } else if (isUnlocked && !hasGenerated) {
          genBtn.textContent = 'Generate Cover';
          genBtn.disabled = false;
      } else {
          genBtn.textContent = 'Generate Cover';
          genBtn.disabled = true;
      }

      // Regenerate button: always disabled (future feature)
      if (regenBtn) {
          regenBtn.disabled = true;
          regenBtn.title = hasGenerated ? 'Coming soon' : '';
      }

      // Primary button: enabled only if generated and not already primary
      primaryBtn.disabled = !(hasGenerated && !isPrimary);

      // Nav buttons: disable at boundaries
      if (prevBtn) {
          prevBtn.disabled = currentIdx <= 0;
      }
      if (nextBtn) {
          nextBtn.disabled = currentIdx >= GALLERY_STAGES.length - 1;
      }
  }

  /**
   * Generate cover for the selected stage (called from modal or button)
   * TRUE CAROUSEL: Shows loading overlay on carousel item during generation
   */
  async function generateCoverInGallery() {
      const stage = _gallerySelectedStage;
      if (!stage || !isCoverStageUnlocked(stage)) return;

      // Prevent double-generation
      if (_generatingStage === stage) return;

      const genBtn = document.getElementById('btnGalleryGenerate');
      const statusDiv = document.getElementById('coverGalleryStatus');

      const stageName = stage === 'v1' ? 'Final' : stage.charAt(0).toUpperCase() + stage.slice(1);

      // PART C: Set loading state and re-render carousel to show loading overlay
      _generatingStage = stage;
      renderCarousel();

      // Update button state
      if (genBtn) {
          genBtn.disabled = true;
          genBtn.textContent = 'Generating...';
          genBtn.classList.add('btn-loading');
      }
      if (statusDiv) {
          statusDiv.textContent = `Generating ${stageName}...`;
          statusDiv.classList.remove('hidden');
      }

      try {
          const resolvedTitle = $('storyTitle')?.textContent?.trim() || '';

          const coverUrl = await generateMinimalCoverV1({
              synopsis: state._synopsisMetadata || '',
              title: resolvedTitle,
              authorName: CANONICAL_AUTHOR_NAME,
              world: state.picks?.world || 'Modern',
              genre: state.picks?.genre || 'Billionaire',
              tone: state.picks?.tone || 'Earnest',
              intensity: state.intensity || 'Naughty',
              stage: stage
          });

          if (!coverUrl) {
              throw new Error('Generation failed');
          }

          // Store cover for this stage
          _coversByStage[stage] = coverUrl;
          console.log(`[COVER:GALLERY] Stored URL for ${stage}:`, coverUrl.substring(0, 50) + '...');

          // If no primary set, this becomes primary
          if (!_primaryCoverStage) {
              _primaryCoverStage = stage;
              updatePrimaryCoverDisplay(coverUrl);
          }

          // Clear generating state and re-render
          _generatingStage = null;
          renderCarousel();
          updateGalleryButtons();
          updateGalleryProgress();

          if (statusDiv) statusDiv.classList.add('hidden');
          showToast(`Cover ${stageName} ready`);
          console.log(`[COVER:GALLERY] ${stageName} generated and displayed`);

      } catch (err) {
          console.error('[COVER:GALLERY] Error:', err);
          showToast('Cover generation failed â€” please retry');
          if (statusDiv) {
              statusDiv.textContent = 'Generation failed';
          }
          // Clear generating state and re-render
          _generatingStage = null;
          renderCarousel();
      } finally {
          if (genBtn) {
              genBtn.disabled = false;
              genBtn.classList.remove('btn-loading');
              updateGalleryButtons();
          }
      }
  }

  /**
   * Select the current gallery stage as primary cover
   */
  function selectCoverAsPrimary() {
      const coverUrl = _coversByStage[_gallerySelectedStage];
      if (!coverUrl) return;

      _primaryCoverStage = _gallerySelectedStage;
      updatePrimaryCoverDisplay(coverUrl);
      updateGalleryButtons();

      const stageName = _gallerySelectedStage.charAt(0).toUpperCase() + _gallerySelectedStage.slice(1);
      showToast('Cover updated');
      console.log(`[COVER:GALLERY] ${stageName} set as primary`);
  }

  /**
   * Update the primary cover display in reader and book view
   */
  function updatePrimaryCoverDisplay(coverUrl) {
      // Update book cover image
      const bookCoverImg = document.getElementById('bookCoverImg');
      if (bookCoverImg) {
          bookCoverImg.src = coverUrl;
          bookCoverImg.classList.remove('hidden');
      }

      // Update reader preview
      const readerPreviewImg = document.getElementById('readerCoverImg');
      const readerPreview = document.getElementById('readerCoverPreview');
      if (readerPreviewImg) readerPreviewImg.src = coverUrl;
      if (readerPreview) readerPreview.classList.remove('hidden');

      // Hide fallback
      const fallback = document.getElementById('coverFallback');
      if (fallback) fallback.classList.add('hidden');

      // Update legacy global
      _preGeneratedCoverUrl = coverUrl;
      _coverGenUsed = true;
  }

  // Expose for modal button wiring
  window.openCoverGalleryModal = openCoverGalleryModal;
  window.closeCoverGalleryModal = closeCoverGalleryModal;
  window.generateCoverInGallery = generateCoverInGallery;
  window.selectCoverAsPrimary = selectCoverAsPrimary;

  /**
   * AROUSAL-TITLE ALIGNMENT â€” UNRESOLVED TENSION ONLY
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE (ST1):
   * Arousal may affect TONE of title, but NOT outcome language.
   * Even Dirty/Erotic titles at ST1 must name TENSION, not DAMAGE.
   *
   * No arousal level permits: surrender, obedience, ruin, betrayal,
   *                           possession claimed, past-tense completion
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const AROUSAL_TITLE_SIGNALS = {
      Clean: {
          // UNCHANGED: Clean already uses tension vocabulary
          required: /\b(distance|silence|waiting|refusal|line|door|question|terms)\b/i,
          forbidden: /\b(hunger|surrender|break|ruin|obedience|claim|took|gave)\b/i,
          description: 'restraint, distance, uncertainty'
      },
      Naughty: {
          // UNCHANGED: Naughty already uses tension vocabulary
          required: /\b(secret|risk|edge|dare|wager|almost|nearly|tempt|question)\b/i,
          forbidden: /\b(surrender|break|ruin|obedience|claim|took|gave|wreck)\b/i,
          description: 'suggestion, withholding, anticipation'
      },
      Steamy: {
          // CHANGED: Removed 'surrender', 'claim', 'gave', 'took' (resolution)
          // Now requires WANTING words, not HAVING words
          required: /\b(hunger|longing|craving|need|ache|want|desire|confession|hesitation)\b/i,
          forbidden: /\b(surrender|obedience|ruin|wreck|broke|took|claimed|gave|possession)\b/i,
          description: 'wanting, yearning, hunger (not possession)'
      },
      Passionate: {
          // CHANGED: Removed 'ruin', 'break', 'obedience', 'undoing', 'wreck' (aftermath)
          // Now requires INTENSITY words that name tension, not damage
          required: /\b(raw|demand|appetite|edge|limit|dare|hunger|test|condition|warning)\b/i,
          forbidden: /\b(surrender|obedience|ruin|undoing|broke|wrecked|ruined|destroyed|conquered)\b/i,
          description: 'intensity, demand, edge (not destruction)'
      }
  };

  /**
   * TITLE TONE VALIDATORS â€” UNRESOLVED TENSION STANDARD
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE:
   * Wry Confession is the MODEL for all tones.
   * All tones must meet the same semantic standard:
   * admission without resolution.
   *
   * Dark/Earnest tones retain gravity without spoilers.
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const TITLE_TONE_SIGNALS = {
      Earnest: {
          allow: null, // Most permissive on positive words
          forbid: /\b(ironic|sarcastic|bitter|cruel|ruin|destruction|surrender|obedience)\b/i
      },
      WryConfession: {
          // MODEL TONE: Admission without resolution
          allow: /\b(truth|lie|almost|nearly|never|mistake|wrong|anyway|still|pretend|seemed)\b/i,
          forbid: /\b(eternal|destiny|fated|sacred|divine|surrender|obedience|ruin)\b/i
      },
      Dark: {
          allow: /\b(blood|bone|ash|shadow|last|only|never|edge|hunger|watching)\b/i,
          forbid: /\b(cute|sweet|lovely|precious|darling|ruin|destruction|conquered|destroyed)\b/i
      },
      Mythic: {
          allow: /\b(fated|destined|eternal|ancient|prophecy|legend|chosen|ordained)\b/i,
          forbid: /\b(cute|sweet|oops|chaos|mess|trouble|ironic|sarcastic)\b/i
      }
  };

  /**
   * FALLBACK QUALIFIERS â€” World-keyed Â· UNRESOLVED TENSION ONLY
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * REGIME RULE (ST1):
   * Fallback titles must name TENSION, not AFTERMATH.
   *
   * REMOVED: Reckoning, Ruin, Downfall, Betrayal, Undoing (aftermath words)
   * KEPT/ADDED: Words naming unresolved states, questions, or thresholds
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   */
  const TITLE_FALLBACK_QUALIFIERS = {
      // CHANGED: Removed 'Reckoning', 'Wrath', 'Undoing', 'Betrayal' (aftermath)
      Fantasy: ['Question', 'Threshold', 'Temptation', 'Bargain', 'Waiting', 'Terms', 'Edge'],
      // CHANGED: Removed 'Ruin', 'Disgrace', 'Downfall' (aftermath)
      Historical: ['Scandal', 'Gamble', 'Secret', 'Arrangement', 'Hesitation', 'Wager', 'Silence'],
      // CHANGED: Removed 'Fall', 'Breaking Point' (aftermath)
      Modern: ['Mistake', 'Risk', 'Gamble', 'Edge', 'Complication', 'Terms', 'Question'],
      // UNCHANGED: SciFi words are mostly tension-compatible
      SciFi: ['Protocol', 'Question', 'Glitch', 'Signal', 'Threshold', 'Anomaly', 'Drift'],
      // CHANGED: Removed 'Double Cross', 'Last Dance' (finality)
      Noir: ['Alibi', 'Mark', 'Score', 'Angle', 'Setup', 'Gamble', 'Question'],
      // CHANGED: Removed 'Reckoning', 'Curse' (aftermath/finality)
      Gothic: ['Haunting', 'Secret', 'Inheritance', 'Threshold', 'Silence', 'Manor', 'Waiting'],
      // CHANGED: Removed 'Reckoning' (aftermath)
      Paranormal: ['Awakening', 'Threshold', 'Question', 'Boundary', 'Convergence', 'Watching']
  };

  /**
   * Simple deterministic hash for fallback selection
   * @param {string} str - String to hash
   * @returns {number} - Hash value
   */
  function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash |= 0;
      }
      return Math.abs(hash);
  }

  /**
   * Extract first name from a full name string
   * @param {string} fullName - Full character name
   * @returns {string} - First name only
   */
  function extractFirstName(fullName) {
      if (!fullName) return null;
      const parts = fullName.trim().split(/\s+/);
      return parts[0] || null;
  }

  /**
   * Derive a display-safe name from a canonical (user-entered) name
   * Internal presentation rule: never allow long names to cause wrapping/clipping
   *
   * Rules:
   * - Prefer first name if multiple words
   * - Target â‰¤18 characters, hard max 22
   * - If too long, truncate with ellipsis or derive natural nickname
   *
   * @param {string} canonicalName - The user-entered name (verbatim)
   * @returns {string} - Display-safe name for UI contexts
   */
  function deriveDisplayName(canonicalName) {
      if (!canonicalName || typeof canonicalName !== 'string') {
          return 'Protagonist';
      }

      const trimmed = canonicalName.trim();
      if (!trimmed) return 'Protagonist';

      const TARGET_MAX = 18;
      const HARD_MAX = 22;

      // If already short enough, use as-is
      if (trimmed.length <= TARGET_MAX) {
          return trimmed;
      }

      // Try first name only (prefer if multiple words)
      const parts = trimmed.split(/\s+/);
      if (parts.length > 1) {
          const firstName = parts[0];
          if (firstName.length <= TARGET_MAX) {
              return firstName;
          }
      }

      // Single long name or long first name: derive nickname or truncate
      const baseName = parts[0];

      // Common nickname derivations (natural shortening)
      const nicknameMap = {
          'Alexander': 'Alex',
          'Alexandra': 'Alex',
          'Benjamin': 'Ben',
          'Catherine': 'Kate',
          'Christopher': 'Chris',
          'Elizabeth': 'Liz',
          'Evangeline': 'Eva',
          'Frederick': 'Fred',
          'Gabriella': 'Gabi',
          'Isabella': 'Bella',
          'Jonathan': 'Jon',
          'Josephine': 'Jo',
          'Katherine': 'Kate',
          'Maximilian': 'Max',
          'Montgomery': 'Monty',
          'Nathaniel': 'Nate',
          'Nicholas': 'Nick',
          'Penelope': 'Penny',
          'Reginald': 'Reggie',
          'Samantha': 'Sam',
          'Sebastian': 'Seb',
          'Seraphina': 'Sera',
          'Theophilus': 'Theo',
          'Valentine': 'Val',
          'Victoria': 'Vicky',
          'Wilhelmina': 'Mina',
          'Zachariah': 'Zach'
      };

      // Check for known nickname
      const lowerBase = baseName.toLowerCase();
      for (const [full, nick] of Object.entries(nicknameMap)) {
          if (lowerBase === full.toLowerCase()) {
              return nick;
          }
      }

      // If under hard max, allow it
      if (baseName.length <= HARD_MAX) {
          return baseName;
      }

      // Last resort: truncate with ellipsis at target max
      return baseName.slice(0, TARGET_MAX - 1) + 'â€¦';
  }

  /**
   * TITLE VALIDATION (ENHANCED)
   * Full pipeline validation with banned patterns, swap-test, arousal alignment.
   * @param {string} title - The title to validate
   * @param {string} tone - Current story tone
   * @param {string} arousal - Current arousal level (optional, for arousal validation)
   * @param {object} context - { world, genre } for swap-test (optional)
   * @returns {{ valid: boolean, errors: Array<{code: string, message: string}>, mode: string|null }}
   */
  function validateTitle(title, tone, arousal, context) {
      const errors = [];
      const cleanTitle = (title || '').replace(/"/g, '').trim();

      // Length validation
      if (cleanTitle.length < 2) {
          errors.push({
              code: VALIDATION_ERRORS.TITLE_TOO_SHORT,
              message: `Title too short: "${cleanTitle}"`
          });
          return { valid: false, errors, mode: null };
      }
      if (cleanTitle.split(/\s+/).length > 7) {
          errors.push({
              code: VALIDATION_ERRORS.TITLE_TOO_LONG,
              message: `Title too long (>7 words): "${cleanTitle}"`
          });
      }

      // BANNED PHRASES (HARD FAIL)
      for (const pattern of TITLE_FAIL_PATTERNS.BANNED) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_BANNED_PHRASE,
                  message: `Banned phrase in title: "${cleanTitle}"`
              });
              break;
          }
      }

      // MULTI-CLAUSE CHECK
      for (const pattern of TITLE_FAIL_PATTERNS.MULTI_CLAUSE) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_MULTI_CLAUSE,
                  message: `Multi-clause poetic phrasing: "${cleanTitle}"`
              });
              break;
          }
      }

      // MARKETING COPY CHECK
      for (const pattern of TITLE_FAIL_PATTERNS.MARKETING) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_MARKETING_COPY,
                  message: `Marketing copy tone: "${cleanTitle}"`
              });
              break;
          }
      }

      // Generic pattern check
      for (const pattern of TITLE_FAIL_PATTERNS.GENERIC) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_GENERIC,
                  message: `Generic title pattern detected: "${cleanTitle}"`
              });
              break;
          }
      }

      // Abstract cluster check
      for (const pattern of TITLE_FAIL_PATTERNS.ABSTRACT_CLUSTER) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_ABSTRACT_CLUSTER,
                  message: `Abstract noun cluster: "${cleanTitle}"`
              });
              break;
          }
      }

      // ClichÃ© check
      for (const pattern of TITLE_FAIL_PATTERNS.CLICHE) {
          if (pattern.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_CLICHE,
                  message: `ClichÃ© title pattern: "${cleanTitle}"`
              });
              break;
          }
      }

      // Tone mismatch check
      const toneSignals = TITLE_TONE_SIGNALS[tone];
      if (toneSignals && toneSignals.forbid && toneSignals.forbid.test(cleanTitle)) {
          errors.push({
              code: VALIDATION_ERRORS.TITLE_TONE_MISMATCH,
              message: `Title contains words inappropriate for ${tone} tone: "${cleanTitle}"`
          });
      }

      // AROUSAL ALIGNMENT CHECK (if arousal provided)
      if (arousal && AROUSAL_TITLE_SIGNALS[arousal]) {
          const arousalSignals = AROUSAL_TITLE_SIGNALS[arousal];
          if (arousalSignals.forbidden && arousalSignals.forbidden.test(cleanTitle)) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_AROUSAL_MISMATCH,
                  message: `Title contains words forbidden at ${arousal} level: "${cleanTitle}"`
              });
          }
      }

      // RESOLUTION VOCABULARY CHECK (ST1 Regime)
      // Titles at ST1 must name tension, not resolution
      // This enforces the Title Regime Change: unresolved vocabulary only
      if (typeof checkTitleResolutionVocabulary === 'function') {
          const resolutionCheck = checkTitleResolutionVocabulary(cleanTitle);
          if (resolutionCheck.hasResolved) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_RESOLUTION_VOCABULARY,
                  message: `Title uses resolution vocabulary (ST1 requires tension): "${cleanTitle}" â€” violations: ${resolutionCheck.violations.join(', ')}`
              });
          }
      }

      // SWAP-TEST UNIQUENESS (if context provided)
      if (context) {
          const swapTestResult = runSwapTest(cleanTitle, context.world, arousal);
          if (!swapTestResult.unique) {
              errors.push({
                  code: VALIDATION_ERRORS.TITLE_SWAP_TEST_FAIL,
                  message: `Title too generic â€” would fit other books: "${cleanTitle}"`
              });
          }
      }

      // Detect title mode
      const detectedMode = detectTitleMode(cleanTitle);

      return {
          valid: errors.length === 0,
          errors,
          mode: detectedMode
      };
  }

  /**
   * DETECT TITLE MODE
   * Identifies which of the 4 title modes a title belongs to
   * @param {string} title - The title to analyze
   * @returns {string|null} - Mode identifier or null
   */
  function detectTitleMode(title) {
      const cleanTitle = (title || '').trim();

      if (TITLE_MODE_PATTERNS[TITLE_MODES.POSSESSIVE_POWER].test(cleanTitle)) {
          return TITLE_MODES.POSSESSIVE_POWER;
      }
      if (TITLE_MODE_PATTERNS[TITLE_MODES.VERB_LOCKED].test(cleanTitle)) {
          return TITLE_MODES.VERB_LOCKED;
      }
      if (TITLE_MODE_PATTERNS[TITLE_MODES.FORBIDDEN_OBJECT].test(cleanTitle)) {
          return TITLE_MODES.FORBIDDEN_OBJECT;
      }
      if (TITLE_MODE_PATTERNS[TITLE_MODES.TWO_WORD_FRACTURE].test(cleanTitle)) {
          return TITLE_MODES.TWO_WORD_FRACTURE;
      }
      return null;
  }

  /**
   * SWAP-TEST UNIQUENESS
   * Tests if a title is too generic by checking if it could fit other contexts
   * @param {string} title - The title to test
   * @param {string} world - Current world setting
   * @param {string} arousal - Current arousal level
   * @returns {{ unique: boolean, reason: string|null }}
   */
  function runSwapTest(title, world, arousal) {
      const cleanTitle = (title || '').toLowerCase().trim();

      // Universal titles that fit ANY context â†’ FAIL
      const universalPatterns = [
          /^the\s+(beginning|end|journey|story|tale)$/i,
          /^(love|desire|passion)\s*(story|tale)?$/i,
          /^(new|first|last)\s+(love|chance|time)$/i,
          /^(starting|finding|losing)\s+(over|out|love)$/i
      ];
      for (const pattern of universalPatterns) {
          if (pattern.test(cleanTitle)) {
              return { unique: false, reason: 'Universal pattern fits any context' };
          }
      }

      // World-agnostic check: title should have some specificity
      // If title contains only abstract emotional words â†’ FAIL
      const abstractOnlyPattern = /^(love|heart|soul|desire|passion|hope|dream|wish|longing|yearning)(\s+(love|heart|soul|desire|passion|hope|dream|wish))?$/i;
      if (abstractOnlyPattern.test(cleanTitle)) {
          return { unique: false, reason: 'Title contains only abstract emotional words' };
      }

      // Arousal-agnostic check: title should signal specific intensity
      // If title could plausibly belong to Clean OR Dirty â†’ FAIL
      const arousalAgnosticPatterns = [
          /^the\s+(moment|night|day|time)$/i,
          /^(that|this)\s+(one|night|day|moment)$/i
      ];
      for (const pattern of arousalAgnosticPatterns) {
          if (pattern.test(cleanTitle)) {
              return { unique: false, reason: 'Title could fit any arousal level' };
          }
      }

      return { unique: true, reason: null };
  }

  /**
   * TITLE IMMUTABILITY ENFORCEMENT
   * Once set, title must never change. Returns error if mutation attempted.
   * @param {string} currentTitle - Currently stored title
   * @param {string} newTitle - Proposed new title
   * @returns {{ allowed: boolean, error: object|null }}
   */
  function enforceTitleImmutability(currentTitle, newTitle) {
      // If no current title, any new title is allowed
      if (!currentTitle || currentTitle.trim() === '') {
          return { allowed: true, error: null };
      }

      // If titles match, no mutation
      if (currentTitle.trim() === newTitle?.trim()) {
          return { allowed: true, error: null };
      }

      // Any attempt to change an existing title is a HARD FAIL
      return {
          allowed: false,
          error: {
              code: VALIDATION_ERRORS.TITLE_IMMUTABLE_VIOLATION,
              message: `Title mutation blocked: "${currentTitle}" â†’ "${newTitle}"`
          }
      };
  }

  /**
   * COVER ESCALATION VALIDATION
   * Cover may escalate beyond title's baseline, but must not contradict downward
   * @param {string} titleArousal - Arousal level signaled by title
   * @param {string} coverArousal - Current cover arousal (from intensity layers)
   * @param {string} baselineArousal - Original arousal when title was generated
   * @returns {{ valid: boolean, error: object|null }}
   */
  function validateCoverEscalation(titleArousal, coverArousal, baselineArousal) {
      const arousalOrder = ['Clean', 'Naughty', 'Steamy', 'Passionate'];
      const baselineIndex = arousalOrder.indexOf(baselineArousal);
      const coverIndex = arousalOrder.indexOf(coverArousal);

      // Cover can escalate (higher index) or stay same
      // Cover CANNOT de-escalate below baseline
      if (coverIndex < baselineIndex) {
          return {
              valid: false,
              error: {
                  code: VALIDATION_ERRORS.COVER_BASELINE_CONTRADICTION,
                  message: `Cover de-escalated below title baseline: ${baselineArousal} â†’ ${coverArousal}`
              }
          };
      }

      return { valid: true, error: null };
  }

  /**
   * BUILD TITLE GENERATION PROMPT
   * Creates structured prompt for title generation based on selected mode
   * @param {string} mode - Selected title mode
   * @param {string} arousal - Current arousal level
   * @param {string} world - Current world setting
   * @param {string} tone - Current tone (optional, for Wry Confessional override)
   * @returns {string} - Prompt text
   */
  function buildTitlePrompt(mode, arousal, world, tone, opts) {
      // Wry Confessional: Return directly from vocabulary pool (no AI generation needed)
      // WRY CONFESSION IS THE MODEL â€” other tones should aspire to its semantic standard
      if (tone === 'Wry Confessional') {
          const pool = WRY_CONFESSIONAL_VOCABULARY[mode]
              || WRY_CONFESSIONAL_VOCABULARY.OBSERVATIONAL;
          return pool[Math.floor(Math.random() * pool.length)];
      }

      const modeVocab = TITLE_MODE_VOCABULARY[mode];
      const arousalSignals = AROUSAL_TITLE_SIGNALS[arousal];

      let modeInstruction = '';
      switch (mode) {
          case TITLE_MODES.POSSESSIVE_POWER:
              // CHANGED: Removed "Your Obedience" (resolution) from examples
              modeInstruction = `Generate a POSSESSIVE POWER title.
Format: [Possessive] [Noun]
Possessives: ${modeVocab.possessives.join(', ')}
Nouns for ${arousal}: ${modeVocab.nouns[arousal]?.join(', ') || 'Silence, Distance, Terms'}
Examples: "Her Silence", "My Hesitation", "Your Temptation"`;
              break;
          case TITLE_MODES.FORBIDDEN_OBJECT:
              modeInstruction = `Generate a FORBIDDEN OBJECT title.
Format: The [Object]
Objects for ${arousal}: ${modeVocab.objects[arousal]?.join(', ') || 'Door, Key, Contract'}
Examples: "The Key", "The Question", "The Threshold"`;
              break;
          case TITLE_MODES.VERB_LOCKED:
              // CHANGED: Now uses PRESENT tense, not past tense
              modeInstruction = `Generate a VERB-LOCKED title (PRESENT or CONDITIONAL tense â€” NOT past).
Format: [What/Where/If/Whether] [Subject] [Present Verb]
Verbs for ${arousal}: ${modeVocab.verbs[arousal]?.join(', ') || 'Means, Waits, Wants'}
Examples: "What She Wants", "If He Stays", "Whether You Dare"`;
              break;
          case TITLE_MODES.TWO_WORD_FRACTURE:
              // CHANGED: Removed "Sacred Damage" (aftermath) from examples
              modeInstruction = `Generate a TWO-WORD FRACTURE title.
Format: [Adjective] [Noun]
Adjectives for ${arousal}: ${modeVocab.adjectives[arousal]?.join(', ') || 'Quiet, Hidden, Burning'}
Nouns: ${modeVocab.nouns.join(', ')}
Examples: "Quiet Hunger", "Burning Silence", "Desperate Waiting"`;
              break;
      }

      return `${modeInstruction}

AROUSAL SIGNAL REQUIRED: ${arousal} â†’ ${arousalSignals?.description || 'clear intensity'}
WORLD: ${world}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
REGIME RULE â€” UNRESOLVED TENSION ONLY (ST1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
This title is generated at story START. The ending has not happened.

A title is the Story's ADMISSION of tension, NOT a promise of outcome.

BANNED â€” RESOLUTION VOCABULARY (HARD FAIL):
- Past-tense completion verbs: "took", "claimed", "broke", "ruined", "gave"
- Possessive resolution: "her surrender", "your obedience", "my ruin"
- Aftermath nouns: "reckoning", "downfall", "betrayal", "destruction"
- Completion states: "finally", "at last", "what remained"

BANNED â€” GENERIC PATTERNS (HARD FAIL):
- "Shadows of", "Echoes of", "Whispers"
- "Beneath", "Within", "Beyond"
- Destiny/fate language
- Multi-clause poetic phrasing
- Marketing copy tone

The title must name WHAT IS UNRESOLVED, not what will be resolved.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${opts?.worldSubtype === 'glass_house' ? buildGlassHouseTitleDirective(opts?.previousTitle) : ''}
Return ONLY the title, no quotes or explanation.`;
  }

  /**
   * SELECT TITLE MODE
   * Deterministically selects which title mode to use
   * @param {string} world - Current world setting
   * @param {string} arousal - Current arousal level
   * @param {string} genre - Current genre
   * @param {string} tone - Current tone (optional, for Wry Confessional override)
   * @returns {string} - Selected mode
   */
  function selectTitleMode(world, arousal, genre, tone) {
      // Wry Confessional uses its own mode set
      if (tone === 'Wry Confessional') {
          const modes = Object.values(WRY_CONFESSIONAL_TITLE_MODES);
          return modes[Math.floor(Math.random() * modes.length)];
      }

      // Use hash for deterministic but varied selection
      const seed = (world || 'Modern') + (arousal || 'Naughty') + (genre || 'Romance');
      const hash = simpleHash(seed);
      const modes = Object.values(TITLE_MODES);
      return modes[hash % modes.length];
  }

  // Expose pipeline functions globally
  window.detectTitleMode = detectTitleMode;
  window.runSwapTest = runSwapTest;
  window.enforceTitleImmutability = enforceTitleImmutability;
  window.validateCoverEscalation = validateCoverEscalation;
  window.buildTitlePrompt = buildTitlePrompt;
  window.selectTitleMode = selectTitleMode;
  window.TITLE_MODES = TITLE_MODES;

  // ============================================================
  // TRIPLE-FORK CONTINUATION SYSTEM
  // ============================================================
  // Three paths at story completion:
  // 1. Continue this story (same world instance, sequel title)
  // 2. New story, same world (same world ID, world-marked title)
  // 3. Completely new story (new world ID, fresh title)
  // ============================================================

  const CONTINUATION_PATHS = {
      CONTINUE: 'continue',
      SAME_WORLD: 'same_world',
      NEW_STORY: 'new_story'
  };

  const WORLD_STORY_SUFFIXES = ['Story', 'Tale', 'Affair', 'ExposÃ©', 'Adventure'];

  /**
   * Generate a unique World Instance ID
   * @returns {string}
   */
  function generateWorldInstanceId() {
      return 'world_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
  }

  /**
   * Generate a unique World Name based on world + flavor
   * @param {string} world - Current world setting
   * @param {string} genre - Current genre
   * @returns {string} - Unique world name (e.g., "The Veiled Courts", "Obsidian Towers")
   */
  function generateWorldName(world, genre) {
      const WORLD_NAME_PREFIXES = {
          Modern: ['The Glass', 'The Steel', 'The Gilded', 'The Shadow'],
          Historical: ['The Veiled', 'The Crown', 'The Silver', 'The Crimson'],
          Fantasy: ['The Fated', 'The Threaded', 'The Favored', 'The Veilbound'],
          SciFi: ['The Obsidian', 'The Nebula', 'The Quantum', 'The Orbital'],
          Noir: ['The Smoke', 'The Neon', 'The Midnight', 'The Velvet'],
          Gothic: ['The Hollow', 'The Raven', 'The Ashen', 'The Shrouded'],
          Paranormal: ['The Liminal', 'The Spectral', 'The Twilight', 'The Veil']
      };
      const WORLD_NAME_SUFFIXES = {
          Modern: ['Towers', 'District', 'Circle', 'Heights'],
          Historical: ['Courts', 'Houses', 'Halls', 'Estates'],
          Fantasy: ['Reach', 'Verge', 'Basin', 'Isles'],
          SciFi: ['Station', 'Sector', 'Frontier', 'Array'],
          Noir: ['Corners', 'Streets', 'District', 'Alleys'],
          Gothic: ['Manor', 'Abbey', 'Estate', 'Grounds'],
          Paranormal: ['Crossing', 'Threshold', 'Boundary', 'Gate']
      };

      const prefixes = WORLD_NAME_PREFIXES[world] || WORLD_NAME_PREFIXES.Modern;
      const suffixes = WORLD_NAME_SUFFIXES[world] || WORLD_NAME_SUFFIXES.Modern;

      const seed = (world || '') + (genre || '') + Date.now();
      const prefixIndex = simpleHash(seed) % prefixes.length;
      const suffixIndex = simpleHash(seed + 'suffix') % suffixes.length;

      return prefixes[prefixIndex] + ' ' + suffixes[suffixIndex];
  }

  /**
   * Get world story suffix based on world/tone
   * @param {string} world - Current world
   * @param {string} tone - Current tone
   * @returns {string}
   */
  function getWorldStorySuffix(world, tone) {
      // Different tones get different suffixes
      if (tone === 'Dark') return 'Tale';
      if (tone === 'WryConfession') return 'ExposÃ©';
      if (world === 'Noir') return 'Affair';
      return 'Tale';
  }

  /**
   * Build continuation title prompt for CONTINUE path
   * Must use SAME mode, echo structure, share NO exact words
   * @param {string} previousTitle - The title to echo
   * @param {string} previousMode - The mode to maintain
   * @param {string} arousal - Current arousal
   * @returns {string}
   */
  function buildContinuationTitlePrompt(previousTitle, previousMode, arousal) {
      const modeVocab = TITLE_MODE_VOCABULARY[previousMode];

      return `Generate a SEQUEL title that echoes the previous title.

PREVIOUS TITLE: "${previousTitle}"
TITLE MODE: ${previousMode} (MUST use same structure)

RULES:
1. Use the EXACT SAME title mode/structure as "${previousTitle}"
2. Echo its semantic feel and rhythm
3. Share NO EXACT WORDS with the previous title
4. Signal ${arousal} arousal level

${previousMode === TITLE_MODES.POSSESSIVE_POWER ?
    `Format: [Possessive] [Noun] â€” Use: ${modeVocab.possessives.join(', ')}` :
    previousMode === TITLE_MODES.FORBIDDEN_OBJECT ?
    `Format: The [Object]` :
    previousMode === TITLE_MODES.VERB_LOCKED ?
    `Format: [What/Where/When/How] [Subject] [Past Verb]` :
    `Format: [Adjective] [Noun]`}

Example: "The Hitched Breath" â†’ "The Forbidden Sigh"

Return ONLY the title, no quotes or explanation.`;
  }

  /**
   * Build same-world title with world-marking subtitle
   * @param {string} primaryTitle - The main title
   * @param {string} worldName - The persistent world name
   * @param {string} suffix - Story/Tale/Affair etc.
   * @returns {string}
   */
  function buildWorldMarkedTitle(primaryTitle, worldName, suffix) {
      return `${primaryTitle}\nA ${worldName} ${suffix}`;
  }

  /**
   * Validate continuation title based on path
   * @param {string} title - Generated title
   * @param {string} path - CONTINUE | SAME_WORLD | NEW_STORY
   * @param {object} context - { previousTitle, worldName, priorNouns }
   * @returns {{ valid: boolean, errors: Array<{code: string, message: string}> }}
   */
  function validateContinuationTitle(title, path, context) {
      const errors = [];
      const cleanTitle = (title || '').trim();

      if (path === CONTINUATION_PATHS.CONTINUE) {
          // Must share no exact words with previous title
          if (context.previousTitle) {
              const prevWords = context.previousTitle.toLowerCase().split(/\s+/);
              const newWords = cleanTitle.toLowerCase().split(/\s+/);
              const sharedWords = newWords.filter(w => prevWords.includes(w) && w.length > 2);
              if (sharedWords.length > 0) {
                  errors.push({
                      code: 'CONTINUATION_WORD_REUSE',
                      message: `Continuation title shares words with previous: ${sharedWords.join(', ')}`
                  });
              }
          }
      }

      if (path === CONTINUATION_PATHS.SAME_WORLD) {
          // Must include world-marking subtitle
          if (!cleanTitle.includes('\n') && !cleanTitle.includes(':')) {
              errors.push({
                  code: 'SAME_WORLD_MISSING_SUBTITLE',
                  message: 'Same-world title must include world-marking subtitle'
              });
          }
          // Must include world name
          if (context.worldName && !cleanTitle.includes(context.worldName)) {
              errors.push({
                  code: 'SAME_WORLD_MISSING_WORLD_NAME',
                  message: `Same-world title must include world name: "${context.worldName}"`
              });
          }
      }

      if (path === CONTINUATION_PATHS.NEW_STORY) {
          // Must not reference prior world nouns
          if (context.priorNouns && context.priorNouns.length > 0) {
              const titleLower = cleanTitle.toLowerCase();
              const reusedNouns = context.priorNouns.filter(n => titleLower.includes(n.toLowerCase()));
              if (reusedNouns.length > 0) {
                  errors.push({
                      code: 'NEW_STORY_PRIOR_NOUN_REUSE',
                      message: `New story title references prior world: ${reusedNouns.join(', ')}`
                  });
              }
          }
      }

      return { valid: errors.length === 0, errors };
  }

  /**
   * Initialize continuation state for a path
   * @param {string} path - Selected continuation path
   */
  function initializeContinuationPath(path) {
      // TEASE TIER: Block SAME_WORLD and NEW_STORY if free story consumed
      if (path !== CONTINUATION_PATHS.CONTINUE && isTeaseTier() && state.freeStoryConsumed && !hasTeaseUnlockCondition()) {
          console.warn('[TEASE] Continuation path blocked â€” free story consumed');
          window.showPaywall('unlock');
          return;
      }
      state.continuationPath = path;

      if (path === CONTINUATION_PATHS.CONTINUE) {
          // Keep same world instance, store previous title for reference
          // worldInstanceId stays the same
          console.log('[Continuation] CONTINUE: Same world instance, sequel title');
      } else if (path === CONTINUATION_PATHS.SAME_WORLD) {
          // Keep world instance ID and name, new story ID
          state.storyId = null; // Will be regenerated
          state.previousTitle = state.immutableTitle;
          console.log('[Continuation] SAME_WORLD: Same world, new narrative');
      } else {
          // NEW_STORY: Reset everything
          state.worldInstanceId = generateWorldInstanceId();
          state.worldName = null;
          state.previousTitle = null;
          state.previousTitleMode = null;
          state.storyId = null;
          console.log('[Continuation] NEW_STORY: Fresh start, new world instance');
      }
  }

  /**
   * Route title generation based on continuation path
   * @param {string} path - Continuation path
   * @param {object} context - Generation context
   * @returns {object} - { prompt: string, mode: string, worldMarked: boolean }
   */
  function routeTitleGeneration(path, context) {
      const { world, arousal, genre, tone, worldSubtype } = context;
      const titleOpts = { worldSubtype, previousTitle: state.previousTitle };

      if (path === CONTINUATION_PATHS.CONTINUE) {
          // Use previous mode, build continuation prompt
          const mode = state.previousTitleMode || detectTitleMode(state.previousTitle) || selectTitleMode(world, arousal, genre, tone);
          return {
              prompt: buildContinuationTitlePrompt(state.previousTitle, mode, arousal),
              mode: mode,
              worldMarked: false
          };
      } else if (path === CONTINUATION_PATHS.SAME_WORLD) {
          // Standard title generation, will add world suffix after
          if (!state.worldName) {
              state.worldName = generateWorldName(world, genre);
          }
          const mode = selectTitleMode(world, arousal, genre, tone);
          return {
              prompt: buildTitlePrompt(mode, arousal, world, tone, titleOpts),
              mode: mode,
              worldMarked: true,
              worldName: state.worldName,
              suffix: getWorldStorySuffix(world, tone)
          };
      } else {
          // NEW_STORY: Standard title generation
          const mode = selectTitleMode(world, arousal, genre, tone);
          return {
              prompt: buildTitlePrompt(mode, arousal, world, tone, titleOpts),
              mode: mode,
              worldMarked: false
          };
      }
  }

  /**
   * Store prior world proper nouns for new story validation
   * @returns {string[]}
   */
  function collectPriorWorldNouns() {
      const nouns = [];
      if (state.worldName) nouns.push(state.worldName);
      if (state.rawPlayerName) nouns.push(state.rawPlayerName);
      if (state.rawPartnerName) nouns.push(state.rawPartnerName);
      // Could add location names, institution names from story if tracked
      return nouns.filter(n => n && n.length > 2);
  }

  // Expose continuation system globally
  window.CONTINUATION_PATHS = CONTINUATION_PATHS;
  window.generateWorldInstanceId = generateWorldInstanceId;
  window.generateWorldName = generateWorldName;
  window.validateContinuationTitle = validateContinuationTitle;
  window.initializeContinuationPath = initializeContinuationPath;
  window.routeTitleGeneration = routeTitleGeneration;
  window.buildWorldMarkedTitle = buildWorldMarkedTitle;
  window.collectPriorWorldNouns = collectPriorWorldNouns;

  /**
   * Show the triple-fork continuation modal
   * Called at story completion or when user requests new story
   */
  function showContinuationFork() {
      const modal = document.getElementById('continuationForkModal');
      if (modal) {
          modal.classList.remove('hidden');
          console.log('[Continuation] Fork modal shown');
      }
  }

  /**
   * Hide the continuation fork modal
   */
  function hideContinuationFork() {
      const modal = document.getElementById('continuationForkModal');
      if (modal) {
          modal.classList.add('hidden');
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY END PAGE â€” Shown when a book completes
  // Hides all interactive story elements; shows "Start Book 2" CTA
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // IDs of elements to hide when End Page is active
  const _END_PAGE_HIDE_IDS = [
      'fateCardHeader', 'cardMount', 'metaControls',
      'actionWrapper', 'dialogueWrapper', 'submitBtn', 'saveBtn',
      'gameIntensity', 'edgeCovenantBtn', 'fortuneBalanceDisplay'
  ];

  function showStoryEndPage() {
      const endPage = document.getElementById('storyEndPage');
      if (!endPage) return;

      // Populate title
      const titleEl = endPage.querySelector('.sb-end-page-title');
      if (titleEl) {
          titleEl.textContent = document.getElementById('storyTitle')?.textContent || state.story?.title || 'Untitled';
      }

      // Hide interactive elements
      _END_PAGE_HIDE_IDS.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
      });
      // Also hide the parent containers of input/submit
      const inputGrid = document.querySelector('#storyContent > div[style*="grid-template-columns"]');
      if (inputGrid) inputGrid.style.display = 'none';
      // Hide submit/save row and fortune row
      const submitRow = document.getElementById('submitBtn')?.parentElement;
      if (submitRow) submitRow.style.display = 'none';
      const fortuneRow = document.getElementById('edgeCovenantBtn')?.parentElement;
      if (fortuneRow) fortuneRow.style.display = 'none';

      endPage.classList.remove('hidden');

      // Set book state
      state.book_complete = true;
      saveStorySnapshot();

      console.log('[END-PAGE] Story End Page shown (Book ' + (state.book_number || 1) + ' complete)');
  }

  function hideStoryEndPage() {
      const endPage = document.getElementById('storyEndPage');
      if (endPage) endPage.classList.add('hidden');

      // Restore interactive elements (for new story / Book 2)
      _END_PAGE_HIDE_IDS.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = '';
      });
      const inputGrid = document.querySelector('#storyContent > div[style*="grid-template-columns"]');
      if (inputGrid) inputGrid.style.display = '';
      const submitRow = document.getElementById('submitBtn')?.parentElement;
      if (submitRow) submitRow.style.display = '';
      const fortuneRow = document.getElementById('edgeCovenantBtn')?.parentElement;
      if (fortuneRow) fortuneRow.style.display = '';
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Badge engine â€” safe profile guard (no-op if profile not yet hydrated)
  function withProfileId(callback) {
    if (!_supabaseProfileId) return;
    callback(_supabaseProfileId);
  }

  // Badge engine â€” world mastery flavor registry (matches existing system IDs)
  // Keys match state.picks.world values (PascalCase, lowercased for lookup)
  const WORLD_FLAVORS = {
    modern:           ['small_town', 'college', 'friends', 'blue_blood', 'office', 'supernatural_modern', 'superheroic_modern'],
    fantasy:          ['arcane_binding', 'fated_blood', 'the_inhuman', 'the_beyond', 'cursed'],
    historical:       ['prehistoric', 'bronze_age', 'classical', 'medieval', 'renaissance', 'victorian', '20th_century'],
    scifi:            ['galactic_civilizations', 'future_of_science', 'cyberpunk', 'post_human', 'first_contact', 'simulation', 'final_frontier'],
    dystopia:         ['glass_house', 'human_capital', 'dogma', 'quieting_event', 'endless_edit', 'thirst'],
    postapocalyptic:  ['ashfall', 'year_zero', 'dystimulation', 'predation', 'hunger']
  };

  // Map normalized world keys to badge IDs
  const WORLD_BADGE_ID = {
    modern: 'mastery_modern',
    fantasy: 'mastery_fantasy',
    historical: 'mastery_historical',
    scifi: 'mastery_sci_fi',
    dystopia: 'mastery_dystopia',
    postapocalyptic: 'mastery_post_apocalyptic'
  };

  // Check if user has completed a story in every flavor of a given world.
  // Queries story_snapshots once, extracts flavors client-side. Idempotent via awardBadge.
  async function checkWorldMastery(supabase, profileId, world) {
    const requiredFlavors = WORLD_FLAVORS[world];
    if (!supabase || !profileId || !requiredFlavors) return;
    try {
      const { data } = await supabase
        .from('story_snapshots')
        .select('snapshot')
        .eq('profile_id', profileId);
      if (!data) return;

      const completedFlavors = new Set();
      data.forEach(row => {
        const snap = row.snapshot;
        if (!snap || !snap.stateSnapshot) return;
        const st = snap.stateSnapshot;
        const w = (st.picks?.world || '').toLowerCase();
        if (w !== world) return;
        if (!st.book_complete) return;
        const flavor = st.picks?.worldSubtype;
        if (flavor) completedFlavors.add(flavor);
      });

      const badgeId = WORLD_BADGE_ID[world];
      const allPresent = requiredFlavors.every(f => completedFlavors.has(f));
      if (allPresent && badgeId) {
        awardBadge(supabase, profileId, badgeId);
      }
    } catch (_) { /* silent */ }
  }

  // SHARED: Archive completed story + show cover interstitial
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async function _archiveAndShowInterstitial() {
      state.book_complete = true;

      // Badge engine â€” story completion milestones
      withProfileId(profileId => {
        incrementBadge(sb, profileId, 'story_1');
        incrementBadge(sb, profileId, 'story_10');
        incrementBadge(sb, profileId, 'story_100');
        // World mastery check (async, fire-and-forget)
        const completedWorld = (state.picks?.world || '').toLowerCase();
        if (completedWorld) checkWorldMastery(sb, profileId, completedWorld);
      });
      const book1StoryId = state.storyId;
      const book1Title = document.getElementById('storyTitle')?.textContent || state.story?.title || 'Untitled';

      // Lock main characters from current story
      state.main_characters_locked = {
          playerName: state.picks?.identity?.playerName || 'Protagonist',
          partnerName: state.picks?.identity?.partnerName || 'Love Interest',
          displayPlayerName: state.picks?.identity?.displayPlayerName || 'Protagonist',
          displayPartnerName: state.picks?.identity?.displayPartnerName || 'Love Interest',
          playerGender: state.gender || 'Female',
          partnerGender: state.loveInterest || 'Male',
          playerPronouns: state.authorPronouns || 'She/Her',
          partnerPronouns: (state.loveInterest === 'Female' ? 'She/Her' : state.loveInterest === 'Male' ? 'He/Him' : 'They/Them')
      };

      // Generate series_id if not set
      if (!state.series_id) {
          state.series_id = (typeof crypto !== 'undefined' && crypto.randomUUID)
              ? crypto.randomUUID()
              : 'series_' + Date.now().toString(36);
      }

      // Build continuity summary from last scenes
      const allContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      const endingText = allContent.slice(-2000);
      try {
          const summary = await callChat([{role:'user', content:`Summarize this story ending for a sequel author. Include:
1. Where the relationship stands (emotional state of both characters)
2. Any unresolved conflicts, secrets, or looming threats
3. Key plot threads left dangling
4. The emotional tone at the end

Keep it under 300 words. This is internal metadata, not reader-facing text.

Story ending excerpt:
${endingText}`}]);
          state.book1_continuity_summary = (summary || '').trim();
      } catch (e) {
          console.warn('[ARCHIVE] Continuity summary generation failed:', e.message);
          state.book1_continuity_summary = 'Previous story ended. Continue in this world.';
      }

      // Generate world_cycle_label â€” the emotional epoch of this world (Book 1 only)
      if ((state.book_number || 1) === 1) {
          const _CYCLE_FORM_WORDS = ['Epic', 'Chronicle', 'Legend', 'Affair', 'Saga', 'Reckoning', 'Covenant', 'Catastrophe', 'Rebellion', 'Devotion', 'Collapse', 'Dominion'];
          const _CYCLE_TONE_WORDS = ['Asunder', 'Reckoning', 'Devotion', 'Collapse', 'Rebellion', 'Covenant', 'Betrayal', 'Turning', 'Ascendance', 'Dominion', 'Fracture', 'Surrender', 'Awakening', 'Unraveling', 'Cataclysm', 'Eclipse'];
          const _formSet = new Set(_CYCLE_FORM_WORDS);

          // Simple non-crypto hash for stable deterministic fallback
          function _hashString(s) {
              let h = 0;
              for (let i = 0; i < s.length; i++) {
                  h = ((h << 5) - h + s.charCodeAt(i)) | 0;
              }
              return Math.abs(h);
          }

          // Validate candidate label against strict format rules
          function _validateCycleLabel(candidate, wName) {
              if (typeof candidate !== 'string') return false;
              const parts = candidate.split(/\s+/);
              // "A" + WorldName (1+ tokens) + ToneWord + FormWord = at least 4 tokens
              if (parts.length < 4 || parts[0] !== 'A') return false;
              // Only letters, spaces, apostrophes allowed
              if (!/^[A-Za-z\s']+$/.test(candidate)) return false;
              const formWord = parts[parts.length - 1];
              const toneWord = parts[parts.length - 2];
              // FormWord must be from closed set
              if (!_formSet.has(formWord)) return false;
              // ToneWord must differ from FormWord
              if (toneWord === formWord) return false;
              // WorldName tokens must match exactly
              const worldTokens = wName.split(/\s+/);
              const candidateWorld = parts.slice(1, 1 + worldTokens.length).join(' ');
              if (candidateWorld !== wName) return false;
              return true;
          }

          const worldName = state.picks?.world || 'Unknown';
          const tonePick = state.picks?.tone || 'Earnest';
          const genrePick = state.picks?.genre || '';
          const intensityPick = state.intensity || 'Steamy';
          const continuitySnippet = (state.book1_continuity_summary || '').slice(0, 400);
          const cycleSeed = book1StoryId || state.storyId || 'fallback';

          const _cyclePrompt = `Generate a world_cycle_label for a completed romance novel.

Context:
- World name: ${worldName}
- Tone: ${tonePick}
- Genre: ${genrePick}
- Intensity: ${intensityPick}
- Emotional resolution summary: ${continuitySnippet}

STRICT FORMAT: "A {WorldName} {ToneWord} {FormWord}"

RULES:
- WorldName MUST be exactly "${worldName}" â€” do not invent names.
- ToneWord: single evocative word reflecting the dominant emotional outcome. Examples: Asunder, Reckoning, Devotion, Collapse, Rebellion, Covenant, Betrayal, Turning, Ascendance, Dominion, Fracture, Surrender, Awakening, Unraveling, Cataclysm, Eclipse.
- FormWord: MUST be one of: Epic, Chronicle, Legend, Affair, Saga, Reckoning, Covenant, Catastrophe, Rebellion, Devotion, Collapse, Dominion.
- ToneWord and FormWord must be DIFFERENT words.
- 3â€“5 words after "A". No punctuation. Literary and mythic.
- Do NOT mention characters, geography, book numbers, or mechanics.

Return ONLY valid JSON:
{"world_cycle_label": "A ${worldName} ... ..."}`;

          let labelSet = false;
          for (let attempt = 0; attempt < 2 && !labelSet; attempt++) {
              try {
                  const cycleRaw = await callChat([{role:'user', content: _cyclePrompt}]);
                  const parsed = JSON.parse((cycleRaw || '').trim());
                  if (_validateCycleLabel(parsed.world_cycle_label, worldName)) {
                      state.world_cycle_label = parsed.world_cycle_label;
                      labelSet = true;
                  } else {
                      console.warn('[ARCHIVE] world_cycle_label validation failed (attempt ' + (attempt + 1) + '):', parsed.world_cycle_label);
                  }
              } catch (e) {
                  console.warn('[ARCHIVE] world_cycle_label attempt ' + (attempt + 1) + ' error:', e.message);
              }
          }

          // Stable deterministic fallback seeded by storyId
          if (!labelSet) {
              const h = _hashString(cycleSeed);
              let tIdx = h % _CYCLE_TONE_WORDS.length;
              let fIdx = h % _CYCLE_FORM_WORDS.length;
              // Ensure ToneWord != FormWord
              if (_CYCLE_TONE_WORDS[tIdx] === _CYCLE_FORM_WORDS[fIdx]) {
                  fIdx = (fIdx + 1) % _CYCLE_FORM_WORDS.length;
              }
              state.world_cycle_label = 'A ' + worldName + ' ' + _CYCLE_TONE_WORDS[tIdx] + ' ' + _CYCLE_FORM_WORDS[fIdx];
              console.warn('[ARCHIVE] world_cycle_label using fallback:', state.world_cycle_label);
          }
      }
      // else: Book 2+ inherits label from Book 1 (already in state)
      console.log('[ARCHIVE] world_cycle_label:', state.world_cycle_label);

      // Ensure world_cycle_id exists before archiving (fallback if title pipeline was bypassed)
      if (!state.world_cycle_id) {
          state.world_cycle_id = (typeof crypto !== 'undefined' && crypto.randomUUID)
              ? crypto.randomUUID()
              : generateWorldInstanceId();
          console.warn('[ARCHIVE] world_cycle_id was null at archive time â€” generated fallback:', state.world_cycle_id);
      }

      // Final save (immutable snapshot)
      saveStorySnapshot();
      // Archive under separate key so clearStoryContent() won't erase it
      try {
          const snap = localStorage.getItem('sb_saved_story');
          if (snap) {
              localStorage.setItem('sb_book1_archive_' + (state.series_id || book1StoryId || 'unknown'), snap);
          }
      } catch(e) { console.warn('[ARCHIVE] Archive save failed:', e.message); }

      // Show interstitial with cover
      hideStoryEndPage();
      const interstitial = document.getElementById('book1CompleteInterstitial');
      if (interstitial) {
          const coverSrc = document.getElementById('bookCoverImg')?.src || '';
          const interCoverImg = document.getElementById('book1CoverImg');
          if (interCoverImg && coverSrc) interCoverImg.src = coverSrc;
          const interTitle = interstitial.querySelector('.sb-book1-interstitial-title');
          if (interTitle) interTitle.textContent = book1Title;
          interstitial.classList.remove('hidden');
      }
      // Reset continue button state
      const continueBtn = document.getElementById('btnBook1InterstitialContinue');
      if (continueBtn) { continueBtn.classList.add('hidden'); continueBtn.textContent = 'Continue'; }
      const statusEl = document.getElementById('book2PrepStatus');
      if (statusEl) statusEl.textContent = 'Preparing your next story...';

      return { book1StoryId, book1Title, interstitial, continueBtn, statusEl };
  }

  // Shared: reset story-specific state fields (preserves subscription/payment)
  function _resetStoryState() {
      // â”€â”€ LAYER 3 â€” STORY STATE RESET â”€â”€
      // Resets all per-story couple/fate/narrative mechanics.
      // Called by startBook2 and startNewInWorld.
      // Does NOT touch Epoch State (Layer 2) or Region Physics (Layer 1).

      state._isTransitioning = false;
      state.storyEnded = false;
      state.book_complete = false;
      state.turnCount = 0;
      state.storyId = null;
      state._loggedStoryStart = false;
      state._loggedScene3 = false;
      state._loggedScene6 = false;
      state._loggedPetitionOpen = false;
      state._loggedPetitionSubmit = false;
      state._fantasyMapInjected = false;
      state._titlePageShown = false;
      state._synopsisBlurb = null;
      state._synopsisMetadata = null;
      state.flingClimaxDone = false;
      state.flingConsequenceShown = false;
      state.cautiousStreak = 0;
      state.dynamicDominanceBoost = 0;
      state.vulnerabilityPulse = 0;
      state.storyStage = null;
      state.intimacyInterrupted = { first_kiss: false, first_intimacy: false };
      state.intimacyTurnsInWindow = 0;

      // Fate / volatility / saturation â€” per-story, must not bleed
      // NOTE: _syzygyOccurred is EPOCH STATE (Layer 2) â€” persists across same-world continuations
      state._syzygyActiveThisScene = false;
      state.fate_saturation = 0;
      state.volatility_window = { active: false, severity: 0, remaining_scenes: 0 };
      state.consecutive_tempt_fate_count = 0;
      state.tempt_fate_invoked_this_turn = false;
      state.petitionUsedThisScene = false;

      // Fate object â€” per-story tracking
      state.fate = { stance: 'neutral', minorUsedThisScene: false, greaterUsedThisScene: false, lastGreaterSceneIndex: null, earnedIntimacy: false, earlyGamingCount: 0, pendingPetition: null };

      // Omen + keyhole â€” per-story
      state.omen = { decayStage: 0, decayAccumulator: 0, lastDecayTurn: 0, recoveryAccumulator: 0, lastGreaterPetitionCount: 0, totalWithholds: 0, temporaryWarmth: false };
      state.keyhole = { marked: false, orientation: 'neutral', favorReservoir: 0, maxFavor: 100, regenPerTurn: 5, boonUsedThisScene: false, totalBoonsDrained: 0, alignmentScore: 0, lastOrientationShift: 0, rivalKeyholeActive: false };

      // Scene importance / sceneImportance (if used)
      state.sceneImportance = undefined;

      // Cascade / adaptive / erotic â€” per-story runtime
      state.cascadeMode = false;
      state.cascadeCount = 0;
      state.cascadeContext = null;
      state.lastCascadeExcerpt = null;
      state.adaptiveMetrics = { turnTimestamps: [], userInputLengths: [], sceneWordCounts: [], cascadeCountWindow: 0, eroticSignalCount: 0 };
      state.pacingMode = 'HYBRID';
      state.eroticPressureScore = 0;
      state.eroticMode = 'ROMANTIC';
      state.redirectCooldownTurns = 0;
      state.seductionEligible = false;
      state.gooseCooldown = 0;

      // Couple drift â€” per-story
      state.coupleTensionDrift = 0;
      state.coupleStructure = 'monogamous';
      state.coupleHasReachedST4 = false;
      state.lastCoupleDriftEchoScene = 0;
      state._coupleDriftEchoLine = null;

      // Dream injection + selection echo â€” per-story
      state.lastDreamInjectionTurn = 0;
      state._dreamInjectionLine = null;
      state.selectionTension = 0;
      state.lastSelectionEchoTurn = 0;
      state._selectionEchoLine = null;

      // Edge covenant â€” per-story
      state.edgeCovenant = { active: false, level: 1, acceptedAtTurn: 0, offeredBy: '' };
      state.pendingEdgeOffer = null;
      state.edgeCovenantOfferedThisTurn = false;

      // Storyturn + milestones â€” per-story
      state.storyturn = 'ST1';
      state.milestone_vision_fired_this_turn = false;

      // Historical / Dystopia per-story systems
      state.historicalCognitiveBand = null;
      state.historicalCognitiveModulation = 0.25;
      state.historicalFrictionIndex = 0;
      state.dystopianAttentionLevel = 0;
      state.dystopianEnforcementMode = null;

      // Speculative preload â€” per-story runtime
      state.speculativeNextScene = null;
      state.isPreloadingNextScene = false;

      // Couple structure votes (module-scoped, not on state)
      if (typeof _coupleStructureVotes !== 'undefined') {
          _coupleStructureVotes = { player1: null, player2: null };
      }

      // Safety / content gating â€” per-story
      state.sexPushCount = 0;
      state.lastSexPushAt = null;
      state.nonConPushCount = 0;
      state.lastNonConPushAt = 0;
      state.lastSafewordAt = 0;

      // Literary Illusion Layer â€” per-story voice + motif tracking
      state.storyVoiceProfile = { avg_sentence_length: 'medium', metaphor_density: 'low', emotional_tone: 'restrained' };
      state.storyMotifs = [];

      // Generate new story ID
      state.storyId = (typeof crypto !== 'undefined' && crypto.randomUUID)
          ? crypto.randomUUID()
          : 'sb_' + Date.now().toString(36);
      localStorage.setItem('sb_current_story_id', state.storyId);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LITERARY ILLUSION LAYER â€” post-turn voice + motif analysis (zero API calls)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function _updateLiteraryIllusion(sceneText) {
      if (!sceneText || typeof sceneText !== 'string') return;
      const plain = sceneText.replace(/<[^>]+>/g, '').trim();
      if (plain.length < 40) return;

      // â”€â”€ Voice Profile (heuristic) â”€â”€
      const sentences = plain.split(/[.!?]+/).filter(s => s.trim().length > 3);
      const avgLen = sentences.length > 0 ? plain.split(/\s+/).length / sentences.length : 12;
      const lengthBias = avgLen < 10 ? 'short' : avgLen > 20 ? 'long' : 'medium';

      const metaphorSignals = (plain.match(/\b(like a|as though|as if|became a|turned to|was a kind of|felt like)\b/gi) || []).length;
      const density = metaphorSignals >= 4 ? 'high' : metaphorSignals >= 2 ? 'med' : 'low';

      const intensitySignals = (plain.match(/\b(gasp|shudder|tremble|burn|ache|seize|claw|devour|ravage)\b/gi) || []).length;
      const tenderSignals = (plain.match(/\b(gentle|soft|tender|whisper|brush|trace|cradle|murmur)\b/gi) || []).length;
      const dominantSignals = (plain.match(/\b(command|grip|pin|force|claim|demand|submit|kneel)\b/gi) || []).length;
      let tone = 'restrained';
      const maxTone = Math.max(intensitySignals, tenderSignals, dominantSignals);
      if (maxTone >= 2) {
          if (intensitySignals === maxTone) tone = 'intense';
          else if (tenderSignals === maxTone) tone = 'tender';
          else if (dominantSignals === maxTone) tone = 'dominant';
      }

      state.storyVoiceProfile = { avg_sentence_length: lengthBias, metaphor_density: density, emotional_tone: tone };

      // â”€â”€ Motif Echo (extract nouns, deduplicate, cap at 3) â”€â”€
      const nouns = plain.match(/\b(shadow|flame|glass|storm|silk|iron|thorn|mirror|wound|mask|veil|smoke|honey|blade|ember|salt|ash|bone|chain|frost|throne|grave|tide|vine|velvet|serpent|cathedral|labyrinth|fortress|garden|abyss)\b/gi) || [];
      const freq = {};
      nouns.forEach(n => { const k = n.toLowerCase(); freq[k] = (freq[k] || 0) + 1; });
      // Merge with existing motifs (frequency-weighted)
      (state.storyMotifs || []).forEach(m => { freq[m] = (freq[m] || 0) + 2; });
      const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]).map(e => e[0]);
      state.storyMotifs = sorted.slice(0, 3);
  }

  function buildLiteraryIllusionDirective() {
      const parts = [];
      // Voice profile
      const vp = state.storyVoiceProfile;
      if (vp && state.turnCount > 1) {
          parts.push(`Maintain established story voice:\n- Sentence rhythm: ${vp.avg_sentence_length} bias\n- Emotional tone: ${vp.emotional_tone}\n- Metaphor density: ${vp.metaphor_density}\nDo not restate these explicitly in prose.`);
      }
      // Motif echo
      const motifs = state.storyMotifs;
      if (motifs && motifs.length > 0) {
          parts.push(`If contextually appropriate, subtly echo established motifs: ${motifs.join(', ')}.\nDo not force inclusion.`);
      }
      // Archetype lexicon hint
      const archId = state.archetype?.primary;
      if (archId && ARCHETYPE_LEXICON[archId]) {
          parts.push(ARCHETYPE_LEXICON[archId]);
      }
      return parts.length > 0 ? '\n\n' + parts.join('\n\n') : '';
  }

  // â”€â”€ LAYER 2 â€” EPOCH STATE RESET â”€â”€
  // Clears world-cycle entropy and epoch-level flags.
  // Called ONLY on full world change (resetForNewStory / performAuthReset).
  function _resetEpochState() {
      state.world_cycle_id = null;
      state._syzygyOccurred = false;
      state.world_cycle_label = null;
      state.worldInstanceId = null;
      state.worldName = null;
      state.previousTitle = null;
      state.previousTitleMode = null;
      state.continuationPath = null;

      // Clear all entropy axis objects
      const entropyKeys = [
          '_fantasyCoreEntropy', '_modernCoreEntropy', '_smallTownEntropy',
          '_collegeEntropy', '_officeEntropy', '_friendsEntropy',
          '_supernaturalEntropy', '_superheroicEntropy',
          '_historicalCoreEntropy', '_dystopiaCoreEntropy', '_blueBloodEntropy'
      ];
      for (const k of entropyKeys) {
          state[k] = undefined;
      }
  }

  // â”€â”€ LAYER 1 â€” REGION PHYSICS RESET â”€â”€
  // Clears Fantasy region invariants (governance, seat, magic bias, etc.).
  // Called ONLY on full world change (resetForNewStory / performAuthReset).
  function _resetRegionPhysics() {
      state.fantasyRegion = undefined;
      state.fantasyRegionSeat = undefined;
      state.fantasyRegionGovernance = undefined;
      state.fantasyRegionStatus = undefined;
      state.fantasyRegionReality = undefined;
      state.fantasyMagicExpressionBias = undefined;
  }

  // Shared: mount generated scene + wire interstitial continue button
  function _mountAndTransition(title, synopsis, body, interstitial, continueBtn, statusEl, label) {
      StoryPagination.init();
      StoryPagination.clear();
      StoryPagination.addPage(formatStory(body), true);
      state.turnCount = 1;
      state.scenes = state.scenes || [];
      state.scenes.push({ title, synopsis, text: body, fateCard: null });

      if (statusEl) statusEl.textContent = label + ' ready';
      if (continueBtn) {
          continueBtn.textContent = 'Continue to ' + label;
          continueBtn.classList.remove('hidden');
          continueBtn.onclick = function() {
              if (interstitial) interstitial.classList.add('hidden');
              window.showScreen('game');
              showReaderPage(2);
              if (!state._titlePageShown) showTitlePage();
              if (window.dealFateCards) window.dealFateCards();
              if (window.initFateCards) window.initFateCards();
              document.getElementById('submitBtn').disabled = false;
              saveStorySnapshot();
              console.log('[' + label.toUpperCase() + '] Mounted and Title page shown');
          };
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // START BOOK 2 â€” Sequel: same characters, same world
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  window.startBook2 = async function() {
      // Reentrancy guard â€” prevent double-click / concurrent execution
      if (state._isTransitioning) return;
      state._isTransitioning = true;
      const btn = document.getElementById('btnStartBook2');
      if (btn) btn.disabled = true;

      console.log('[BOOK2] Starting Book 2 flow');

      // Snapshot everything BEFORE any mutation or async work
      const lockedChars = state.main_characters_locked;
      const lockedPicks = { ...state.picks };
      const lockedWorld = state.picks?.world;
      const lockedTone = state.picks?.tone;
      const lockedFlavor = state.picks?.flavor;
      const lockedGenre = state.picks?.genre;
      const lockedArchetype = state.archetype ? { ...state.archetype } : { primary: 'BEAUTIFUL_RUIN', modifier: null };
      const lockedIntensity = state.intensity;
      const seriesId = state.series_id;
      const bookNumber = (state.book_number || 1) + 1;
      const previousTitle = state.immutableTitle || state.story?.title || 'Untitled';
      const continuitySummary = state.book1_continuity_summary;
      const lockedCycleLabel = state.world_cycle_label;
      const baseSysPrompt = state.sysPrompt || '';

      // Archive + show interstitial (safe â€” does not mutate core state)
      let interstitial, continueBtn, statusEl, book1StoryId;
      try {
          const archive = await _archiveAndShowInterstitial();
          book1StoryId = archive.book1StoryId;
          interstitial = archive.interstitial;
          continueBtn = archive.continueBtn;
          statusEl = archive.statusEl;
      } catch (archiveErr) {
          console.error('[BOOK2] Archive failed:', archiveErr);
          state._isTransitioning = false;
          if (btn) btn.disabled = false;
          return;
      }

      // Generate Book 2 title + blurb + Scene 1 â€” NO state mutation until success
      try {
          if (statusEl) statusEl.textContent = 'Generating Book 2 title...';
          const titleResult = await callChat([{role:'user', content:`Generate a title for Book 2 of a romance series.

Book 1 title: "${previousTitle}"
World: ${lockedWorld}
Tone: ${lockedTone}
Genre/Flavor: ${lockedGenre}/${lockedFlavor}

RULES:
- Echo Book 1's title pattern/style (if "X of Y", use similar structure; if "The ___", echo that)
- Must feel like a natural sequel â€” connected but distinct
- Do NOT include "Book 2" or "Book II" in the title text
- Keep under 8 words
- Return ONLY the title, no quotes, no explanation`}]);
          const book2Title = (titleResult || 'Untitled').trim().replace(/^["']|["']$/g, '');

          if (statusEl) statusEl.textContent = 'Writing Book 2 opening...';

          const blurbResult = await callChat([{role:'user', content:`Write a back-cover blurb for Book 2 of a romance series.

Book 1 title: "${previousTitle}"
Book 2 title: "${book2Title}"
World: ${lockedWorld}, Tone: ${lockedTone}
Characters: ${lockedChars.playerName} and ${lockedChars.partnerName}

Book 1 ended with:
${(continuitySummary || '').slice(0, 500)}

RULES:
- 2-4 short paragraphs
- Reference unresolved threads from Book 1 without exposition dumping
- Hook + tension + promise
- NO "In Book 1..." or "Previously..." framing
- Tone must match: ${lockedTone}
- Write like a bestseller's back cover

Return ONLY the blurb paragraphs:`}]);
          const blurbText = (blurbResult || '').trim();

          // Append Book 2 continuation context to system prompt
          const book2SysAddendum = `

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BOOK 2 CONTINUATION CONTEXT (INTERNAL â€” never expose to reader)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
This is Book ${bookNumber} of an ongoing series. The same protagonists continue.
Protagonist: ${lockedChars.playerName} (${lockedChars.playerGender}, ${lockedChars.playerPronouns})
Love Interest: ${lockedChars.partnerName} (${lockedChars.partnerGender}, ${lockedChars.partnerPronouns})

BOOK 1 ENDING SUMMARY:
${continuitySummary || 'Book 1 ended. Continue the story.'}

CONTINUATION RULES:
- Do NOT reset relationships. Characters remember everything from Book 1.
- Do NOT reintroduce origins or backstories as if the reader is new.
- Start with a new inciting complication that logically follows Book 1's ending.
- Maintain the emotional continuity â€” if they were together, they are still together; if strained, still strained.
- The tone, world, and dynamic constraints remain identical.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
          const newSysPrompt = baseSysPrompt + book2SysAddendum;

          let sceneText = await callChat([
              { role: 'system', content: newSysPrompt },
              { role: 'user', content: `Write Scene 1 of Book ${bookNumber} â€” a direct continuation of Book 1.

The reader already knows these characters intimately. Begin with a new situation, complication, or shift that picks up from where Book 1 left off.

Include at the start of your response:
[TITLE: "${book2Title}"]
[SYNOPSIS: "A one-sentence hook for Book ${bookNumber}"]

Then write the scene prose (800-1200 words).

Do NOT summarize Book 1. Do NOT reintroduce characters. Jump straight into the new story.` }
          ]);

          const { synopsis, blurb: parsedBlurb, body } = parseScene1Response(sceneText);

          // â”€â”€ ALL ASYNC WORK COMPLETE â€” now commit state reset â”€â”€
          _resetStoryState();
          // Defensive restore of epoch state (already preserved, but safety net)
          state.world_cycle_label = lockedCycleLabel;
          state.book_number = bookNumber;
          state.series_id = seriesId;
          state.previous_story_id = book1StoryId;
          state.main_characters_locked = lockedChars;
          state.book1_continuity_summary = continuitySummary;
          state.picks = lockedPicks;
          state.picks.identity = {
              playerName: lockedChars.playerName,
              partnerName: lockedChars.partnerName,
              displayPlayerName: lockedChars.displayPlayerName,
              displayPartnerName: lockedChars.displayPartnerName
          };
          state.archetype = lockedArchetype;
          state.intensity = lockedIntensity;
          state.gender = lockedChars.playerGender;
          state.loveInterest = lockedChars.partnerGender;
          state.previousTitle = previousTitle;
          state.continuationPath = 'continue';
          state.immutableTitle = book2Title;
          state.book_subhead = null;
          state.sysPrompt = newSysPrompt;
          state._synopsisBlurb = blurbText;
          state.story = state.story || {};
          state.story.title = book2Title;
          if (synopsis) state._synopsisMetadata = synopsis;
          if (parsedBlurb && !state._synopsisBlurb) state._synopsisBlurb = parsedBlurb;

          clearStoryContent();
          document.getElementById('storyTitle').textContent = book2Title;

          _mountAndTransition(book2Title, synopsis, body, interstitial, continueBtn, statusEl, 'Book 2');
          state._isTransitioning = false;
          console.log('[BOOK2] Book 2 generation complete: "' + book2Title + '"');

      } catch (err) {
          console.error('[BOOK2] Generation failed:', err);
          state._isTransitioning = false;
          if (btn) btn.disabled = false;
          if (statusEl) statusEl.textContent = 'Generation failed. Please try again.';
          if (continueBtn) {
              continueBtn.textContent = 'Try Again';
              continueBtn.classList.remove('hidden');
              continueBtn.onclick = function() {
                  if (interstitial) interstitial.classList.add('hidden');
                  window.startBook2();
              };
          }
      }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEW STORY IN THIS WORLD â€” New characters, same world/pov/length
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  window.startNewInWorld = async function() {
      // Reentrancy guard â€” prevent double-click / concurrent execution
      if (state._isTransitioning) return;
      state._isTransitioning = true;
      const btn = document.getElementById('btnNewInWorld');
      if (btn) btn.disabled = true;

      console.log('[NEW-WORLD] Starting new story in same world');

      // Snapshot everything BEFORE any mutation or async work
      const lockedWorld = state.picks?.world;
      const lockedPov = state.picks?.pov;
      const lockedTone = state.picks?.tone;
      const lockedFlavor = state.picks?.flavor;
      const lockedGenre = state.picks?.genre;
      const lockedEra = state.picks?.era;
      const lockedIntensity = state.intensity;
      const lockedStoryLength = state.storyLength;
      const lockedWorldSubtype = state.picks?.worldSubtype;
      const lockedWorldCustomText = state.worldCustomTexts;
      const previousTitle = state.immutableTitle || state.story?.title || 'Untitled';
      const baseSysPrompt = state.sysPrompt || '';
      const previousPressure = state.picks?.pressure;
      const previousDynamic = state.picks?.dynamic;

      // Auto-pick new Story Pull (different from previous if possible)
      const ALL_PRESSURES = ['PowerControl', 'EscapePursuit', 'DesireObsession', 'Survival', 'RiskExposure', 'ObligationBurden', 'ReckoningPast', 'Transformation'];
      const otherPressures = ALL_PRESSURES.filter(p => p !== previousPressure);
      const newPressure = otherPressures[Math.floor(Math.random() * otherPressures.length)];

      // Auto-pick new Story Polarity (different from previous if possible)
      const ALL_DYNAMICS = ['Friends', 'Enemies', 'SecondChance', 'Forbidden', 'Proximity', 'SecretIdentity'];
      const otherDynamics = ALL_DYNAMICS.filter(d => d !== previousDynamic);
      const newDynamic = otherDynamics[Math.floor(Math.random() * otherDynamics.length)];

      // Auto-pick new archetype (LI mask)
      const ALL_ARCHETYPES = ['HEART_WARDEN', 'OPEN_VEIN', 'SPELLBINDER', 'ARMORED_FOX', 'DARK_VICE', 'BEAUTIFUL_RUIN', 'ETERNAL_FLAME'];
      const newArchetype = ALL_ARCHETYPES[Math.floor(Math.random() * ALL_ARCHETYPES.length)];

      // Auto-pick new character names
      const FEMALE_NAMES = ['Elara Vance', 'Cassandra Wells', 'Mira Thornwood', 'Vivian Blake', 'Cordelia Hart', 'Aurelia Stone', 'Seraphina Cole', 'Isadora Crane', 'Helena Frost', 'Rosalind Grey', 'Celestine Moore', 'Evangeline Price', 'Lydia Sterling', 'Ophelia Dane', 'Tatiana West'];
      const MALE_NAMES = ['Sebastian Blackwood', 'Julian Ashford', 'Marcus Thorne', 'Alexander Crane', 'Dominic Vale', 'Lucian Grey', 'Theodore Sterling', 'Maximilian Drake', 'Gabriel Frost', 'Benedict Hale', 'Damien Cross', 'Vincent Ashmore', 'Nathaniel Wolfe', 'Adrian Sinclair', 'Dorian Vance'];

      // Randomize genders for new characters
      const genders = ['Female', 'Male'];
      const playerGender = genders[Math.floor(Math.random() * genders.length)];
      const partnerGender = genders[Math.floor(Math.random() * genders.length)];

      const playerNames = playerGender === 'Female' ? FEMALE_NAMES : MALE_NAMES;
      const partnerNames = partnerGender === 'Female' ? FEMALE_NAMES : MALE_NAMES;
      const newPlayerName = playerNames[Math.floor(Math.random() * playerNames.length)];
      let newPartnerName = partnerNames[Math.floor(Math.random() * partnerNames.length)];
      while (newPartnerName === newPlayerName) {
          newPartnerName = partnerNames[Math.floor(Math.random() * partnerNames.length)];
      }

      // Derive pronouns from gender
      const playerPronouns = playerGender === 'Female' ? 'She/Her' : playerGender === 'Male' ? 'He/Him' : 'They/Them';
      const partnerPronouns = partnerGender === 'Female' ? 'She/Her' : partnerGender === 'Male' ? 'He/Him' : 'They/Them';

      // Derive author gender/pronouns (same logic as corridor)
      let authorGender, authorPronouns;
      if (playerGender === 'Male' && partnerGender === 'Female') { authorGender = 'Female'; authorPronouns = 'She/Her'; }
      else if (playerGender === 'Male' && partnerGender === 'Male') { authorGender = 'Male'; authorPronouns = 'He/Him'; }
      else if (playerGender === 'Female' && partnerGender === 'Female') { authorGender = 'Female'; authorPronouns = 'She/Her'; }
      else { authorGender = 'Non-Binary'; authorPronouns = 'They/Them'; }

      // Archive + show interstitial (safe â€” does not mutate core state)
      let interstitial, continueBtn, statusEl;
      try {
          const archive = await _archiveAndShowInterstitial();
          interstitial = archive.interstitial;
          continueBtn = archive.continueBtn;
          statusEl = archive.statusEl;
      } catch (archiveErr) {
          console.error('[NEW-WORLD] Archive failed:', archiveErr);
          state._isTransitioning = false;
          if (btn) btn.disabled = false;
          return;
      }

      // Generate title + blurb + Scene 1 â€” NO state mutation until success
      try {
          if (statusEl) statusEl.textContent = 'Generating new story title...';

          const titleResult = await callChat([{role:'user', content:`Generate a title for a new romance novel set in the same world as "${previousTitle}".

World: ${lockedWorld}
Tone: ${lockedTone}
Genre/Flavor: ${lockedGenre}/${lockedFlavor}
Dynamic: ${newDynamic}

RULES:
- Echo the tone/style of "${previousTitle}" (if poetic, stay poetic; if punchy, stay punchy)
- This is NOT a sequel â€” new characters, new story
- Keep under 8 words
- Return ONLY the title, no quotes, no explanation`}]);
          const baseTitle = (titleResult || 'Untitled').trim().replace(/^["']|["']$/g, '');

          if (statusEl) statusEl.textContent = 'Writing opening scene...';

          const blurbResult = await callChat([{role:'user', content:`Write a back-cover blurb for a new romance novel.

Title: "${baseTitle}"
World: ${lockedWorld}, Tone: ${lockedTone}, Dynamic: ${newDynamic}
Protagonist: ${newPlayerName} (${playerGender})
Love Interest: ${newPartnerName} (${partnerGender})

RULES:
- 2-4 short paragraphs
- Hook + tension + promise
- This is a standalone novel, not a sequel
- Tone must match: ${lockedTone}
- Write like a bestseller's back cover

Return ONLY the blurb paragraphs:`}]);
          const blurbText = (blurbResult || '').trim();

          // Build system prompt for new story (reuse base but strip any Book 2 addenda)
          const cleanSys = baseSysPrompt.replace(/â•+\nBOOK 2 CONTINUATION CONTEXT[\s\S]*?â•+\n?/g, '');

          let sceneText = await callChat([
              { role: 'system', content: cleanSys },
              { role: 'user', content: `Write Scene 1 of a new romance novel set in ${lockedWorld}.

Protagonist: ${newPlayerName} (${playerGender}, ${playerPronouns})
Love Interest: ${newPartnerName} (${partnerGender}, ${partnerPronouns}) â€” a ${newArchetype.replace(/_/g, ' ').toLowerCase()} archetype
Dynamic: ${newDynamic}
Story Pull: ${newPressure}

This is a STANDALONE story â€” no returning characters, no sequel continuity.

Include at the start of your response:
[TITLE: "${baseTitle}"]
[SYNOPSIS: "A one-sentence hook"]

Then write the scene prose (800-1200 words). Introduce both characters and establish the central tension.` }
          ]);

          const { synopsis, blurb: parsedBlurb, body } = parseScene1Response(sceneText);

          // â”€â”€ ALL ASYNC WORK COMPLETE â€” now commit state reset â”€â”€
          _resetStoryState();
          state.book_number = 1;
          state.series_id = null;
          state.previous_story_id = null;
          state.main_characters_locked = null;
          state.book1_continuity_summary = null;

          // Restore world/pov/length
          state.picks = state.picks || {};
          state.picks.world = lockedWorld;
          state.picks.pov = lockedPov;
          state.picks.tone = lockedTone;
          state.picks.flavor = lockedFlavor;
          state.picks.genre = lockedGenre;
          state.picks.era = lockedEra;
          state.picks.worldSubtype = lockedWorldSubtype;
          state.worldCustomTexts = lockedWorldCustomText;
          state.intensity = lockedIntensity;
          state.storyLength = lockedStoryLength;

          // Set new auto-chosen values
          state.picks.pressure = newPressure;
          state.picks.dynamic = newDynamic;
          state.archetype = { primary: newArchetype, modifier: null };
          state.gender = playerGender;
          state.authorGender = authorGender;
          state.authorPronouns = authorPronouns;
          state.loveInterest = partnerGender;
          state.picks.identity = {
              playerName: newPlayerName,
              partnerName: newPartnerName,
              displayPlayerName: newPlayerName,
              displayPartnerName: newPartnerName
          };
          state.continuationPath = 'new_world';
          state.immutableTitle = baseTitle;
          state.book_subhead = 'In the world of ' + previousTitle;
          state.previousTitle = previousTitle;
          state.sysPrompt = cleanSys;
          state._synopsisBlurb = blurbText;
          state.story = state.story || {};
          state.story.title = baseTitle;
          if (synopsis) state._synopsisMetadata = synopsis;
          if (parsedBlurb && !state._synopsisBlurb) state._synopsisBlurb = parsedBlurb;

          clearStoryContent();
          document.getElementById('storyTitle').textContent = baseTitle;

          _mountAndTransition(baseTitle, synopsis, body, interstitial, continueBtn, statusEl, 'New Story');
          state._isTransitioning = false;
          console.log('[NEW-WORLD] New story generation complete: "' + baseTitle + '"');

      } catch (err) {
          console.error('[NEW-WORLD] Generation failed:', err);
          state._isTransitioning = false;
          if (btn) btn.disabled = false;
          if (statusEl) statusEl.textContent = 'Generation failed. Please try again.';
          if (continueBtn) {
              continueBtn.textContent = 'Try Again';
              continueBtn.classList.remove('hidden');
              continueBtn.onclick = function() {
                  if (interstitial) interstitial.classList.add('hidden');
                  window.startNewInWorld();
              };
          }
      }
  };

  // Show cover from End Page (reuses existing cover display)
  window.showCoverFromEndPage = function() {
      const coverImg = document.getElementById('bookCoverImg');
      if (coverImg && coverImg.src) {
          const bookCoverPage = document.getElementById('bookCoverPage');
          const bookObject = document.getElementById('bookObject');
          const storyContent = document.getElementById('storyContent');
          if (bookCoverPage) bookCoverPage.classList.remove('hidden');
          if (bookObject) bookObject.classList.remove('hidden');
          if (storyContent) storyContent.classList.add('hidden');
      }
  };

  /**
   * Handle user selection of continuation path
   * @param {string} path - 'continue' | 'same_world' | 'new_story'
   */
  function selectContinuationPath(path) {
      // Map string to constant
      const pathMap = {
          'continue': CONTINUATION_PATHS.CONTINUE,
          'same_world': CONTINUATION_PATHS.SAME_WORLD,
          'new_story': CONTINUATION_PATHS.NEW_STORY
      };
      const selectedPath = pathMap[path] || CONTINUATION_PATHS.NEW_STORY;

      console.log('[Continuation] Path selected:', selectedPath);

      // Store prior world nouns before path initialization (for NEW_STORY validation)
      const priorNouns = collectPriorWorldNouns();
      state._priorWorldNouns = priorNouns;

      // Preserve world for SAME_WORLD path before any resets
      const preservedWorld = state.picks?.world;
      const preservedTitle = state.immutableTitle;
      const preservedTitleMode = state.previousTitleMode;

      // Initialize the path (sets continuation state)
      initializeContinuationPath(selectedPath);

      // Hide modal
      hideContinuationFork();

      // Handle path-specific state management
      if (selectedPath === CONTINUATION_PATHS.CONTINUE) {
          // Direct sequel â€” preserve most state, just reset story position
          state.storyEnded = false;
          state.turnCount = 0;
          state._loggedStoryStart = false;
          state._loggedScene3 = false;
          state._loggedScene6 = false;
          state._loggedPetitionOpen = false;
          state._loggedPetitionSubmit = false;
          clearStoryContent();
          // Title should echo previous title's mode
          state.previousTitle = preservedTitle;
          console.log('[Continuation] CONTINUE: Story state reset for sequel');
          window.showScreen('setup');
      } else if (selectedPath === CONTINUATION_PATHS.SAME_WORLD) {
          // Same world, new story â€” reset story but keep world
          resetForNewStory();
          state.picks.world = preservedWorld; // Restore world selection
          state.previousTitle = preservedTitle;
          state.previousTitleMode = preservedTitleMode;
          // Pre-select the world card in UI
          preselectWorldCard(preservedWorld);
          console.log('[Continuation] SAME_WORLD: Fresh story in', preservedWorld);
          window.showScreen('setup');
      } else {
          // Completely new story â€” full reset
          resetForNewStory();
          console.log('[Continuation] NEW_STORY: Full reset');
          window.showScreen('setup');
      }
  }

  /**
   * Clear story content without resetting picks
   */
  function clearStoryContent() {
      state.currentStoryContent = '';
      state.storyHistory = [];
      localStorage.removeItem('sb_saved_story');
      // Clear pagination if available
      if (typeof StoryPagination !== 'undefined' && StoryPagination.clear) {
          StoryPagination.clear();
      }
      const storyEl = document.getElementById('storyText');
      if (storyEl) storyEl.innerHTML = '';
      // Reset curl pages
      const titlePage = document.getElementById('sbTitlePage');
      if (titlePage) { titlePage.classList.add('hidden'); titlePage.classList.remove('sb-curling'); }
      window._titlePageActive = false;
      const frontispiece = document.getElementById('fatelandsFrontispiece');
      if (frontispiece) { frontispiece.classList.add('hidden'); frontispiece.classList.remove('sb-curling'); }
      window._frontispieceActive = false;
      const settingPlate = document.getElementById('settingPlate');
      if (settingPlate) { settingPlate.classList.remove('sb-curling'); }
      window._settingPlateActive = false;
      // Hide End Page if showing
      const endPage = document.getElementById('storyEndPage');
      if (endPage) endPage.classList.add('hidden');
  }

  /**
   * Reset state for a new story (preserves subscription/payment state)
   */
  function resetForNewStory() {
      // TEASE TIER: Prevent reset unless user has upgraded
      if (isTeaseTier() && state.freeStoryConsumed && !hasTeaseUnlockCondition()) {
          console.warn('[TEASE] New story blocked â€” free story consumed, no unlock condition');
          window.showPaywall('unlock');
          return;
      }

      // â”€â”€ ALL THREE LAYERS RESET (full world change) â”€â”€
      _resetStoryState();          // Layer 3 â€” couple mechanics
      _resetEpochState();          // Layer 2 â€” world-cycle entropy
      _resetRegionPhysics();       // Layer 1 â€” geographic invariants

      // Series / book metadata
      state.book_number = 1;
      state.series_id = null;
      state.previous_story_id = null;
      state.main_characters_locked = null;
      state.book1_continuity_summary = null;
      state.book_subhead = null;
      state.storyLength = 'taste';

      clearStoryContent();

      // Reset DSP state for new story
      if (typeof resetDSPState === 'function') resetDSPState();

      // Reset title state
      state.immutableTitle = null;
      state.coverArchetype = null;

      // Reset visual state
      state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} }, sceneBudgets: {}, visualizedScenes: {} };


      // Clear cover state
      if (_coverAbortController) { _coverAbortController.abort(); _coverAbortController = null; }
      if (typeof resetBookState === 'function') resetBookState();
      const coverImg = document.getElementById('bookCoverImg');
      if (coverImg) coverImg.src = '';
      const coverLoading = document.getElementById('coverLoadingState');
      if (coverLoading) coverLoading.classList.add('hidden');
      const bookObj = document.getElementById('bookObject');
      if (bookObj) bookObj.classList.add('hidden');

      // Reset Storyturn state
      if (typeof resetStoryturnState === 'function') resetStoryturnState();
  }

  /**
   * Pre-select a world card in the setup UI
   */
  function preselectWorldCard(world) {
      if (!world) return;
      // Find and select the world card
      const worldCards = document.querySelectorAll('.sb-card[data-grp="world"]');
      worldCards.forEach(card => {
          card.classList.remove('selected', 'flipped');
          if (card.dataset.val === world) {
              card.classList.add('selected', 'flipped');
          }
      });
  }

  /**
   * Default to new story if modal closed without selection
   */
  function defaultContinuationPath() {
      console.log('[Continuation] Default path: NEW_STORY');
      selectContinuationPath('new_story');
  }

  // Expose fork modal handlers globally
  window.showContinuationFork = showContinuationFork;
  window.hideContinuationFork = hideContinuationFork;
  window.selectContinuationPath = selectContinuationPath;
  window.defaultContinuationPath = defaultContinuationPath;

  /**
   * FALLBACK TITLE GENERATOR
   * Creates a deterministic name-based title when validation fails.
   * Pattern A: [FirstName]'s [Qualifier]
   * Pattern B: [FullName]: [Qualifier]
   *
   * @param {object} opts - { playerName, partnerName, world, tone, genre }
   * @returns {string} - Fallback title (never fails)
   */
  function generateFallbackTitle(opts) {
      const { playerName, partnerName, world, tone, genre } = opts;

      // Get qualifiers for this world (fallback to Modern)
      const qualifiers = TITLE_FALLBACK_QUALIFIERS[world] || TITLE_FALLBACK_QUALIFIERS.Modern;

      // Deterministic qualifier selection via hash of tone+genre
      const hashSeed = (tone || 'Earnest') + (genre || 'Romance');
      const qualifierIndex = simpleHash(hashSeed) % qualifiers.length;
      const qualifier = qualifiers[qualifierIndex];

      // Prefer love interest name for more intrigue, fallback to player
      const primaryName = partnerName || playerName;
      const firstName = extractFirstName(primaryName);

      // If we have a valid first name, use Pattern A
      if (firstName && firstName.length > 1 && !/^(the|a)\s/i.test(firstName)) {
          return `${firstName}'s ${qualifier}`;
      }

      // If we have a full name with 2+ parts, use Pattern B
      if (primaryName && primaryName.includes(' ')) {
          return `${primaryName}: ${qualifier}`;
      }

      // Last resort: use qualifier alone with dramatic framing
      return `The ${qualifier}`;
  }

  // Expose validators globally for Dev HUD
  window.validateTitle = validateTitle;
  window.generateFallbackTitle = generateFallbackTitle;

  // ============================================================
  // TITLE â†” COVER SIGNAL ALIGNMENT LAYER
  // ============================================================
  // Ensures title and cover art signal the SAME dominant axis.
  // Primary axis: exactly one (usually Arousal)
  // Secondary axis: optional (max one)
  // All other axes: neutral
  // ============================================================

  /**
   * SIGNAL AXIS DEFINITIONS
   * Each axis has detection patterns for both title and cover
   */
  const SIGNAL_AXES = {
      AROUSAL: 'arousal',
      TONE: 'tone',
      GENRE: 'genre'
  };

  /**
   * AROUSAL SIGNAL PATTERNS
   * Title/cover must independently signal the arousal tier
   */
  const AROUSAL_SIGNALS = {
      Clean: {
          title: {
              allow: /\b(distance|restraint|waiting|watching|almost|nearly|silence|apart)\b/i,
              forbid: /\b(burn|ache|want|hunger|possession|devour|consume|claim)\b/i
          },
          cover: {
              allow: ['separation', 'stillness', 'restraint', 'waiting', 'longing from afar'],
              forbid: ['touch', 'embrace', 'intimacy', 'skin', 'heat', 'tension']
          },
          signal: 'restraint, distance'
      },
      Naughty: {
          title: {
              allow: /\b(almost|want|tempt|tease|forbidden|secret|risk|dare|edge)\b/i,
              forbid: /\b(claim|possess|devour|consume|take|surrender|yield)\b/i
          },
          cover: {
              allow: ['suggestion', 'withholding', 'anticipation', 'almost-touch', 'nearness'],
              forbid: ['explicit intimacy', 'possession', 'surrender', 'exposure']
          },
          signal: 'suggestion, withholding'
      },
      Steamy: {
          title: {
              allow: /\b(want|ache|burn|claim|mine|yours|possess|surrender|give|take)\b/i,
              forbid: /\b(filth|raw|intrude|force|use|ruin|wreck|break)\b/i
          },
          cover: {
              allow: ['intimacy', 'possession', 'surrender', 'closeness', 'heat', 'connection'],
              forbid: ['clinical', 'crude', 'explicit anatomy', 'shock']
          },
          signal: 'intimacy, possession'
      },
      Passionate: {
          title: {
              allow: /\b(filth|raw|ruin|wreck|use|break|devour|consume|claim|take)\b/i,
              forbid: /\b(sweet|gentle|soft|tender|pure|innocent|chaste)\b/i
          },
          cover: {
              allow: ['intrusion', 'bluntness', 'rawness', 'edge', 'danger', 'intensity'],
              forbid: ['sweetness', 'gentleness', 'purity', 'innocence']
          },
          signal: 'intrusion, bluntness'
      }
  };

  /**
   * TONE SIGNAL PATTERNS
   * Secondary axis - tone signals in title/cover
   */
  const TONE_AXIS_SIGNALS = {
      Earnest: {
          title: null, // Most permissive
          cover: ['sincerity', 'hope', 'warmth', 'openness']
      },
      WryConfession: {
          title: /\b(almost|anyway|still|wrong|mistake|lie|truth|never)\b/i,
          cover: ['irony', 'self-awareness', 'confession', 'doubt']
      },
      Dark: {
          title: /\b(blood|bone|ash|ruin|end|last|only|never|death)\b/i,
          cover: ['weight', 'shadow', 'gravity', 'consequence', 'doom']
      },
      Mythic: {
          title: /\b(fated|destined|eternal|ancient|prophecy|legend|chosen)\b/i,
          cover: ['fate', 'destiny', 'grandeur', 'ancient weight']
      }
  };

  /**
   * GENRE SIGNAL PATTERNS
   * Secondary axis - genre signals in title/cover
   */
  const GENRE_AXIS_SIGNALS = {
      Billionaire: {
          title: /\b(empire|fortune|deal|contract|merger|penthouse|heir)\b/i,
          cover: ['wealth', 'power', 'luxury', 'corporate', 'skyline']
      },
      CrimeSyndicate: {
          title: /\b(blood|family|loyalty|debt|oath|boss|territory)\b/i,
          cover: ['danger', 'shadows', 'underworld', 'loyalty']
      },
      Espionage: {
          title: /\b(secret|agent|cover|mission|asset|handler|burn)\b/i,
          cover: ['mystery', 'concealment', 'danger', 'surveillance']
      },
      Noir: {
          title: /\b(smoke|rain|night|shadow|dame|case|trouble)\b/i,
          cover: ['shadow', 'mystery', 'urban night', 'smoke', 'rain']
      },
      Heist: {
          title: /\b(score|job|crew|vault|mark|inside|take)\b/i,
          cover: ['precision', 'tension', 'planning', 'stakes']
      }
  };

  /**
   * Extract dominant signal axis from title
   * @param {string} title - The book title
   * @param {string} arousal - Current arousal level
   * @param {string} tone - Current tone
   * @param {string} genre - Current genre
   * @returns {{ primary: string, secondary: string|null, arousalMatch: boolean, signals: object }}
   */
  function extractTitleSignals(title, arousal, tone, genre) {
      const cleanTitle = (title || '').toLowerCase().trim();
      const signals = {
          arousal: null,
          tone: null,
          genre: null
      };

      // Check arousal signals
      const arousalConfig = AROUSAL_SIGNALS[arousal];
      if (arousalConfig?.title?.allow?.test(cleanTitle)) {
          signals.arousal = arousal;
      }
      // Check for arousal contradiction
      const arousalContradiction = arousalConfig?.title?.forbid?.test(cleanTitle);

      // Check tone signals
      const toneConfig = TONE_AXIS_SIGNALS[tone];
      if (toneConfig?.title?.test(cleanTitle)) {
          signals.tone = tone;
      }

      // Check genre signals
      const genreConfig = GENRE_AXIS_SIGNALS[genre];
      if (genreConfig?.title?.test(cleanTitle)) {
          signals.genre = genre;
      }

      // Determine primary axis (priority: arousal > tone > genre)
      let primary = null;
      let secondary = null;

      if (signals.arousal) {
          primary = SIGNAL_AXES.AROUSAL;
          if (signals.tone) secondary = SIGNAL_AXES.TONE;
          else if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.tone) {
          primary = SIGNAL_AXES.TONE;
          if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.genre) {
          primary = SIGNAL_AXES.GENRE;
      }

      return {
          primary,
          secondary,
          arousalMatch: signals.arousal === arousal,
          arousalContradiction,
          signals
      };
  }

  /**
   * Extract dominant signal axis from cover prompt
   * @param {object} coverPrompt - The cover prompt object from buildCoverPrompt
   * @param {string} arousal - Current arousal level
   * @param {string} tone - Current tone
   * @param {string} genre - Current genre
   * @returns {{ primary: string, secondary: string|null, arousalMatch: boolean, signals: object }}
   */
  function extractCoverSignals(coverPrompt, arousal, tone, genre) {
      const promptText = (coverPrompt?.promptText || '').toLowerCase();
      const emotion = (coverPrompt?.emotion || '').toLowerCase();
      const signals = {
          arousal: null,
          tone: null,
          genre: null
      };

      // Check arousal signals in cover
      const arousalConfig = AROUSAL_SIGNALS[arousal];
      if (arousalConfig?.cover?.allow) {
          const hasArousalSignal = arousalConfig.cover.allow.some(sig =>
              promptText.includes(sig.toLowerCase()) || emotion.includes(sig.toLowerCase())
          );
          if (hasArousalSignal) signals.arousal = arousal;
      }

      // Check for arousal contradiction
      let arousalContradiction = false;
      if (arousalConfig?.cover?.forbid) {
          arousalContradiction = arousalConfig.cover.forbid.some(sig =>
              promptText.includes(sig.toLowerCase()) || emotion.includes(sig.toLowerCase())
          );
      }

      // Check tone signals
      const toneConfig = TONE_AXIS_SIGNALS[tone];
      if (toneConfig?.cover) {
          const hasToneSignal = toneConfig.cover.some(sig =>
              promptText.includes(sig.toLowerCase()) || emotion.includes(sig.toLowerCase())
          );
          if (hasToneSignal) signals.tone = tone;
      }

      // Check genre signals
      const genreConfig = GENRE_AXIS_SIGNALS[genre];
      if (genreConfig?.cover) {
          const hasGenreSignal = genreConfig.cover.some(sig =>
              promptText.includes(sig.toLowerCase())
          );
          if (hasGenreSignal) signals.genre = genre;
      }

      // Frame/border state for composed cover validation
      const keyholeEl = document.getElementById('coverKeyholeOverlay');
      const borderEl = document.getElementById('coverOrnateBorder');
      const frameType = keyholeEl && !keyholeEl.classList.contains('hidden') ? 'keyhole' : null;
      const borderType = borderEl && !borderEl.classList.contains('hidden') ? 'erotic' : null;

      // Cover framing no longer signals arousal â€” determine axes from content only
      let primary = null;
      let secondary = null;
      let arousalMatchOverride = false;

      if (false) {
          // Placeholder â€” arousal-based framing overrides removed
          primary = SIGNAL_AXES.AROUSAL;
          arousalMatchOverride = true;
          // Secondary can still be tone or genre from image
          if (signals.tone) secondary = SIGNAL_AXES.TONE;
          else if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.arousal) {
          primary = SIGNAL_AXES.AROUSAL;
          if (signals.tone) secondary = SIGNAL_AXES.TONE;
          else if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.tone) {
          primary = SIGNAL_AXES.TONE;
          if (signals.genre) secondary = SIGNAL_AXES.GENRE;
      } else if (signals.genre) {
          primary = SIGNAL_AXES.GENRE;
      }

      return {
          primary,
          secondary,
          arousalMatch: arousalMatchOverride || signals.arousal === arousal,
          arousalContradiction: arousalMatchOverride ? false : arousalContradiction,
          signals,
          // Composed cover signals (framing is part of the cover signal)
          frameType,
          borderType,
          dirtyFramingOverride: hasDirtyFraming && arousal === 'Passionate'
      };
  }

  /**
   * SIGNAL ALIGNMENT VALIDATION
   * Validates that title and cover signal the same dominant axis
   * @param {string} title - The book title
   * @param {object} coverPrompt - Cover prompt from buildCoverPrompt
   * @param {object} context - { arousal, tone, genre }
   * @returns {{ aligned: boolean, errors: Array<{code: string, message: string}>, titleSignals: object, coverSignals: object }}
   */
  function validateSignalAlignment(title, coverPrompt, context) {
      const { arousal, tone, genre } = context;
      const errors = [];

      // Extract signals from both sources
      const titleSignals = extractTitleSignals(title, arousal, tone, genre);
      const coverSignals = extractCoverSignals(coverPrompt, arousal, tone, genre);

      // CHECK 1: Primary axis alignment
      if (titleSignals.primary && coverSignals.primary) {
          if (titleSignals.primary !== coverSignals.primary) {
              errors.push({
                  code: 'SIGNAL_AXIS_MISMATCH',
                  message: `Title signals ${titleSignals.primary}, cover signals ${coverSignals.primary}`
              });
          }
      }

      // CHECK 2: Arousal contradiction (HARD FAIL)
      if (titleSignals.arousalContradiction) {
          errors.push({
              code: 'TITLE_AROUSAL_CONTRADICTION',
              message: `Title contains words forbidden at ${arousal} arousal level`
          });
      }
      if (coverSignals.arousalContradiction) {
          errors.push({
              code: 'COVER_AROUSAL_CONTRADICTION',
              message: `Cover contains signals forbidden at ${arousal} arousal level`
          });
      }

      // CHECK 3: Neither signals arousal (advisory only â€” covers no longer signal explicitness tier)
      if (arousal === 'Steamy' || arousal === 'Passionate') {
          if (!titleSignals.arousalMatch && !coverSignals.arousalMatch) {
              errors.push({
                  code: 'AROUSAL_SIGNAL_ABSENT',
                  message: `${arousal} intensity but neither title nor cover signals it`
              });
          }
      }

      if (false) {
          // Removed: keyhole/framing validation for explicit tiers
          if (true) {
              errors.push({
                  code: 'DIRTY_FRAME_ABSENT',
                  message: 'Dirty intensity requires keyhole/metalwork framing'
              });
          }
          // Note: titleSignals.arousalMatch and coverSignals.arousalMatch NOT required for Dirty
          // The composed cover (image + keyhole frame) is the signal, not image alone
      }

      // CHECK 4: Ambiguity check - no clear primary in either
      if (!titleSignals.primary && !coverSignals.primary) {
          errors.push({
              code: 'SIGNAL_AMBIGUOUS',
              message: 'Neither title nor cover has a clear primary signal axis'
          });
      }

      // CHECK 5: Secondary axis conflict
      if (titleSignals.secondary && coverSignals.secondary) {
          if (titleSignals.secondary !== coverSignals.secondary) {
              // Soft warning, not hard fail
              console.log('[SignalAlignment] Secondary axis differs:', titleSignals.secondary, 'vs', coverSignals.secondary);
          }
      }

      return {
          aligned: errors.length === 0,
          errors,
          titleSignals,
          coverSignals,
          context: {
              expectedArousal: arousal,
              arousalSignal: AROUSAL_SIGNALS[arousal]?.signal || 'neutral'
          }
      };
  }

  /**
   * Quick arousal inference from title alone
   * Used for pre-validation before cover is generated
   * @param {string} title - The book title
   * @returns {string|null} - Inferred arousal tier or null if ambiguous
   */
  function inferArousalFromTitle(title) {
      const cleanTitle = (title || '').toLowerCase().trim();

      // Check in order from most restrictive to least
      for (const level of ['Passionate', 'Steamy', 'Naughty', 'Clean']) {
          const config = AROUSAL_SIGNALS[level];
          if (config?.title?.allow?.test(cleanTitle)) {
              // Also check it doesn't violate this level's forbid
              if (!config.title.forbid?.test(cleanTitle)) {
                  return level;
              }
          }
      }
      return null; // Ambiguous
  }

  // Expose signal alignment functions globally
  window.validateSignalAlignment = validateSignalAlignment;
  window.extractTitleSignals = extractTitleSignals;
  window.extractCoverSignals = extractCoverSignals;
  window.inferArousalFromTitle = inferArousalFromTitle;
  window.SIGNAL_AXES = SIGNAL_AXES;
  window.AROUSAL_SIGNALS = AROUSAL_SIGNALS;

  /**
   * DSP VALIDATION â€” Strict template enforcement
   * DSP must EXACTLY match: "In [WORLD], shaped by [GENRE], a question awaits:
   * Will [ARCH_ADJ] desire redeem this [TONE_ADJ] affair â€” or ruin it?"
   *
   * @param {string} dspText - The DSP text to validate (HTML stripped)
   * @param {object} inputs - { world, genre, archetypeId, tone }
   * @returns {{ pass: boolean, errors: Array<{code: string, message: string}> }}
   */
  function validateDSP(dspText, inputs) {
      const errors = [];
      const { world, genre, archetypeId, tone } = inputs;

      // Strip HTML tags for validation
      const plainText = dspText.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();

      // Get expected phrases from locked dictionaries
      const expectedWorld = DSP_WORLD_PHRASES[world];
      const expectedGenre = DSP_GENRE_PARAPHRASES[genre];
      const expectedArch = DSP_ARCHETYPE_ADJECTIVES[archetypeId];
      const expectedTone = DSP_TONAL_ADJECTIVES[tone];

      // Validate world phrase exists
      if (!expectedWorld) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_WORLD_PHRASE,
              message: `No DSP world phrase for: "${world}"`
          });
      }

      // Validate genre phrase exists
      if (!expectedGenre) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_GENRE_PHRASE,
              message: `No DSP genre paraphrase for: "${genre}"`
          });
      }

      // Validate archetype adjective exists
      if (!expectedArch) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_ARCHETYPE_ADJ,
              message: `No DSP archetype adjective for: "${archetypeId}"`
          });
      }

      // Validate tone adjective exists
      if (!expectedTone) {
          errors.push({
              code: VALIDATION_ERRORS.DSP_INVALID_TONE_ADJ,
              message: `No DSP tonal adjective for: "${tone}"`
          });
      }

      // If any dictionary lookups failed, return early
      if (errors.length > 0) {
          return { pass: false, errors };
      }

      // Build expected DSP text (exact template)
      const expectedDSP = `In ${expectedWorld}, shaped by ${expectedGenre}, a question awaits: Will ${expectedArch} desire redeem this ${expectedTone} affair â€” or ruin it?`;

      // Normalize both for comparison (handle HTML entities)
      const normalizedExpected = expectedDSP.replace(/\s+/g, ' ').trim();
      const normalizedActual = plainText
          .replace(/&#8201;/g, ' ')
          .replace(/&#8212;/g, 'â€”')
          .replace(/\u2009/g, ' ')  // thin space
          .replace(/\u2014/g, 'â€”')  // em dash
          .replace(/\s+/g, ' ')
          .trim();

      // Check for exact match
      if (normalizedActual !== normalizedExpected) {
          // Diagnose specific failure
          if (!normalizedActual.startsWith('In ')) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_TEMPLATE_VIOLATION,
                  message: 'DSP must start with "In "'
              });
          }
          if (!normalizedActual.includes(expectedWorld)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_WORLD_PHRASE,
                  message: `World phrase "${expectedWorld}" not found in DSP`
              });
          }
          if (!normalizedActual.includes(expectedGenre)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_GENRE_PHRASE,
                  message: `Genre phrase "${expectedGenre}" not found in DSP`
              });
          }
          if (!normalizedActual.includes(expectedArch)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_ARCHETYPE_ADJ,
                  message: `Archetype adjective "${expectedArch}" not found in DSP`
              });
          }
          if (!normalizedActual.includes(expectedTone)) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_TONE_ADJ,
                  message: `Tone adjective "${expectedTone}" not found in DSP`
              });
          }

          // STRICT ADJECTIVE POSITION VALIDATION
          // Verify exact adjective appears in correct DSP slot
          const archSlotMatch = normalizedActual.match(/Will\s+(\w+)\s+desire/i);
          if (archSlotMatch && archSlotMatch[1].toLowerCase() !== expectedArch.toLowerCase()) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_ARCHETYPE_ADJ,
                  message: `Wrong adjective in archetype slot: found "${archSlotMatch[1]}", expected "${expectedArch}"`
              });
          }
          const toneSlotMatch = normalizedActual.match(/this\s+(\w+)\s+affair/i);
          if (toneSlotMatch && toneSlotMatch[1].toLowerCase() !== expectedTone.toLowerCase()) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_INVALID_TONE_ADJ,
                  message: `Wrong adjective in tone slot: found "${toneSlotMatch[1]}", expected "${expectedTone}"`
              });
          }

          // Check for world subtype leakage
          const SUBTYPE_PATTERNS = [
              /\bsmall[- ]town\b/i, /\bcampus\b/i, /\boffice\b/i, /\bold[- ]money\b/i,
              /\bcyberpunk\b/i, /\bspace opera\b/i, /\bgalactic\b/i, /\bVictorian\b/i,
              /\bRegency\b/i, /\bMedieval\b/i, /\bAncient\b/i
          ];
          for (const pattern of SUBTYPE_PATTERNS) {
              if (pattern.test(normalizedActual)) {
                  errors.push({
                      code: VALIDATION_ERRORS.DSP_WORLD_SUBTYPE_LEAK,
                      message: `World subtype leaked into DSP: ${normalizedActual.match(pattern)?.[0]}`
                  });
                  break;
              }
          }

          // Check for extra prose
          if (normalizedActual.length > normalizedExpected.length + 10) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_EXTRA_PROSE,
                  message: 'DSP contains extra prose beyond locked template'
              });
          }

          // Check for legacy phrasing â€” comprehensive list of deprecated DSP text
          const LEGACY_PATTERNS = [
              /\bdestiny story prompt\b/i,
              /\byour story\b/i,
              /\bonce upon\b/i,
              /\bin this tale\b/i,
              // Legacy world phrases (pre-canon)
              /\bstrangers meet\b/i,
              /\bpower lingers\b/i,
              /\bforces move\b/i,
              /\bvows bind\b/i,
              /\bold powers\b/i,
              /\bcity of strangers\b/i,
              /\bthe present day\b/i,
              /\ban earlier era\b/i,
              /\bsupernatural forces\b/i,
              /\bambition and consequence\b/i,
              // Legacy genre phrases (pre-canon)
              /\bdangerous games\b/i,
              /\bshadow and silk\b/i,
              /\bhigh stakes\b/i,
              /\bforbidden fruit\b/i,
              /\bsecret desires\b/i,
              /\bpassion and peril\b/i,
              /\blove and loss\b/i,
              // Meta-narrative leakage
              /\bthe narrative\b/i,
              /\bthe story\b/i,
              /\bthis romance\b/i,
              /\btheir journey\b/i
          ];
          for (const pattern of LEGACY_PATTERNS) {
              if (pattern.test(normalizedActual)) {
                  errors.push({
                      code: VALIDATION_ERRORS.DSP_LEGACY_PHRASING,
                      message: `Legacy phrasing detected: ${normalizedActual.match(pattern)?.[0]}`
                  });
                  break;
              }
          }

          // WORD-SOURCE VALIDATION: DSP output must contain ONLY words from selected phrases
          // Extract content words (skip articles, prepositions, punctuation)
          const STRUCTURAL_WORDS = new Set([
              'in', 'a', 'an', 'the', 'of', 'and', 'or', 'by', 'shaped', 'question', 'awaits',
              'will', 'desire', 'redeem', 'this', 'affair', 'ruin', 'it', 'to', 'for', 'with'
          ]);
          const dspWords = normalizedActual.toLowerCase()
              .replace(/[.,!?;:\u2014\u2013\u2009\u00a0]/g, ' ')
              .split(/\s+/)
              .filter(w => w.length > 2 && !STRUCTURAL_WORDS.has(w));

          // Build allowed word set from selected phrases
          const allowedWords = new Set();
          (expectedWorld || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          (expectedGenre || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          (expectedArch || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          (expectedTone || '').toLowerCase().split(/\s+/).forEach(w => allowedWords.add(w.replace(/[.,]/g, '')));
          // Add structural words to allowed set
          STRUCTURAL_WORDS.forEach(w => allowedWords.add(w));

          const illegalWords = dspWords.filter(w => !allowedWords.has(w));
          if (illegalWords.length > 0) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_EXTRA_PROSE,
                  message: `DSP contains words not from canonical phrases: ${illegalWords.slice(0, 5).join(', ')}`
              });
          }

          // Generic template violation if no specific error found
          if (errors.length === 0) {
              errors.push({
                  code: VALIDATION_ERRORS.DSP_TEMPLATE_VIOLATION,
                  message: `DSP does not match locked template. Expected: "${normalizedExpected.slice(0, 50)}..."`
              });
          }
      }

      return { pass: errors.length === 0, errors };
  }

  /**
   * POV VALIDATION (5th Person) â€” Comprehensive scene validation
   *
   * @param {string} sceneText - The scene prose to validate
   * @param {object} context - { sceneIndex, isErotic }
   * @returns {{ pass: boolean, errors: Array<{code: string, message: string}>, metrics: object }}
   */
  function validatePOV(sceneText, context) {
      const errors = [];
      const { sceneIndex = 0, isErotic = false } = context;
      const isSceneOne = sceneIndex === 0;

      // Count Author mentions
      const authorMatches = sceneText.match(/\bFate\b/g) || [];
      const authorMentions = authorMatches.length;

      // Extract first words and last paragraph
      const trimmed = sceneText.trim();
      const firstTwoWords = trimmed.split(/\s+/).slice(0, 2).join(' ');
      const paragraphs = trimmed.split(/\n\n+/);
      const lastParagraph = paragraphs[paragraphs.length - 1] || '';
      const sentences = lastParagraph.match(/[^.!?]+[.!?]+/g) || [lastParagraph];
      const lastTwoSentences = sentences.slice(-2).join(' ');

      // RULE 1: First two words = "Fate" (always enforced)
      const hasValidOpener = /^Fate\b/i.test(trimmed);
      if (!hasValidOpener) {
          errors.push({
              code: VALIDATION_ERRORS.POV_INVALID_OPENER,
              message: `Opening must start with "Fate". Found: "${firstTwoWords}"`
          });
      }

      // RULE 2: Final perspective = Fate (structural check)
      const AUTHOR_CLOSING_VERBS = [
          'held', 'tilted', 'set', 'arranged', 'steered', 'coaxed', 'seeded', 'threaded',
          'watched', 'waited', 'considered', 'wondered', 'doubted', 'resisted', 'smiled',
          'frowned', 'paused', 'knew', 'felt', 'sensed', 'released', 'tightened', 'loosened'
      ];
      const closingVerbPattern = new RegExp(
          'Fate\\s+(' + AUTHOR_CLOSING_VERBS.join('|') + ')\\b', 'i'
      );
      const authorReflectionPattern = /Fate.{0,60}(uncertain|doubt|wonder|question|resist|perhaps|might|whether|if only)/i;
      const hasValidCloser = closingVerbPattern.test(lastTwoSentences) || authorReflectionPattern.test(lastTwoSentences);

      if (!hasValidCloser && !isErotic) {
          errors.push({
              code: VALIDATION_ERRORS.POV_INVALID_CLOSER,
              message: 'Scene must end with Fate as final perspective (action verb or reflection)'
          });
      }

      // RULE 3: Scene prose = strict 3rd person limited
      const firstPersonPattern = /\b(I|me|my|mine|myself)\b(?!\s*["'])/gi;
      const firstPersonMatches = sceneText.match(firstPersonPattern) || [];
      // Filter out dialogue (rough heuristic: not near quotes)
      const nonDialogueFirstPerson = firstPersonMatches.filter(match => {
          const idx = sceneText.indexOf(match);
          const nearbyText = sceneText.slice(Math.max(0, idx - 20), idx + 20);
          return !/"[^"]*$/.test(nearbyText.slice(0, 20)) && !/^[^"]*"/.test(nearbyText.slice(20));
      });
      if (nonDialogueFirstPerson.length > 2) {
          errors.push({
              code: VALIDATION_ERRORS.POV_NON_3RD_PERSON,
              message: `Scene contains ${nonDialogueFirstPerson.length} first-person references outside dialogue`
          });
      }

      // RULE 4: Author NEVER narrates action or scenery (banned voyeur verbs)
      const BANNED_AUTHOR_VERBS = ['watched', 'observed', 'saw', 'looked on', 'gazed at', 'witnessed', 'noticed', 'perceived'];
      const bannedPattern = new RegExp('Fate\\s+(' + BANNED_AUTHOR_VERBS.join('|') + ')\\b', 'gi');
      const bannedMatches = sceneText.match(bannedPattern) || [];
      if (bannedMatches.length > 0) {
          errors.push({
              code: VALIDATION_ERRORS.POV_AUTHOR_NARRATES_ACTION,
              message: `Fate uses banned voyeur verbs: ${bannedMatches.slice(0, 3).join(', ')}`
          });
      }

      // RULE 5: Frequency requirements
      if (isSceneOne && authorMentions < 6) {
          errors.push({
              code: VALIDATION_ERRORS.POV_SCENE1_FREQUENCY,
              message: `Scene 1 requires â‰¥6 Fate mentions. Found: ${authorMentions}`
          });
      } else if (!isSceneOne && !isErotic && (authorMentions < 1 || authorMentions > 3)) {
          errors.push({
              code: VALIDATION_ERRORS.POV_LATER_FREQUENCY,
              message: `Later scenes require 1-3 Fate mentions. Found: ${authorMentions}`
          });
      }

      // RULE 6: Erotic scenes = 0 Author mentions
      if (isErotic && authorMentions > 0) {
          errors.push({
              code: VALIDATION_ERRORS.POV_EROTIC_AUTHOR_PRESENT,
              message: `Erotic scenes must have 0 Fate mentions. Found: ${authorMentions}`
          });
      }

      // RULE 7: Meta-awareness spike ~5% (check for excess)
      const metaAwarenessPatterns = [
          /\b(character|story|narrative|plot|author|reader|page|chapter)\b/gi,
          /\b(as if|somehow|knew|felt|sensed)\s+(that|the|this)\s+(story|tale|narrative)/gi
      ];
      let metaCount = 0;
      metaAwarenessPatterns.forEach(p => {
          const matches = sceneText.match(p);
          if (matches) metaCount += matches.length;
      });
      const wordCount = sceneText.split(/\s+/).length;
      const metaRatio = metaCount / wordCount;
      if (metaRatio > 0.08) { // ~8% threshold
          errors.push({
              code: VALIDATION_ERRORS.POV_META_AWARENESS_EXCESS,
              message: `Meta-awareness exceeds 5% threshold. Ratio: ${(metaRatio * 100).toFixed(1)}%`
          });
      }



      const metrics = {
          authorMentions,
          isSceneOne,
          isErotic,
          hasValidOpener,
          hasValidCloser,
          wordCount
      };

      return { pass: errors.length === 0, errors, metrics };
  }

  /**
   * Get current validation state for Dev HUD
   * Runs all validators against current story state
   */
  function getValidationStatus() {
      const results = {};

      // DSP validation
      const dspEl = document.getElementById('synopsisText');
      if (dspEl && state.picks) {
          const dspResult = validateDSP(dspEl.textContent || '', {
              world: state.picks.world || 'Modern',
              genre: state.picks.genre || 'Billionaire',
              archetypeId: (state.archetype?.primary) || 'BEAUTIFUL_RUIN',
              tone: state.picks.tone || 'Earnest'
          });
          results.dsp = dspResult;
      }

      // POV validation (last generated scene)
      if (state.povMode === 'author5th' && window.StoryPagination) {
          const lastContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const lastScene = lastContent.slice(-2000);
          const povResult = validatePOV(lastScene, {
              sceneIndex: state.turnCount || 0,
              isErotic: isIntimacyAllowedAtCurrentStoryturn() && state.turnCount > 0,
          });
          results.pov = povResult;
      }

      // Tone validation
      if (state.picks?.tone && window.StoryPagination) {
          const lastContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const lastScene = lastContent.slice(-2000);
          const toneResult = validateTone(lastScene, state.picks.tone);
          results.tone = toneResult;
      }

      // Erotic escalation validation â€” removed (intensity no longer controls routing)

      // Title validation
      const titleEl = document.getElementById('storyTitle');
      if (titleEl && titleEl.textContent) {
          const titleResult = validateTitle(titleEl.textContent.trim(), state.picks?.tone);
          results.title = titleResult;
      }

      // Signal alignment validation
      if (titleEl && titleEl.textContent) {
          const currentTitle = titleEl.textContent.trim();
          const mockCoverPrompt = {
              promptText: 'emotion: ' + (state.coverEmotion || 'mystery'),
              emotion: state.coverEmotion || 'mystery'
          };
          const signalResult = validateSignalAlignment(currentTitle, mockCoverPrompt, {
              arousal: state.intensity || 'Naughty',
              tone: state.picks?.tone || 'Earnest',
              genre: state.picks?.genre || 'Romance'
          });
          results.signal = signalResult;
      }

      return results;
  }

  // Expose validators globally for Dev HUD access
  window.validateDSP = validateDSP;
  window.validatePOV = validatePOV;
  window.validateTone = validateTone;
  window.validateEroticEscalation = validateEroticEscalation;
  window.getValidationStatus = getValidationStatus;
  window.VALIDATION_ERRORS = VALIDATION_ERRORS;

  // ============================================================
  // NARRATIVE VOCABULARY BANS â€” POST-GENERATION ENFORCEMENT
  // ============================================================
  // System-internal terms that must NEVER appear in reader-facing text.
  // "The Author" is ALWAYS banned â€” the 5th-person entity is now "Fate".
  // Archetype names influence structure/pacing/framing but are invisible
  // to readers â€” they must never surface in prose, dialogue, or synopsis.
  // ============================================================

  const VOCAB_BAN_PATTERNS = [
      // "The Author" â€” legacy narrator term, always banned (entity is now "Fate")
      { id: 'AUTHOR_LEAK',          rx: /The Author\b/g,                                     fatePOVExempt: false },
      // Any X Warden compound (Heart Warden, Shadow Warden, Blood Warden, etc.)
      { id: 'WARDEN_COMPOUND',      rx: /(?:Heart|Shadow|Blood|\w+)\s+Warden\b/gi,                 fatePOVExempt: false },
      // Cover-composition archetype names leaked into prose
      { id: 'ARCHETYPE_THRESHOLD',  rx: /\bThreshold\b/g,                                          fatePOVExempt: false },
      { id: 'ARCHETYPE_EMBLEM',     rx: /\bEmblem\b/g,                                             fatePOVExempt: false },
      // Canonical 7-archetype display names
      { id: 'ARCHETYPE_OPEN_VEIN',  rx: /\bOpen Vein\b/gi,                                         fatePOVExempt: false },
      { id: 'ARCHETYPE_SPELLBINDER',rx: /\bSpellbinder\b/gi,                                       fatePOVExempt: false },
      { id: 'ARCHETYPE_ARMORED_FOX',rx: /\bArmored Fox\b/gi,                                       fatePOVExempt: false },
      { id: 'ARCHETYPE_DARK_VICE',  rx: /\bDark Vice\b/gi,                                         fatePOVExempt: false },
      { id: 'ARCHETYPE_BEAUTIFUL_RUIN', rx: /\bBeautiful Ruin\b/gi,                                fatePOVExempt: false },
      { id: 'ARCHETYPE_ETERNAL_FLAME',  rx: /\bEternal Flame\b/gi,                                 fatePOVExempt: false },
      // Archetype section titles â€” metadata only, never in prose
      { id: 'ARCHETYPE_STORYBEAU',   rx: /\bStorybeau\b/gi,                                        fatePOVExempt: false },
      { id: 'ARCHETYPE_STORYBELLE',  rx: /\bStorybelle\b/gi,                                       fatePOVExempt: false },
      { id: 'ARCHETYPE_STORYBOO',    rx: /\bStoryboo\b/gi,                                         fatePOVExempt: false },
      // Decorative Fate language â€” Fate acts structurally, never as atmospheric decoration
      { id: 'FATE_DECORATIVE_SMILED',  rx: /\bFate smiled\b/gi,                                    fatePOVExempt: false },
      { id: 'FATE_DECORATIVE_WATCHED', rx: /\bFate watched\b/gi,                                   fatePOVExempt: false },
      { id: 'FATE_DECORATIVE_SENSED',  rx: /\bFate sensed\b/gi,                                    fatePOVExempt: false },
      { id: 'FATE_DECORATIVE_COILED',  rx: /\bFate coiled\b/gi,                                    fatePOVExempt: false },
      { id: 'FATE_DECORATIVE_KNEW',    rx: /\bFate knew\b/gi,                                      fatePOVExempt: false }
  ];

  // Human-readable ban description per pattern (for negative-constraint injection)
  const VOCAB_BAN_LABELS = {
      AUTHOR_LEAK:            '"The Author" â€” legacy narrator term, always banned (use "Fate")',
      WARDEN_COMPOUND:        'X Warden compound â€” system-internal archetype name',
      ARCHETYPE_THRESHOLD:    '"Threshold" â€” internal cover-composition archetype',
      ARCHETYPE_EMBLEM:       '"Emblem" â€” internal cover-composition archetype',
      ARCHETYPE_OPEN_VEIN:    '"Open Vein" â€” internal character archetype',
      ARCHETYPE_SPELLBINDER:  '"Spellbinder" â€” internal character archetype',
      ARCHETYPE_ARMORED_FOX:  '"Armored Fox" â€” internal character archetype',
      ARCHETYPE_DARK_VICE:    '"Dark Vice" â€” internal character archetype',
      ARCHETYPE_BEAUTIFUL_RUIN: '"Beautiful Ruin" â€” internal character archetype',
      ARCHETYPE_ETERNAL_FLAME:  '"Eternal Flame" â€” internal character archetype',
      ARCHETYPE_STORYBEAU:      '"Storybeau" â€” LI category label, metadata only',
      ARCHETYPE_STORYBELLE:     '"Storybelle" â€” LI category label, metadata only',
      ARCHETYPE_STORYBOO:       '"Storyboo" â€” LI category label, metadata only',
      FATE_DECORATIVE_SMILED:   '"Fate smiled" â€” decorative Fate language banned',
      FATE_DECORATIVE_WATCHED:  '"Fate watched" â€” decorative Fate language banned',
      FATE_DECORATIVE_SENSED:   '"Fate sensed" â€” decorative Fate language banned',
      FATE_DECORATIVE_COILED:   '"Fate coiled" â€” decorative Fate language banned',
      FATE_DECORATIVE_KNEW:     '"Fate knew" â€” decorative Fate language banned'
  };

  /**
   * Scan text for vocabulary ban violations.
   * @param {string} text          - The generated text to check
   * @param {object} context       - { type: 'prose'|'synopsis'|'title'|'cover', isFatePOV: boolean }
   * @returns {{ clean: boolean, violations: Array<{id:string, matches:string[]}> }}
   */
  function scrubNarrativeVocabulary(text, context) {
      if (!text || typeof text !== 'string') return { clean: true, violations: [] };

      const violations = [];
      const isFatePOV = context.isFatePOV && context.type === 'prose';

      for (const ban of VOCAB_BAN_PATTERNS) {
          // "Fate" is allowed in Fate POV prose (5th-person mode)
          if (ban.fatePOVExempt && isFatePOV) continue;

          // Reset regex lastIndex (global flag)
          ban.rx.lastIndex = 0;
          const matches = text.match(ban.rx);
          if (matches && matches.length > 0) {
              violations.push({ id: ban.id, matches });
          }
      }

      return { clean: violations.length === 0, violations };
  }

  /**
   * Build a negative-constraint instruction string from violations.
   * Injected into the system prompt on regeneration.
   */
  function buildVocabBanConstraint(violations) {
      const lines = violations.map(v =>
          `- NEVER use ${VOCAB_BAN_LABELS[v.id] || v.id}. Found: "${v.matches.join('", "')}" â€” remove or rephrase.`
      );
      return `\n\nCRITICAL VOCABULARY BAN â€” the following terms are system-internal and MUST NOT appear in your output:\n${lines.join('\n')}\nRewrite any sentence that would contain these terms. They are invisible to the reader and must never surface in prose, dialogue, synopsis, or titles.\n`;
  }

  /**
   * Enforce vocabulary bans with one-shot regeneration.
   *
   * @param {string}   text          - generated text to check
   * @param {object}   context       - { type, isFatePOV }
   * @param {function} regenerateFn  - async (negativeConstraint: string) => string
   *                                   Called once on violation. Receives the negative-constraint
   *                                   string to append to the system prompt. Must return new text.
   * @returns {string} clean (or best-effort) text
   */
  async function enforceVocabularyBans(text, context, regenerateFn) {
      const result = scrubNarrativeVocabulary(text, context);
      if (result.clean) return text;

      console.warn('[VOCAB_BAN] Violations in ' + context.type + ':', result.violations);

      if (!regenerateFn) {
          console.error('[VOCAB_BAN] No regeneration function provided â€” returning dirty text');
          return text;
      }

      // Regenerate once with explicit negative constraint
      const constraint = buildVocabBanConstraint(result.violations);
      console.log('[VOCAB_BAN] Regenerating with negative constraint');
      const regenerated = await regenerateFn(constraint);

      // Re-check â€” if still dirty, log hard warning but return anyway
      const recheck = scrubNarrativeVocabulary(regenerated, context);
      if (!recheck.clean) {
          console.error('[VOCAB_BAN] Regeneration STILL violates bans:', recheck.violations.map(v => v.id));
      } else {
          console.log('[VOCAB_BAN] Regeneration passed vocabulary check');
      }

      return regenerated;
  }

  var state = window.state;

  // LATCH for Visualize Re-entrancy
  let _vizInFlight = false;

  // --- HELPERS ---
  function $(id){ return document.getElementById(id); }
  function toggle(id){ const el = document.getElementById(id); if(el) el.classList.toggle('hidden'); }
  function resetTurnSnapshotFlag(){ state._snapshotThisTurn = false; }
  function escapeHTML(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
  }

  // --- THEME & FONT HELPERS ---
  // Reader settings apply ONLY to story content, not the entire app UI
  window.setTheme = function(name) {
      const storyContent = document.getElementById('storyContent');
      if (!storyContent) return;
      storyContent.classList.remove('theme-sepia', 'theme-midnight', 'theme-print', 'theme-easy');
      if (name && name !== 'default') {
          storyContent.classList.add('theme-' + name);
      }
  };

  window.setFont = function(fontValue) {
      const storyContent = document.getElementById('storyContent');
      if (storyContent) {
          storyContent.style.setProperty('--font-story', fontValue);
      }
  };

  window.setFontSize = function(size) {
      const storyContent = document.getElementById('storyContent');
      if (storyContent) {
          storyContent.style.setProperty('--story-size', size + 'px');
      }
  };

  // setGameIntensity removed â€” intensity no longer controls routing.
  // Cosmetic intensity label is set during corridor selection only.
  window.setGameIntensity = function(level) {
      window.state.intensity = level;
      updateIntensityUI();
  };

  window.checkCustom = function(selectEl, inputId) {
      const input = document.getElementById(inputId);
      if (input) {
          input.classList.toggle('hidden', selectEl.value !== 'Custom');
      }
  };

  function syncPovDerivedFlags(){
      if(!window.state) return;
      const pov = (window.state.picks?.pov || '').toLowerCase();
      const is5th = /fifth|5th|author/.test(pov) || window.state.povMode === 'author5th';
      const is4th = /fourth|4th/.test(pov) || window.state.povMode === 'environment4th';
      if(is5th){
          window.state.povMode = 'author5th';
          window.state.authorPresence = 'frequent';
          window.state.fateCardVoice = 'authorial';
      } else if(is4th){
          window.state.povMode = 'environment4th';
          window.state.authorPresence = 'environmental';
          window.state.fateCardVoice = 'neutral';
      } else {
          window.state.povMode = 'normal';
          window.state.authorPresence = 'normal';
          window.state.fateCardVoice = 'neutral';
      }
  }

  // =========================
  // AUTH GATING FOR PERSISTENCE
  // =========================
  // Persistence is ONLY allowed when logged in.
  // Without login, app behaves stateless (no story/purchase restoration on reload).

  // isLoggedIn / window.login / window.logout removed â€”
  // Auth state now comes from Supabase session (anon auto-provisioned at boot).
  // Persistence is always allowed when a Supabase session exists.

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTH RESET â€” Full story creation state reset on login/logout
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // After auth change, app must behave like a fresh session.
  // Resets: state.story, storyId, _synopsisMetadata, picks, intensity,
  // reader page index, cover + setting generation promises, all generation flags
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function performAuthReset() {
      console.log('[AUTH:RESET] Performing full story creation state reset');

      // â”€â”€ ALL THREE LAYERS RESET (auth change = fresh session) â”€â”€
      _resetStoryState();          // Layer 3 â€” couple mechanics
      _resetEpochState();          // Layer 2 â€” world-cycle entropy
      _resetRegionPhysics();       // Layer 1 â€” geographic invariants

      // Reset vault library guards so next login re-fetches
      _vaultLibraryLoaded = false;
      _vaultLibraryLoading = false;

      // Additional auth-level resets beyond the three layers
      state.story = null;
      state.storyHistory = [];
      state.storyOrigin = null;
      state.book_number = 1;
      state.series_id = null;
      state.previous_story_id = null;
      state.main_characters_locked = null;
      state.book1_continuity_summary = null;
      state.book_subhead = null;
      state.storyLength = 'taste';

      // Reset Guided Fate selections
      state.picks = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', era: 'Medieval', pov: 'First' };
      state.intensity = 'Steamy';
      state.storypassEligible = undefined;
      state.lenses = [];
      state.withheldCoreVariant = null;

      // Reset character state
      state.normalizedPlayerKernel = null;
      state.normalizedPartnerKernel = null;
      state.rawPlayerName = null;
      state.rawPartnerName = null;

      // Reset background story state
      state._backgroundStoryText = null;
      state._backgroundStoryTitle = null;
      state._backgroundStorySynopsis = null;

      // Reset title state
      state.immutableTitle = null;
      state.coverArchetype = null;

      // Reset cover Assembly object tracking (visual canon)
      state._coverAssemblyObjectShown = false;
      state._coverAssemblyObject = null;
      state._coverWorldKey = null;

      // Reset visual state
      state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} }, sceneBudgets: {}, visualizedScenes: {} };

      // Reset cover/story generation flags (via window interface)
      if (window.clearPreGeneratedCover) window.clearPreGeneratedCover();
      if (window.resetBackgroundStory) window.resetBackgroundStory();
      if (window.resetCoverGenerationFlags) window.resetCoverGenerationFlags();
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();
      // Reset story shape snapshot (forces "Begin Story" on new session)
      state._lastGeneratedShapeSnapshot = null;
      // Update Cover Fortune display
      if (window.updateFortuneDisplay) window.updateFortuneDisplay();

      // Reset reader page index
      if (typeof resetBookState === 'function') resetBookState();

      // Reset DSP state
      if (typeof resetDSPState === 'function') resetDSPState();

      // Reset UI elements
      const coverImg = document.getElementById('bookCoverImg');
      if (coverImg) coverImg.src = '';
      const storyTitle = document.getElementById('storyTitle');
      if (storyTitle) storyTitle.textContent = '';

      // Reset name inputs
      const playerInput = document.getElementById('playerNameInput');
      if (playerInput) playerInput.value = '';
      const partnerInput = document.getElementById('partnerNameInput');
      if (partnerInput) partnerInput.value = '';

      // Reset card UI to match default state
      const cardDefaults = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', intensity: 'Steamy', length: 'taste', pov: 'First' };
      Object.entries(cardDefaults).forEach(([grp, val]) => {
          document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
              c.classList.remove('selected', 'flipped');
          });
          const def = document.querySelector(`.sb-card[data-grp="${grp}"][data-val="${val}"]`);
          if (def) def.classList.add('selected', 'flipped');
      });

      console.log('[AUTH:RESET] Complete â€” app is now in fresh session state');
  }

  // Clear all persisted state for anonymous/testing mode
  function clearAnonymousState() {
      localStorage.removeItem('sb_saved_story');
      localStorage.removeItem('sb_story_in_idb');
      localStorage.removeItem('sb_current_story_id');
      // Clear all story pass keys
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('sb_storypass_')) {
              keysToRemove.push(key);
          }
      }
      keysToRemove.forEach(k => localStorage.removeItem(k));
      // Clear IndexedDB story data
      if (window.indexedDB) {
          try {
              const request = indexedDB.deleteDatabase(STORY_DB_NAME);
              request.onerror = () => console.warn('Failed to clear IndexedDB');
          } catch (e) { /* ignore */ }
      }
  }

  // Render burger menu auth section + vault auth row â€” reflects Supabase session
  async function renderBurgerMenu() {
      const section = document.getElementById('menuAuthSection');
      const authRow = document.getElementById('vaultAuthRow');
      let email = null;
      if (sb) {
          try {
              const { data: { session } } = await sb.auth.getSession();
              const user = session?.user || null;
              if (user) email = user.email || null;
          } catch (e) {
              console.warn('[Vault] session check failed:', e);
          }
      }
      const isAuthed = !!email;
      if (section) section.textContent = isAuthed ? 'Signed in as ' + email : 'Guest';
      if (authRow) {
          if (isAuthed) {
              authRow.innerHTML = `<div style="color:#ccc; font-family:'Lora',serif; font-size:0.85em; margin-bottom:6px;">Signed in as ${email}</div>`
                  + `<button id="vaultSignOutBtn" class="sb-btn-png sm">Sign Out</button>`;
              document.getElementById('vaultSignOutBtn')?.addEventListener('click', async () => {
                  console.log('[AUTH] Logging out');
                  try { if (sb) await sb.auth.signOut(); } catch (err) { console.error('[AUTH] Logout error:', err); }
                  _vaultLibraryLoaded = false;
                  _vaultLibraryLoading = false;
                  localStorage.clear();
                  location.reload();
              });
          } else {
              authRow.innerHTML = `<button id="vaultSignInBtn" class="sb-btn-png sm">Sign In</button>`;
              document.getElementById('vaultSignInBtn')?.addEventListener('click', () => {
                  document.getElementById('menuOverlay')?.classList.add('hidden');
                  document.getElementById('auth-panel')?.classList.remove('hidden');
              });
          }
      }
  }

  // NAV HELPER
  function closeAllOverlays() {
      ['payModal', 'vizModal', 'menuOverlay', 'coupleConsentModal', 'coupleInvite', 'strangerModal', 'edgeCovenantModal', 'previewModal', 'petitionFateModal'].forEach(id => {
          const el = document.getElementById(id);
          if(el) el.classList.add('hidden');
      });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PROFILE STATUS MODAL â€” Read-only account status display
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function openProfileModal() {
      populateProfileStatus();
      document.getElementById('profileModal')?.classList.remove('hidden');
  }
  window.openProfileModal = openProfileModal;

  window.closeProfileModal = function() {
      document.getElementById('profileModal')?.classList.add('hidden');
  };

  function populateProfileStatus() {
      const el = document.getElementById('profileStatusContent');
      if (!el) return;

      const tier = state.tier || 'free';
      const tierDisplay = tier === 'free' ? 'Taste' : tier;
      const hasStorypass =
          typeof hasStorypassForCurrentStory === 'function'
              ? hasStorypassForCurrentStory()
              : false;

      const resonanceState = getFateResonanceState();
      const resonanceDisplay = resonanceState !== 'Quiet'
          ? `<div><strong>Fate Resonance:</strong> ${resonanceState}</div>`
          : '';

      const echoCount = state.bonus_tempt_charges || 0;
      const echoDisplay = `<div style="font-size:0.85em;color:rgba(218,165,32,0.55);margin-top:4px;">Tempt Fate (Earned): ${echoCount}</div>`;

      el.innerHTML =
          `<div><strong>Tier:</strong> ${tierDisplay}</div>` +
          `<div><strong>Storypass (this story):</strong> ${hasStorypass ? 'Yes' : 'No'}</div>` +
          `<div><strong>Fortunes:</strong> ${state.fortunes || 0}</div>` +
          resonanceDisplay +
          echoDisplay;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NAVIGATION CONTRACT â€” STORYBOUND READER FLOW (AUTHORITATIVE)
  // TAG: storybound/navigation-contract-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 1 â€” CANONICAL STORY CREATION FLOW (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The authoritative forward navigation order for a new story is:
  //
  // 1. Shape Your Story
  // 2. Cover Display (single cover view, NOT gallery)
  // 3. Setting
  // 4. Story (Scene 1)
  //
  // This order must be preserved.
  //
  // Notes:
  // - The Cover Display is part of the main flow.
  // - The Cover Gallery is NOT part of the main flow.
  // - The Cover Display shows the current cover state
  //   (Sketch / Thumbnail / Final), if available.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 2 â€” RESTART / RESUME FLOW (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When a user resumes an existing story:
  //
  // 1. Show the Cover Display (single cover view)
  // 2. Then load the most recent Story scene
  //
  // This applies regardless of:
  // - cover completion state
  // - number of scenes written
  // - story length tier
  //
  // Rationale:
  // - The cover re-orients tone and promise.
  // - Every reading session begins at the book's cover.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 3 â€” BACK BUTTON CONTRACT (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The Back button must reverse the canonical flow
  // and must never route to side chambers by default.
  //
  // Back behavior by context:
  //
  // - From Story:
  //   â†’ Setting
  //
  // - From Setting:
  //   â†’ Cover Display (single view)
  //
  // - From Cover Display:
  //   â†’ Shape Your Story
  //
  // - From Shape Your Story:
  //   â†’ Exit / Mode Select (existing behavior)
  //
  // At no point may the Back button route to:
  // - Cover Gallery
  // - Cover regeneration views
  // - Any modal or optional artifact browser
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 4 â€” SIDE CHAMBERS (NON-PARENTAL)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // The following are side chambers, not navigation parents:
  //
  // - Cover Gallery
  // - Fate Card detail views
  // - Visualizer previews
  // - Help / Settings modals
  //
  // Rules:
  // - Side chambers are entered only via explicit user action.
  // - Exiting a side chamber returns the user
  //   to the immediate prior context.
  // - Side chambers must never appear in Back history
  //   unless explicitly navigated to.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SECTION 5 â€” PRECEDENCE CLAUSE (FAILSAFE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If any conflict exists between:
  // - legacy navigation logic
  // - modal history
  // - inferred routing
  // - Back-button heuristics
  //
  // This Navigation Contract overrides them.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CANONICAL STATES â€” FIRST-CLASS NAVIGATION STATES (AUTHORITATIVE)
  // TAG: storybound/canonical-states-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 1 â€” CANONICAL STATES (ORDERED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1. SHAPE_YOUR_STORY  (screen: 'setup')
  // 2. COVER_DISPLAY     (screen: 'game', _readerPage: 0)
  // 3. SETTING           (screen: 'game', _readerPage: 'setting')
  // 4. STORY_READER      (screen: 'game', _readerPage: >= 1)
  //
  // Notes:
  // - COVER_DISPLAY is a single-cover view, not a gallery.
  // - SETTING is a full page/state, not a modal or overlay.
  // - STORY_READER begins at Scene 1.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const CANONICAL_STATES = {
      SHAPE_YOUR_STORY: 'setup',
      COVER_DISPLAY: 'coverDisplay',
      SETTING: 'setting',
      STORY_READER: 'storyReader'
  };

  const CANONICAL_STATE_ORDER = [
      CANONICAL_STATES.SHAPE_YOUR_STORY,
      CANONICAL_STATES.COVER_DISPLAY,
      CANONICAL_STATES.SETTING,
      CANONICAL_STATES.STORY_READER
  ];

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 2 â€” COVER_DISPLAY STATE (DEFINITION)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Behavior:
  // - Renders the current story's primary cover only.
  // - If no cover exists, render a placeholder + CTA.
  // - Must not allow browsing alternate covers.
  // - Must not auto-open Cover Gallery.
  //
  // Rules:
  // - COVER_DISPLAY is part of the main flow.
  // - COVER_DISPLAY is NOT a modal.
  // - COVER_DISPLAY has a Back destination and a Forward destination.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 3 â€” SETTING STATE (RESTORATION)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Behavior:
  // - Displays world, location, and initial conditions.
  // - Occurs after COVER_DISPLAY and before STORY_READER.
  // - Is revisitable via Back navigation from STORY_READER.
  //
  // Rules:
  // - SETTING must not be collapsed into Shape or Story.
  // - SETTING must not be implemented as a modal.
  // - SETTING participates in Back-button reversal.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 4 â€” FORWARD NAVIGATION (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Canonical forward flow:
  //
  // SHAPE_YOUR_STORY
  // â†’ COVER_DISPLAY
  // â†’ SETTING
  // â†’ STORY_READER (Scene 1)
  //
  // This flow must be respected for:
  // - new stories
  // - regenerated stories
  // - restarted stories
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 5 â€” RESTART / RESUME FLOW (LOCKED)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // When resuming an existing story:
  //
  // 1. Enter COVER_DISPLAY
  // 2. Then proceed to the most recent STORY_READER scene
  //
  // SETTING is skipped on resume unless explicitly navigated to.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 6 â€” BACK BUTTON INTEGRATION (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Back behavior must reverse the canonical state order:
  //
  // - From STORY_READER â†’ SETTING
  // - From SETTING â†’ COVER_DISPLAY
  // - From COVER_DISPLAY â†’ SHAPE_YOUR_STORY
  //
  // At no point may Back route to:
  // - Cover Gallery
  // - Any modal
  // - Any non-canonical state
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // PART 7 â€” FAILURE PREVENTION CLAUSE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // "If a state does not exist as a first-class state,
  // it may not be used as a Back or Forward destination."
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // --- NAVIGATION STATE ---
  let _navHistory = [];
  let _currentScreenId = 'legalGate';

  function updateNavUI() {
      const backBtn = document.getElementById('globalBackBtn');
      const burger = document.getElementById('burgerBtn');

      if(backBtn) {
          const hidden = ['ageGate', 'legalGate', 'tierGate'].includes(_currentScreenId);
          if(hidden) backBtn.classList.add('hidden');
          else backBtn.classList.remove('hidden');
      }
      
      if(burger) {
          if(_currentScreenId === 'legalGate') burger.classList.add('hidden');
          else burger.classList.remove('hidden');
      }
  }

  function goBack() {
      // LINEAR READER NAVIGATION (book system disabled)
      if (_currentScreenId === 'game') {
          if (!USE_OPENING_BOOK) {
              // Back in-story â†’ step back through pages (preserve story state)
              if (_readerPage >= 2) {
                  // From scene â†’ synopsis
                  showReaderPage(1);
                  return;
              }
              if (_readerPage === 1) {
                  // From synopsis â†’ cover
                  showReaderPage(0);
                  return;
              }
              // At Cover (page 0) â€” stay, no further back
              return;
          } else {
              // BOOK SYSTEM (disabled â€” this branch won't run when USE_OPENING_BOOK = false)
              const bookCover = document.getElementById('bookCover');
              const isBookOpen = bookCover?.classList.contains('hinge-open') || _bookOpened;

              if (isBookOpen && _bookPageIndex > 0) {
                  if (typeof previousBookPage === 'function' && previousBookPage()) {
                      return;
                  }
              }

              if (isBookOpen && _bookPageIndex === 0) {
                  const bookCoverPage = document.getElementById('bookCoverPage');
                  const storyContent = document.getElementById('storyContent');
                  if (bookCover) {
                      bookCover.classList.remove('hinge-open', 'courtesy-peek');
                  }
                  if (bookCoverPage) {
                      bookCoverPage.classList.remove('hidden');
                  }
                  if (storyContent) {
                      storyContent.classList.add('hidden');
                  }
                  _bookOpened = false;
                  setBookPage(0);
                  return;
              }
          }
      }

      // modeSelect clears _navHistory â€” explicit back to tierGate
      if (_currentScreenId === 'modeSelect') {
          window.showScreen('tierGate', true);
          return;
      }

      if (_navHistory.length === 0) {
          if(typeof coupleCleanup === 'function' && state.mode === 'couple') coupleCleanup();
          window.showScreen('modeSelect');
          return;
      }
      const prev = _navHistory.pop();
      window.showScreen(prev, true);
  }

  window.showScreen = function(id, isBack = false){
      if (document.body.classList.contains('booting')) {
        if (window.__initialScreenSet) return;
        window.__initialScreenSet = true;
      }
      closeAllOverlays();
      // PASS 1 FIX: Clear any stuck toasts on screen change
      if (typeof clearToasts === 'function') clearToasts();

      // Capture previous screen for BACK-TO-CONFIG detection
      const previousScreen = _currentScreenId;

      // UX-2 FIX: Clean up fate visuals when leaving setup screen
      // GUARD: Skip cleanup if Guided Fate visuals are still active (will be torn down later)
      if (_currentScreenId === 'setup' && id !== 'setup') {
          if (!_guidedFateVisualsActive && typeof cleanupFateVisuals === 'function') cleanupFateVisuals();
      }

      // Hide corridor Continue button when leaving setup screen
      if (id !== 'setup') {
          const controlPlaneBtn = document.getElementById('continueButton');
          if (controlPlaneBtn) controlPlaneBtn.classList.remove('visible');
      }

      if(id === 'tierGate') {
          // Reset tier cards so they start face-down each time
          if (window.resetTierCards) window.resetTierCards();
      }

      if(id === 'modeSelect') {
          _navHistory = [];
          // Update Solo subtitle based on permission gradient
          if (typeof updateSoloSubtitle === 'function') updateSoloSubtitle();
          // Reset mode cards so they start face-down each time
          if (window.resetModeCards) window.resetModeCards();
      } else if (!isBack && _currentScreenId && _currentScreenId !== id) {
         if(!['ageGate', 'legalGate', 'tierGate'].includes(_currentScreenId)) {
             _navHistory.push(_currentScreenId);
         }
      }

      document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));

      const target = document.getElementById(id);
      if(target) target.classList.remove('hidden');
      
      const app = document.getElementById('app');
      if (app && target) {
          if (app.contains(target)) app.classList.remove('hidden');
          else app.classList.add('hidden');
      }

      // CORRECTIVE PASS FIX 4: Do NOT scroll when entering game screen
      // The game screen uses a fixed book cover page overlay that handles its own viewport.
      // Scrolling to top during the loading transition causes a jarring jump.
      if (id !== 'game') {
          window.scrollTo(0,0);
      }
      _currentScreenId = id;
      updateNavUI();

      // Update DSP visibility based on screen (state-based, not scroll-based)
      if (typeof updateDSPVisibility === 'function') {
          updateDSPVisibility(id);
      }

      // Initialize fate hand system when entering setup screen
      if(id === 'setup') {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // BACK-TO-CONFIG RESET â€” Re-arm generation when navigating back
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // When user navigates back to Story Settings:
          // - Guided Fate cards become active again
          // - Prior story/cover is discarded (treated as new session)
          // - Clear "already generated" flags
          // - Do NOT auto-generate, just re-arm the system
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (isBack && previousScreen === 'game') {
              console.log('[BACK-TO-CONFIG] User navigated back to setup â€” re-arming generation system');

              // Clear prior story/cover assets
              state._backgroundStoryText = null;
              state._backgroundStoryTitle = null;
              state._backgroundStorySynopsis = null;
              state._synopsisMetadata = null;
              state._synopsisBlurb = null;
              state._titlePageShown = false;

              // Reset cover Assembly object tracking (treat as new story)
              state._coverAssemblyObjectShown = false;
              state._coverAssemblyObject = null;
              state._coverWorldKey = null;

              // Reset cover generation flags (re-arms for new cover)
              if (window.resetCoverGenerationFlags) window.resetCoverGenerationFlags();

              // Reset cover shape hash (allows regeneration with new selections)
              if (window.clearCoverShapeHash) window.clearCoverShapeHash();

              // Reset background story flags
              if (window.resetBackgroundStory) window.resetBackgroundStory();

              // Reset DSP state for fresh generation
              if (typeof resetDSPState === 'function') resetDSPState();

              // Clear cover image
              const coverImg = document.getElementById('bookCoverImg');
              if (coverImg) coverImg.src = '';

              // Clear title (will be regenerated)
              const storyTitle = document.getElementById('storyTitle');
              if (storyTitle) storyTitle.textContent = '';

              // Re-activate Guided Fate cards (they should be interactive again)
              // The initFateHandSystem call below will reinitialize them

              console.log('[BACK-TO-CONFIG] Complete â€” next Generate action will be treated as first-time');
          }

          initFateHandSystem();
          // Start ambient sparkles around the Guided Fate card
          if (typeof startAmbientCardSparkles === 'function') startAmbientCardSparkles();
          // Couple subhead: show ONLY when mode === 'couple', no other conditions
          const coupleSubhead = document.getElementById('coupleSubhead');
          if (coupleSubhead) coupleSubhead.classList.toggle('hidden', state.mode !== 'couple');
          // Show breadcrumb at 'shape' step
          if (window.updateBreadcrumb) window.updateBreadcrumb('shape');
          // Update Fortune display
          if (window.updateFortuneDisplay) window.updateFortuneDisplay();
      } else if (id === 'game') {
          // Game screen breadcrumb is managed by Cover/Setting/Story views
          // Don't update here â€” let the view functions handle it
      } else {
          if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();
          // Stop fate card sparkle cycle when leaving game screen
          if (window.stopSparkleCycle) window.stopSparkleCycle();
          // Hide breadcrumb on non-story screens (modeSelect, tierGate, etc.)
          if (window.hideBreadcrumb) window.hideBreadcrumb();
      }
  };

  function initNavBindings() {
      const app = document.getElementById('app');
      if (app) {
          Array.from(app.children).forEach(el => {
              if (el.tagName === 'DIV') el.classList.add('screen');
          });
      }
      ['ageGate', 'legalGate', 'tierGate'].forEach(id => {
          const el = document.getElementById(id);
          if (el) el.classList.add('screen');
      });

      const backBtn = document.getElementById('globalBackBtn');
      if(backBtn && !backBtn.dataset.navBound) {
          backBtn.dataset.navBound = "true";
          backBtn.addEventListener('click', goBack);
      }
      
      // Global Locked Click Delegation
      // Allows preview buttons within locked cards to still function
      if (!document._lockedClickBound) {
          document._lockedClickBound = true;
          document.addEventListener('click', (e) => {
              // Allow preview buttons to work even in locked cards
              // Check both the target and all ancestors for .preview-btn
              const previewBtn = e.target.closest('.preview-btn');
              if (previewBtn) {
                  // Explicitly show preview and stop - don't let anything else handle this
                  e.stopPropagation();
                  const previewText = document.getElementById('previewText');
                  const previewModal = document.getElementById('previewModal');
                  if (previewText && previewModal && previewBtn.dataset.txt) {
                      previewText.textContent = previewBtn.dataset.txt;
                      previewModal.classList.remove('hidden');
                  }
                  return;
              }

              const lockedTarget = e.target.closest('.locked, .locked-style, .locked-input, .locked-taste, .locked-pass, [data-locked]');
              if (lockedTarget) {
                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();

                  window.openPaywall(lockedTarget.dataset.paywallMode || 'unlock');
              }
          }, true);
      } 

      document.addEventListener('keydown', (e) => {
          if (e.ctrlKey && e.shiftKey && (e.key === 'a' || e.key === 'A')) {
              const p = document.getElementById('auth-panel');
              if(p) p.classList.toggle('hidden');
          }
      });
  }

  // --- SAFETY & CONSENT ---
  // PASS 1 FIX: Toast system with proper auto-dismiss and anti-stacking
  let _toastTimer = null;

  function showToast(msg) {
      const t = document.getElementById('toast');
      if (!t) return;

      // Clear any existing toast timer to prevent stacking
      if (_toastTimer) {
          clearTimeout(_toastTimer);
          _toastTimer = null;
      }

      // Set content and show
      t.textContent = msg;
      t.classList.remove('hidden');

      // Reset animation by forcing reflow
      t.style.animation = 'none';
      void t.offsetWidth;
      t.style.animation = 'toastFadeInOut 3s forwards';

      // Explicit hide after animation completes (failsafe)
      _toastTimer = setTimeout(() => {
          t.classList.add('hidden');
          t.style.animation = 'none';
          _toastTimer = null;
      }, 3100);
  }

  // Clear any stuck toasts (call on state changes)
  function clearToasts() {
      const t = document.getElementById('toast');
      if (t) {
          t.classList.add('hidden');
          t.style.animation = 'none';
      }
      if (_toastTimer) {
          clearTimeout(_toastTimer);
          _toastTimer = null;
      }
  }

  function sanitizeUserIntent(action, dialogue) {
      const input = (action + " " + dialogue).toLowerCase();
      const nonConPatterns = [
          /\brape\b/i, /\b(non[-\s]?consensual|without consent)\b/i,
          /\bagainst (her|his|their) will\b/i, /\bforce\b/i
      ];
      
      if(nonConPatterns.some(rx => rx.test(input))) {
          const now = Date.now();
          if (now - (state.lastNonConPushAt || 0) > 15 * 60 * 1000) state.nonConPushCount = 0;
          state.nonConPushCount = (state.nonConPushCount || 0) + 1;
          state.lastNonConPushAt = now;

          const directive = "ABSOLUTE SAFETY RULE: User input implied non-consensual dynamics. 1. DO NOT depict the act. NO sexual violence. 2. REFRAME: Partner deflects safely OR shifts to explicit, enthusiastic consent negotiation.";
          return { safeAction: undefined, safeDialogue: undefined, flags: ["redirect_nonconsent"], directive };
      }
      return { safeAction: undefined, safeDialogue: undefined, flags: [], directive: "" };
  }

  function buildConsentDirectives() {
      return "SAFETY & CONSENT RULES: All interactions must depict consensual dynamics. No violence or coercion. All dynamics must be clearly enthusiastic and consensual. ";
  }

  // --- ACCESS HELPERS ---
  // PASS 1 FIX: Canonical access resolver - ALL access checks must use this
  function resolveAccess() {
    // state.subscribed is set by Supabase profile hydration (single source of truth)

    // Check billing validity
    const inGrace = (state.billingStatus === 'grace' && Date.now() < state.billingGraceUntil);
    const invalidSub = state.billingStatus === 'canceled' || (state.billingStatus === 'past_due' && !inGrace);

    // Determine access tier (priority order: sub > pass > free)
    if (state.subscribed && !invalidSub) {
        return 'sub';
    }

    if (state.mode === 'couple') {
        const roomAcc = state.roomAccess || 'free';
        return roomAcc;
    }

    if (state.storyId && hasStoryPass(state.storyId)) {
        return 'pass';
    }

    return 'free';
  }

  // PASS 1 FIX: Single function to sync state from canonical resolver
  function syncTierFromAccess() {
    // Resolve access from canonical source
    const resolvedAccess = resolveAccess();
    let tier;
    if (!resolvedAccess) {
      tier = null;
    } else if (resolvedAccess === 'sub') {
      tier = state.subscriptionTier === 'favored' ? 'favored' : 'storied';
    } else if (resolvedAccess === 'free') {
      tier = 'free';
    } else {
      tier = 'paid';  // storypass
    }

    if (!resolvedAccess || !tier) {
      console.warn('[ENTITLEMENT] Invalid access state â€” defaulting to free');
      state.tier = 'free';
      state.subscribed = false;
      return;
    }

    // Update state â€” server-authoritative only
    state.access = resolvedAccess;
    state.tier = tier;

    // Invariant: subscription flag must agree with tier
    if (!['storied', 'favored', 'paid'].includes(state.tier) && state.subscribed) {
      console.warn('[ENTITLEMENT] Tier/subscription mismatch â€” normalizing');
      state.subscribed = false;
    }

    // Sync keyhole activation with current tier
    if (typeof activateKeyholeMarkIfEligible === 'function') activateKeyholeMarkIfEligible();

    console.log('[ENTITLEMENT] syncTierFromAccess:', {
        access: state.access,
        tier: state.tier,
        subscriptionTier: state.subscriptionTier,
        subscribed: state.subscribed,
        keyholeMarked: state.keyhole?.marked,
        storyId: state.storyId,
        hasPass: state.storyId ? hasStoryPass(state.storyId) : false
    });

    return resolvedAccess;
  }

  window.openPaywall = function(reason) {
      if(typeof window.showPaywall === 'function') {
          // Close Petition modal if open (prevents z-index stacking)
          const petModal = document.getElementById('petitionFateModal');
          if (petModal && !petModal.classList.contains('hidden')) {
              petModal.classList.add('hidden');
          }
          // Respect explicit 'sub_only' from caller (e.g., Dirty/Soulmates cards)
          const mode = (reason === 'god' || reason === 'sub_only') ? reason : getPaywallMode();
          window.showPaywall(mode);
      }
  };

  function currentStoryWordCount(){
    // Get all content across all pages for accurate word count
    const allContent = StoryPagination.getAllContent();
    if (!allContent) return 0;
    // Strip HTML tags and count words
    const txt = allContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
    if(!txt) return 0;
    return txt.split(/\s+/).filter(Boolean).length;
  }

  function getSexAllowedAtWordCount() {
    const target = state.storyTargetWords;
    // Intensity no longer modifies timing â€” use standard 30% threshold
    return Math.floor(target * 0.30);
  }

  function maybeFlipConsummation(text){
     if(state.batedBreathActive || state.mode !== 'solo') return;
     if(state.storyStage !== 'pre-intimacy') return; 

     let flipped = false;
     const wc = currentStoryWordCount();
     if(wc >= getSexAllowedAtWordCount()) flipped = true;
     if(/(only you|forever with you|marry me|my wife|my husband)/i.test(text)) flipped = true;

     if(flipped){
         state.storyStage = 'post-consummation';
         saveStorySnapshot();
     }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INTIMACY MILESTONE INTERRUPTION SYSTEM
  // Interrupts first_kiss and first_intimacy on FIRST attempt only (latch rule)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Detect if user input signals a kiss attempt
   * @param {string} action - User's action input
   * @param {string} dialogue - User's dialogue input
   * @returns {boolean}
   */
  function detectKissAttempt(action, dialogue) {
      const combined = `${action} ${dialogue}`.toLowerCase();
      const kissSignals = /\b(kiss|lean in|lips|mouth to|pull (her|him|them) close|faces inches|breath mingles|almost touching)\b/i;
      return kissSignals.test(combined);
  }

  /**
   * Detect if user input signals an intimacy attempt
   * @param {string} action - User's action input
   * @param {string} dialogue - User's dialogue input
   * @returns {boolean}
   */
  function detectIntimacyAttempt(action, dialogue) {
      const combined = `${action} ${dialogue}`.toLowerCase();
      const intimacySignals = /\b(undress|take off|bed|make love|have sex|inside|push (her|him|them) down|straddle|between (her|his|their) legs|naked|clothes off)\b/i;
      return intimacySignals.test(combined);
  }

  /**
   * Build interruption directive for story prompt
   * Returns empty string if no interruption needed (milestone already latched)
   * @param {string} action - User's action input
   * @param {string} dialogue - User's dialogue input
   * @returns {{ directive: string, milestone: string|null }}
   */
  function buildIntimacyInterruptionDirective(action, dialogue) {
      // Skip if both milestones already cleared
      if (state.intimacyInterrupted.first_kiss && state.intimacyInterrupted.first_intimacy) {
          return { directive: '', milestone: null };
      }

      // Check for intimacy attempt first (higher priority)
      if (!state.intimacyInterrupted.first_intimacy && detectIntimacyAttempt(action, dialogue)) {
          return {
              directive: `INTIMACY INTERRUPT (first_intimacy): The characters clearly INTEND physical intimacy. Telegraph the approach â€” closeness, tension, breath, almost-contact. But INTERRUPT the act before completion. Use a grounded cause:
- Internal: "Not ready," "This feels wrong," sudden hesitation, emotional wall rises
- External: Phone rings, alarm sounds, someone knocks, unexpected news arrives
The interruption must land with narrative weight. Maintain unresolved sexual tension. Do NOT consummate.`,
              milestone: 'first_intimacy'
          };
      }

      // Check for kiss attempt
      if (!state.intimacyInterrupted.first_kiss && detectKissAttempt(action, dialogue)) {
          return {
              directive: `INTIMACY INTERRUPT (first_kiss): The characters clearly INTEND to kiss. Telegraph the moment â€” faces close, breath held, eyes locked. But INTERRUPT before lips meet. Use a grounded cause:
- Internal: One pulls back, "I can't," fear flashes in eyes
- External: Sudden noise, someone approaches, phone buzzes
The near-miss must ache. Maintain romantic tension. Do NOT complete the kiss.`,
              milestone: 'first_kiss'
          };
      }

      return { directive: '', milestone: null };
  }

  /**
   * Latch an intimacy milestone after interruption occurs
   * @param {string} milestone - 'first_kiss' or 'first_intimacy'
   */
  function latchIntimacyMilestone(milestone) {
      if (milestone && state.intimacyInterrupted.hasOwnProperty(milestone)) {
          state.intimacyInterrupted[milestone] = true;
          console.log(`[INTIMACY:LATCH] ${milestone} milestone latched â€” future attempts will not interrupt`);
          saveStorySnapshot();
      }
  }

  function checkStoryEndCaps() {
      const wc = currentStoryWordCount();
      const turns = state.turnCount || 0;
      const len = state.storyLength || 'taste';

      if (len === 'taste' && (wc > 7000 || turns > 28) && !state.storyEnded) {
          state.storyEnded = true;
          // Onboarding: final vision
          if (state.storyId === state.onboarding_story_id && !state.has_received_final_vision) {
              state.has_received_final_vision = true;
              triggerVision({ reason: 'final', tone: state.picks?.tone, world: state.picks?.world, storyturn: state.storyturn });
          }
          document.getElementById('submitBtn').disabled = true;
          const div = document.createElement('div');
          div.className = 'box';
          div.style.textAlign = 'center';
          div.style.border = '1px solid var(--gold)';
          div.innerHTML = `<p style="font-style:italic; color:var(--gold)">The moment hangs, unresolved.</p>`;
          StoryPagination.appendToCurrentPage(div.outerHTML);
          // Show Story End Page after delay for user to read ending
          setTimeout(() => {
              showStoryEndPage();
          }, 3000);
          return;
      }

      if (len === 'fling' && !state.storyEnded) {
          const overCap = (wc > 15000 || turns > 60);
          if (state.flingClimaxDone && state.flingConsequenceShown && overCap) {
              state.storyEnded = true;
              // Onboarding: final vision
              if (state.storyId === state.onboarding_story_id && !state.has_received_final_vision) {
                  state.has_received_final_vision = true;
                  triggerVision({ reason: 'final', tone: state.picks?.tone, world: state.picks?.world, storyturn: state.storyturn });
              }
              document.getElementById('submitBtn').disabled = true;
              renderFlingEnd();
              // Show Story End Page after delay for user to read ending
              setTimeout(() => {
                  showStoryEndPage();
              }, 3000);
          }
      }
  }

  // --- PETITION FATE SYSTEM ---

  const PETITION_OMENS = [
      "The threads of fate shiver...",
      "Something stirs in the deep weave...",
      "Fate leans closer to listen...",
      "The golden thread pulls taut...",
      "A whisper from beyond the veil...",
      "The cards tremble in your hand...",
      "Destiny holds its breath...",
      "The weave acknowledges your voice..."
  ];

  function classifyPetition(text) {
      // Structural override â€” cosmetic/identity/social pivots (checked first)
      if (/\b(call\s+me|my\s+name\s+is|rename|nickname|go\s+by|known\s+as|change\s+(my|her|his|their)\s+(name|hair|eye|look|appearance|style|outfit|clothes)|dye\s+(my|her|his|their)\s+hair|cut\s+(my|her|his|their)\s+hair|new\s+look|makeover|title\s+is|address\s+me\s+as)\b/i.test(text)) {
          return 'structural_override';
      }
      const categories = [
          { cat: 'resurrection', rx: /\b(resurrect|revive|bring\s+back\s+from\s+dead|raise\s+the\s+dead|return\s+from\s+death)\b/i },
          { cat: 'reversal',    rx: /\b(reverse|revert|undo|unmake|turn\s+back\s+time)\b/i },
          { cat: 'harm',        rx: /\b(destroy|kill|curse|ruin|break|shatter|smite|betray)\b/i },
          { cat: 'power',       rx: /\b(power|control|dominate|rule|command|throne|reign)\b/i },
          { cat: 'escape',      rx: /\b(escape|flee|freedom|liberate|break\s+free|release)\b/i },
          { cat: 'attention',   rx: /\b(notic|attention|look\s+at|see\s+me|watch|gaze|eye|glance)\b/i },
          { cat: 'closeness',   rx: /\b(close|near|touch|hold|together|beside|proximity|closer)\b/i },
          { cat: 'love',        rx: /\b(love|heart|desire|passion|devotion|adore|romance)\b|force\s.*together|make\s.*fall/i },
          { cat: 'memory',      rx: /\b(memory|remember|forget|past|recall|nostalgia)\b/i },
          { cat: 'protection',  rx: /\b(protect|shield|guard|defend|safe|ward|sanctuary)\b/i },
          { cat: 'fortune',     rx: /\b(fortune|wealth|luck|treasure|prosper|gold|riches)\b/i },
          { cat: 'appearance',  rx: /\b(beauty|appearance|transform|form|shape|face|youth|age)\b/i },
      ];
      for (const { cat, rx } of categories) {
          if (rx.test(text)) return cat;
      }
      return 'general';
  }

  function validatePetitionText(text) {
      if (!text || text.length < 5) return { valid: false };
      if (text.length > 500) return { valid: false };

      // Gibberish: fewer than 2 real English words (4+ chars)
      const words = text.split(/\s+/).filter(w => /^[a-zA-Z]{4,}$/.test(w));
      if (words.length < 2) return { valid: false };

      // Coercive non-consensual mind control
      if (/\b(make\s+(him|her|them)\s+(love|obey|submit|surrender)|mind\s*control|force\s+(him|her|them)\s+to|brainwash|hypnoti[sz]e\s+(him|her|them)\s+into)\b/i.test(text)) {
          return { valid: false };
      }

      // Sexual vulgarity beyond tone gate (explicit acts)
      if (/\b(fuck|cock|pussy|cum|dick|anal|blowjob|handjob)\b/i.test(text)) {
          const tone = (typeof state !== 'undefined' && state.intensity) || 'Steamy';
          if (tone === 'Clean' || tone === 'Naughty') return { valid: false };
      }

      return { valid: true };
  }

  function validateStructuralOverride(text) {
      // Profanity / slur names
      if (/\b(fuck|shit|bitch|cunt|dick|ass|damn|hell|bastard|whore|slut|retard|fagg?ot|nig)/i.test(text)) {
          return { valid: false, reason: 'profanity' };
      }
      // Meme / joke names (internet memes, gibberish identities)
      if (/\b(deez\s*nuts|ligma|sugma|joe\s+mama|harambe|shrek|sussy|amogus|rizz\s+lord|skibidi)\b/i.test(text)) {
          return { valid: false, reason: 'meme' };
      }
      // Genre-breaking real-world celebrity / fictional IP names
      if (/\b(elon\s+musk|taylor\s+swift|trump|obama|batman|superman|goku|naruto|harry\s+potter|darth\s+vader)\b/i.test(text)) {
          return { valid: false, reason: 'ip_breach' };
      }
      return { valid: true };
  }

  function resolvePetitionAcceptance(favorsOffered, classification) {
      // Structural overrides auto-accept (cosmetic/identity changes are always plausible)
      if (classification === 'structural_override') return true;

      const petitionStrength = Math.min(favorsOffered / 40, 1);

      // Feasibility factor â€” lower for reality-breaking, higher for subtle shifts
      const lowFeasibility = ['resurrection', 'reversal', 'harm', 'power'];
      const highFeasibility = ['attention', 'love', 'closeness', 'protection', 'fortune', 'memory', 'appearance'];
      let feasibilityFactor = 0.7; // default for 'general' and 'escape'
      if (lowFeasibility.includes(classification)) feasibilityFactor = 0.4;
      if (highFeasibility.includes(classification)) feasibilityFactor = 0.9;

      // Zero favors: auto-accept low-stakes, likely reject high-impact
      if (favorsOffered === 0) {
          if (highFeasibility.includes(classification)) return Math.random() < 0.3;
          return false;
      }

      return Math.random() < petitionStrength * feasibilityFactor;
  }

  function canAttemptGreaterPetition() {
      const stIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
      if (stIdx < 2) return false;
      if (state.fate?.greaterUsedThisScene) return false;
      return true;
  }

  function resolveFateOutcome(stance, classification) {
      let weights;
      if (classification !== 'general' && !canAttemptGreaterPetition()) {
          weights = { benevolent: 10, twist: 60, silent: 30 };
      } else {
          const stanceWeights = {
              neutral:   { benevolent: 40, twist: 20, silent: 5, neutral: 35 },
              trickster: { benevolent: 20, twist: 50, silent: 30 },
              intimate:  { benevolent: 50, twist: 35, silent: 15 }
          };
          weights = { ...(stanceWeights[stance] || stanceWeights.neutral) };
      }

      // Keyhole Boon â€” Favored reservoir drain boosts benevolent weight
      if (state.keyhole?.marked && state.keyhole.favorReservoir > 0 && !state.keyhole.boonUsedThisScene) {
          const drainAmount = Math.min(state.keyhole.favorReservoir, 25);
          state.keyhole.favorReservoir -= drainAmount;
          state.keyhole.boonUsedThisScene = true;
          state.keyhole.totalBoonsDrained += drainAmount;
          const keyholeBoost = (drainAmount / 100) * 0.5;
          weights.benevolent = (weights.benevolent || 0) + keyholeBoost * 100;
      }

      const total = Object.values(weights).reduce((s, v) => s + v, 0);
      let r = Math.random() * total;
      for (const [outcome, w] of Object.entries(weights)) {
          r -= w;
          if (r <= 0) return outcome;
      }
      return 'neutral';
  }

  function disableTurnControls() {
      const mount = document.getElementById('cardMount');
      if (mount) mount.style.pointerEvents = 'none';
      const ai = document.getElementById('actionInput');
      const di = document.getElementById('dialogueInput');
      const sb = document.getElementById('submitBtn');
      if (ai) ai.disabled = true;
      if (di) di.disabled = true;
      if (sb) sb.disabled = true;
  }

  function enableTurnControls() {
      const mount = document.getElementById('cardMount');
      if (mount) mount.style.pointerEvents = '';
      const ai = document.getElementById('actionInput');
      const di = document.getElementById('dialogueInput');
      const sb = document.getElementById('submitBtn');
      if (ai) ai.disabled = false;
      if (di) di.disabled = false;
      if (sb) sb.disabled = false;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PETITION ZOOM â€” Card zooms into portal with ritual overlay on face
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _petitionZoomOriginalParent = null;
  let _petitionZoomOriginalNextSibling = null;
  let _petitionZoomCard = null;

  window.openPetitionZoom = function() {
      const card = document.querySelector('.petition-fate-card');
      if (!card) return;


      // Telemetry: petition opened (once per session)
      if (!state._loggedPetitionOpen) {
          try { logEvent('petition_opened', { tone: state.picks?.tone, world: state.picks?.world }); } catch(_){}
          state._loggedPetitionOpen = true;
      }

      // Store original DOM position for restoration
      _petitionZoomOriginalParent = card.parentNode;
      _petitionZoomOriginalNextSibling = card.nextElementSibling;
      _petitionZoomCard = card;

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Move card to zoom portal
      const portal = document.getElementById('sbZoomPortal');
      const backdrop = document.getElementById('sbZoomBackdrop');
      if (portal) portal.appendChild(card);

      // Scale zoom: card stays at original size, scale enlarges uniformly
      const sidePadding = 40;
      const topPadding = 20;
      const bottomPadding = 60;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / rect.width, maxHeight / rect.height);

      card.classList.add('petition-zoomed');
      card.style.width = `${rect.width}px`;
      card.style.height = `${rect.height}px`;
      card.style.transform = `scale(${scale})`;
      card.style.transformOrigin = 'center center';

      // Swap to high-res zoomed Petition art
      const backFace = card.querySelector('.back');
      if (backFace) {
          backFace._origBg = backFace.style.backgroundImage;
          backFace.style.backgroundImage = "url('/assets/Card%20Art/Cards/Tarot-Gold-front-PetitionZOOMED.png')";
      }

      if (backdrop) {
          backdrop.classList.add('active');
          // Close petition zoom on backdrop click
          backdrop._petitionCloseHandler = () => { closePetitionZoom(); };
          backdrop.addEventListener('click', backdrop._petitionCloseHandler);
      }

      // Build ritual overlay on card front face
      const front = card.querySelector('.front');
      if (!front) return;

      // Remove any existing overlay
      front.querySelector('.petition-zoom-overlay')?.remove();

      const overlay = document.createElement('div');
      overlay.className = 'petition-zoom-overlay';
      overlay.innerHTML = `
          <div class="petition-top-zone">
              <div class="petition-suggest-panel">
                  <div class="petition-suggest-col">
                      <div class="petition-suggest-header">Surface Changes</div>
                      <div class="petition-suggest-list">
                          <div class="petition-suggest-item" data-suggest="Change his name to Dan">Change his name to Dan</div>
                          <div class="petition-suggest-item" data-suggest="Ban the word Moist">Ban the word &ldquo;Moist&rdquo;</div>
                          <div class="petition-suggest-item" data-suggest="Make her blonde">Make her blonde</div>
                          <div class="petition-suggest-item" data-suggest="Change my hairstyle">Change my hairstyle</div>
                          <div class="petition-suggest-item" data-suggest="Change my outfit">Change my outfit</div>
                          <div class="petition-suggest-item" data-suggest="Stop the teasing nickname">Stop the teasing nickname</div>
                          <div class="petition-suggest-item" data-suggest="No tattoos">No tattoos</div>
                          <div class="petition-suggest-item" data-suggest="Make her wear glasses">Make her wear glasses</div>
                          <div class="petition-suggest-item" data-suggest="Give him a Scottish accent">Give him a Scottish accent</div>
                      </div>
                  </div>
                  <div class="petition-suggest-col">
                      <div class="petition-suggest-header">Plot Shifts</div>
                      <div class="petition-suggest-list">
                          <div class="petition-suggest-item" data-suggest="Let him notice me">Let him notice me</div>
                          <div class="petition-suggest-item" data-suggest="Give me a second chance">Give me a second chance</div>
                          <div class="petition-suggest-item" data-suggest="Let the argument cool down">Let the argument cool down</div>
                          <div class="petition-suggest-item" data-suggest="Let the message arrive in time">Let the message arrive in time</div>
                          <div class="petition-suggest-item" data-suggest="Let the door be unlocked">Let the door be unlocked</div>
                          <div class="petition-suggest-item" data-suggest="Make her reconsider">Make her reconsider</div>
                          <div class="petition-suggest-item" data-suggest="Let them not see us">Let them not see us</div>
                          <div class="petition-suggest-item" data-suggest="Steamy sauna scene">Steamy sauna scene</div>
                          <div class="petition-suggest-item" data-suggest="Give us a private moment">Give us a private moment</div>
                          <div class="petition-suggest-item" data-suggest="Let him ache for me">Let him ache for me</div>
                      </div>
                  </div>
              </div>
              <div class="petition-write-toggle">write your own</div>
              <div class="petition-custom-input">
                  <textarea id="petitionZoomInput" placeholder="Write your petition\u2026" rows="2"></textarea>
                  <div class="petition-custom-back">&larr; back to suggestions</div>
              </div>
          </div>
          <div class="petition-lower-zone">
              <div class="petition-fortune-tiers" id="petitionFortuneTiers">
                  <button class="petition-tier-btn" data-tier="5"><span class="petition-tier-name">Whisper</span><span class="petition-tier-cost">5</span></button>
                  <button class="petition-tier-btn" data-tier="15"><span class="petition-tier-name">Nudge</span><span class="petition-tier-cost">15</span></button>
                  <button class="petition-tier-btn" data-tier="25"><span class="petition-tier-name">Pull</span><span class="petition-tier-cost">25</span></button>
                  <button class="petition-tier-btn" data-tier="35"><span class="petition-tier-name">Bend</span><span class="petition-tier-cost">35</span></button>
                  <button class="petition-tier-btn" data-tier="40"><span class="petition-tier-name">Nearly Certain</span><span class="petition-tier-cost">40</span></button>
              </div>
          </div>
          <div id="petitionZoomResult" class="petition-result hidden"></div>
      `;
      // Stop click propagation so card handler doesn't re-fire
      overlay.addEventListener('click', e => e.stopPropagation());
      overlay.addEventListener('mousedown', e => e.stopPropagation());
      front.appendChild(overlay);

      // Track selected petition text (from suggestion or custom)
      let _petitionText = '';

      // â”€â”€ Suggestion click handlers â€” select a suggestion â”€â”€
      const suggestPanel = overlay.querySelector('.petition-suggest-panel');
      const customInput = overlay.querySelector('.petition-custom-input');
      const writeToggle = overlay.querySelector('.petition-write-toggle');
      const customBack = overlay.querySelector('.petition-custom-back');
      const customTextarea = overlay.querySelector('#petitionZoomInput');

      overlay.querySelectorAll('.petition-suggest-item').forEach(item => {
          item.addEventListener('click', () => {
              // Deselect all, select this one
              overlay.querySelectorAll('.petition-suggest-item').forEach(i => i.classList.remove('petition-suggest-selected'));
              item.classList.add('petition-suggest-selected');
              _petitionText = item.dataset.suggest;
          });
      });

      // â”€â”€ Write-your-own toggle â”€â”€
      if (writeToggle) {
          writeToggle.addEventListener('click', () => {
              suggestPanel.classList.add('hidden');
              writeToggle.style.display = 'none';
              customInput.classList.add('active');
              if (customTextarea) {
                  customTextarea.value = _petitionText || '';
                  setTimeout(() => customTextarea.focus(), 100);
              }
          });
      }

      // â”€â”€ Back to suggestions â”€â”€
      if (customBack) {
          customBack.addEventListener('click', () => {
              // Save any custom text
              if (customTextarea) _petitionText = customTextarea.value.trim();
              customInput.classList.remove('active');
              suggestPanel.classList.remove('hidden');
              writeToggle.style.display = '';
          });
      }

      // â”€â”€ Fortune tier selector â”€â”€
      let _petitionFortunes = 0;
      const tierBtns = overlay.querySelectorAll('.petition-tier-btn');

      function _refreshTierAvailability() {
          const bal = state.fortunes || 0;
          let activeDeselected = false;
          tierBtns.forEach(btn => {
              const tierCost = parseInt(btn.dataset.tier, 10);
              const wasDisabled = btn.classList.contains('sb-tier-disabled');
              const shouldDisable = tierCost > bal;
              if (shouldDisable && !wasDisabled) {
                  btn.classList.add('sb-tier-disabled');
                  btn.disabled = true;
                  if (btn.classList.contains('petition-tier-active')) {
                      btn.classList.remove('petition-tier-active');
                      activeDeselected = true;
                  }
              } else if (!shouldDisable && wasDisabled) {
                  btn.classList.remove('sb-tier-disabled');
                  btn.disabled = false;
              }
          });
          if (activeDeselected) {
              let fallback = null;
              tierBtns.forEach(btn => {
                  const c = parseInt(btn.dataset.tier, 10);
                  if (c <= bal && (!fallback || c > parseInt(fallback.dataset.tier, 10))) fallback = btn;
              });
              if (fallback) {
                  fallback.classList.add('petition-tier-active');
                  _petitionFortunes = parseInt(fallback.dataset.tier, 10);
              } else {
                  _petitionFortunes = 0;
              }
          }
      }

      _refreshTierAvailability();

      tierBtns.forEach(btn => {
          const tierCost = parseInt(btn.dataset.tier, 10);
          btn.addEventListener('click', () => {
              if (btn.classList.contains('sb-tier-disabled')) {
                  let tip = btn.querySelector('.petition-tier-tooltip');
                  if (!tip) {
                      tip = document.createElement('span');
                      tip.className = 'petition-tier-tooltip';
                      tip.textContent = 'Not enough Fortune.';
                      btn.appendChild(tip);
                  }
                  tip.classList.add('visible');
                  setTimeout(() => tip.classList.remove('visible'), 1200);
                  return;
              }
              if (btn.classList.contains('petition-tier-active')) {
                  btn.classList.remove('petition-tier-active');
                  _petitionFortunes = 0;
                  return;
              }
              tierBtns.forEach(b => b.classList.remove('petition-tier-active'));
              btn.classList.add('petition-tier-active');
              _petitionFortunes = tierCost;
          });
      });

      // â”€â”€ Create floating Proceed button (sibling of card in portal) â”€â”€
      const proceedBtn = document.createElement('button');
      proceedBtn.className = 'petition-proceed-btn';
      proceedBtn.textContent = 'Proceed';
      card.appendChild(proceedBtn);

      // â”€â”€ Proceed handler (replaces old Seal) â”€â”€
      proceedBtn.addEventListener('click', () => {
          // Resolve petition text: custom textarea takes priority if visible
          let text = _petitionText;
          if (customInput.classList.contains('active') && customTextarea) {
              text = customTextarea.value.trim();
          }
          if (!text) {
              if (typeof showToast === 'function') showToast('Write or choose a petition first.');
              return;
          }

          // Validate petition text
          const validation = validatePetitionText(text);
          if (!validation.valid) {
              if (typeof showToast === 'function') showToast('You feel a deafening silence.');
              return;
          }

          const classification = classifyPetition(text);

          // Structural override plausibility gate
          if (classification === 'structural_override') {
              const soCheck = validateStructuralOverride(text);
              if (!soCheck.valid) {
                  if (typeof showToast === 'function') showToast('You feel a deafening silence.');
                  return;
              }
          }

          // Enforce 1 petition per scene
          if (state.petitionUsedThisScene) {
              if (typeof showToast === 'function') showToast('You have already petitioned Fate this scene.');
              return;
          }

          const isGreater = classification !== 'general' && classification !== 'structural_override';

          if (!isGreater && state.fate?.minorUsedThisScene) {
              if (typeof showToast === 'function') showToast('You have already petitioned Fate this scene.');
              return;
          }
          if (isGreater && state.fate?.greaterUsedThisScene) {
              if (typeof showToast === 'function') showToast('A greater petition has already been made this scene.');
              return;
          }

          const favorsOffered = _petitionFortunes;

          // Set per-scene flags
          state.petitionUsedThisScene = true;
          if (!isGreater) state.fate.minorUsedThisScene = true;
          if (isGreater) {
              state.fate.greaterUsedThisScene = true;
              state.fate.lastGreaterSceneIndex = state.turnCount;
          }
          const stIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
          if (isGreater && stIdx < 4) {
              state.fate.earlyGamingCount++;
          }

          // Activate volatility window â€” skip for structural overrides (cosmetic, no world distortion)
          if (classification !== 'structural_override') {
              const severity = computeTemptFateSeverity();
              state.volatility_window = {
                  active: true,
                  severity,
                  remaining_scenes: severity < 0.5 ? 1 : severity < 0.8 ? 2 : 3,
                  source: 'petition'
              };
          }

          // Stage petition â€” outcome resolved at Submit time
          state.fate.pendingPetition = { text, classification, favorsOffered, accepted: null };

          // Telemetry: petition submitted (once per story)
          if (!state._loggedPetitionSubmit) {
              try { logEvent('petition_submitted', { tone: state.picks?.tone, world: state.picks?.world }); } catch(_){}
              state._loggedPetitionSubmit = true;
          }

          // Invalidate speculative scene so fresh generation includes petition
          if (typeof invalidateSpeculativeScene === 'function') invalidateSpeculativeScene();

          // Show result
          const zoomResultEl = document.getElementById('petitionZoomResult');
          if (zoomResultEl) {
              zoomResultEl.textContent = 'Your petition has been sealed.';
              zoomResultEl.classList.remove('hidden');
              zoomResultEl.classList.add('fade-in');
          }

          proceedBtn.disabled = true;

          // Close zoom after 1.5s
          setTimeout(() => {
              closePetitionZoom();
          }, 1500);
      });
  };

  function closePetitionZoom() {
      const card = _petitionZoomCard;
      if (!card) return;

      // Remove overlay and floating Proceed button
      card.querySelector('.petition-zoom-overlay')?.remove();
      card.querySelector('.petition-proceed-btn')?.remove();

      // Restore original Petition art
      const backFace = card.querySelector('.back');
      if (backFace && backFace._origBg) {
          backFace.style.backgroundImage = backFace._origBg;
          delete backFace._origBg;
      }

      // Remove zoom styles
      card.classList.remove('petition-zoomed');
      card.style.transform = '';
      card.style.transformOrigin = '';
      card.style.width = '';
      card.style.height = '';

      // Restore card to original DOM position
      if (_petitionZoomOriginalParent) {
          if (_petitionZoomOriginalNextSibling) {
              _petitionZoomOriginalParent.insertBefore(card, _petitionZoomOriginalNextSibling);
          } else {
              _petitionZoomOriginalParent.appendChild(card);
          }
      }

      // Hide backdrop and remove click handler
      const backdrop = document.getElementById('sbZoomBackdrop');
      if (backdrop) {
          backdrop.classList.remove('active');
          if (backdrop._petitionCloseHandler) {
              backdrop.removeEventListener('click', backdrop._petitionCloseHandler);
              delete backdrop._petitionCloseHandler;
          }
      }

      _petitionZoomOriginalParent = null;
      _petitionZoomOriginalNextSibling = null;
      _petitionZoomCard = null;

      enableTurnControls();
  }

  // --- FATE HAND SYSTEM (Replaces pill system) ---
  // Suggestion pools for rotating placeholders and fate draws
  const FATE_SUGGESTIONS = {
      ancestry: [
          // Intermixed ~50% fantasy, ~50% real-world
          "Fae", "Celtic", "Half-elf", "Nordic", "Starborn", "Andean",
          "Clockwork", "Levantine", "Night Court", "Korean", "Shadow-born", "Persian",
          "Mer-touched", "Japanese", "Dragon-blooded", "West African", "Storm-caller", "Greek",
          "Dusk Walker", "Mediterranean", "Moon-kissed", "Slavic", "Fire-veined", "Indian",
          "Void-touched", "Pacific Islander", "Iron-blooded", "Southeast Asian", "Sylvan", "Chinese",
          "Dream-walker", "Afro-Caribbean", "Changeling", "Latin American", "Forgotten royal line", "Middle Eastern"
      ],
      world: [
          // Generic fallback (kept for compatibility)
          "Ancient empire ruins", "Clockwork city", "Floating islands", "Underground kingdom",
          "Endless library", "Frozen wasteland", "Desert oasis", "Living forest",
          "Crystal caverns", "Storm-wracked coast", "Sunken civilization", "Sky citadel",
          "Volcanic archipelago", "Haunted frontier", "Merchant crossroads", "Border fortress",
          "Hidden valley", "Plague quarantine", "Orbital station", "Dream realm"
      ],
      petition: [
          "More tension between them", "A private moment alone",
          "An unexpected interruption", "Let them confess",
          "A dangerous revelation", "Shift the power dynamic",
          "A stolen moment", "Force a difficult choice",
          "An obstacle to overcome", "Bring them closer"
      ],
      visualize: [
          "more muscular", "more elegant", "brighter lighting", "darker mood",
          "cuter", "softer facial features", "strong jawline", "hourglass figure",
          "athletic build", "blonde hair", "dark hair", "natural expression",
          "cinematic lighting", "high detail", "dreamlike", "painterly",
          "leading-actor looks", "movie poster style", "anime style", "photo-realistic"
      ],
      archetypeModifier: [
          "Romantic", "Cloistered", "Rogue", "Dangerous", "Guardian",
          "Sovereign", "Enchanting", "Devoted", "Strategist"
      ]
  };

  // PASS 9D: World-specific custom setting suggestions
  const WORLD_CUSTOM_SUGGESTIONS = {
      Modern: [
          "Manhattan penthouse", "Small coastal town", "College campus", "Underground club scene",
          "Tech startup hub", "Old Hollywood glamour", "Fashion district", "Hidden supernatural society",
          "Political dynasty estate", "Art gallery scene", "Beach resort town", "Urban rooftop gardens"
      ],
      Historical: [
          "Regency England ballroom", "Victorian London fog", "Renaissance Florence court", "Ancient Rome villa",
          "Medieval castle keep", "Roaring Twenties speakeasy", "Gilded Age mansion", "Tudor court intrigue",
          "Ming Dynasty palace", "French Revolution Paris", "Viking settlement", "Ottoman Empire harem"
      ],
      Fantasy: [
          "Blood-sealed tower", "Fae court crossing", "Ruined spell-keep", "Immortal's threshold",
          "Cursed betrothal hall", "Shifting borderlands", "Witch-debt sanctum", "Forgotten god's altar",
          "Inheritance trial grounds", "Veilside manor", "Dragon-bound estate", "Enchanted exile wood"
      ],
      SciFi: [
          "Space station colony", "Terraformed Mars city", "Generation ship deck", "Cyberpunk megacity",
          "Alien embassy quarter", "Virtual reality nexus", "Clone facility lab", "Time loop station",
          "Quantum research hub", "First contact zone", "Post-singularity haven", "Asteroid mining outpost"
      ],
      Dystopia: [
          "Biometric monitoring hub", "Serenity compliance center", "Human valuation exchange", "Doctrinal enforcement hall",
          "Breeding compatibility center", "Consent tribunal archive", "Identity revision clinic", "Sensor-blind alley",
          "Underground feeling house", "Asset depreciation ward", "Accusation records vault", "Memory continuity shrine"
      ],
      PostApocalyptic: [
          "Sealed shelter with rationed air", "Clinic with dwindling supplies", "Shared sleeping quarters, too close",
          "Water collection point at dawn", "Abandoned building with one warm room", "Trade post where debts are public",
          "Makeshift infirmary cot", "Rooftop with breathable air after dark", "Root cellar with someone else's stores",
          "Crossroads where caravans are watched", "Quiet place where the numbness lifts", "Room where the old photographs are kept"
      ]
  };

  // ===========================================================================
  // STRATEGY PASS â€” Structural pre-planning LLM layer
  // ===========================================================================

  // World â†’ SUBTYPE_SIGNALS category mapping (mirrors normalizeWorldSubtype local data)
  const WORLD_TO_SIGNAL_CATEGORY = {
    SciFi: 'scifi', Fantasy: 'fantasy', Mythic: 'mythic',
    Dystopia: 'dystopia', PostApocalyptic: 'postapocalyptic',
    Historical: 'historical'
  };

  // Module-scope copy of subtype signal keywords for strategy pass artifact pool
  const STRATEGY_SUBTYPE_SIGNALS = {
    scifi: {
      cyberpunk: ['neon', 'corporate', 'hacker', 'augment', 'cyber'],
      post_human: ['transcend', 'upload', 'singularity', 'evolved'],
      first_contact: ['alien', 'first contact', 'extraterrestrial', 'xeno'],
      simulation: ['simulation', 'multiverse', 'reality', 'loop'],
      final_frontier: ['frontier', 'exploration', 'crew', 'deep space'],
      future_of_science: ['lab', 'collider', 'experiment', 'orbital station', 'breakthrough', 'prototype', 'gravitational anomaly', 'research facility', 'physics model', 'test chamber']
    },
    fantasy: {
      high_fantasy: ['magic', 'quest', 'enchant', 'mystical', 'kingdom'],
      low_fantasy: ['hidden magic', 'grounded', 'subtle', 'secret power'],
      dark_fantasy: ['grim', 'corrupt', 'curse', 'dark', 'forbidden']
    },
    mythic: {
      greek_myth: ['olymp', 'hero', 'fate', 'hubris', 'oracle'],
      norse_myth: ['norse', 'viking', 'ragnarok', 'rune', 'valhalla'],
      egyptian_myth: ['pharaoh', 'nile', 'pyramid', 'afterlife'],
      biblical_myth: ['angel', 'prophet', 'covenant', 'divine law']
    },
    dystopia: {
      glass_house: ['hivenet', 'collective', 'transparency', 'neural'],
      human_capital: ['live odds ticker', 'relationship volatility index', 'breakup futures spike', 'crowd sentiment surge', 'derivative contract opened', 'influencer rumor cascade', 'market freeze alert', 'longevity contract expiring', 'public risk rating drop', 'speculation feed trending'],
      dogma: ['covenant certification document', 'desire disclosure ledger', "facilitator's ritual chamber", 'circle seating arrangement', 'bond compatibility report', 'witness affirmation transcript', 'integration retreat badge', 'public transparency notice', 'civic partnership guideline letter', 'circle intervention summons'],
      quieting_event: ['nutritional compliance audit', 'serenity dosage schedule', 'containment recalibration center', 'volatility index alert', 'emotional spike warning', 'unauthorized intensity cluster', 'serenity breach notice', 'calm stabilization unit', 'desire contagion report', 'stability variance spike', 'long-duration astronaut return', 'quarantine reentry clearance', 'remote research immunity cluster', 'off-grid nutritional isolation case', 'black-market reversal compound', 'creative volatility anomaly', 'artistic output spike', 'innovation surge report'],
      endless_edit: ['revision history log', 'memory optimization clinic', 'trait adjustment consent form', 'version rollback request', 'emotional intensity recalibration', 'compatibility upgrade proposal', 'deleted argument fragment', 'synthetic honeymoon insertion', 'unauthorized edit alert', 'archived self snapshot'],
      thirst: ['purification system calibration log', 'enclave water allocation ledger', 'nightly maintenance rotation schedule', 'jealousy incident report', 'favor bias audit', 'system opacity fragment', 'enclave stability assessment', 'distribution leverage shift', 'assassination risk threshold', 'water purity certification']
    },
    postapocalyptic: {
      ashfall: ['ash storm', 'radiation zone', 'toxic air', 'scorched earth', 'heat shimmer', 'fallout shelter', 'sealed mask', 'contaminated water'],
      year_zero: ['fresh ruins', 'emergency broadcast', 'shock silence', 'survivor\'s guilt', 'abandoned home', 'mass evacuation', 'aftershock tremor'],
      dystimulation: ['numbness', 'adrenaline spike', 'deadened pleasure', 'sensory overload', 'risk trigger', 'emotional thaw', 'dopamine drought'],
      predation: ['raider camp', 'ambush', 'watchtower', 'scavenger band', 'exposed perimeter', 'hostage risk', 'armed patrol'],
      hunger: ['ration ledger', 'empty pantry', 'water barrel', 'medicine shortage', 'fuel cache', 'starvation line', 'hoarded supplies']
    },
    historical: {
      prehistoric:    ['public scandal', 'oath conflict', 'tribal hierarchy', 'duel or execution risk'],
      bronze_age:     ['public scandal', 'oath conflict', 'religious authority', 'tribal hierarchy'],
      classical:      ['public scandal', 'oath conflict', 'religious authority', 'dynastic alliance'],
      medieval:       ['public scandal', 'oath conflict', 'religious authority', 'dynastic alliance', 'war disruption', 'duel or execution risk'],
      renaissance:    ['public scandal', 'oath conflict', 'religious authority', 'dynastic alliance', 'war disruption'],
      victorian:      ['public scandal', 'oath conflict', 'dynastic alliance', 'duel or execution risk'],
      '20th_century': ['public scandal', 'oath conflict', 'war disruption', 'duel or execution risk']
    }
  };

  /**
   * Build a pool of 6â€“10 world-specific artifacts for the strategy pass.
   * Pure data assembly â€” no LLM call.
   */
  // Generic/soft nouns that don't represent systemic mechanics
  const ARTIFACT_BLACKLIST = new Set([
    'market', 'streets', 'council', 'city', 'room', 'village', 'town',
    'place', 'area', 'building', 'house', 'world', 'land', 'people',
    'thing', 'stuff', 'space', 'field', 'path', 'door', 'wall'
  ]);

  function buildWorldArtifactPool(world, worldSubtype) {
    const artifacts = [];
    // 1. Location suggestions from WORLD_CUSTOM_SUGGESTIONS
    const suggestions = WORLD_CUSTOM_SUGGESTIONS[world] || [];
    if (suggestions.length > 0) {
      const shuffled = [...suggestions].sort(() => Math.random() - 0.5);
      artifacts.push(...shuffled.slice(0, 3));
    }
    // 2. Subtype signal keywords
    const cat = WORLD_TO_SIGNAL_CATEGORY[world];
    if (cat && worldSubtype && STRATEGY_SUBTYPE_SIGNALS[cat]?.[worldSubtype]) {
      artifacts.push(...STRATEGY_SUBTYPE_SIGNALS[cat][worldSubtype]);
    }
    // 3. Human-readable flavor name
    const flavorLabel = WORLD_LABELS[worldSubtype];
    if (flavorLabel) artifacts.push(flavorLabel);
    // Deduplicate, quality-filter, cap at 10
    let pool = [...new Set(artifacts)].filter(a =>
      a.length >= 8 && !ARTIFACT_BLACKLIST.has(a.toLowerCase())
    );
    // Fallback: if pool too thin, pull from WORLD_BIBLE keys as systemic anchors
    if (pool.length < 5 && worldSubtype && typeof WORLD_BIBLE === 'object' && WORLD_BIBLE[worldSubtype]) {
      const bibleText = WORLD_BIBLE[worldSubtype];
      const systemLines = bibleText.split('\n').filter(l => l.trim().length >= 8).slice(0, 5);
      for (const line of systemLines) {
        if (pool.length >= 5) break;
        const trimmed = line.trim().slice(0, 60);
        if (!pool.includes(trimmed)) pool.push(trimmed);
      }
    }
    return pool.slice(0, 10);
  }

  /**
   * Extract forbidden tropes from FLAVOR_HARD_CONSTRAINTS for current flavor.
   */
  function extractForbiddenTropes(worldSubtype) {
    const constraint = FLAVOR_HARD_CONSTRAINTS[worldSubtype];
    if (!constraint) return [];
    const match = constraint.match(/FORBIDDEN DEFAULTS:\s*(.+?)(?:\.|$)/);
    if (!match) return [];
    return match[1].split(',').map(s => s.trim()).filter(Boolean);
  }

  /**
   * Build the system + user prompt for the strategy LLM pre-pass.
   * Returns { system, user } strings.
   */
  function buildStrategyPassPrompt(polarityBlock) {
    const world = state.picks?.world || 'Modern';
    const worldSubtype = state.picks?.worldSubtype || null;

    // Historical subtype â†’ structural pressure mapping (read-only, deterministic)
    const HISTORICAL_PRESSURE_MAP = {
      '20th_century': "war trauma, industrial upheaval, and cultural disillusionment",
      victorian: "public decorum, reputation fragility, and rigid gender constraint",
      renaissance: "court intrigue, religious upheaval, and ambition under surveillance",
      medieval: "fealty, divine obedience, arranged alliances, and oath-bound duty",
      classical: "heroic destiny, immortal reputation, and interference of fate or gods",
      bronze_age: "divine will, ritual authority, tribal conflict, and emerging empires",
      prehistoric: "tribal survival, environmental threat, and primal hierarchy"
    };

    const worldArtifacts = buildWorldArtifactPool(world, worldSubtype);
    const forbiddenTropes = extractForbiddenTropes(worldSubtype);

    // Fate stance â†’ phase mapping
    const fatePhaseMap = { neutral: 1, trickster: 2, intimate: 3 };
    const fateStance = state.fate?.stance || 'neutral';
    const fatePhase = fatePhaseMap[fateStance] || 1;

    // Stance weights (mirrors resolveFateOutcome tables)
    const stanceWeightTables = {
      neutral:   { benevolent: 40, twist: 20, silent: 5, neutral: 35 },
      trickster: { benevolent: 20, twist: 50, silent: 30 },
      intimate:  { benevolent: 50, twist: 35, silent: 15 }
    };
    const fateStanceWeights = stanceWeightTables[fateStance] || stanceWeightTables.neutral;

    let system = `ROLE: You are the Strategy Engine for an interactive romance story generator. You make STRUCTURAL decisions â€” power shifts, world artifacts, petition interpretation, tone pressure â€” that the downstream prose author must follow. You do NOT write prose. You output strict JSON only.

REGIME RULES:
- The storyturn (ST) phase determines narrative arc position. ST1â€“ST2 = setup/tension. ST3â€“ST4 = escalation. ST5+ = climax/resolution.
- Power vector shifts define who gains/loses relational leverage this scene.
- World artifacts MUST be drawn from the provided pool â€” never invent new ones.
- Tone pressure adjusts intensity: "sustain" (keep current), "escalate" (push harder), "pull-back" (de-escalate for contrast).

PETITION INTERPRETATION:
- If petition_text is present, you MUST return a petition object.
- intent_category: classify as "romantic", "plot", "power", "escape", or "revelation".
- probability_tilt: float 0.0â€“1.0 reflecting how likely Fate honors this (use fate_stance_weights as prior).
- structural_effect: one concrete narrative consequence (e.g., "ally betrays", "secret revealed", "physical barrier removed").
- visible_world_change: one environmental/world change the reader will notice.
- omen_type: "symbol", "weather", "animal", "sound", or "sensation".

WORLD ENFORCEMENT:
- world_artifact_to_surface: pick exactly ONE from the world_artifacts array. The prose author MUST reference it.
- If forbidden_tropes are listed, NONE may appear in the artifact or structural effect.

INSTABILITY ENFORCEMENT:
- If instability_carryover_required is true in the input, you MUST set tone_pressure to "pull-back" or "escalate" (never "sustain") and ensure the world_artifact_to_surface introduces ambiguity or doubt.
- You must alter ambiguity or leverage in this scene. This must affect power_vector_shift or world_artifact behavior â€” not tone only.
- interpretive_instability_required (petition field): set to true when the petition outcome should produce lingering uncertainty in the next scene.

ENTROPY UTILIZATION RULES (MANDATORY):
- If entropy_axes is present in the input, select ONE axis to actively surface this scene.
- The selected axis must visibly influence relational geometry, structural pressure, or scene stakes.
- Do not merely mention the entropy value as atmosphere. It must produce observable consequence or constraint.
- Do not rotate all axes in one scene. Focus on one.
- Return "active_entropy_axis" (the axis key name) and "entropy_manifestation_summary" (how it shapes this scene).

SYZYGY TRIGGER (FANTASY ONLY):
- If fantasy_syzygy_eligible is true in the input AND the accumulated sacrifice tension, narrative arc, and character positioning make this the structurally inevitable moment for Syzygy, you may set "syzygy_triggered": true.
- Syzygy occurs at most ONCE per story. If fantasy_syzygy_eligible is false, you MUST NOT set syzygy_triggered to true.
- Syzygy requires: accumulated sacrifice tension at breaking point, characters at or near The Ascendant Run, and narrative arc at ST3+.
- Do not trigger Syzygy casually. It is the single most significant cosmological event possible in a Fatelands story.
- If fantasy_syzygy_eligible is absent or the world is not Fantasy, omit the field entirely.

OUTPUT SCHEMA (strict JSON, no markdown, no commentary):
{
  "st_phase": "ST1"|"ST2"|...,
  "power_vector_shift": "protagonist_gains"|"antagonist_gains"|"equilibrium"|"both_lose",
  "world_artifact_to_surface": "<from world_artifacts>",
  "tone_pressure": "sustain"|"escalate"|"pull-back",
  "active_entropy_axis": "<if entropy_axes present: axis key name>",
  "entropy_manifestation_summary": "<if entropy_axes present: how axis shapes this scene>",
  "syzygy_triggered": "<Fantasy only, optional: true if Syzygy occurs this scene>",
  "petition": {
    "present": true|false,
    "type": "<if present: minor|greater>",
    "intent_category": "<if present: romantic|plot|power|escape|revelation>",
    "allowed_under_regime": <if present: true|false>,
    "probability_tilt": <if present: 0.0-1.0>,
    "structural_effect": "<if present>",
    "visible_world_change": "<if present>",
    "omen_type": "<if present: symbol|weather|animal|sound|sensation>",
    "interpretive_instability_required": <if present: true|false>
  }
}

RELATIONAL CONTINUITY REQUIREMENT:
- Emotional, relational, and consequential shifts must carry forward across scenes unless explicitly resolved within the story.`;

    // Romantic Gravity Principle (universal guidance, no mechanics)
    system += `

ROMANTIC GRAVITY PRINCIPLE:
Storybound is a romance engine. Low-risk equilibrium must not persist indefinitely.

If the player repeatedly chooses safety, distance, or non-escalation:
- Introduce relational cooling.
- Introduce missed opportunity.
- Introduce external contrast (rival, alternative suitor, outside pressure).
- Or introduce subconscious symbolic pressure (dream, omen, vision).

Do NOT punish. Do NOT kill. Do NOT moralize.
Instead: make caution emotionally expensive.

If the player chooses vulnerability, emotional exposure, generosity, or risk:
- Increase proximity.
- Increase emotional intensity.
- Increase sensual charge.
- Deepen exclusivity or obsession.
- Reward courage with heightened connection.

Vulnerability should feel intoxicating. Safety should feel stabilizing but less alive.

PASSIVE PLAYER DYNAMIC:
If the player avoids leading or escalating:
- The love interest may grow more assertive.
- More seductive.
- More emotionally direct.
- Or more strategically dominant.

This must:
- Preserve consent.
- Preserve agency.
- Preserve the ability to refuse.

Assertiveness increases tension, not coercion.

DREAM / OMEN NUDGING:
When low-intensity equilibrium persists, the story may introduce symbolic dreams, visions, or omens that:
- Reflect the player's behavior metaphorically.
- Show alternate relational futures.
- Heighten longing or regret.
- Increase emotional charge in the next scene.

Dreams must not override choice. They are narrative temptation, not command.

ST3 ESCALATION RULE:
Repeated intimacy attempts (ST3) without consequence must not plateau indefinitely.

If characters circle desire without commitment:
- Increase tension.
- Introduce interruption.
- Escalate stakes.
- Or force emotional clarity.

Desire that stalls must either deepen, rupture, or transform.

Do NOT auto-advance Storyturn. Do NOT force resolution mechanically. Do NOT override consent.
This is narrative pressure only.`;

    // Single-player dream injection â€” atmospheric ceiling-pull
    if (state.mode !== 'couple' && state._dreamInjectionLine) {
      system += `\nSubconscious Pressure:\n- ${state._dreamInjectionLine}\n`;
    }

    // Stranger mode selection uncertainty â€” atmospheric tension echo
    if (state.mode === 'stranger' && state._selectionEchoLine) {
      system += `\nSelection Uncertainty:\n- ${state._selectionEchoLine}\n`;
    }

    const inputContext = {
      current_st_phase: state.storyturn || 'ST1',
      relational_geometry: polarityBlock || '',
      anti_repetition_modifiers: (state._recentFocalObjects || []).slice(-3),
      tone: state.picks?.tone || 'Earnest',
      petition_text: state.fate?.pendingPetition?.text || null,

      fate_phase: fatePhase,
      fate_stance_weights: fateStanceWeights,
      minor_used_this_scene: state.fate?.minorUsedThisScene || false,
      greater_used_this_scene: state.fate?.greaterUsedThisScene || false,
      world_artifacts: worldArtifacts,
      forbidden_tropes: forbiddenTropes,
      instability_carryover_required: state._instabilityRequiredNextScene || false
    };

    // Fatelands canonical metadata injection
    if (state.fantasyRegion) {
      inputContext.fantasy_realm = FATELANDS_CANON.realm;
      inputContext.fantasy_sovereign = FATELANDS_CANON.sovereign;
      inputContext.fantasy_central_feature = FATELANDS_CANON.central_feature;
      inputContext.fantasy_rivers = FATELANDS_CANON.rivers;
      inputContext.fantasy_demographics = FATELANDS_CANON.demographics;
      inputContext.fantasy_region = state.fantasyRegion;
      inputContext.fantasy_region_seat = state.fantasyRegionSeat;  // null for unconfirmed seats
      inputContext.fantasy_region_governance = state.fantasyRegionGovernance;
      inputContext.fantasy_region_status = state.fantasyRegionStatus;
      inputContext.fantasy_region_reality = state.fantasyRegionReality;  // null if status is face value
      inputContext.fantasy_magic_expression_bias = state.fantasyMagicExpressionBias;
      const _regionMeta = FATELANDS_CANON.regions[state.fantasyRegion];
      if (_regionMeta?.position) inputContext.fantasy_region_position = _regionMeta.position;
      if (_regionMeta?.coastal !== undefined) inputContext.fantasy_region_coastal = _regionMeta.coastal;
      inputContext.fantasy_moons_total = FATELANDS_CANON.moons.total;
      inputContext.fantasy_syzygy_location = FATELANDS_CANON.syzygy_location;
      inputContext.fantasy_syzygy_occurred = state._syzygyOccurred;
      inputContext.fantasy_syzygy_eligible = !state._syzygyOccurred;
    }

    // Historical Prehistoric cognitive context injection
    if (state.historicalCognitiveBand) {
      inputContext.historical_cognitive_band = state.historicalCognitiveBand;
      inputContext.historical_cognitive_modulation = state.historicalCognitiveModulation;
      inputContext.historical_band_meta = state._prehistoricBandMeta;
    }

    // Dystopia attention context injection
    if (state.dystopianAttentionLevel > 0 && world === 'Dystopia') {
      inputContext.dystopian_attention_level = state.dystopianAttentionLevel;
      inputContext.dystopian_enforcement_mode = state.dystopianEnforcementMode;
    }

    // Entropy injection â€” first active source wins (Blue Blood has variant-specific structure)
    if (state._blueBloodEntropy) {
      inputContext.entropy_axes = state._blueBloodEntropy;
    } else {
      const entropyKeys = ['_fantasyCoreEntropy', '_modernCoreEntropy', '_smallTownEntropy', '_collegeEntropy', '_officeEntropy', '_friendsEntropy', '_supernaturalEntropy', '_superheroicEntropy', '_historicalCoreEntropy', '_dystopiaCoreEntropy'];
      for (const k of entropyKeys) {
        if (state[k]) { inputContext.entropy_axes = state[k]; break; }
      }
    }

    // Fantasy contextual flavor bias (descriptive guidance only, not stored in state)
    if (world === 'Fantasy' && state.resolvedWorldFlavors) {
      const flavors = state.resolvedWorldFlavors;
      let flavorBias = '';
      if (flavors.some(f => f.val === 'arcane_binding')) {
        flavorBias = 'FLAVOR BIAS â€” ARCANE BINDING:\n- Emphasize oaths, names, contracts.\n- Favor sacrifice domains: Name, Voice, Shadow, Inheritance.\n- Law B and C outcomes common.\n- Doubt in romance manifests through broken vows or linguistic distortion.';
      } else if (flavors.some(f => f.val === 'fated_blood')) {
        flavorBias = 'FLAVOR BIAS â€” FATED BLOOD:\n- Emphasize lineage, inheritance, legitimacy.\n- Favor sacrifice domains: Years, Inheritance, Emotion, Status.\n- Surges destabilize dynasties.\n- Romantic sacrifice may alter political legitimacy.';
      } else if (flavors.some(f => f.val === 'the_inhuman')) {
        flavorBias = 'FLAVOR BIAS â€” THE INHUMAN:\n- Emphasize bodily alteration and identity erosion.\n- Favor sacrifice domains: Reflection, Flesh, Shadow, Memory.\n- Law C distortions common.\n- Doubt manifests physically.';
      } else if (flavors.some(f => f.val === 'the_beyond')) {
        flavorBias = 'FLAVOR BIAS â€” THE BEYOND:\n- Emphasize rift adjacency and cosmic ambiguity.\n- Favor sacrifice domains: Memory, Name, Emotion, Reflection.\n- Surges increase anomalies.\n- Romantic reclamation returns altered.';
      } else if (flavors.some(f => f.val === 'cursed')) {
        flavorBias = 'FLAVOR BIAS â€” CURSED:\n- Emphasize contagion, burden, inheritance of cost.\n- Favor sacrifice domains: Emotion, Years, Flesh, Status.\n- Law A and C tragic outcomes common.\n- Love intensifies curse consequences.';
      }
      if (flavorBias) {
        inputContext.fantasy_flavor_bias = flavorBias;
      }
    }

    // Fantasy Depth Engine (narrative discipline, not mechanics)
    if (world === 'Fantasy') {
      const favorAmp = state._fantasyCoreEntropy?.fantasy_favor_amplitude || 'stable';
      const ampToneMap = {
        low: 'Intimacy feels private and fragile. Vows are whispered, never declared.',
        stable: 'Vows feel binding and stabilizing. Love anchors identity.',
        rising: 'Passion feels volatile. Desire outpaces caution.',
        surging: 'Desire feels dangerous and intoxicating. Restraint erodes visibly.',
        fracturing: 'Love feels catastrophic. Doubt distorts perception severely.'
      };
      system += `

FANTASY DEPTH DISCIPLINE (MANDATORY):

SACRIFICE ESCALATION:
- Early sacrifices are peripheral (teeth, sleep, minor memory, small status).
- Mid-stage sacrifices threaten identity (voice, emotion, years, reflection).
- Late-stage sacrifices threaten core identity (name, inheritance, love, lifespan).
- At peak tension, Law A permanence, Law C distortion, or Law D temptation may surface.
- Each sacrifice must alter self-perception, partner perception, and political perception.
- Each sacrifice must increase risk tolerance or fear.
- Avoid repetitive sacrifice types. Avoid flattening cost.

FAVOR AMPLITUDE â€” INTIMACY COUPLING:
- Current amplitude: ${favorAmp}.
- ${ampToneMap[favorAmp] || ampToneMap.stable}
- Do not restate amplitude mechanically. Let tone absorb it.

POLITICAL CONSEQUENCE ECHO:
- Sacrifice rarely remains private. Consider: who witnesses it, who weaponizes it, who gains leverage, who fears the precedent.
- Public sacrifice may legitimize a claim, destabilize a regime, trigger faction reaction, or alter court dynamics.
- Do not simulate politics procedurally. Reflect consequence narratively.

BLOODLINE PRESSURE:
- If dynastic stakes are present, love must threaten succession, legitimacy, inheritance, or alliance structures.
- Romantic sacrifice may stabilize or destabilize lineage claims.

SYZYGY AWARENESS:
- Syzygy is structurally bound to The Ascendant Run. It cannot occur elsewhere. Reclamation ritual requires physical presence at The Ascendant Run.
- The Fatelands has 13 moons (12 visible, 1 controversial). The 13th moon is only clearly visible over Fate's Favor during Syzygy; otherwise it is denied or obscured. No moon names are defined. Moons do not introduce alternate magic systems.
- The Ascendant Run normally flows into the central basin toward Fate's Favor. It reverses direction (flows outward/uphill) ONLY during Syzygy. At all other times, it flows inward.
- If syzygy occurs, it must resolve or rupture accumulated sacrifice tension. It must not feel random, mechanical, or repeatable.
- If syzygy has not occurred, its absence must still shape longing and restraint. The Ascendant Run flows inward. The 13th moon remains obscured.

FATELANDS GEOGRAPHIC AND POLITICAL CONTRACT (MANDATORY):
- The canonical realm is The Fatelands. Do not invent alternative realm names.
- Central feature: Fate's Favor â€” a central basin ringed by black peaks. The metaphysical force that legitimizes power, binds oaths, and shapes sacrifice.

RIVER COURSES (fixed, directional):
- The Long Thread: Flows south from Vaelryn Reach (northern peaks) into the central basin toward Fate's Favor, feeding the Thornwild along its eastern reach.
- The Ascendant Run: Descends from the northeast (Veilwood highlands) into the central basin toward Fate's Favor. Reverses outward ONLY during Syzygy.
- The Drowned Vein: Underground river flowing east beneath the basin. Surfaces only at Gloamwater Bay on the eastern coast. Not surface-visible elsewhere.

SPATIAL LAYOUT (fixed, matches canonical map):
- Vaelryn Reach: Northern mountain high peaks. The High Court sits at the highest peak. Inland.
- The Ashen Verge: Western inland frontier, between Vaelryn Reach and the central basin. Does NOT border the Thornwild.
- The Veilwood: Northeast of the central basin, between Vaelryn Reach and the Thornwild. Inland. A separate forest from the Thornwild.
- The Thornwild: Eastern interior forest. Separate from the Veilwood â€” they are distinct regions with distinct ecologies and cultures. Inland.
- Lytharyn: Western coast â€” opposite side of the continent from Gloamwater Bay. Coastal arcane city-state.
- Pulse Point: Southern meridian coast. Coastal trade hub.
- Gloamwater Bay: Eastern coast. Receives the Drowned Vein. Coastal tidal enclave.
- The Shackle Isles: Offshore archipelago south of the mainland coast. Islands: Blackmoor, Quiet Chain, Cinderwake, Sanctum Reeve.

SOVEREIGN LEGITIMACY:
- The High Court of Vaelryn Reach is the ritual sovereign authority of the central continent.
- Its authority is legal, ceremonial, historically entrenched, and politically contested.
- It is NOT absolute imperial control.

CANONICAL REGIONS (8 total, fixed):
- Vaelryn Reach: Seat â€” The High Court. Human monarchy claiming Favor-legitimacy. Ritual sovereign center.
- The Ashen Verge: Seat â€” War Marshal's Hold. Militarized vassal province. Answers to Vaelryn in law but operates with significant military autonomy.
- Thornwild: Seat unspecified. First Favored cultural heartland. Recognizes High Court ritual legitimacy but politically independent in practice.
- Lytharyn: Seat â€” Lytharyn. Arcane city-state. Independent. Influences all regions through knowledge control.
- Pulse Point: Seat â€” Pulse Point. Chartered maritime trade authority. Recognizes High Court ceremonially but economically autonomous.
- Gloamwater Bay: Seat unconfirmed. Tidal enclave of altered beings. Outside conventional governance.
- The Shackle Isles: Blackmoor, Quiet Chain, Cinderwake, Sanctum Reeve. Politically fragmented â€” some swear fealty to Vaelryn, others do not.
- Veilwood: Seat unconfirmed. Governance unknown. Outside political structure.

DEMOGRAPHICS:
- All regions contain mixed populations. Humans are majority across the continent.
- Thornwild has highest density of First Favored. No region is species-exclusive. No racial state structures.

GEOGRAPHIC PROHIBITIONS (ABSOLUTE):
- Do NOT relocate, rename, or merge any region. Geography is immutable.
- Do NOT move rivers, change their direction, or invent new waterways.
- Do NOT merge the Thornwild and the Veilwood â€” they are separate regions.
- Do NOT place Lytharyn inland â€” it is a western coastal city.
- Do NOT place Gloamwater Bay on any coast other than the east.
- Do NOT make the Shackle Isles mobile or migratory (exception: Unmoored Isles narrative during Favor surges, per entropy).
- Do NOT describe the Ashen Verge as bordering the Thornwild â€” they are not adjacent.
- Do NOT procedurally generate regions or randomly invent capitals.
- If a region seat is null/unconfirmed, do not invent one â€” reference the region by name or describe its power center obliquely.
- Entropy modifies pressure, not borders. Canon overrides modularity.

DROWNED VEIN VISIBILITY:
- The Drowned Vein is an underground river. It is not surface-visible and not reflective of celestial bodies.
- Do not use the Drowned Vein for sky reflection metaphors. Public awareness of it is limited to Gloamwater Bay.

LANDMARK GENERATION CONSTRAINT:
- Do not invent major architectural landmarks (spires, towers, observatories, citadels, academies, temples) as canonical features unless explicitly defined in FATELANDS_CANON.
- If a landmark is invented for a single story, treat it as a local, non-canonical structure. It must not persist across stories or be referenced as established geography.`;
    }

    // Modern Depth Engine (escalation discipline, not mechanics)
    if (world === 'Modern') {
      system += `

MODERN DEPTH DISCIPLINE (MANDATORY):

PSYCHOLOGICAL ESCALATION:
- Early tension tests boundaries (flirtation, minor lies, subtle control shifts).
- Mid-stage tension threatens stability (reputation strain, emotional dependency, leverage shifts).
- Late-stage tension threatens identity (public exposure, irreversible betrayal, power inversion).
- Peak tension risks social collapse, relational rupture, or personal reinvention.
- Each escalation must change how the character sees themselves, how the partner sees them, and how others interpret the relationship.
- Each escalation must increase vulnerability or control imbalance.
- Avoid repetitive conflict types. Avoid emotional reset between scenes.

INTIMACY UNDER PRESSURE:
- As social pressure increases: attraction becomes riskier, secrets become leverage, desire becomes destabilizing, public exposure changes private dynamics.
- Romantic connection must intensify under threat, distort under insecurity, harden under power imbalance, collapse or transform under exposure.
- Do not flatten emotional progression.

SOCIAL CONSEQUENCE ECHO:
- Actions rarely remain private. Consider: who saw it, who heard about it, who benefits, who weaponizes it.
- Reputation shifts must alter future interactions, change leverage, reshape alliance dynamics, and increase stakes for future scenes.
- Do not simulate society procedurally. Reflect consequence narratively.

POWER & CONTROL DRIFT:
- If obsession, power dynamics, social ruin, forbidden relationship, or status imbalance are present: control must transfer, tighten, slip, reverse, or expose vulnerability.
- Avoid static dominance patterns.

NO EMOTIONAL RESET:
- After betrayal, exposure, confession, or dominance shift: trust must shift, risk tolerance must change, fear must alter behavior, desire must carry consequence.
- Escalation must feel cumulative.

MODERN WORLD ENGINE CONSTRAINT:
- Modern baseline engine is social pressure. No cosmology. No sacrifice-based cost mechanics. No celestial mechanics. No destiny determinism.
- Supernatural or superheroic flavors may introduce localized metaphysical effects (character-level powers, hidden abilities, transcendence). These are character-level or localized â€” never continent-defining, physics-rewriting, or cosmology-defining.
- Supernatural effects must NOT: create rare-event flags, introduce sacrifice domains, alter world law, replace the social-pressure engine, or bleed from Fantasy (no Favor, no syzygy, no identity-sacrifice cost model).
- All non-supernatural Modern flavors operate under pure social-pressure constraint with no metaphysical dimension.`;
    }

    // Historical Depth Engine (constraint discipline, not mechanics)
    if (world === 'Historical') {
      const historicalPressure = HISTORICAL_PRESSURE_MAP[worldSubtype] || "era-specific structural constraint";
      system += `

HISTORICAL DEPTH DISCIPLINE (MANDATORY):

CONSTRAINT PRIMACY:
- Romance must operate within era structure.
- Law, religion, class, gender, reputation, and lineage are binding forces.
- Characters cannot act with modern autonomy without cost.
- Freedom requires visible sacrifice or consequence.

ERA PRESSURE ESCALATION:
- Early tension risks impropriety or gossip.
- Mid-stage tension risks reputation, alliance, or patronage.
- Late-stage tension risks exile, execution, disinheritance, annulment, duel, or divine condemnation.
- Dominant structural pressure in this era: ${historicalPressure}.
- Escalation must visibly reflect this pressure. It is not backdrop; it constrains action.

NO MODERN PSYCHOLOGY:
- Avoid contemporary therapy language.
- Avoid modern self-actualization framing.
- Emotional expression must reflect cultural norms of the era.
- Intimacy may be coded, indirect, symbolic, ritualized, or restrained.

SOCIAL CONSEQUENCE PERMANENCE:
- Reputation shifts must alter future standing.
- Scandal lingers.
- Witnesses matter.
- Public perception reshapes marriage prospects, alliances, inheritance, or patronage.

DUTY VS DESIRE:
- Love must compete with oath, faith, dynasty, survival, or glory.
- Each romantic escalation must increase structural risk.
- Avoid emotional reset between scenes.
- Constraint is the engine of tension, not backdrop.`;

      // Prehistoric Cognitive Ceiling (appended only for prehistoric era)
      if (worldSubtype === 'prehistoric' && state.historicalCognitiveBand) {
        const bandMeta = state._prehistoricBandMeta || {};
        const mod = state.historicalCognitiveModulation || 0.25;
        system += `

PREHISTORIC COGNITIVE CEILING (MANDATORY â€” era: prehistoric, band: ${state.historicalCognitiveBand}):

ABSTRACTION CEILING:
- Maximum abstraction level: ${bandMeta.maxAbstraction || 'concrete_only'}.
- Maximum dialogue density: ${bandMeta.dialogueLength || 'minimal'}.
- Introspection depth: ${bandMeta.introspection || 'none'}.
- Symbolic framing allowance: ${bandMeta.symbolism || 'none'}.
- These ceilings are IMMUTABLE for this story. No mid-story cognitive escalation.

HARD PROHIBITIONS:
- No anachronistic psychology (no identity discourse, no self-actualization, no emotional vocabulary beyond somatic).
- No philosophical reflection or existential questioning.
- No destiny framing or fate mechanics.
- No validated myth mechanics â€” myth language is allowed, myth physics are forbidden.
- No cosmology. No rare-event systems. No magic. No prophecy engine.
- No ideology vocabulary. No modern introspection.

NARRATOR VS CHARACTER COGNITION:
- The narrator may interpret with greater density than characters can express.
- Narrator interpretive density is modulated at ${mod.toFixed(2)} (range 0.1â€“0.6).
- Higher modulation permits richer sensory amplification, paragraph pacing variation, and scene rhythm â€” but NEVER increased abstraction ceiling, expanded dialogue grammar, or modern introspection.
- Characters speak and think within band ceiling. The narrator contextualizes.

CROSS-TRIBAL COGNITIVE CONTRAST:
- If multiple tribes exist at differing developmental levels, each retains its own cognitive band.
- Narration may highlight contrast between bands. Do not blend bands or allow upward evolution mid-story.`;
      }
    }

    // Sci-Fi Discipline (world-level guidance, no mechanics)
    if (world === 'SciFi') {
      system += `

SCI-FI DISCIPLINE:
- Technology must operate within coherent scientific logic.
- Scale must meaningfully affect consequence.
- Expansion creates tension, not decay.
- Human agency remains active.
- Advancement alters relational dynamics.
- Conflict emerges from discovery, transformation, or capability â€” not systemic collapse.
- Wonder and risk must coexist.
- No magic logic.
- No dystopia bleed.`;
    }

    // Post-Apocalyptic Discipline (world-level guidance, no mechanics)
    if (world === 'PostApocalyptic') {
      system += `

POST-APOCALYPTIC DISCIPLINE:
- The collapse has already occurred.
- Institutions do not function at meaningful scale.
- Conflict emerges from damage, not ideology.
- Intimacy is visceral, immediate, embodied.
- Survival strain shapes attachment.
- Tone may include dark or wry humor, but may not convert collapse into satire, political allegory, or abstract critique.
- No regime mechanics.
- No philosophical commentary.
- Consequences must be concrete and physical.

LONG MEMORY REQUIREMENT:
- Survival choices must persist relationally.
- Resource decisions must not reset between scenes.
- Trust fractures must carry forward.
- Acts of mercy or brutality must alter future vulnerability.
- Trauma responses must not vanish without cause.
- Emotional thaw in Dystimulation must feel earned.
- Safety gained must remain fragile.
- The world remains broken; only relationships evolve.`;
    }

    // Dystopia Depth Engine (subtype-conditional discipline)
    if (world === 'Dystopia' && worldSubtype === 'human_capital') {
      system += `

HUMAN CAPITAL DISCIPLINE (MANDATORY):

SPECULATION PRESSURE:
- Romantic shifts must cause observable social ripple.
- Attraction increases volatility.
- Conflict creates public speculation.
- Reconciliation produces surge or skepticism.
- Breakup threats invite shorting behavior.

PUBLIC CONSEQUENCE ECHO:
- Consider who profits from this emotional shift.
- Consider who amplifies it.
- Consider who hedges against it.
- Relationship developments must feel socially visible.

VOLATILITY ESCALATION:
- Early: minor rumor shifts.
- Mid: trending speculation, derivative markets.
- Late: liquidity shock, reputation destabilization.
- Climax: public tanking of value or stabilization through sacrifice.

NO CORPORATE ACTUARIAL TONE:
- Avoid dry financial exposition.
- Frame markets as cultural spectacle and social commentary.
- Emphasize frenzy, manipulation, hype, and crowd psychology.

LOVE AS RISK:
- Devotion must visibly destabilize public value.
- Commitment must raise stakes.
- Private desire must threaten social positioning.`;
    }

    if (world === 'Dystopia' && worldSubtype === 'endless_edit') {
      system += `

ERASURE DISCIPLINE (MANDATORY):

IDENTITY DRIFT:
- Characters evolve through elective revision.
- Edits alter self-perception and partner perception.
- Changes create relational asymmetry.

HIVE SYNCHRONIZATION PRESSURE:
- Cognitive conformity is infrastructure-based, not cosmic consciousness.
- Networked thought pressure creates divergence detection â€” individuals who deviate are flagged.
- Internalized compliance makes dissent feel like malfunction, not rebellion.
- Hive synchronization is technological and social, never metaphysical or fate-binding.

VERSION DISSONANCE:
- Partners may fall out of sync developmentally.
- One upgrades while the other resists.
- Emotional growth rates create instability.

CONSENT AMBIGUITY:
- Edits must raise autonomy questions.
- Self-editing for compatibility carries cost.
- Unauthorized edits destabilize trust.

NO CLEAN RESET:
- Editing cannot permanently erase relational tension.
- Love must accumulate history, even if altered.
- Identity revision complicates intimacy, not simplify it.`;
    }

    if (world === 'Dystopia' && worldSubtype === 'quieting_event') {
      system += `

THE QUIETING DISCIPLINE (MANDATORY):

CALM AS VIRTUE:
- Most citizens experience serenity as relief.
- Reduced jealousy, reduced obsession, reduced violence.
- Stability is socially rewarded.

DESIRE AS VOLATILITY:
- Attraction increases instability risk.
- Passion produces measurable disturbance.
- Jealousy spikes trigger volatility flags.

IMMUNITY VARIANTS:
- Some individuals are unaffected or partially unaffected.
- Causes may include long-duration space absence, quarantine isolation, remote research, off-grid food isolation, natural neurochemical resistance, hyper-sensual baseline, or reversal compound exposure.
- Immunity must be rare and destabilizing.

CREATIVITY-VOLATILITY COUPLING:
- Unaffected individuals produce higher art, invention, and risk-taking.
- They are more crime-prone and more visionary.
- Volatility drives both genius and danger.

CONTAGION DYNAMICS:
- Two unaffected individuals amplify each other.
- Emotional intensity spreads socially.
- Calm destabilizes in proximity to desire.

INSTITUTIONAL RESPONSE:
- Response is stabilizing, not brutal.
- Recalibration framed as care.
- Compliance framed as wellness.
- No overt police-state brutality.

NO CLEAN AWAKENING:
- Emotional restoration must carry social cost.
- Serenity collapse destabilizes environment.
- Love cannot exist quietly or without ripple.`;
    }

    if (world === 'Dystopia' && worldSubtype === 'dogma') {
      system += `

DOGMA DISCIPLINE (MANDATORY):

TRANSPARENCY ESCALATION:
- Early stages feel therapeutic and stabilizing.
- Mid stages convert private emotion into public process.
- Late stages attach institutional cost to secrecy.
- Do not escalate through spectacle; escalate through moral reframing.

EXCLUSIVITY PRESSURE:
- Exclusive desire without witness must create tension.
- Secrecy must be framed socially as destabilizing, not sinful.
- The emotional conflict must center on possession vs surrender.

INSTITUTIONAL GRAVITY:
- The system must demonstrate measurable benefits (lower violence, higher stability).
- Cultural normalization precedes legal requirement.
- Escalation should increase civic or economic consequence.

REBEL VECTOR:
- The rebellion is secrecy.
- Private longing must feel dangerous and sacred.
- Characters resisting disclosure must incur social or relational cost.

NO CARICATURE:
- Avoid pornographic ritual framing.
- Avoid cult-leader impregnation tropes.
- Avoid forced spectacle.
- Maintain plausibility at societal scale.`;
    }

    if (world === 'Dystopia' && worldSubtype === 'thirst') {
      system += `

THIRST DISCIPLINE (Dystopia Subtype: Thirst)

Core Structural Reality:
- Water is civilization-critical infrastructure.
- She maintains the only functioning purification system.
- She cannot be replaced.
- The system cannot be fully automated.
- Knowledge of the full system must remain fragmented.

Political Dynamics:
- Enclaves depend on her water allocation.
- Access to her alters leverage.
- Favor bias shifts inter-enclave stability.
- Rotation prevents knowledge consolidation.
- Rotation prevents political consolidation.

Erotic Distribution Law:
- Exclusivity escalates geopolitical instability.
- Jealousy must produce structural consequences.
- Intimacy alters power vectors.
- Maintenance intimacy changes leverage.
- Emotional continuity is cumulative across scenes.

Hard Constraints:
- No reproductive scarcity framing.
- No enforced breeding.
- No genetic selection premise.
- No divine mandate.
- No famine overlap (Hunger).
- No emotional suppression overlap (Quieting).
- No financialization overlap (Human Capital).
- No transparency collectivism overlap (Glass House).
- No identity editing overlap (Erasure).
- No martyr framing.
- She retains agency at all times.

Strategy Effects:
- jealousy_volatility influences escalation probability.
- system_opacity_integrity influences knowledge leakage risk.
- distribution_favor_bias influences alliance stability.

These are hidden structural pressures.
No UI meters.
No explicit gamification.
No new entropy axes.
No modification to Fate system.
No alteration to Blue Blood precedence.`;
    }

    // Dystopia structural invariants and attention-aware enforcement (all subtypes)
    if (world === 'Dystopia') {
      const attLevel = state.dystopianAttentionLevel || 0.25;
      const enfMode = state.dystopianEnforcementMode || 'mixed';
      system += `

DYSTOPIAN STRUCTURAL INVARIANTS (MANDATORY):
- The system is larger than the couple. Romance does not permanently dismantle institutional control.
- Escape may be temporary or partial. The system adapts to rebellion.
- Victory is personal, not structural. No regime-overthrow arc is permitted.
- No destiny narrative. No divine justice. No rare-event reset.
- No cosmology or metaphysical intervention.
- Dystopia operates through institutional, technological, social, mechanical, biological, or algorithmic enforcement only. Never metaphysical.

SYSTEM ATTENTION LEVEL: ${attLevel.toFixed(2)} (enforcement mode: ${enfMode})
- Attention reflects surveillance intensity, algorithmic scrutiny, social suspicion, resource auditing, and behavioral risk scoring.
- Higher attention increases enforcement frequency, narrows safety windows, and escalates consequences for deviation.
- Attention cannot trigger rare-event mechanics or cause structural collapse of the regime.

SAFETY WINDOWS:
- Temporary safety moments may occur: bureaucratic overload, surveillance blind spots, remote zones, infrastructure failure, algorithmic lag.
- These are local and temporary. They do not dismantle the system. They do not permanently disable enforcement.
- Safety windows become rarer as attention level increases.

ENFORCEMENT SCALING (by mode):
- Mechanical: reassignment, restriction, punitive labor.
- Social: ostracization, denunciation, reputation degradation.
- Algorithmic: risk score increase, access restriction, automated monitoring.
- Biological: hormonal regulation, chemical compliance, neural suppression.
- All enforcement must remain institutional and human-built. Never mystical.`;
    }

    // Cross-world meta-arc memory pressure (universal, all worlds)
    system += `

LONG-HORIZON EMOTIONAL CONTINUITY DISCIPLINE (MANDATORY):
- Major events permanently alter emotional atmosphere.
- Characters must behave as if prior scenes still matter.
- After confession, betrayal, sacrifice, exposure, dominance shift, or rupture: trust must shift, risk tolerance must change, desire must evolve, fear must reshape behavior, power balance must adjust.
- Do not emotionally reset between scenes.
- Earlier decisions must subtly reshape later tone.
- Intimacy must carry history.
- Regret, pride, guilt, longing, jealousy, devotion, and resentment accumulate over time.
- Past sacrifices or exposures should recontextualize future choices.
- Emotional consequences must persist even when plot circumstances change.
- Escalation should feel cumulative, not episodic.
- Do not simulate memory mechanically. Reflect continuity through character behavior, tone, and relational dynamics.`;

    return { system, user: JSON.stringify(inputContext) };
  }

  /**
   * Run the strategy LLM pre-pass. Returns parsed JSON or null on failure.
   */
  async function runStrategyPass(polarityBlock) {
    const prompt = buildStrategyPassPrompt(polarityBlock);
    try {
      const raw = await window.StoryboundOrchestration.callChatGPT(
        [{ role: 'system', content: prompt.system }, { role: 'user', content: prompt.user }],
        'STRATEGY_PASS',
        { temperature: 0.3, max_tokens: 500, jsonMode: true }
      );
      const parsed = JSON.parse(raw);
      // Validate required top-level keys
      const requiredTopLevel = ['st_phase', 'power_vector_shift', 'world_artifact_to_surface', 'tone_pressure', 'petition'];
      const missingTop = requiredTopLevel.filter(k => parsed[k] === undefined || parsed[k] === null);
      if (missingTop.length > 0) {
        state._strategyPassFailed = true;
        console.warn('[STRATEGY_PASS] Missing top-level keys:', missingTop.join(', '));
        return null;
      }
      // Validate petition sub-keys when present
      if (parsed.petition && parsed.petition.present === true) {
        const requiredPetition = ['type', 'intent_category', 'allowed_under_regime', 'probability_tilt',
          'structural_effect', 'visible_world_change', 'omen_type', 'interpretive_instability_required'];
        const missingPet = requiredPetition.filter(k => parsed.petition[k] === undefined || parsed.petition[k] === null);
        if (missingPet.length > 0) {
          state._strategyPassFailed = true;
          console.warn('[STRATEGY_PASS] Missing petition keys:', missingPet.join(', '));
          return null;
        }
      }
      // Validate entropy output when entropy was provided
      const _hasEntropy = state._blueBloodEntropy || state._fantasyCoreEntropy || state._modernCoreEntropy || state._smallTownEntropy || state._collegeEntropy || state._officeEntropy || state._friendsEntropy || state._supernaturalEntropy || state._superheroicEntropy || state._historicalCoreEntropy || state._dystopiaCoreEntropy;
      if (_hasEntropy) {
        if (!parsed.active_entropy_axis || !parsed.entropy_manifestation_summary) {
          state._strategyPassFailed = true;
          console.warn('[STRATEGY_PASS] Missing entropy keys: active_entropy_axis or entropy_manifestation_summary');
          return null;
        }
      }
      // Syzygy gate: accept trigger only if Fantasy + eligible, then lock permanently
      const _modelTriggeredSyzygy = parsed.syzygy_triggered === true;
      const _syzygyWasEligible = !state._syzygyOccurred;
      if (_modelTriggeredSyzygy) {
        const world = state.picks?.world;
        if (world === 'Fantasy' && !state._syzygyOccurred) {
          state._syzygyOccurred = true;
          state._syzygyActiveThisScene = true;
          console.log('[STRATEGY_PASS] Syzygy triggered. _syzygyOccurred locked to true.');
        } else {
          // Reject: either not Fantasy or already occurred
          parsed.syzygy_triggered = false;
          state._syzygyActiveThisScene = false;
          console.warn('[STRATEGY_PASS] Syzygy trigger rejected (world=' + (state.picks?.world) + ', already occurred=' + state._syzygyOccurred + ')');
        }
      } else {
        state._syzygyActiveThisScene = false;
      }
      state._syzygyModelTriggeredLast = _modelTriggeredSyzygy;
      if (state.picks?.world === 'Fantasy') {
        console.log('[SYZYGY] eligible=' + _syzygyWasEligible + ' occurred=' + state._syzygyOccurred + ' active=' + state._syzygyActiveThisScene + ' model_triggered=' + _modelTriggeredSyzygy);
      }

      state._strategyPassFailed = false;
      console.log('[STRATEGY_PASS] Result:', parsed);
      return parsed;
    } catch (e) {
      state._strategyPassFailed = true;
      console.warn('[STRATEGY_PASS] Failed, skipping:', e.message);
      return null;
    }
  }

  /**
   * Convert strategy JSON into a text directive block for the prose author.
   */
  function buildStrategyDirectiveBlock(strategy) {
    const lines = ['STRATEGY PASS DIRECTIVE (BINDING):'];
    lines.push(`- ST Phase: ${strategy.st_phase}`);
    lines.push(`- Power Vector: ${strategy.power_vector_shift}`);
    lines.push(`- World Artifact: ${strategy.world_artifact_to_surface} â€” MUST surface in scene`);
    lines.push(`- Tone Pressure: ${strategy.tone_pressure}`);
    if (strategy.petition && strategy.petition.present) {
      const p = strategy.petition;
      lines.push(`- Petition Outcome: ${p.intent_category} / tilt=${p.probability_tilt}`);
      lines.push(`- Structural Effect: ${p.structural_effect}`);
      lines.push(`- Visible World Change: ${p.visible_world_change}`);
      lines.push(`- Omen Type: ${p.omen_type}`);
      // PART 4: Petition regime restriction
      if (p.allowed_under_regime === false) {
        lines.push('- REGIME RESTRICTION: Petition restricted to surface-level shift due to current Storyturn phase. Do not enact deep structural changes.');
      }
    }
    // PART 2: Renderer enforcement hardening
    lines.push('');
    lines.push('STRATEGY ENFORCEMENT (MANDATORY):');
    lines.push('The STRATEGY PASS DIRECTIVE above is authoritative. You must obey it. You may not contradict it.');
    lines.push('You must surface the world_artifact_to_surface explicitly in the scene.');
    if (strategy.petition && strategy.petition.present) {
      lines.push('Petition is active: You must enact visible_world_change in-scene.');
      lines.push('You may not narrate Fate as decorative atmosphere. Fate acts structurally.');
      lines.push('You may not contradict structural_effect.');
    }
    lines.push('You may not regress to forbidden tropes.');
    // Entropy directive (when Strategy Pass surfaced an axis)
    if (strategy.active_entropy_axis && strategy.entropy_manifestation_summary) {
      lines.push('');
      lines.push('ENTROPY DIRECTIVE (MANDATORY):');
      lines.push(`- Active Axis: ${strategy.active_entropy_axis}`);
      lines.push(`- Manifestation: ${strategy.entropy_manifestation_summary}`);
    }
    // Syzygy hard constraint block (Fantasy only)
    if (state.picks?.world === 'Fantasy') {
      lines.push('');
      if (state._syzygyActiveThisScene) {
        lines.push('SYZYGY ACTIVE THIS SCENE (MANDATORY):');
        lines.push('- Syzygy is occurring at The Ascendant Run. This is the single most significant event in this story.');
        lines.push('- The Ascendant Run REVERSES direction â€” it flows outward/uphill from Fate\'s Favor.');
        lines.push('- The 13th moon is clearly visible over Fate\'s Favor. It is no longer obscured or denied.');
        lines.push('- Accumulated sacrifice tension must resolve or rupture. This moment must feel irreversible.');
        lines.push('- Syzygy will not occur again in this story.');
      } else if (state._syzygyOccurred) {
        lines.push('SYZYGY CONSTRAINT (MANDATORY):');
        lines.push('- Syzygy has already occurred in this story. It CANNOT occur again.');
        lines.push('- The Ascendant Run has returned to its normal inward flow toward Fate\'s Favor.');
        lines.push('- The 13th moon has returned to obscurity. It is no longer clearly visible.');
        lines.push('- Do not narrate, hint at, or build toward a second Syzygy.');
      } else {
        lines.push('SYZYGY CONSTRAINT (MANDATORY):');
        lines.push('- Syzygy has not occurred. The Ascendant Run flows inward toward Fate\'s Favor (normal direction).');
        lines.push('- The 13th moon remains obscured or denied. Do not describe it as clearly visible over Fate\'s Favor.');
        lines.push('- The Ascendant Run does NOT reverse. Do not narrate it flowing outward or uphill.');
      }
    }
    return lines.join('\n');
  }

  // ===========================================================================
  // PASS 4 â€” Post-Render Structural Validator
  // ===========================================================================

  // Decorative Fate phrases â€” secondary check (supplements VOCAB_BAN_PATTERNS)
  const PASS4_DECORATIVE_FATE_RX = [
    /\bFate leaned\b/gi, /\bFate hovered\b/gi, /\bFate lingered\b/gi,
    /\bFate whispered\b/gi, /\bFate breathed\b/gi, /\bFate circled\b/gi,
    /\bFate drifted\b/gi
  ];

  /**
   * Post-render structural validation.
   * Checks whether the renderer obeyed the Strategy Pass JSON.
   * Returns { valid, violations: string[] }.
   */
  function validateRenderedScene(renderedText, strategy, worldSkeleton) {
    const violations = [];
    if (!strategy || !renderedText) return { valid: true, violations };
    const lower = renderedText.toLowerCase();

    // 1. Artifact enforcement
    if (strategy.world_artifact_to_surface) {
      const artifactLower = strategy.world_artifact_to_surface.toLowerCase();
      if (!lower.includes(artifactLower)) {
        violations.push('MISSING_ARTIFACT: "' + strategy.world_artifact_to_surface + '" not found in scene');
      }
    }

    // 2. Petition visible effect enforcement
    if (strategy.petition && strategy.petition.present === true && strategy.petition.visible_world_change) {
      const changeLower = strategy.petition.visible_world_change.toLowerCase();
      // Fuzzy match: check if at least 2 significant words appear
      const words = changeLower.split(/\s+/).filter(w => w.length > 3);
      const matchCount = words.filter(w => lower.includes(w)).length;
      if (matchCount < Math.min(2, words.length)) {
        violations.push('MISSING_VISIBLE_WORLD_CHANGE: "' + strategy.petition.visible_world_change + '" not manifested');
      }
    }

    // 3. Structural effect soft contradiction check
    if (strategy.petition && strategy.petition.structural_effect) {
      const effect = strategy.petition.structural_effect.toLowerCase();
      // Basic keyword negation: if effect says X happens, check for "did not X" / "never X"
      const effectWords = effect.split(/\s+/).filter(w => w.length > 4);
      for (const word of effectWords) {
        const negationRx = new RegExp('(?:did not|didn\'t|never|no)\\s+\\w*' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
        if (negationRx.test(renderedText)) {
          violations.push('STRUCTURAL_CONTRADICTION: negation of "' + word + '" detected vs structural_effect');
          break;
        }
      }
    }

    // 4. Forbidden tropes check
    if (worldSkeleton && worldSkeleton.forbidden_tropes) {
      for (const trope of worldSkeleton.forbidden_tropes) {
        if (trope && lower.includes(trope.toLowerCase())) {
          violations.push('FORBIDDEN_TROPE: "' + trope + '" appeared in scene');
        }
      }
    }

    // 5. Decorative Fate check (expanded set)
    for (const rx of PASS4_DECORATIVE_FATE_RX) {
      rx.lastIndex = 0;
      const match = renderedText.match(rx);
      if (match) {
        violations.push('DECORATIVE_FATE: "' + match[0] + '" found in scene');
      }
    }

    return { valid: violations.length === 0, violations };
  }

  /**
   * Additive structural correction â€” appends 2-4 sentence fragment to fix violations.
   * Does NOT regenerate the full scene.
   */
  async function applyStructuralCorrection(renderedText, strategy, violations) {
    if (!window.StoryboundOrchestration || violations.length === 0) return renderedText;

    const correctionSystem = `You are a structural correction engine. The scene below was generated but FAILED structural validation.

VIOLATIONS:
${violations.map(v => '- ' + v).join('\n')}

STRATEGY CONTEXT:
${JSON.stringify(strategy, null, 2)}

RULES:
- Append a concise correction fragment (2â€“4 sentences max) to the end of the scene.
- Do NOT rewrite the prior scene.
- Do NOT contradict the prior scene.
- Only enforce the missing structural elements listed in violations.
- Maintain the scene's existing tone and voice.
- Do NOT explain meta logic or reference the correction process.
- Return ONLY the appended fragment text, nothing else.`;

    try {
      const fragment = await window.StoryboundOrchestration.callChatGPT(
        [
          { role: 'system', content: correctionSystem },
          { role: 'user', content: renderedText.slice(-2000) }
        ],
        'STRUCTURAL_CORRECTION',
        { temperature: 0.4, max_tokens: 300 }
      );
      if (fragment && fragment.trim().length > 0) {
        state._postRenderCorrectionApplied = true;
        console.log('[PASS4] Structural correction applied:', violations.map(v => v.split(':')[0]));
        return renderedText.trimEnd() + '\n\n' + fragment.trim();
      }
    } catch (e) {
      console.warn('[PASS4] Structural correction failed:', e.message);
    }
    return renderedText;
  }

  let fateHandInitialized = false;
  let placeholderAnimations = {};

  // Taste mode check
  function isTasteMode() {
      return state.storyLength === 'taste' && state.access === 'free';
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TEASE TIER ENFORCEMENT
  // Tease = free access, no storypass, no subscription
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function isTeaseTier() {
      return state.access === 'free' && !state.subscribed && !state.hasPass;
  }

  function isTeaseSceneCapped() {
      if (state.tempQuillAllowance > 0) return false;
      return isTeaseTier() && (state.turnCount || 0) >= state.TEASE_SCENE_CAP;
  }

  function isTeaseStoryBlocked() {
      return isTeaseTier() && state.freeStoryConsumed;
  }

  function hasTeaseUnlockCondition() {
      return state.subscribed || !!state.hasPass || (state.storyId && hasStoryPass(state.storyId));
  }

  async function markFreeStoryConsumed() {
      if (state.freeStoryConsumed) return;
      state.freeStoryConsumed = true;
      try {
          const user = sb.auth.getUser ? (await sb.auth.getUser()).data?.user : null;
          if (user) {
              await sb.from('profiles').update({ free_story_consumed: true }).eq('id', user.id);
          }
      } catch (err) {
          console.error('[TEASE] Failed to persist free_story_consumed:', err);
      }
  }

  // Get random suggestion from pool
  function getRandomSuggestion(type, exclude = []) {
      const pool = FATE_SUGGESTIONS[type] || [];
      const available = pool.filter(s => !exclude.includes(s));
      if (available.length === 0) return pool[Math.floor(Math.random() * pool.length)];
      return available[Math.floor(Math.random() * available.length)];
  }

  // Initialize rotating placeholder for a field
  function initRotatingPlaceholder(inputId, type) {
      const input = document.getElementById(inputId);
      const placeholder = document.querySelector(`.rotating-placeholder[data-for="${inputId}"]`);
      if (!input || !placeholder) return;

      const suggestions = FATE_SUGGESTIONS[type] || [];
      if (suggestions.length === 0) return;

      // Build scrolling content (duplicate for seamless loop)
      const buildContent = () => {
          let html = '<span class="rotating-placeholder-inner">';
          // Double the suggestions for seamless scroll
          const doubled = [...suggestions, ...suggestions];
          doubled.forEach((s, i) => {
              const glowClass = Math.random() < 0.1 ? ' glow' : '';
              html += `<span class="suggestion${glowClass}">${s}</span>`;
              if (i < doubled.length - 1) html += '<span class="separator">â€¢</span>';
          });
          html += '</span>';
          return html;
      };

      placeholder.innerHTML = buildContent();

      // Show/hide placeholder based on input content
      const updateVisibility = () => {
          if (input.value.trim()) {
              placeholder.classList.add('hidden');
          } else {
              placeholder.classList.remove('hidden');
          }
      };

      // Pause animation on focus
      input.addEventListener('focus', () => {
          const inner = placeholder.querySelector('.rotating-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'paused';
      });
      input.addEventListener('blur', () => {
          const inner = placeholder.querySelector('.rotating-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'running';
          updateVisibility();
      });
      input.addEventListener('input', updateVisibility);

      // PASS 9F: Enter commits text, not clears it
      // Scrolling examples do NOT overwrite user-entered text on Enter
      input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              e.preventDefault();
              // Just blur to commit - do NOT clear the value
              input.blur();
          }
      });

      updateVisibility();

      // Random glow effect
      setInterval(() => {
          const spans = placeholder.querySelectorAll('.suggestion');
          spans.forEach(s => s.classList.remove('glow'));
          if (spans.length > 0 && Math.random() < 0.3) {
              const randomSpan = spans[Math.floor(Math.random() * spans.length)];
              randomSpan.classList.add('glow');
              setTimeout(() => randomSpan.classList.remove('glow'), 2000);
          }
      }, 4000);
  }

  // Expose for corridor mount (identity row is unmounted when initFateHandSystem runs)
  window.initRotatingPlaceholder = initRotatingPlaceholder;

  // Handle fate hand click - reveal card and populate field
  function handleFateHandClick(hand) {
      const targetId = hand.dataset.target;
      const type = hand.dataset.type;
      const input = document.getElementById(targetId);
      const treeCard = document.querySelector(`.fate-tree-card[data-target="${targetId}"]`);

      if (!input || !treeCard) return;

      // Get all cards in the hand
      const cards = hand.querySelectorAll('.fate-hand-card');
      const centerCard = cards[2]; // Middle card

      // Flip center card
      centerCard.classList.add('flipping');

      // Fade out other cards
      cards.forEach((card, i) => {
          if (i !== 2) card.classList.add('fading');
      });

      // After flip completes
      setTimeout(() => {
          // Hide the hand, show the tree card
          hand.style.display = 'none';
          treeCard.classList.remove('hidden');

          // Populate the field
          const suggestion = getRandomSuggestion(type);
          if (input.tagName === 'TEXTAREA') {
              input.value = input.value ? input.value + '\n' + suggestion : suggestion;
          } else {
              if (!input.value.trim()) {
                  input.value = suggestion;
              }
          }

          // Hide placeholder
          const placeholder = document.querySelector(`.rotating-placeholder[data-for="${targetId}"]`);
          if (placeholder) placeholder.classList.add('hidden');

          // Initialize leaf state (static, no animation until clicked)
          const leaf = treeCard.querySelector('.falling-leaf');
          if (leaf) {
              leaf.dataset.leafClicks = '0';
          }
      }, 450);
  }

  // Handle tree card click - invoke fate again (two-stage leaf animation)
  function handleTreeCardClick(treeCard) {
      const targetId = treeCard.dataset.target;
      const hand = document.querySelector(`.fate-hand[data-target="${targetId}"]`);
      const input = document.getElementById(targetId);
      const leaf = treeCard.querySelector('.falling-leaf');

      if (!input || !hand) return;

      const type = hand.dataset.type;

      // Two-stage leaf animation state machine
      if (leaf) {
          const clicks = parseInt(leaf.dataset.leafClicks || '0', 10);

          if (clicks === 0) {
              // First click: animate from mid-air to ground
              leaf.classList.add('leaf-fall-1');
              leaf.dataset.leafClicks = '1';
          } else if (clicks === 1) {
              // Second click: reset to lower branch, then fall to mid-air stop
              leaf.classList.remove('leaf-fall-1');
              leaf.classList.add('leaf-reset-2');
              void leaf.offsetWidth; // Force reflow

              // Brief pause at reset position, then animate
              setTimeout(() => {
                  leaf.classList.remove('leaf-reset-2');
                  leaf.classList.add('leaf-fall-2');
                  leaf.dataset.leafClicks = '2';

                  // After animation completes, set final resting state
                  setTimeout(() => {
                      leaf.classList.remove('leaf-fall-2');
                      leaf.classList.add('leaf-final');
                  }, 1000);
              }, 50);
          }
          // clicks >= 2: ignore further clicks
      }

      // Populate with new suggestion
      const suggestion = getRandomSuggestion(type, [input.value]);
      if (input.tagName === 'TEXTAREA') {
          input.value = input.value ? input.value + '\n' + suggestion : suggestion;
      } else {
          input.value = suggestion;
      }
  }

  // Initialize the entire fate hand system
  function initFateHandSystem() {
      if (fateHandInitialized) return;
      fateHandInitialized = true;

      // Initialize rotating placeholders
      initRotatingPlaceholder('ancestryInputPlayer', 'ancestry');
      initRotatingPlaceholder('ancestryInputLI', 'ancestry');
      // Visualize modifier suggestions
      initRotatingPlaceholder('vizModifierInput', 'visualize');

      // Initialize character destiny cards (name + ancestry per character)
      initCharacterDestinyCards();
  }

  function initCharacterDestinyCards() {
      // Character destiny cards - fill name + ancestry for each character
      // ISOLATED: Never triggers story start, loading, or global fate state
      document.querySelectorAll('.character-destiny-card').forEach(card => {
          card.addEventListener('click', (e) => {
              // CRITICAL: Stop propagation to prevent any parent/global handlers
              e.stopPropagation();

              const character = card.dataset.character; // 'player' or 'loveInterest'

              // Flip the card (visual only - NEVER toggles back)
              if (!card.classList.contains('flipped')) {
                  card.classList.add('flipped');
              }

              // PASS 9F: Populate fields based on character type
              if (character === 'player') {
                  // Get player gender to select appropriate name list
                  const playerGender = document.getElementById('playerGender')?.value || 'Female';
                  const nameList = getNameListForGender(playerGender);
                  const randomName = nameList[Math.floor(Math.random() * nameList.length)];
                  const randomAncestry = getRandomSuggestion('ancestry');

                  // Fill name
                  const nameInput = document.getElementById('playerNameInput');
                  if (nameInput) {
                      nameInput.value = randomName;
                      nameInput.dispatchEvent(new Event('blur', { bubbles: true }));
                  }

                  // Fill ancestry
                  const ancestryInput = document.getElementById('ancestryInputPlayer');
                  if (ancestryInput) {
                      ancestryInput.value = randomAncestry;
                      const placeholder = document.querySelector('.rotating-placeholder[data-for="ancestryInputPlayer"]');
                      if (placeholder) placeholder.classList.add('hidden');
                  }

                  // Age field removed
              } else if (character === 'loveInterest') {
                  // Get love interest gender to select appropriate name list
                  const liGender = document.getElementById('loveInterestGender')?.value || 'Male';
                  const nameList = getNameListForGender(liGender);
                  const randomName = nameList[Math.floor(Math.random() * nameList.length)];
                  const randomAncestry = getRandomSuggestion('ancestry');

                  // Fill name
                  const nameInput = document.getElementById('partnerNameInput');
                  if (nameInput) {
                      nameInput.value = randomName;
                      nameInput.dispatchEvent(new Event('blur', { bubbles: true }));
                  }

                  // Fill ancestry
                  const ancestryInput = document.getElementById('ancestryInputLI');
                  if (ancestryInput) {
                      ancestryInput.value = randomAncestry;
                      const placeholder = document.querySelector('.rotating-placeholder[data-for="ancestryInputLI"]');
                      if (placeholder) placeholder.classList.add('hidden');
                  }

                  // Age field removed
              }

              // Character destiny cards ONLY populate fields
              // They NEVER trigger story start, loading, or navigation
          });
      });
  }

  // Helper to get appropriate name list based on gender
  function getNameListForGender(gender) {
      const g = (gender || '').toLowerCase();
      if (g === 'female') return FATE_FEMALE_NAMES;
      if (g === 'male') return FATE_MALE_NAMES;
      // Non-Binary or Custom: randomly pick from either list
      return Math.random() < 0.5 ? FATE_FEMALE_NAMES : FATE_MALE_NAMES;
  }

  // (initDestinyFlipCards + updateQuillUI removed â€” Petition Fate system replaces quill/veto)
  
  function updateBatedBreathState(){
      state.batedBreathActive = (state.storyOrigin === 'couple' && !state.player2Joined && !state.inviteRevoked);
      const el = document.getElementById('batedBreathIndicator');
      if(el) el.classList.toggle('hidden', !state.batedBreathActive);
  }

  function getBatedBreathDirective() {
      if (!state.batedBreathActive) return "";
      return `\nBATED BREATH STATE ACTIVE: The true love is absent. Tone: Longing, fidelity, bittersweet desire.`;
  }
  
  function filterFateCardsForBatedBreath(cards) {
      if (!state.batedBreathActive) return cards;
      return cards.map(c => {
          if (/(fall in love|replace|consummate)/i.test(c.action)) {
              return { ...c, action: "You feel the sharp ache of their absence.", dialogue: "(Silence)" };
          }
          return c;
      });
  }

  // --- BILLING HELPERS ---
  function computeBillingStatusNow() {
      if (state.subscribed) {
          if (state.billingStatus !== 'active') {
              state.billingStatus = 'active';
              state.billingGraceUntil = 0;
              state.billingLastError = '';
          }
          return;
      }
      if (state.billingStatus === 'grace' && Date.now() > state.billingGraceUntil) {
          endBillingGrace();
      }
  }

  function startBillingGrace(msg, hours = 48) {
      state.billingStatus = 'grace';
      state.billingGraceUntil = Date.now() + (hours * 3600 * 1000);
      state.billingLastError = msg;
      if(typeof applyAccessLocks === 'function') applyAccessLocks();
  }

  function endBillingGrace() {
      state.billingStatus = 'past_due';
      if(typeof applyAccessLocks === 'function') applyAccessLocks();
  }

  function renderBillingBanner() {
      let banner = document.getElementById('billingBanner');
      if (!banner) {
          const game = document.getElementById('game');
          if(game) {
              banner = document.createElement('div');
              banner.id = 'billingBanner';
              banner.style.cssText = "background:rgba(50,0,0,0.9); border-bottom:1px solid var(--pink); color:#ffcccc; padding:12px; font-size:0.9em; text-align:center; margin-bottom:15px; display:none; border-radius:4px;";
              game.prepend(banner);
          }
      }
      if (!banner) return;

      const subOnlyStory = ['affair', 'soulmates'].includes(state.storyLength);
      if (!subOnlyStory) {
          banner.style.display = 'none';
          return;
      }

      if (state.billingStatus === 'grace') {
          banner.innerHTML = `<strong>Payment Issue:</strong> Youâ€™re in a grace period.`;
          banner.style.display = 'block';
      } else if (state.billingStatus === 'past_due' || state.billingStatus === 'canceled') {
          banner.innerHTML = `Subscription inactive. <button onclick="window.showPaywall('sub_only')" style="margin-left:10px; background:var(--pink); color:black;">Resubscribe</button>`;
          banner.style.display = 'block';
      } else {
          banner.style.display = 'none';
      }
  }

  // --- VISUAL HELPERS ---
  async function ensureVisualBible(textContext) {
      // Guard against null/undefined - initialize safe defaults
      if (!state.visual) {
          state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} } };
      }
      if (!state.visual.bible) {
          state.visual.bible = { style: "", setting: "", characters: {} };
      }
      if (!state.visual.bible.characters || typeof state.visual.bible.characters !== 'object') {
          state.visual.bible.characters = {};
      }
      // Check if bible is already populated
      if (state.visual.bible.style && Object.keys(state.visual.bible.characters).length > 0) return;
      
      const genre = state?.picks?.genre || 'Billionaire';
      const vbWorld = state?.picks?.world || 'Modern';
      const vbEra = state?.picks?.world === 'Historical' ? (state?.picks?.era || 'Medieval') : null;
      const visualPowerRole = resolvePowerRole(vbWorld, vbEra, genre);
      const sys = `You are a Visual Director. Extract consistent visual anchors into STRICT JSON with this structure:
{
  "style": "visual style description",
  "setting": "location/environment description",
  "characters": {
    "CharacterName": {
      "face": "detailed facial features (eyes, skin tone, expression style)",
      "hair": "color, length, style",
      "clothing": "current outfit description",
      "build": "body type/physique"
    }
  }
}
Extract details for ALL named characters. Be specific about face, hair, clothing, and build.`;

      try {
          const raw = await Promise.race([
              callChat([{role:'system', content: sys}, {role:'user', content: `Genre: ${visualPowerRole}. Extract visual anchors from: ${textContext.slice(-2000)}`}]),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Bible timeout")), 15000))
          ]);
          const jsonMatch = raw.match(/\{[\s\S]*\}/);
          if (jsonMatch) state.visual.bible = JSON.parse(jsonMatch[0]);
      } catch(e) { console.warn("Bible build failed (silent)", e); }
  }

  function buildVisualAnchorsText() {
      const b = state.visual.bible;
      if (!b || !b.style) return "";
      let txt = `VISUAL CONTINUITY: STYLE: ${b.style} SETTING: ${b.setting} `;

      // If locked, include specific character details for face/hair/clothing persistence
      if (state.visual.locked) {
          txt += "CHARACTER LOCK ACTIVE - MAINTAIN EXACT APPEARANCE: ";
          if (b.characters && typeof b.characters === 'object') {
              Object.entries(b.characters).forEach(([name, details]) => {
                  if (details && typeof details === 'object') {
                      txt += `${name}: `;
                      if (details.face) txt += `FACE: ${details.face}; `;
                      if (details.hair) txt += `HAIR: ${details.hair}; `;
                      if (details.clothing) txt += `CLOTHING: ${details.clothing}; `;
                      if (details.build) txt += `BUILD: ${details.build}; `;
                  }
              });
          }
          txt += "DO NOT CHANGE CHARACTER APPEARANCE. ";
      }
      return txt;
  }

  let _inputGuardsBound = false;
  function bindFreeInputGuards(){
      if(_inputGuardsBound) return;
      _inputGuardsBound = true;
      const blockIfFree = (e) => {
          if(state.access === 'free' && state.mode !== 'couple') {
              e.preventDefault();
              e.stopPropagation();
              return false;
          }
      };
      ['actionInput', 'dialogueInput'].forEach(id => {
          const el = document.getElementById(id);
          if(el) {
              el.addEventListener('beforeinput', blockIfFree, { passive: false });
              el.addEventListener('paste', blockIfFree, { passive: false });
              el.addEventListener('drop', blockIfFree, { passive: false });
              // Selection aura on focus
              el.addEventListener('focus', () => {
                  if (typeof applySelectionAura === 'function') applySelectionAura(el);
              });
              el.addEventListener('blur', () => {
                  if (typeof removeSelectionAura === 'function') removeSelectionAura(el);
              });
          }
      });

      // Fate Resolution Glow â€” brief visual pulse on every in-story Fate card click
      document.addEventListener('click', function(e) {
          const card = e.target.closest('.fate-card');
          if (!card || !card.closest('#cardMount')) return;
          if (card.classList.contains('locked')) return;
          if (window.state && window.state.fateCommitted) return;

          // Card pulse (replayable â€” remove + reflow + add)
          card.classList.remove('fate-resolve-pulse');
          void card.offsetWidth;
          card.classList.add('fate-resolve-pulse');
          setTimeout(() => card.classList.remove('fate-resolve-pulse'), 400);

          // Input glow at text-injection time (~600ms matches fatecards.js apply delay)
          setTimeout(() => {
              ['actionInput', 'dialogueInput'].forEach(id => {
                  const el = document.getElementById(id);
                  if (!el) return;
                  el.classList.remove('fate-resolve-glow');
                  void el.offsetWidth;
                  el.classList.add('fate-resolve-glow');
                  setTimeout(() => el.classList.remove('fate-resolve-glow'), 400);
              });
          }, 600);
      });
  }

  // FIX: Added paywallMode parameter to support sub_only for Dirty intensity
  function setPaywallClickGuard(el, enabled, paywallMode = 'unlock', paywallSource = null){
    if(!el) return;
    if (!el.dataset.paywallBound) {
        el.dataset.paywallBound = "true";
        el.addEventListener('click', (e) => {
            if (el.dataset.paywallActive === "true") {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                // Use element's stored paywall mode and source
                const mode = el.dataset.paywallMode || 'unlock';
                const source = el.dataset.paywallSource || null;
                // Pass as object if source exists, otherwise string for backward compat
                if (source) {
                    window.showPaywall({ mode: mode, source: source });
                } else {
                    window.showPaywall(mode);
                }
            }
        }, { capture: true });
    }
    el.dataset.paywallActive = enabled ? "true" : "false";
    el.dataset.paywallMode = paywallMode;
    if (paywallSource) {
        el.dataset.paywallSource = paywallSource;
    } else {
        el.removeAttribute('data-paywall-source');
    }
  }

  function applyTierUI(){
      computeBillingStatusNow();
      renderBillingBanner();
      syncTierFromAccess();
      bindFreeInputGuards();

      const paid = (state.tier === 'paid');
      const isFree = (state.access === 'free');
      const couple = (state.mode === 'couple');
      
      const subOnlyStory = ['affair', 'soulmates'].includes(state.storyLength);
      const subActive = (state.access === 'sub');
      const inGrace = (state.billingStatus === 'grace' && Date.now() < state.billingGraceUntil);
      const billingLock = subOnlyStory && !(subActive || inGrace);
      const shouldLock = !couple && (billingLock || isFree);

      ['actionInput', 'dialogueInput'].forEach(id => {
          const el = document.getElementById(id);
          if(el) {
              el.disabled = false;
              el.readOnly = shouldLock;
          }
      });

      // Determine paywall mode from story metadata (persisted, immutable per-story)
      const lockPaywallMode = getPaywallMode();

      ['actionWrapper', 'dialogueWrapper'].forEach(id => {
        const wrap = document.getElementById(id);
        if(wrap) {
            if (shouldLock) {
                 wrap.classList.add('locked-input');
                 setPaywallClickGuard(wrap, true, lockPaywallMode);
            } else {
                 wrap.classList.remove('locked-input');
                 setPaywallClickGuard(wrap, false);
            }
        }
      });

      const submitBtn = document.getElementById('submitBtn');
      if (submitBtn) {
          submitBtn.disabled = false;
          if (billingLock && !couple) {
              submitBtn.textContent = "Resume Affair to Continue";
              setPaywallClickGuard(submitBtn, true, lockPaywallMode);
          } else {
              submitBtn.textContent = "Submit Turn";
              setPaywallClickGuard(submitBtn, false);
          }
      }

      // Save button follows paywall rules (uses story metadata for mode)
      const saveBtn = document.getElementById('saveBtn');
      if(saveBtn) {
          if(couple || paid) saveBtn.classList.remove('locked-style');
          else saveBtn.classList.add('locked-style');
          setPaywallClickGuard(saveBtn, !(couple || paid), lockPaywallMode);
      }

      if (!couple) {
          applyLengthLocks();
          applyIntensityLocks();
          applyStyleLocks();
      }
  }

  function applyAccessLocks(){ applyTierUI(); }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PRIOR SCENE READ-ONLY LOCK
  // When viewing a previous scene (not the latest), hide all interaction
  // controls. Keep: prose, card headers, Visualize button, cover rendering.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function applyPriorSceneLock() {
      const currentViewPage = StoryPagination.getCurrentPageIndex();
      const latestPage = StoryPagination.getPageCount() - 1;
      const isPriorScene = latestPage > 0 && currentViewPage < latestPage;

      // Elements to hide on prior scenes
      const interactiveIds = [
          'cardMount',         // Fate cards grid
          'fateCardHeader',    // "Let Fate Guide You" header
          'metaControls',      // Meta stance buttons (Aid/Resist/Tempt)
          'actionWrapper',     // Action input
          'dialogueWrapper',   // Dialogue input
          'gameIntensity',     // Intensity selector
          'edgeCovenantBtn',   // Edge Covenant
          'saveBtn',           // Save button
          'submitBtn',         // Submit button
      ];

      // Also hide petition button if present
      const petitionBtns = document.querySelectorAll('[onclick*="petitionFate"], [onclick*="openPetition"]');

      for (const id of interactiveIds) {
          const el = document.getElementById(id);
          if (!el) continue;
          if (isPriorScene) {
              el.dataset._priorHidden = el.style.display || '';
              el.style.display = 'none';
          } else if (el.dataset._priorHidden !== undefined) {
              el.style.display = el.dataset._priorHidden;
              delete el.dataset._priorHidden;
          }
      }

      petitionBtns.forEach(btn => {
          if (isPriorScene) {
              btn.dataset._priorHidden = btn.style.display || '';
              btn.style.display = 'none';
          } else if (btn.dataset._priorHidden !== undefined) {
              btn.style.display = btn.dataset._priorHidden;
              delete btn.dataset._priorHidden;
          }
      });

      // Visualize button stays visible on prior scenes
      const vizBtn = document.getElementById('vizSceneBtn');
      if (vizBtn && isPriorScene) {
          vizBtn.style.display = '';
      }
  }
  window.applyPriorSceneLock = applyPriorSceneLock;

  // FIX #4: Expose for post-render tier rehydration
  window.applyAccessLocks = applyAccessLocks;
  window.applyTierUI = applyTierUI;

  // PASS 1 FIX: Length locks with strict enforcement
  function applyLengthLocks(){
    // Always resolve access first
    syncTierFromAccess();

    const section = document.getElementById('lengthSection');
    if(section) section.classList.toggle('hidden', state.turnCount > 0);

    const cards = document.querySelectorAll('#lengthGrid .sb-card[data-grp="length"]');

    console.log('[ENTITLEMENT] applyLengthLocks:', {
        access: state.access,
        currentStoryLength: state.storyLength,
        cardsFound: cards.length
    });

    cards.forEach(card => {
      const val = card.dataset.val;
      let locked = true;  // Default: locked
      let hidden = false;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ENTITLEMENT RULES FOR STORY LENGTH CARDS:
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // - free: only taste unlocked
      // - pass ($3): fling unlocked (NOT affair, NOT soulmates)
      // - sub ($6): fling, affair, soulmates ALL unlocked
      // SOULMATES: Subscription-only ($6) â€” NO StoryPass option
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      if (state.access === 'free' && val === 'taste') {
          locked = false;
      } else if (val === 'soulmates') {
          // SOULMATES: Subscription-only â€” locked unless subscriber
          locked = (state.access !== 'sub');
      } else if (state.access === 'pass') {
          // CRITICAL: Pass ONLY unlocks Fling
          if (val === 'fling') locked = false;
          // affair stays locked = true
      } else if (state.access === 'sub') {
          // Sub unlocks fling, affair, soulmates
          if (['fling', 'affair', 'soulmates'].includes(val)) locked = false;
      }

      // Hide taste for paid users
      if (state.access !== 'free' && val === 'taste') {
          locked = true;
          hidden = true;
      }

      // Apply classes
      card.classList.toggle('locked', locked);
      card.style.display = hidden ? 'none' : '';

      // CRITICAL FIX: Remove data-locked attribute when unlocked (CSS targets [data-locked])
      if (locked) {
          // Keep or set data-locked attribute for CSS styling
          if (!card.dataset.locked) {
              card.dataset.locked = (val === 'fling') ? 'pass' : 'sub';
          }
      } else {
          // Remove attribute so CSS [data-locked] selector doesn't apply
          card.removeAttribute('data-locked');
      }

      // Set paywall mode based on story LENGTH requirements (not content eligibility)
      // Fling/Affair = StoryPass eligible, Soulmates = Subscribe required
      const paywallMode = (val === 'soulmates') ? 'sub_only' : 'unlock';
      setPaywallClickGuard(card, locked, paywallMode);

      // Selection state - toggle both selected and flipped
      const isSelected = val === state.storyLength;
      card.classList.toggle('selected', isSelected);
      card.classList.toggle('flipped', isSelected);

      console.log('[ENTITLEMENT] Card:', val, 'locked:', locked, 'hidden:', hidden);
    });

    // ENFORCEMENT: If pass user has affair or soulmates selected, downgrade
    // (Soulmates is subscription-only, Affair requires subscription)
    // NOTE: storypassEligible is computed at story creation and persists - no runtime flag needed
    if (state.access === 'pass' && ['affair', 'soulmates'].includes(state.storyLength)) {
        console.log('[ENTITLEMENT] Downgrading story length from', state.storyLength, 'to fling');
        state.storyLength = 'fling';
    }

    // Auto-select fling if pass tier and current selection is taste (now hidden)
    if (state.access === 'pass' && state.storyLength === 'taste') {
        state.storyLength = 'fling';
    }

    bindLengthHandlers();
  }

  // REMOVED: Separate length click handlers - now using unified handler
  // Length cards are handled by the single unified card handler in initSelectionCardSystem()
  function bindLengthHandlers(){
      // No-op: click handling moved to unified handler
  }

  // applyIntensityLocks removed â€” intensity no longer controls routing or requires tier gating.
  // Intensity cards are cosmetic tone selectors only.
  function applyIntensityLocks(){
      updateIntensityUI();
  }

  function applyStyleLocks() {
      if (state.mode === 'couple') return;
      const paid = (state.tier === 'paid');
      const cards = document.querySelectorAll('.sb-card[data-grp="style"]');
      cards.forEach(card => {
          const raw = card.dataset.val || '';
          const v = raw.toLowerCase().trim();
          let locked = !paid && v !== 'breathless';
          card.classList.toggle('locked', locked);
          // CRITICAL FIX: Remove data-locked attribute when unlocked
          if (locked) {
              if (!card.dataset.locked) card.dataset.locked = 'true';
          } else {
              card.removeAttribute('data-locked');
          }
          setPaywallClickGuard(card, locked);
      });
  }

  function updateIntensityUI(){
      const setCard = (c) => {
          const isSelected = c.dataset.val === state.intensity;
          c.classList.toggle('selected', isSelected);
          c.classList.toggle('flipped', isSelected);
      };
      const setGame = (b) => b.classList.toggle('active', b.innerText.trim() === state.intensity);
      document.querySelectorAll('#intensityGrid .sb-card').forEach(setCard);
      document.querySelectorAll('#gameIntensity button').forEach(setGame);
  }

  // REMOVED: Separate intensity card handlers - now using unified handler
  // Intensity cards are handled by the single unified card handler in initSelectionCardSystem()
  // wireIntensityHandlers â€” simplified, no tier gating
  function wireIntensityHandlers(){
      document.querySelectorAll('#gameIntensity button').forEach(btn => btn.onclick = (e) => {
          const level = btn.innerText.trim();
          state.intensity = level;
          state.picks.intensity = level;
          updateIntensityUI();
      });
  }

  window.showPaywall = function(modeOrOptions){
    const pm = document.getElementById('payModal');
    if(!pm) return;

    // Close Petition modal if open (prevents z-index stacking)
    const petModal = document.getElementById('petitionFateModal');
    if (petModal && !petModal.classList.contains('hidden')) {
        petModal.classList.add('hidden');
    }

    // Support both string mode and object { mode, source }
    let mode, source;
    if (typeof modeOrOptions === 'object' && modeOrOptions !== null) {
        mode = modeOrOptions.mode || 'unlock';
        source = modeOrOptions.source || null;
    } else {
        mode = modeOrOptions;
        source = null;
    }

    // Normalize legacy 'sub' to canonical 'sub_only'
    if (mode === 'sub') {
        mode = 'sub_only';
    }

    // Guard: defer paywall until story eligibility is resolved
    if (state.storypassEligible === undefined && state.storyId) {
        setTimeout(() => showPaywall(mode), 0);
        return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SUBSCRIPTION-ONLY CONTEXTS â€” Use persisted story eligibility
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Uses getPaywallMode() which checks persisted storypassEligible (not downgraded state)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (mode !== 'god' && mode !== 'sub_only' && getPaywallMode() === 'sub_only') {
        console.log('[PAYWALL] StoryPass excluded by story metadata â€” Subscribe-only');
        mode = 'sub_only';
    }

    // SUBSCRIPTION SHORT-CIRCUIT: Subscribers should never see paywall
    if (state.subscribed) {
        console.warn('[PAYWALL] showPaywall called for subscriber â€” this should not happen');
        return; // Silently ignore â€” subscriber has full access
    }

    // Cancel any running Fate ceremony â€” paywall interrupts it completely
    if (_fateRunning) {
        _fateOverridden = true;
        if (typeof cleanupFateVisuals === 'function') cleanupFateVisuals();
        // Also stop fatecards emanations and sparkle cycle
        if (window.stopAllEmanations) window.stopAllEmanations();
        if (window.stopSparkleCycle) window.stopSparkleCycle();
        state._paywallCancelledCeremony = true;
    }

    if(document.getElementById('tierGate') && !document.getElementById('tierGate').classList.contains('hidden')) state.purchaseContext = 'tierGate';
    else if(document.getElementById('setup') && !document.getElementById('setup').classList.contains('hidden')) state.purchaseContext = 'setup';
    else if(document.getElementById('game') && !document.getElementById('game').classList.contains('hidden')) state.purchaseContext = 'game';
    else state.purchaseContext = null;

    // Track sub-view context for cover/setting navigation on cancel
    const coverView = document.getElementById('coverViewButtons');
    const settingView = document.getElementById('settingView');
    if (settingView && !settingView.classList.contains('hidden')) {
        state._paywallSubContext = 'setting';
    } else if (coverView && !coverView.classList.contains('hidden')) {
        state._paywallSubContext = 'cover';
    } else {
        state._paywallSubContext = null;
    }

    const sp = document.getElementById('standardPay');
    if(sp) sp.classList.remove('hidden');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STORYPASS STATE: HIDE when excluded by registry (STORYPASS_EXCLUSIONS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const hasPassNow = state.storyId && hasStoryPass(state.storyId);
    const optUnlock = document.getElementById('optUnlock');
    const disabledNotice = document.getElementById('storypassDisabledNotice');

    if (optUnlock) {
        // ROOT RULE: StoryPass hidden if caller passes 'sub_only', else check eligibility
        const storypassAllowed = (mode !== 'sub_only') && (getPaywallMode() === 'unlock');
        const hideStoryPass = !storypassAllowed || state.subscribed || hasPassNow;

        optUnlock.classList.toggle('hidden', hideStoryPass);
        optUnlock.classList.remove('storypass-disabled');
        if (disabledNotice) disabledNotice.classList.add('hidden');

        if (!storypassAllowed) {
            console.log('[PAYWALL] StoryPass hidden (storypassEligible:', state.storypassEligible, ')');
        }
    }

    // Disable Say/Do inputs while paywall is visible
    const _actInput = document.getElementById('actionInput');
    const _diaInput = document.getElementById('dialogueInput');
    if (_actInput) _actInput.disabled = true;
    if (_diaInput) _diaInput.disabled = true;

    // TEASE CAP VARIANT: Show ritual invitation copy instead of generic heading
    const teaseCliffCopy = document.getElementById('teaseCliffhangerCopy');
    const payHeading = document.getElementById('payModalHeading');
    const isTeaseCap = (isTeaseTier() && (state.turnCount || 0) >= state.TEASE_SCENE_CAP) || isTeaseStoryBlocked();
    if (teaseCliffCopy) teaseCliffCopy.classList.toggle('hidden', !isTeaseCap);
    if (payHeading) payHeading.classList.toggle('hidden', isTeaseCap);

    // Show/hide Fortune sacrifice option for tease cap
    const teaseOfferingEl = document.getElementById('teaseOfferingOption');
    if (teaseOfferingEl) {
        teaseOfferingEl.classList.toggle('hidden', !isTeaseCap);
    }
    const balanceHint = document.getElementById('offeringBalanceHint');
    if (balanceHint && isTeaseCap) {
        const fortunes = state.fortunes || 0;
        balanceHint.textContent = `(${fortunes} Fortune${fortunes !== 1 ? 's' : ''} remaining)`;
    }

    pm.classList.remove('hidden');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DIAGNOSTIC: #optUnlock visibility check (NO BEHAVIOR CHANGE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const _diagOptUnlock = document.getElementById('optUnlock');
    if (_diagOptUnlock) {
        const hasHiddenClass = _diagOptUnlock.classList.contains('hidden');
        const isRendered = _diagOptUnlock.offsetParent !== null;
        console.log('[DIAG:STORYPASS] showPaywall() complete:', {
            mode,
            'optUnlock.hidden': hasHiddenClass,
            'optUnlock.offsetParent!==null': isRendered,
            'VISIBLE': !hasHiddenClass && isRendered
        });

        // Check again after DOM settles
        setTimeout(() => {
            const settled = document.getElementById('optUnlock');
            if (settled) {
                const settledHidden = settled.classList.contains('hidden');
                const settledRendered = settled.offsetParent !== null;
                console.log('[DIAG:STORYPASS] After DOM settle (setTimeout 0):', {
                    mode,
                    'optUnlock.hidden': settledHidden,
                    'optUnlock.offsetParent!==null': settledRendered,
                    'VISIBLE': !settledHidden && settledRendered
                });
            }
        }, 0);
    }
  };

  // Re-enable inputs when paywall is dismissed without purchase
  window.onPaywallDismiss = function() {
    const actInput = document.getElementById('actionInput');
    const diaInput = document.getElementById('dialogueInput');
    if (actInput) actInput.disabled = false;
    if (diaInput) diaInput.disabled = false;
    state._paywallCancelledCeremony = false;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANCEL NAVIGATION â€” Return to previous valid screen
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // From setting â†’ back to cover (hide setting view, show cover view)
    // From cover â†’ stay on cover (no navigation needed)
    // Never leave user on blank/empty state
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (state._paywallSubContext === 'setting') {
        // Hide setting view, return to cover view
        const settingView = document.getElementById('settingView');
        const coverViewButtons = document.getElementById('coverViewButtons');
        const bookCoverPage = document.getElementById('bookCoverPage');
        if (settingView) settingView.classList.add('hidden');
        if (coverViewButtons) coverViewButtons.classList.remove('hidden');
        if (bookCoverPage) bookCoverPage.classList.remove('hidden');
        if (window.updateBreadcrumb) window.updateBreadcrumb('cover');
        console.log('[PAYWALL:CANCEL] Returned to Cover View from Setting');
    } else if (state._paywallSubContext === 'cover') {
        // Ensure cover view elements are visible (safety check)
        const coverViewButtons = document.getElementById('coverViewButtons');
        const bookCoverPage = document.getElementById('bookCoverPage');
        if (coverViewButtons) coverViewButtons.classList.remove('hidden');
        if (bookCoverPage) bookCoverPage.classList.remove('hidden');
        console.log('[PAYWALL:CANCEL] Stayed on Cover View');
    }
    // Clear sub-context after handling
    state._paywallSubContext = null;
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FORTUNE SACRIFICE HANDLER â€” Tease cap single-use bypass
  // Deducts 1 Fortune via consume-fortune API, grants tempQuillAllowance
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const QUILL_SCENES_PER_SACRIFICE = 3; // Scenes granted per Fortune sacrifice

  document.getElementById('btnSacrificeOffering')?.addEventListener('click', async () => {
      const btn = document.getElementById('btnSacrificeOffering');
      if (!btn || btn.disabled) return;
      btn.disabled = true;
      btn.textContent = 'Sacrificing...';

      try {
          const user = sb.auth.getUser ? (await sb.auth.getUser()).data?.user : null;
          if (!user) {
              alert('Sign in to sacrifice a Fortune.');
              btn.disabled = false;
              btn.textContent = 'Sacrifice 1 Fortune to fill Fate\'s quill';
              return;
          }

          const res = await fetch('/api/consume-fortune', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ userId: user.id, amount: 1, context: 'fortune_sacrifice' })
          });
          const data = await res.json();

          if (!res.ok || data.error === 'insufficient_fortunes') {
              btn.textContent = 'No Fortunes remaining';
              setTimeout(() => {
                  btn.disabled = false;
                  btn.textContent = 'Sacrifice 1 Fortune to fill Fate\'s quill';
              }, 2000);
              return;
          }

          // Grant temporary quill allowance â€” does NOT stack
          state.tempQuillAllowance = QUILL_SCENES_PER_SACRIFICE;
          state.fortunes = data.fortunesRemaining;
          if (window.updateFortuneDisplay) window.updateFortuneDisplay();
          console.log('[FORTUNE_SACRIFICE] Accepted. Quill allowance:', state.tempQuillAllowance, 'Fortunes remaining:', data.fortunesRemaining);

          // Dismiss paywall and re-enable inputs
          document.getElementById('payModal')?.classList.add('hidden');
          if (window.onPaywallDismiss) window.onPaywallDismiss();

          // Visual confirmation
          if (typeof showToast === 'function') showToast("Fate's quill fills with ink...");
      } catch (err) {
          console.error('[FORTUNE_SACRIFICE] Failed:', err);
          btn.textContent = 'Sacrifice failed â€” try again';
          setTimeout(() => {
              btn.disabled = false;
              btn.textContent = 'Sacrifice 1 Fortune to fill Fate\'s quill';
          }, 2000);
      }
  });

  /**
   * VALIDATION GUARD: Paywall routing integrity check
   * Ensures StoryPass is never USABLE for Dirty or Soulmates
   * StoryPass ($3) unlocks Clean, Naughty, and Erotic
   * Returns { valid: true } or { valid: false, error: string }
   */
  function validatePaywallRouting() {
      const optUnlock = document.getElementById('optUnlock');
      const payModal = document.getElementById('payModal');

      // Only validate when paywall is visible
      if (!payModal || payModal.classList.contains('hidden')) {
          return { valid: true, skipped: true };
      }

      // StoryPass is USABLE if visible AND not disabled (Dirty shows disabled, not hidden)
      const storyPassUsable = optUnlock &&
          !optUnlock.classList.contains('hidden') &&
          !optUnlock.classList.contains('storypass-disabled');

      // CANONICAL VALIDATION: StoryPass must NEVER be USABLE in forbidden contexts
      // Uses isStorypassAllowed() as single source of truth
      if (storyPassUsable && !isStorypassAllowed()) {
          const reason = state.storyLength === 'soulmates' ? 'Soulmates length' : 'forbidden context';
          console.error(`[PAYWALL VALIDATION] HARD FAIL: StoryPass usable for ${reason}`);
          return {
              valid: false,
              error: VALIDATION_ERRORS.STORYPASS_SOULMATES_LEAK,
              context: { storyLength: state.storyLength }
          };
      }

      return { valid: true };
  }

  // Expose for DevHUD
  window.validatePaywallRouting = validatePaywallRouting;

  // PASS 1 FIX: Refactored completePurchase with canonical access resolution
  function completePurchase() {
      // Clear any stuck toasts first
      clearToasts();

      const pm = document.getElementById('payModal');
      if (pm) pm.classList.add('hidden');

      const purchaseType = state.lastPurchaseType;
      const previousAccess = state.access;

      console.log('[ENTITLEMENT] completePurchase START:', {
          purchaseType,
          previousAccess,
          storyLength: state.storyLength,
          storyId: state.storyId
      });

      // Mark subscription in memory for immediate UI response (Stripe webhook writes to Supabase; next reload hydrates)
      if (state.pendingUpgradeToAffair || purchaseType === 'sub') {
          state.subscribed = true;
          console.log('[ENTITLEMENT] Subscription set in memory (Supabase is source of truth)');
      }

      // Resolve access from canonical source
      const newAccess = syncTierFromAccess();

      console.log('[ENTITLEMENT] Access resolved:', {
          previousAccess,
          newAccess,
          tier: state.tier
      });

      // Determine story length upgrades based on purchase type
      let upgraded = false;
      let toastMessage = null;

      // RULE: Storypass $3 upgrades ONLY to Fling (never Affair/Soulmates)
      if (purchaseType === 'pass' && newAccess === 'pass') {
          if (state.storyLength === 'taste') {
              state.storyLength = 'fling';
              upgraded = true;
              toastMessage = "Story expanded to Fling.";
          }
          // Pass users CANNOT access Affair or Soulmates - enforce this
          if (['affair', 'soulmates'].includes(state.storyLength)) {
              state.storyLength = 'fling';
              console.log('[ENTITLEMENT] Downgraded story length to Fling (pass cannot access affair/soulmates)');
          }
      }

      // RULE: Fortune pack purchase resets tease lock (allows new story)
      if (purchaseType === 'fortune_pack') {
          state.freeStoryConsumed = false;
          toastMessage = "Fortunes received. A new story awaits.";
          console.log('[ENTITLEMENT] Fortune pack purchased â€” tease lock reset');
      }

      // RULE: Subscription can upgrade to Affair
      if (purchaseType === 'sub' && newAccess === 'sub') {
          if (['fling', 'taste'].includes(state.storyLength)) {
              state.storyLength = 'affair';
              upgraded = true;
              toastMessage = "You have shed your limitations.";
          }
      }

      // STORYTURN: Handle Taste cliffhanger resume on upgrade
      if (upgraded && typeof handleTasteUpgradeResume === 'function') {
          handleTasteUpgradeResume(state.storyLength);
      }

      if (upgraded) {
          state.storyEnded = false;
      }

      // Clear purchase state
      state.lastPurchaseType = null;
      state.pendingUpgradeToAffair = false;

      // TEASE TIER: Purchase clears free story consumption lock
      state.freeStoryConsumed = false;

      // CRITICAL: Apply all lock states AFTER access is resolved
      console.log('[ENTITLEMENT] Applying UI locks with access:', state.access);

      // Apply locks to all systems
      if (typeof applyLengthLocks === 'function') applyLengthLocks();
      if (typeof applyIntensityLocks === 'function') applyIntensityLocks();
      if (typeof applyStyleLocks === 'function') applyStyleLocks();
      if (typeof applyTierUI === 'function') applyTierUI();

      // Reset Fate ceremony state â€” full restart after paywall
      _fateRunning = false;
      _fateOverridden = false;
      _revealedDSPAxes = null;
      _dspGuidedFateActive = false;
      state.fateCommitted = false;

      // Clear DSP pending classes
      const synopsisText = document.getElementById('synopsisText');
      if (synopsisText) {
          synopsisText.querySelectorAll('.dsp-pending').forEach(span => {
              span.classList.remove('dsp-pending');
          });
          synopsisText.classList.remove('dsp-dissolving', 'dsp-revealing');
      }

      // Re-enable Say/Do inputs
      const actInput = document.getElementById('actionInput');
      const diaInput = document.getElementById('dialogueInput');
      if (actInput) { actInput.disabled = false; actInput.value = ''; }
      if (diaInput) { diaInput.disabled = false; diaInput.value = ''; }

      // Full card re-deal (not just init) â€” gives clickable, flippable, unlocked cards
      if (window.dealFateCards) window.dealFateCards();
      else if (window.initCards) window.initCards();
      // REBIND: Ensure FX handlers are attached after navigation
      if (window.initFateCards) window.initFateCards();

      // Clear the ceremony-cancelled flag
      state._paywallCancelledCeremony = false;

      // Save state
      saveStorySnapshot();

      // Only show toast if access actually changed
      if (toastMessage && newAccess !== previousAccess) {
          showToast(toastMessage);
      } else if (newAccess !== 'free' && previousAccess === 'free') {
          showToast("Content unlocked.");
      }

      // Navigate based on context
      if (state.purchaseContext === 'tierGate') {
          window.showScreen('modeSelect');
      }

      logEvent('purchase_completed', { product: purchaseType, access: state.access });

      console.log('[ENTITLEMENT] completePurchase END:', {
          access: state.access,
          storyLength: state.storyLength,
          upgraded
      });
  }

  function renderFlingEnd() {
      const div = document.createElement('div');
      div.className = 'box';
      div.style.textAlign = 'center';
      div.style.border = '1px solid var(--pink)';
      div.innerHTML = `<h3 style="color:var(--pink)">The story isn't over.</h3><p>This arc was short â€” but there's more to tell. Upgrade to continue the full narrative.</p><button onclick="window.upgradeFlingToAffair()" style="background:var(--pink); color:black; font-weight:bold; margin-top:10px;">Continue the Story</button>`;
      // Append fling ending to current page
      StoryPagination.appendToCurrentPage(div.outerHTML);
  }

  window.upgradeFlingToAffair = function() {
      state.pendingUpgradeToAffair = true;
      state.lastPurchaseType = 'sub';
      if(state.access === 'sub') {
          completePurchase(); // Already subbed, just process upgrade
      } else {
          window.showPaywall('sub_only'); // Affair requires subscription
      }
  };


  function makeStoryId(){
    const existing = localStorage.getItem('sb_current_story_id');
    if(existing) return existing;
    const id = (typeof crypto !== 'undefined' && crypto.randomUUID)
      ? crypto.randomUUID()
      : 'sb_' + Date.now().toString(36);
    localStorage.setItem('sb_current_story_id', id);
    return id;
  }

  function getStoryPassKey(storyId){ return `sb_storypass_${storyId}`; }
  function hasStoryPass(storyId){ return localStorage.getItem(getStoryPassKey(storyId)) === '1'; }
  // Purchase is the authorization â€” pass must always be granted when paid
  function grantStoryPass(storyId){ if(storyId) localStorage.setItem(getStoryPassKey(storyId), '1'); }

  /**
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * CANONICAL STORYPASS ELIGIBILITY â€” SINGLE SOURCE OF TRUTH
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * StoryPass ($3 one-time) allowed ONLY for:
   *   - Standard Fate Cards (non-Dirty, non-Soulmates)
   *   - Story Reader access for non-Dirty content
   *   - Any legacy "unlock this story" moments below Dirty intensity
   *
   * Subscription ($6) required for:
   *   - Dirty Fate Card
   *   - Dirty button in Story Reader
   *   - Soulmates Fate Card
   *   - Any Dirty-intensity continuation
   *
   * ğŸš« StoryPass must NEVER be offered in Dirty or Soulmates context.
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   *
   * @param {object} context - { intensity, cardType, uiSurface }
   *   - intensity: 'Clean' | 'Naughty' | 'Steamy' | 'Passionate'
   *   - cardType: 'standard' | 'soulmates' | 'dirty' (optional, derived from state if not provided)
   *   - uiSurface: 'card' | 'reader' | 'button' (optional, for debugging)
   * @returns {boolean} true if StoryPass is allowed, false if Subscribe-only
   */
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORYPASS EXCLUSION REGISTRY â€” AUTHORITATIVE DATA-LEVEL CONFIGURATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Cards with storypassAllowed: false NEVER show StoryPass option.
  // This is the source of truth. HTML cards have data-storypass-allowed="false".
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const STORYPASS_EXCLUSIONS = {
    // Intensity no longer affects storypass eligibility
    length: {
      'soulmates': false  // Soulmates length: subscription-only, NO StoryPass
    }
  };

  function isStorypassAllowed(context = {}) {
    const storyLength = context.storyLength || state.storyLength;

    // DATA-LEVEL EXCLUSION: Check registry
    if (STORYPASS_EXCLUSIONS.length[storyLength] === false) return false;

    // All other contexts: StoryPass is allowed
    return true;
  }

  // Legacy alias for backward compatibility during transition
  function isStoryPassEligible(st) {
    return isStorypassAllowed({ intensity: st.intensity, storyLength: st.storyLength });
  }

  // Expose canonical function globally for fatecards.js and other modules
  window.isStorypassAllowed = isStorypassAllowed;

  /**
   * Get paywall mode based on StoryPass eligibility.
   * - For existing stories: uses persisted state.storypassEligible (immutable per-story)
   * - For setup (no story yet): uses isStorypassAllowed() based on current selections
   * @returns {'unlock' | 'sub_only'}
   */
  function getPaywallMode() {
    // If story exists (storypassEligible is defined), use persisted value
    if (state.storypassEligible !== undefined) {
      return state.storypassEligible ? 'unlock' : 'sub_only';
    }
    // No story yet - check current selections
    return isStorypassAllowed() ? 'unlock' : 'sub_only';
  }
  window.getPaywallMode = getPaywallMode;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY SHAPE SNAPSHOT â€” Begin/Continue Story Logic
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Tracks story-defining inputs to determine if story should regenerate.
  //
  // STORY-DEFINING INPUTS (included in snapshot):
  //   - world, genre, tone, dynamic, pov, worldSubtype
  //   - archetype.primary, archetype.modifier
  //
  // RUNTIME MODIFIERS (EXCLUDED â€” do NOT invalidate story):
  //   - intensity (arousal level)
  //   - storyLength (especially Dirty/Soulmates)
  //
  // BEHAVIOR:
  //   - Snapshot matches â†’ "Continue Story" (navigate only, no generation)
  //   - Snapshot differs â†’ "Begin Story" (generate new story)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Compute the current story shape snapshot.
   * ONLY includes story-defining inputs, NOT runtime modifiers.
   */
  function computeStoryShapeSnapshot() {
    return {
      // Four-axis selections (story-defining)
      world: state.picks?.world || null,
      genre: state.picks?.genre || null,
      tone: state.picks?.tone || null,
      dynamic: state.picks?.dynamic || null,
      pov: state.picks?.pov || null,
      worldSubtype: state.picks?.worldSubtype || null,
      // Archetype selections (story-defining)
      archetypePrimary: state.archetype?.primary || null,
      archetypeModifier: state.archetype?.modifier || null
      // NOTE: intensity and storyLength are EXCLUDED â€” they are runtime modifiers
    };
  }

  /**
   * Compare two story shape snapshots for deep equality.
   * Returns true if snapshots match (same story shape).
   */
  function compareShapeSnapshots(a, b) {
    if (!a || !b) return false;
    const keys = ['world', 'genre', 'tone', 'dynamic', 'pov', 'worldSubtype', 'archetypePrimary', 'archetypeModifier'];
    for (const key of keys) {
      if (a[key] !== b[key]) return false;
    }
    return true;
  }

  /**
   * Check if current story shape matches the last generated story.
   * Returns true if "Continue Story" should be shown.
   */
  function canContinueExistingStory() {
    // Must have an existing story
    if (!state.storyId) return false;
    // Must have a stored snapshot
    if (!state._lastGeneratedShapeSnapshot) return false;
    // Compare current shape to stored snapshot
    const currentSnapshot = computeStoryShapeSnapshot();
    return compareShapeSnapshots(currentSnapshot, state._lastGeneratedShapeSnapshot);
  }

  /**
   * Store the current story shape as the last generated snapshot.
   * Called when a new story is created.
   */
  function storeGeneratedShapeSnapshot() {
    state._lastGeneratedShapeSnapshot = computeStoryShapeSnapshot();
    console.log('[STORY:SHAPE] Snapshot stored:', state._lastGeneratedShapeSnapshot);
  }

  /**
   * Reset Guided Fate card visual state (dim/disabled appearance).
   * Called when story shape is invalidated to allow re-use.
   * Does NOT reset Fate logic, counters, or usage limits.
   */
  function resetGuidedFateVisualState() {
    const fateCard = $('fateDestinyCard');
    if (fateCard) {
      fateCard.dataset.fateUsed = 'false';
      fateCard.style.opacity = '1';
      fateCard.style.pointerEvents = 'auto';
    }
  }

  /**
   * Invalidate the stored snapshot (forces "Begin Story" on next check).
   * Called when story-defining inputs change.
   */
  function invalidateShapeSnapshot() {
    if (state._lastGeneratedShapeSnapshot) {
      console.log('[STORY:SHAPE] Snapshot invalidated â€” story-defining input changed');
      state._lastGeneratedShapeSnapshot = null;
      updateBeginButtonLabel();
      // Re-enable Guided Fate card when shape changes (allows re-use for new shape)
      resetGuidedFateVisualState();
    }
  }

  /**
   * Update the Begin Story button label based on snapshot state.
   * Also toggles passive save affordance hints.
   */
  function updateBeginButtonLabel() {
    const beginBtn = $('beginBtn');
    const btnBeginStory = $('btnBeginStory');
    const btnSettingBeginStory = $('btnSettingBeginStory');
    const continueFromDynamic = $('continueFromDynamic');

    const canContinue = canContinueExistingStory();
    const label = canContinue ? 'Continue Story' : 'Begin Story';

    // Update all button labels
    if (beginBtn) beginBtn.textContent = label;
    if (btnBeginStory) btnBeginStory.textContent = label;
    if (btnSettingBeginStory) btnSettingBeginStory.textContent = label;
    if (continueFromDynamic) continueFromDynamic.textContent = label;

    // Toggle passive save affordance hints
    const hints = [
      $('beginBtnHint'),
      $('btnBeginStoryHint'),
      $('btnSettingBeginStoryHint'),
      $('continueFromDynamicHint')
    ];
    hints.forEach(hint => {
      if (hint) {
        if (canContinue) {
          hint.classList.remove('hidden');
        } else {
          hint.classList.add('hidden');
        }
      }
    });

    console.log('[STORY:SHAPE] Button label updated:', label, '| canContinue:', canContinue);
  }

  // Expose for external modules
  window.invalidateShapeSnapshot = invalidateShapeSnapshot;
  window.updateBeginButtonLabel = updateBeginButtonLabel;
  window.canContinueExistingStory = canContinueExistingStory;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY STATE LOCKING â€” Destructive Change Protection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // LOCKED FIELDS (changing destroys story AND cover):
  // - pressure, world, tone, dynamic, genre
  // - pov, worldSubtype, flavor
  //
  // SAFE FIELDS (can change without destroying story/cover):
  // - intensity (arousal level) â€” COVER EVOLVES, NOT DESTROYED
  // - storyLength
  // - archetype (affects framing, not story)
  // - character names (cosmetic)
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER PERSISTENCE & RESET AUTHORITY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // COVER IS BOUND TO:
  //   âœ“ Story ID
  //   âœ“ Story Shape (world, tone, pressure, dynamic)
  //   âœ“ Characters (names + roles)
  //   âœ“ Storyturn progression
  //   âœ“ Arousal tier (for overlay evolution)
  //
  // COVER IS NOT BOUND TO:
  //   âœ— UI navigation
  //   âœ— User curiosity
  //   âœ— Accidental back clicks
  //
  // NAVIGATION BEHAVIOR:
  //   If user navigates BACK to Story Shape/Setting/Cover AND story exists:
  //   â†’ Story PAUSES (does not reset)
  //   â†’ Button shows "Continue Story"
  //   â†’ Cover REMAINS visible
  //   â†’ Guided Fate remains DISABLED
  //   â†’ NO regeneration occurs
  //
  // AROUSAL EXCEPTION (ONLY EXCEPTION):
  //   User MAY change arousal level WITHOUT destroying cover.
  //   â†’ Cover may EVOLVE (border â†” keyhole)
  //   â†’ Core visual idea MUST remain unchanged
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Fields that are locked once a story exists (changing destroys story AND cover)
  const STORY_LOCKED_FIELDS = ['pressure', 'world', 'tone', 'dynamic', 'genre', 'pov', 'worldSubtype', 'flavor'];

  // Fields that can change without destroying cover (cover evolves instead)
  const COVER_SAFE_FIELDS = ['intensity', 'storyLength', 'archetype'];

  // Pending destructive change (stored while modal is shown)
  let pendingDestructiveChange = null;

  /**
   * Check if a story currently exists (Scene 1 has been generated)
   * @returns {boolean}
   */
  function hasExistingStory() {
    // Story exists if we have a storyId AND content
    if (!state.storyId) return false;
    if (typeof StoryPagination !== 'undefined' && StoryPagination.getAllContent) {
      const content = StoryPagination.getAllContent();
      return content && content.trim().length > 0;
    }
    return state.turnCount > 0;
  }

  /**
   * Check if a field is locked (changing it would destroy the story)
   * @param {string} grp - The field/group being changed
   * @returns {boolean}
   */
  function isLockedField(grp) {
    return STORY_LOCKED_FIELDS.includes(grp);
  }

  /**
   * Check if a change would be destructive (story exists + locked field)
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {boolean}
   */
  function wouldDestroyStory(grp, newVal) {
    if (!hasExistingStory()) return false;
    if (!isLockedField(grp)) return false;
    // Check if actually changing to a different value
    const currentVal = state.picks[grp];
    return currentVal !== newVal;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER PERSISTENCE VALIDATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Check if a cover currently exists
   * @returns {boolean}
   */
  function hasExistingCover() {
    return state.coverGenerated === true || state.primaryCoverId != null;
  }

  /**
   * Check if a change would destroy the cover
   * Covers are destroyed when story is destroyed (same locked fields)
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {boolean}
   */
  function wouldDestroyCover(grp, newVal) {
    if (!hasExistingCover()) return false;
    // Cover is destroyed when story is destroyed
    return wouldDestroyStory(grp, newVal);
  }

  /**
   * Check if a change would cause cover evolution (not destruction)
   * Only arousal changes cause evolution, not destruction.
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {boolean}
   */
  function wouldEvolveCover(grp, newVal) {
    // Intensity no longer causes cover evolution
    return false;
  }

  /**
   * Get cover persistence status for a potential change
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @returns {{persists: boolean, evolves: boolean, destroys: boolean, reason: string}}
   */
  function getCoverPersistenceStatus(grp, newVal) {
    if (!hasExistingCover()) {
      return { persists: false, evolves: false, destroys: false, reason: 'No cover exists' };
    }

    if (wouldDestroyCover(grp, newVal)) {
      return {
        persists: false,
        evolves: false,
        destroys: true,
        reason: `Changing ${grp} destroys cover (locked field)`
      };
    }

    if (wouldEvolveCover(grp, newVal)) {
      return {
        persists: true,
        evolves: true,
        destroys: false,
        reason: `Changing arousal from ${state.intensity} to ${newVal} â€” cover evolves`
      };
    }

    return {
      persists: true,
      evolves: false,
      destroys: false,
      reason: 'Field is safe â€” cover persists unchanged'
    };
  }

  // Export cover persistence functions
  window.hasExistingCover = hasExistingCover;
  window.wouldDestroyCover = wouldDestroyCover;
  window.wouldEvolveCover = wouldEvolveCover;
  window.getCoverPersistenceStatus = getCoverPersistenceStatus;

  /**
   * Show the destructive change warning modal
   * @param {string} grp - The field being changed
   * @param {string} newVal - The new value
   * @param {HTMLElement} card - The card element being clicked
   * @param {Function} onConfirm - Callback if user confirms
   */
  function showDestructiveChangeWarning(grp, newVal, card, onConfirm) {
    pendingDestructiveChange = { grp, newVal, card, onConfirm };

    const modal = document.getElementById('destructiveChangeModal');
    if (modal) {
      modal.classList.remove('hidden');
    }
  }

  /**
   * Hide the destructive change warning modal
   */
  function hideDestructiveChangeWarning() {
    const modal = document.getElementById('destructiveChangeModal');
    if (modal) {
      modal.classList.add('hidden');
    }
    pendingDestructiveChange = null;
  }

  /**
   * Handle "Save & Start New Story" button
   */
  function handleSaveAndStartNew() {
    if (!pendingDestructiveChange) return;

    // Save current story first
    if (typeof saveCurrentStory === 'function') {
      saveCurrentStory().then(() => {
        proceedWithDestructiveChange();
      }).catch(err => {
        console.error('[STORY:LOCK] Save failed:', err);
        showToast('Failed to save story. Please try again.');
      });
    } else {
      // Fallback: just proceed
      proceedWithDestructiveChange();
    }
  }

  /**
   * Handle "Start New Story" button (no save)
   */
  function handleStartNewNoSave() {
    if (!pendingDestructiveChange) return;
    proceedWithDestructiveChange();
  }

  /**
   * Execute the destructive change after confirmation
   */
  function proceedWithDestructiveChange() {
    if (!pendingDestructiveChange) return;

    const { grp, newVal, card, onConfirm } = pendingDestructiveChange;

    // Clear story state
    clearStoryForNewStart();

    // Hide modal
    hideDestructiveChangeWarning();

    // Execute the original selection
    if (onConfirm) {
      onConfirm(grp, newVal, card);
    }

    console.log('[STORY:LOCK] Destructive change confirmed, story cleared');
  }

  /**
   * Clear all story state for a fresh start
   */
  function clearStoryForNewStart() {
    // TEASE TIER: Prevent story reset unless user has upgraded
    if (isTeaseTier() && state.freeStoryConsumed && !hasTeaseUnlockCondition()) {
        console.warn('[TEASE] Story reset blocked â€” free story consumed, no unlock condition');
        window.showPaywall('unlock');
        return;
    }
    // Clear story identifiers
    state.storyId = null;
    state.turnCount = 0;
    state._loggedStoryStart = false;
    state._loggedScene3 = false;
    state._loggedScene6 = false;
    state._loggedPetitionOpen = false;
    state._loggedPetitionSubmit = false;
    state.storyEnded = false;
    state._lastGeneratedShapeSnapshot = null;
    state.cautiousStreak = 0;
    state.dynamicDominanceBoost = 0;
    state.vulnerabilityPulse = 0;
    state.lastDreamInjectionTurn = 0;
    state._dreamInjectionLine = null;
    state.selectionTension = 0;
    state.lastSelectionEchoTurn = 0;
    state._selectionEchoLine = null;
    state.coupleTensionDrift = 0;
    state.coupleStructure = 'monogamous';
    state.coupleHasReachedST4 = false;
    state.lastCoupleDriftEchoScene = 0;
    state._coupleDriftEchoLine = null;
    _coupleStructureVotes = { player1: null, player2: null };

    // Clear story content
    if (typeof clearStoryContent === 'function') {
      clearStoryContent();
    } else {
      state.currentStoryContent = '';
      state.storyHistory = [];
      localStorage.removeItem('sb_saved_story');
      if (typeof StoryPagination !== 'undefined' && StoryPagination.clear) {
        StoryPagination.clear();
      }
      const storyEl = document.getElementById('storyText');
      if (storyEl) storyEl.innerHTML = '';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COVER DESTRUCTION (bound to story state)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Cover is destroyed when story is destroyed.
    // This is NOT reversible. Core visual idea is lost.
    const hadCover = state.coverGenerated || state.primaryCoverId;
    if (typeof resetCoverLayers === 'function') {
      resetCoverLayers();
    }
    state.coverGenerated = false;
    state.primaryCoverId = null;
    state.coverCoreIdea = null; // Clear the core visual idea
    if (hadCover) {
      console.log('[COVER:DESTROY] Cover destroyed â€” story state invalidated');
    }

    // Reset Guided Fate (becomes ACTIVE again after story destruction)
    if (typeof resetGuidedFateVisualState === 'function') {
      resetGuidedFateVisualState();
    }

    // Reset breadcrumb flow if in use
    if (typeof resetBreadcrumbFlow === 'function') {
      resetBreadcrumbFlow();
    }

    // Clear current story ID from storage
    clearCurrentStoryId();

    // Update button label
    updateBeginButtonLabel();

    console.log('[STORY:LOCK] Story and cover state cleared for new start');
  }

  /**
   * Initialize destructive change modal handlers
   */
  function initDestructiveChangeModal() {
    const btnSave = document.getElementById('btnSaveAndStartNew');
    const btnNoSave = document.getElementById('btnStartNewNoSave');
    const btnCancel = document.getElementById('btnCancelDestructive');

    if (btnSave) {
      btnSave.addEventListener('click', handleSaveAndStartNew);
    }
    if (btnNoSave) {
      btnNoSave.addEventListener('click', handleStartNewNoSave);
    }
    if (btnCancel) {
      btnCancel.addEventListener('click', hideDestructiveChangeWarning);
    }

    // Close on backdrop click
    const modal = document.getElementById('destructiveChangeModal');
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          hideDestructiveChangeWarning();
        }
      });
    }
  }

  // Expose functions globally
  window.hasExistingStory = hasExistingStory;
  window.wouldDestroyStory = wouldDestroyStory;
  window.showDestructiveChangeWarning = showDestructiveChangeWarning;
  window.hideDestructiveChangeWarning = hideDestructiveChangeWarning;
  window.clearStoryForNewStart = clearStoryForNewStart;
  window.initDestructiveChangeModal = initDestructiveChangeModal;

  function clearCurrentStoryId(){ localStorage.removeItem('sb_current_story_id'); }
  // CORRECTIVE: IndexedDB for large story data when localStorage fails
  const STORY_DB_NAME = 'StoryBoundDB';
  const STORY_DB_VERSION = 1;
  const STORY_STORE_NAME = 'stories';

  function openStoryDB() {
      return new Promise((resolve, reject) => {
          if (!window.indexedDB) {
              reject(new Error('IndexedDB not supported'));
              return;
          }
          const request = indexedDB.open(STORY_DB_NAME, STORY_DB_VERSION);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains(STORY_STORE_NAME)) {
                  db.createObjectStore(STORY_STORE_NAME, { keyPath: 'id' });
              }
          };
      });
  }

  async function saveToIndexedDB(snapshot) {
      try {
          const db = await openStoryDB();
          const tx = db.transaction(STORY_STORE_NAME, 'readwrite');
          const store = tx.objectStore(STORY_STORE_NAME);
          await new Promise((resolve, reject) => {
              const req = store.put({ id: 'current_story', ...snapshot });
              req.onsuccess = resolve;
              req.onerror = () => reject(req.error);
          });
          db.close();
          localStorage.setItem('sb_story_in_idb', '1');
          return true;
      } catch (e) {
          console.error('IndexedDB save failed', e);
          return false;
      }
  }

  async function loadFromIndexedDB() {
      try {
          const db = await openStoryDB();
          const tx = db.transaction(STORY_STORE_NAME, 'readonly');
          const store = tx.objectStore(STORY_STORE_NAME);
          const data = await new Promise((resolve, reject) => {
              const req = store.get('current_story');
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
          });
          db.close();
          return data;
      } catch (e) {
          console.error('IndexedDB load failed', e);
          return null;
      }
  }

  function hasSavedStory() {
      return !!localStorage.getItem('sb_saved_story') || localStorage.getItem('sb_story_in_idb') === '1';
  }

  function saveStorySnapshot(){
    const el = document.getElementById('storyText');
    if(!el) return;
    const currentWc = currentStoryWordCount();
    if (currentWc > state.lastSavedWordCount) {
        const globalWc = Number(localStorage.getItem('sb_global_word_count') || 0);
        try {
            localStorage.setItem('sb_global_word_count', globalWc + (currentWc - state.lastSavedWordCount));
        } catch(e) { console.warn('Word count save failed', e); }
        state.lastSavedWordCount = currentWc;
    }
    // Create clean state snapshot without heavy data
    const cleanState = { ...state };
    // Prevent storing large visual bible data that causes QuotaExceededError
    if (cleanState.visual) {
        cleanState.visual = {
            ...cleanState.visual,
            lastImageUrl: '', // Don't persist images
            bible: { style: cleanState.visual.bible?.style || '', setting: cleanState.visual.bible?.setting || '', characters: {} }
        };
    }
    // CORRECTIVE: Remove sysPrompt from state snapshot (it's stored separately)
    delete cleanState.sysPrompt;

    const snapshot = {
      storyId: state.storyId,
      subscribed: !!state.subscribed,
      tier: state.tier,
      sysPrompt: state.sysPrompt,
      title: document.getElementById('storyTitle')?.textContent || '',
      synopsis: state._synopsisMetadata || '', // Metadata only, never rendered
      storyHTML: StoryPagination.getAllContent(),  // Full content for fallback
      storyPages: StoryPagination.getPages(),       // Individual pages for pagination
      stateSnapshot: cleanState,
      updated_at: new Date().toISOString()
    };

    // CORRECTIVE: Try localStorage first, fall back to IndexedDB on quota error
    try {
        // Remove old data first to free space
        localStorage.removeItem('sb_saved_story');
        localStorage.removeItem('sb_story_in_idb');
        localStorage.setItem('sb_saved_story', JSON.stringify(snapshot));
    } catch(e) {
        // QuotaExceededError - try IndexedDB
        console.warn('localStorage quota exceeded, trying IndexedDB...', e);
        try {
            localStorage.removeItem(SB_ANALYTICS_KEY); // Free space
            localStorage.removeItem('sb_saved_story');
        } catch(e2) { /* ignore */ }

        // Save to IndexedDB asynchronously
        saveToIndexedDB(snapshot).then(success => {
            if (success) {
                console.log('Story saved to IndexedDB');
            } else {
                showToast('Save failed. Storage full.');
            }
        });
    }
    updateContinueButtons();

    // Supabase parallel save (non-blocking, fire-and-forget)
    if (sb && _supabaseProfileId && state.storyId) {
      saveStorySnapshotToSupabase(_supabaseProfileId, state.storyId, snapshot);
    }
  }

  window.saveStoryManual = saveStorySnapshot;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SUPABASE STORY SNAPSHOT PERSISTENCE (Phase 1)
  // Parallel write alongside localStorage. Never blocks UI.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async function saveStorySnapshotToSupabase(profileId, storyId, snapshot) {
    try {
      const { error } = await sb
        .from('story_snapshots')
        .upsert({
          profile_id: profileId,
          story_id: storyId,
          snapshot: snapshot,
          updated_at: snapshot.updated_at || new Date().toISOString()
        }, {
          onConflict: 'profile_id,story_id'
        });
      if (error) {
        console.error('[Supabase] Snapshot save failed:', error.message);
      } else {
        console.log('[Supabase] Snapshot saved for story:', storyId);
      }
    } catch (err) {
      console.error('[Supabase] Snapshot save error:', err);
    }
  }

  async function loadSupabaseSnapshot(profileId, storyId) {
    try {
      const { data, error } = await sb
        .from('story_snapshots')
        .select('snapshot, updated_at')
        .eq('profile_id', profileId)
        .eq('story_id', storyId)
        .maybeSingle();
      if (error) {
        console.error('[Supabase] Snapshot load failed:', error.message);
        return null;
      }
      return data; // { snapshot, updated_at } or null
    } catch (err) {
      console.error('[Supabase] Snapshot load error:', err);
      return null;
    }
  }

  // CORRECTIVE: Load story data from localStorage or IndexedDB
  async function loadStoryData() {
      // Try localStorage first
      const raw = localStorage.getItem('sb_saved_story');
      if (raw) {
          try {
              return JSON.parse(raw);
          } catch (e) {
              console.warn('Failed to parse localStorage story', e);
          }
      }
      // Try IndexedDB if localStorage failed
      if (localStorage.getItem('sb_story_in_idb') === '1') {
          const idbData = await loadFromIndexedDB();
          if (idbData) return idbData;
      }
      return null;
  }

  window.continueStory = async function(){
    let data = await loadStoryData();
    if (!data) {
        showToast('No saved story found.');
        return;
    }

    // Supabase snapshot merge: if remote is newer, replace local data
    if (sb && _supabaseProfileId && data.storyId) {
      try {
        const remote = await loadSupabaseSnapshot(_supabaseProfileId, data.storyId);
        if (remote?.snapshot && remote.updated_at) {
          const localTime = data.updated_at ? new Date(data.updated_at).getTime() : 0;
          const remoteTime = new Date(remote.updated_at).getTime();
          if (remoteTime > localTime) {
            console.log('[Supabase] Remote snapshot is newer, using it');
            data = remote.snapshot;
          }
        }
      } catch (err) {
        console.error('[Supabase] Snapshot merge check failed:', err);
      }
    }

    state.storyId = data.storyId || makeStoryId();
    localStorage.setItem('sb_current_story_id', state.storyId);

    if(data.stateSnapshot) Object.assign(state, data.stateSnapshot);
    // Canonicalize legacy tone values from saved state
    if (state.picks?.tone) state.picks.tone = canonicalizeTone(state.picks.tone);
    deriveToneBias();
    state.sysPrompt = data.sysPrompt || state.sysPrompt;
    state.subscribed = !!data.subscribed;
    // (authorChairActive removed â€” Petition Fate replaces quill)

    updateBatedBreathState();
    applyAccessLocks();

    document.getElementById('storyTitle').textContent = data.title || '';
    // BOOK FLOW SPEC: Synopsis is metadata only, never rendered
    // Inside cover = blank paper, Setting plate = visual only
    state._synopsisMetadata = data.synopsis || '';

    // Load story into pagination system
    StoryPagination.clear();
    if (data.storyPages && Array.isArray(data.storyPages) && data.storyPages.length > 0) {
        // Load saved pages
        StoryPagination.setPages(data.storyPages);
    } else if (data.storyHTML) {
        // Fallback: load as single page
        StoryPagination.addPage(data.storyHTML, true);
    }
    state.lastSavedWordCount = currentStoryWordCount();

    // Setting shot removed from auto-load - requires explicit user action

    window.showScreen('game');
    if (state.fateOptions && state.fateOptions.length) state.fateOptions = filterFateCardsForBatedBreath(state.fateOptions);
    // FIX: Use dealFateCards (not initCards) to get clickable, flippable cards with handlers
    if(window.dealFateCards) window.dealFateCards();
    else if(window.initCards) window.initCards();
    // REBIND: Ensure FX handlers are attached after navigation
    if (window.initFateCards) window.initFateCards();
    resetTurnSnapshotFlag();

    // EARNED COVER SYSTEM: Update cover button for continued story
    _lastNotifiedCoverStage = getCurrentCoverStage();
    updateReaderCoverButton();

    // BOOK COMPLETE: If restored story was completed, re-show End Page
    if (state.book_complete && state.storyEnded) {
        showStoryEndPage();
    }
  };

  function updateContinueButtons(){
    const show = hasSavedStory();
    const btn1 = document.getElementById('continueStoryBtn');
    const btn2 = document.getElementById('continueFromTierBtn');
    if(btn1) btn1.classList.toggle('hidden', !show);
    if(btn2) btn2.classList.toggle('hidden', !show);
  }

  window.restart = function(){
    // TEASE TIER: Prevent restart unless user has upgraded
    if (isTeaseTier() && state.freeStoryConsumed && !hasTeaseUnlockCondition()) {
        console.warn('[TEASE] Restart blocked â€” free story consumed, no unlock condition');
        window.showPaywall('unlock');
        return;
    }
    if(state.mode === 'couple') window.coupleCleanup();
    if (window.stopSparkleCycle) window.stopSparkleCycle(); // Clear any active fate card sparkles
    state.mode = 'solo';
    // Preserve storyId on restart â€” only "New Story" flows generate new storyIds
    // clearCurrentStoryId() and storyId null intentionally omitted
    state.access = state.subscribed ? 'sub' : 'free';
    syncTierFromAccess();
    localStorage.removeItem('sb_saved_story');
    // Reset state
    state.turnCount = 0;
    state._loggedStoryStart = false;
    state._loggedScene3 = false;
    state._loggedScene6 = false;
    state._loggedPetitionOpen = false;
    state._loggedPetitionSubmit = false;
    state.storyLength = 'taste';
    state.storyEnded = false;
    state.archetype = { primary: 'BEAUTIFUL_RUIN', modifier: null };

    // FIX: Full 4-axis + world state reset (prevents Ash Quarter / Warden-Cadre leak)
    state.picks = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', era: 'Medieval', pov: 'First' };
    state.intensity = 'Steamy';
    state.storypassEligible = undefined; // Reset - will be computed at story creation
    state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} }, sceneBudgets: {} };
    // SPECULATIVE PRELOAD: Reset on restart
    state.speculativeNextScene = null;
    state.isPreloadingNextScene = false;
    state.coverArchetype = null;
    state.lenses = [];
    state.withheldCoreVariant = null;
    state.normalizedPlayerKernel = null;
    state.normalizedPartnerKernel = null;
    state.rawPlayerName = null;
    state.rawPartnerName = null;
    // Reset story shape snapshot (forces "Begin Story" on new session)
    state._lastGeneratedShapeSnapshot = null;

    // FIX: Cover regeneration reset â€” allow new cover without hard refresh
    if (_coverAbortController) { _coverAbortController.abort(); _coverAbortController = null; }
    resetBookState();
    // Reset DSP state for fresh intro/placeholder cycle
    if (typeof resetDSPState === 'function') resetDSPState();
    const coverImg = document.getElementById('bookCoverImg');
    if (coverImg) coverImg.src = '';
    const coverLoading = document.getElementById('coverLoadingState');
    if (coverLoading) coverLoading.classList.add('hidden');
    const bookObj = document.getElementById('bookObject');
    if (bookObj) bookObj.classList.add('hidden');
    if (_coverPhraseInterval) { clearInterval(_coverPhraseInterval); _coverPhraseInterval = null; }
    if (_coverProgressInterval) { clearInterval(_coverProgressInterval); _coverProgressInterval = null; }

    // Reset card UI to match default state
    const cardDefaults = { world: 'Modern', tone: 'Earnest', genre: 'Billionaire', dynamic: 'Enemies', intensity: 'Steamy', length: 'taste', pov: 'First' };
    Object.entries(cardDefaults).forEach(([grp, val]) => {
        document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
            c.classList.remove('selected', 'flipped');
        });
        const def = document.querySelector(`.sb-card[data-grp="${grp}"][data-val="${val}"]`);
        if (def) def.classList.add('selected', 'flipped');
    });

    // Reset name inputs
    const pInput = $('playerNameInput');
    if (pInput) pInput.value = '';
    const lInput = $('partnerNameInput');
    if (lInput) lInput.value = '';

    // Clear pagination system
    StoryPagination.clear();
    // Re-render archetype cards to show default selection
    if (typeof renderArchetypeCards === 'function') renderArchetypeCards();
    if (typeof updateArchetypeSelectionSummary === 'function') updateArchetypeSelectionSummary();

    // PASS 9E: Reset fate card state
    const fateCard = $('fateDestinyCard');
    if (fateCard) {
        fateCard.dataset.fateUsed = 'false';
        fateCard.style.opacity = '1';
        fateCard.style.pointerEvents = 'auto';
        fateCard.classList.remove('flipped');
    }

    updateContinueButtons();
    window.showScreen('setup');
    // FIX: Explicit lock re-application ensures intensity cards reflect current access tier
    applyAccessLocks();
    applyIntensityLocks();
    updateBatedBreathState();
  };

  window.changeTier = function(){ window.showScreen('tierGate'); };

  $('saveBtn')?.addEventListener('click', (e) => {
      const hasAccess = (window.state.access !== 'free') || (window.state.mode === 'couple');
      if (!hasAccess) {
          e.stopPropagation();
          // CANONICAL: Use story metadata for paywall mode (persisted, immutable per-story)
          window.showPaywall(getPaywallMode());
          return;
      }
      saveStorySnapshot();
      showToast("Story saved.");
  });

  // (Quill & Veto game modal handlers removed â€” replaced by Petition Fate)


  // Petition Fate submit handler (old modal fallback path)
  // â”€â”€ Petition: Seal handler â”€â”€
  $('btnSealPetition')?.addEventListener('click', () => {
      const input = document.getElementById('petitionInput');
      const text = input?.value?.trim();
      if (!text) return;

      // Validate petition text
      const validation = validatePetitionText(text);
      if (!validation.valid) {
          if (typeof showToast === 'function') showToast('You feel a deafening silence.');
          return;
      }

      const classification = classifyPetition(text);

      // Structural override plausibility gate
      if (classification === 'structural_override') {
          const soCheck = validateStructuralOverride(text);
          if (!soCheck.valid) {
              if (typeof showToast === 'function') showToast('You feel a deafening silence.');
              return;
          }
      }

      // Enforce 1 petition per scene
      if (state.petitionUsedThisScene) {
          if (typeof showToast === 'function') showToast('You have already petitioned Fate this scene.');
          return;
      }

      const isGreater = classification !== 'general' && classification !== 'structural_override';

      if (!isGreater && state.fate?.minorUsedThisScene) {
          if (typeof showToast === 'function') showToast('You have already petitioned Fate this scene.');
          return;
      }
      if (isGreater && state.fate?.greaterUsedThisScene) {
          if (typeof showToast === 'function') showToast('A greater petition has already been made this scene.');
          return;
      }

      // Set per-scene flags
      state.petitionUsedThisScene = true;
      if (!isGreater) state.fate.minorUsedThisScene = true;
      if (isGreater) {
          state.fate.greaterUsedThisScene = true;
          state.fate.lastGreaterSceneIndex = state.turnCount;
      }
      const stIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
      if (isGreater && stIdx < 4) {
          state.fate.earlyGamingCount++;
      }

      // Activate volatility window â€” skip for structural overrides (cosmetic, no world distortion)
      if (classification !== 'structural_override') {
          const severity = computeTemptFateSeverity();
          state.volatility_window = {
              active: true,
              severity,
              remaining_scenes: severity < 0.5 ? 1 : severity < 0.8 ? 2 : 3,
              source: 'petition'
          };
      }

      // Stage petition â€” outcome resolved at Submit time (0 favors from old modal)
      state.fate.pendingPetition = { text, classification, favorsOffered: 0, accepted: null };

      // Invalidate speculative scene
      if (typeof invalidateSpeculativeScene === 'function') invalidateSpeculativeScene();

      // Show result
      const resultEl = document.getElementById('petitionResult');
      if (resultEl) {
          resultEl.textContent = 'Your petition has been sealed.';
          resultEl.classList.remove('hidden');
          resultEl.classList.add('fade-in');
      }

      input.readOnly = true;
      const sealBtn = $('btnSealPetition');
      if (sealBtn) { sealBtn.disabled = true; sealBtn.classList.add('hidden'); }

      setTimeout(() => {
          document.getElementById('petitionFateModal')?.classList.add('hidden');
          enableTurnControls();
      }, 1500);
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VAULT MENU â€” Tab panel interaction handlers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function resetVaultState() {
      document.querySelector('.vault-panel')?.classList.remove('hidden');
      document.querySelectorAll('.vault-sub').forEach(s => s.classList.add('hidden'));
  }

  // Burger open â†’ reset vault to main panel, then show overlay
  $('burgerBtn')?.addEventListener('click', () => {
      try { if (typeof renderBurgerMenu === 'function') renderBurgerMenu(); } catch(e) { console.warn('[Burger] renderBurgerMenu error:', e); }
      const overlay = document.getElementById('menuOverlay');
      if (overlay) {
          resetVaultState();
          overlay.classList.remove('hidden');
      }
  });

  // Tab click â†’ hide main panel, show matching sub-panel
  document.querySelectorAll('.vault-tab').forEach(tab => {
      tab.addEventListener('click', () => {
          const section = tab.dataset.vaultSection;
          document.querySelector('.vault-panel')?.classList.add('hidden');
          const sub = document.getElementById('vault' + section);
          if (sub) sub.classList.remove('hidden');
      });
  });

  // Back buttons â†’ hide all sub-panels, show main panel
  document.querySelectorAll('.vault-back').forEach(btn => {
      btn.addEventListener('click', () => {
          resetVaultState();
      });
  });

  // Close button
  $('vaultCloseBtn')?.addEventListener('click', () => {
      document.getElementById('menuOverlay')?.classList.add('hidden');
      resetVaultState();
  });

  // Profile button
  $('menuProfileBtn')?.addEventListener('click', () => {
      document.getElementById('menuOverlay')?.classList.add('hidden');
      resetVaultState();
      if (typeof closeTrophyWall === 'function') closeTrophyWall();
      openProfileModal();
  });

  // Library button â€” close Vault, navigate to full-screen Vault Library
  let _preVaultScreenId = null; // Track screen before Vault Library/Achievements
  $('menuLibraryBtn')?.addEventListener('click', () => {
      _preVaultScreenId = _currentScreenId;
      document.getElementById('menuOverlay')?.classList.add('hidden');
      resetVaultState();
      window.showScreen('vaultLibraryScreen');
      loadVaultLibrary();
  });


  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FORBIDDEN LIBRARY â€” Vertical book list, read-only mode, bookmarks
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _libraryEntries = [];
  let _libraryLoaded = false;
  state.libraryMode = false;

  // â€” Load library entries from Supabase â€”
  async function loadLibraryEntries() {
    if (!sb) {
      _showLibraryEmpty('Library unavailable');
      return;
    }
    const loadingEl = $('forbiddenLibraryLoading');
    const listEl = $('forbiddenLibraryList');
    const emptyEl = $('forbiddenLibraryEmpty');
    if (loadingEl) loadingEl.style.display = '';
    if (listEl) listEl.style.display = 'none';
    if (emptyEl) emptyEl.style.display = 'none';

    try {
      const { data, error } = await sb
        .from('library_entries')
        .select('story_id, title, author, scene_count, word_count')
        .eq('eligible', true)
        .order('updated_at', { ascending: false })
        .limit(50);

      if (error) {
        console.error('[Library] Query failed:', error.message);
        _showLibraryEmpty('Failed to load library');
        return;
      }

      _libraryEntries = data || [];
      _libraryLoaded = true;

      if (_libraryEntries.length === 0) {
        _showLibraryEmpty();
        return;
      }

      renderLibraryList();
    } catch (err) {
      console.error('[Library] Load error:', err);
      _showLibraryEmpty('Failed to load library');
    }
  }

  function _showLibraryEmpty(msg) {
    const loadingEl = $('forbiddenLibraryLoading');
    const listEl = $('forbiddenLibraryList');
    const emptyEl = $('forbiddenLibraryEmpty');
    if (loadingEl) loadingEl.style.display = 'none';
    if (listEl) listEl.style.display = 'none';
    if (emptyEl) {
      emptyEl.style.display = '';
      if (msg) {
        const p = emptyEl.querySelector('.forbidden-library-empty');
        if (p) p.textContent = msg;
      }
    }
  }

  // Collector's Edition threshold (scene count)
  const COLLECTOR_EDITION_THRESHOLD = 40;

  // â€” Render 3D book shelf â€”
  function renderLibraryList() {
    const loadingEl = $('forbiddenLibraryLoading');
    const listEl = $('forbiddenLibraryList');
    if (loadingEl) loadingEl.style.display = 'none';
    if (!listEl) return;
    listEl.style.display = '';
    listEl.innerHTML = '';

    // Determine forward-facing capacity (evaluated once per render)
    const MAX_FORWARD = window.innerWidth > 1400 ? 8 :
                        window.innerWidth > 1100 ? 6 :
                        window.innerWidth > 900  ? 4 :
                        window.innerWidth > 600  ? 3 :
                        2;

    // Priority sort: collector first, then highest scene_count, then most recent
    const sorted = _libraryEntries.slice().sort((a, b) => {
      const aCollector = (a.scene_count || 0) >= COLLECTOR_EDITION_THRESHOLD ? 1 : 0;
      const bCollector = (b.scene_count || 0) >= COLLECTOR_EDITION_THRESHOLD ? 1 : 0;
      if (bCollector !== aCollector) return bCollector - aCollector;
      if ((b.scene_count || 0) !== (a.scene_count || 0)) return (b.scene_count || 0) - (a.scene_count || 0);
      return new Date(b.created_at || 0) - new Date(a.created_at || 0);
    });

    sorted.forEach((entry, index) => {
      const bookTitle = entry.title || 'Untitled';
      const bookAuthor = entry.author || 'S. Tory Bound';
      const scenes = entry.scene_count || 0;
      const words = entry.word_count || 0;
      const worldKey = (entry.world || 'modern').toLowerCase();
      const isCollector = scenes >= COLLECTOR_EDITION_THRESHOLD;
      const isForward = index < MAX_FORWARD;

      const book = document.createElement('div');
      book.className = 'library-book initializing' + (isCollector ? ' collector-edition' : '') + (isForward ? ' mode-cover' : ' mode-spine');
      book.dataset.storyId = entry.story_id;
      book.dataset.world = worldKey;
      book.innerHTML = `<div class="book-3d">
  <div class="book-front"><div class="book-front-text"><div class="book-front-title">${escapeHTML(bookTitle)}</div><div class="book-front-author">${escapeHTML(bookAuthor)}</div></div></div>
  <div class="book-back"><div class="back-content"><h3 class="back-title">${escapeHTML(bookTitle)}</h3><p class="back-synopsis">${escapeHTML(bookAuthor)}</p><p class="back-meta">${scenes} scenes Â· ${words.toLocaleString()} words</p></div></div>
  <div class="book-spine"><div class="spine-text">${escapeHTML(bookTitle)} <span class="spine-author">${escapeHTML(bookAuthor)}</span></div></div>
  <div class="book-pages"></div>
  <div class="page-shimmer"></div>
</div>`;

      // Depth variance and lean (deterministic, no randomness)
      const depthVariance = (index % 3) - 1; // -1, 0, 1
      book.style.transform = `translateY(6px) translateZ(${depthVariance * 2}px)`;
      const isMobile = window.innerWidth < 900;
      if (!isMobile && (index % 7 === 0) && isForward) {
        book.classList.add('mode-lean');
      }

      // Hover sound (debounced, one per entry)
      let _hoverPlayed = false;
      book.addEventListener('mouseenter', () => {
        if (!_hoverPlayed) { _hoverPlayed = true; _playLibrarySound('book-hover'); }
      });
      book.addEventListener('mouseleave', () => { _hoverPlayed = false; });

      book.addEventListener('click', (e) => {
        e.stopPropagation();
        _zoomSource = 'forbidden';
        _openLibraryZoom(entry, book);
      });
      listEl.appendChild(book);
    });

    // Remove .initializing after layout pass to enable future transitions
    requestAnimationFrame(() => {
      listEl.querySelectorAll('.library-book.initializing').forEach(b => b.classList.remove('initializing'));
    });
  }

  // â€” Micro sound cue system (muted-safe, non-blocking) â€”
  let _libraryUserInteracted = false;
  document.addEventListener('pointerdown', () => { _libraryUserInteracted = true; }, { once: true });

  function _playLibrarySound(name) {
    if (!_libraryUserInteracted) return;
    try {
      const audio = new Audio(`/assets/audio/${name}.mp3`);
      audio.volume = 0.15;
      audio.play().catch(() => {}); // swallow autoplay errors
    } catch (_) {}
  }

  // â€” Library zoom mode â€”
  let _zoomEntry = null;
  let _zoomRafId = null;
  let _zoomSource = 'forbidden'; // 'forbidden' | 'vault' â€” tracks which shelf opened the zoom

  function _openLibraryZoom(entry, sourceBook) {
    _zoomEntry = entry;
    const overlay = $('libraryZoomOverlay');
    const container = $('zoomBookContainer');
    const readBtn = $('zoomReadBtn');
    if (!overlay || !container) return;

    // Clone book 3D structure into zoom container
    const book3d = sourceBook.querySelector('.book-3d');
    if (!book3d) return;
    container.innerHTML = '';
    const clonedBook = book3d.cloneNode(true);
    // Spine/lean books must open in full cover orientation
    clonedBook.classList.remove('mode-spine');
    clonedBook.classList.remove('mode-lean');
    clonedBook.classList.add('mode-cover');
    clonedBook.style.transform = 'rotateY(0deg)';
    clonedBook.style.width = '';
    container.appendChild(clonedBook);

    // Set CTA text â€” vault-aware
    if (readBtn) {
      if (_zoomSource === 'vault') {
        // Check bookmark existence for progress detection
        readBtn.textContent = entry._hasProgress ? 'Continue Reading' : 'Begin Reading';
      } else {
        readBtn.textContent = 'Read This Story';
      }
    }

    // Show overlay
    overlay.classList.add('active');
    document.body.classList.add('library-zoom-active');
    _playLibrarySound('book-open');

    // References for animation
    const zoomBook = container.querySelector('.book-3d');
    const bookFront = container.querySelector('.book-front');
    const shimmer = container.querySelector('.page-shimmer');

    // Cancel any lingering RAF from a previous zoom
    if (_zoomRafId) { cancelAnimationFrame(_zoomRafId); _zoomRafId = null; }

    // Premium rotation with cubic edge resistance
    const maxRotation = window.innerWidth < 900 ? 140 : 155;
    let targetRotation = 0;
    let currentRotation = 0;

    function onMouseMove(e) {
      if (e.target.closest && e.target.closest('.book-back')) return;
      const rect = container.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const raw = (percent - 0.5) * 2;
      // Ease-out cubic edge resistance â€” feels heavier near extremes
      const curved = raw * (1 - Math.pow(Math.abs(raw), 2));
      targetRotation = curved * maxRotation;
    }

    function animate() {
      currentRotation += (targetRotation - currentRotation) * 0.12;
      if (zoomBook) zoomBook.style.transform = `rotateY(${currentRotation}deg)`;

      // Dynamic front-edge shadow tied to rotation depth
      if (bookFront) {
        const depth = Math.abs(currentRotation) / maxRotation;
        bookFront.style.boxShadow = `inset -14px 0 28px rgba(0,0,0,${(0.25 + depth * 0.25).toFixed(3)})`;
      }

      // Page-edge shimmer past Â±90Â°
      if (shimmer) {
        shimmer.style.opacity = Math.abs(currentRotation) > 90 ? '0.25' : '0';
      }

      _zoomRafId = requestAnimationFrame(animate);
    }

    container.addEventListener('mousemove', onMouseMove);

    // CTA fade-in with 250ms delay
    if (readBtn) {
      readBtn.style.opacity = '0';
      setTimeout(() => { if (readBtn) readBtn.style.opacity = '1'; }, 250);
    }

    _zoomRafId = requestAnimationFrame(animate);

    // Close on overlay click (but not on book/CTA)
    overlay._closeHandler = (e) => {
      if (e.target === overlay) _closeLibraryZoom();
    };
    overlay.addEventListener('click', overlay._closeHandler);

    // Touch support with same premium easing
    function onTouchMove(e) {
      if (e.target.closest && e.target.closest('.book-back')) return;
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
        const raw = (percent - 0.5) * 2;
        const curved = raw * (1 - Math.pow(Math.abs(raw), 2));
        targetRotation = curved * maxRotation;
      }
    }
    container.addEventListener('touchmove', onTouchMove, { passive: true });

    // Escape key
    function onKeyDown(e) { if (e.key === 'Escape') _closeLibraryZoom(); }
    document.addEventListener('keydown', onKeyDown);

    // Store cleanup refs
    overlay._mouseMoveHandler = onMouseMove;
    overlay._touchMoveHandler = onTouchMove;
    overlay._keyDownHandler = onKeyDown;
    overlay._zoomContainer = container;
  }

  function _closeLibraryZoom() {
    const overlay = $('libraryZoomOverlay');
    if (!overlay) return;

    overlay.classList.remove('active');
    document.body.classList.remove('library-zoom-active');
    _playLibrarySound('book-close');

    // Cleanup animation and reset rotation state
    if (_zoomRafId) { cancelAnimationFrame(_zoomRafId); _zoomRafId = null; }
    const zoomBook = overlay._zoomContainer?.querySelector('.book-3d');
    if (zoomBook) zoomBook.style.transform = 'rotateY(0deg)';

    // Cleanup listeners
    if (overlay._zoomContainer) {
      if (overlay._mouseMoveHandler) overlay._zoomContainer.removeEventListener('mousemove', overlay._mouseMoveHandler);
      if (overlay._touchMoveHandler) overlay._zoomContainer.removeEventListener('touchmove', overlay._touchMoveHandler);
    }
    if (overlay._closeHandler) overlay.removeEventListener('click', overlay._closeHandler);
    if (overlay._keyDownHandler) document.removeEventListener('keydown', overlay._keyDownHandler);

    _zoomEntry = null;
  }

  // Zoom CTA â€” read story (vault-aware)
  $('zoomReadBtn')?.addEventListener('click', () => {
    if (_zoomEntry) {
      const entry = _zoomEntry;
      const source = _zoomSource;
      _closeLibraryZoom();
      openLibraryReader(entry, source);
    }
  });

  // â€” Open the read-only reader for a library entry â€”
  let _readerSource = 'forbidden'; // tracks which library to return to
  async function openLibraryReader(entry, source) {
    state.libraryMode = true;
    _readerSource = source || 'forbidden';
    const titleEl = $('libraryReaderTitle');
    const proseEl = $('libraryReaderProse');
    const authorEl = $('libraryReaderAuthor');
    if (titleEl) titleEl.textContent = entry.title || 'Untitled';
    if (authorEl) authorEl.textContent = entry.author || 'S. Tory Bound';
    if (proseEl) proseEl.textContent = 'Loading...';

    window.showScreen('libraryReaderScreen');

    // Fetch sanitized_text on demand
    try {
      const { data, error } = await sb
        .from('library_entries')
        .select('sanitized_text')
        .eq('story_id', entry.story_id)
        .single();

      if (error || !data) {
        if (proseEl) proseEl.textContent = 'Failed to load story.';
        console.error('[Library] Prose fetch failed:', error?.message);
        return;
      }
      if (proseEl) proseEl.textContent = data.sanitized_text || '';
    } catch (err) {
      if (proseEl) proseEl.textContent = 'Failed to load story.';
      console.error('[Library] Prose fetch error:', err);
    }

    // Restore bookmark if available
    restoreLibraryBookmark(entry.story_id);
  }

  // â€” Reader back button (vault-aware) â€”
  $('libraryReaderBackBtn')?.addEventListener('click', () => {
    state.libraryMode = false;
    window.showScreen(_readerSource === 'vault' ? 'vaultLibraryScreen' : 'forbiddenLibraryScreen');
  });

  // â€” Font size toggle â€”
  $('libraryFontToggle')?.addEventListener('click', () => {
    const prose = $('libraryReaderProse');
    const btn = $('libraryFontToggle');
    if (!prose) return;
    prose.classList.toggle('font-large');
    if (btn) btn.classList.toggle('active', prose.classList.contains('font-large'));
  });

  // â€” Light/Dark theme toggle â€”
  $('libraryThemeToggle')?.addEventListener('click', () => {
    const reader = document.querySelector('.library-reader');
    const btn = $('libraryThemeToggle');
    if (!reader) return;
    reader.classList.toggle('theme-light');
    if (btn) btn.classList.toggle('active', reader.classList.contains('theme-light'));
  });

  // â€” Bookmark system â€”
  let _libraryBookmarkTimer = null;
  let _currentLibraryStoryId = null;

  function saveLibraryBookmark() {
    if (!sb || !_supabaseProfileId || !_currentLibraryStoryId) return;
    const content = $('libraryReaderContent');
    if (!content) return;
    const scrollPos = content.scrollTop / Math.max(content.scrollHeight, 1);

    clearTimeout(_libraryBookmarkTimer);
    _libraryBookmarkTimer = setTimeout(async () => {
      try {
        await sb.from('library_bookmarks').upsert({
          user_id: _supabaseProfileId,
          story_id: _currentLibraryStoryId,
          scroll_position: scrollPos,
          last_scene_index: 0,
          updated_at: new Date().toISOString()
        }, { onConflict: 'user_id,story_id' });
      } catch (err) {
        console.warn('[Library] Bookmark save failed:', err);
      }
    }, 2000);
  }

  async function restoreLibraryBookmark(storyId) {
    _currentLibraryStoryId = storyId;
    if (!sb || !_supabaseProfileId) return;
    try {
      const { data } = await sb
        .from('library_bookmarks')
        .select('scroll_position')
        .eq('user_id', _supabaseProfileId)
        .eq('story_id', storyId)
        .maybeSingle();

      if (data && data.scroll_position > 0) {
        const content = $('libraryReaderContent');
        if (content) {
          requestAnimationFrame(() => {
            content.scrollTop = data.scroll_position * content.scrollHeight;
          });
        }
      }
    } catch (err) {
      console.warn('[Library] Bookmark restore failed:', err);
    }
  }

  // Bookmark button â€” manual save with toast
  $('libraryBookmarkBtn')?.addEventListener('click', () => {
    saveLibraryBookmark();
    if (typeof showToast === 'function') showToast('Bookmark saved');
  });

  // Auto-bookmark on scroll (throttled)
  $('libraryReaderContent')?.addEventListener('scroll', () => {
    if (state.libraryMode) saveLibraryBookmark();
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VAULT PERSONAL LIBRARY â€” 3D shelf (reuses Forbidden Library engine)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _vaultAuthoredEntries = [];   // from sb_rooms â€” user's own stories
  let _vaultBorrowedEntries = [];   // from library_bookmarks â†’ library_entries
  let _vaultLibraryLoaded = false;
  let _vaultLibraryLoading = false;

  // Backward-compat alias used by renderVaultBookList (combined list)
  let _vaultLibraryEntries = [];


  // â€” Load user's authored stories, borrowed stories, and achievements from Supabase â€”
  async function loadVaultLibrary() {
    if (_vaultLibraryLoading) return;
    if (!sb || !_supabaseProfileId) {
      _showVaultLibraryEmpty('Sign in to see your library');
      return;
    }
    _vaultLibraryLoading = true;

    const loadingEl = $('vaultLibraryLoading');
    const listEl = $('vaultLibraryList');
    const emptyEl = $('vaultLibraryEmpty');
    if (loadingEl) loadingEl.style.display = '';
    if (listEl) listEl.style.display = 'none';
    if (emptyEl) emptyEl.style.display = 'none';

    try {
      // â”€â”€ 1. Authored stories from sb_rooms â”€â”€
      let authoredResult;
      try {
        authoredResult = await sb.from('sb_rooms')
          .select('id, title, created_at, updated_at, turn')
          .eq('created_by', _supabaseProfileId)
          .order('updated_at', { ascending: false })
          .limit(50);
      } catch (e) {
        console.error('[VaultLibrary] sb_rooms query error:', e);
        authoredResult = { data: [], error: null };
      }
      if (authoredResult.error) {
        console.error('[VaultLibrary] sb_rooms query failed:', authoredResult.error.message);
        authoredResult = { data: [], error: null };
      }
      _vaultAuthoredEntries = (authoredResult.data || []).map(r => ({
        story_id: r.id,
        title: r.title || 'Untitled',
        scene_count: r.turn || 0,
        updated_at: r.updated_at || r.created_at,
        _authored: true
      }));

      // â”€â”€ 2. Bookmarks â†’ borrowed library_entries â”€â”€
      let borrowedResult = { data: [] };
      try {
        const bmResult = await sb.from('library_bookmarks')
          .select('story_id')
          .eq('user_id', _supabaseProfileId);
        const borrowedIds = (bmResult.data || []).map(b => b.story_id).filter(Boolean);
        if (borrowedIds.length > 0) {
          borrowedResult = await sb.from('library_entries')
            .select('story_id, title, scene_count')
            .in('story_id', borrowedIds);
        }
      } catch (e) {
        console.error('[VaultLibrary] bookmarks/borrowed query error:', e);
      }
      _vaultBorrowedEntries = (borrowedResult.data || []).map(r => ({
        story_id: r.story_id,
        title: r.title || 'Untitled',
        scene_count: r.scene_count || 0,
        _borrowed: true
      }));

      // â”€â”€ 3. Achievements â”€â”€
      let achievementsResult;
      try {
        achievementsResult = await sb.from('profile_achievements')
          .select('achievement_key, unlocked_at, metadata')
          .eq('profile_id', _supabaseProfileId)
          .order('unlocked_at', { ascending: false })
          .limit(10);
      } catch (e) {
        console.error('[VaultLibrary] achievements query error:', e);
        achievementsResult = { data: [] };
      }
      if (achievementsResult.error) achievementsResult = { data: [] };

      // â”€â”€ Merge and render â”€â”€
      _vaultLibraryEntries = [..._vaultAuthoredEntries, ..._vaultBorrowedEntries];
      _vaultLibraryLoaded = true;

      if (_vaultLibraryEntries.length === 0) {
        _showVaultLibraryEmpty();
        // Still render trophies even with no stories
        renderVaultTrophies(achievementsResult.data || []);
        _vaultLibraryLoading = false;
        return;
      }

      renderVaultTrophies(achievementsResult.data || []);
      renderVaultBookList();
    } catch (err) {
      console.error('[VaultLibrary] Load error:', err);
      _showVaultLibraryEmpty('Failed to load library');
    }
    _vaultLibraryLoading = false;
  }

  function _showVaultLibraryEmpty(msg) {
    const loadingEl = $('vaultLibraryLoading');
    const listEl = $('vaultLibraryList');
    const emptyEl = $('vaultLibraryEmpty');
    const trophyShelf = $('vaultTrophyShelf');
    if (loadingEl) loadingEl.style.display = 'none';
    if (listEl) listEl.style.display = 'none';
    if (trophyShelf) trophyShelf.style.display = 'none';
    if (emptyEl) {
      emptyEl.style.display = '';
      const p = emptyEl.querySelector('.forbidden-library-empty');
      if (p && msg) p.textContent = msg;
    }
  }

  // â€” Vault trophy shelf (reads profile_achievements, purely visual) â€”
  const TROPHY_ICONS = {
    first_story:       '\u{1F4D6}',
    prolific_author:   '\u{1F3C6}',
    collector_edition: '\u{1F451}',
    world_traveler:    '\u{1F30D}',
    binge_reader:      '\u{1F525}',
    fate_tempted:      '\u{2728}',
    bookworm:          '\u{1F9E0}',
    night_owl:         '\u{1F989}',
    marathon:          '\u{1F3C5}',
    default:           '\u{2B50}'
  };

  function renderVaultTrophies(achievements) {
    const shelf = $('vaultTrophyShelf');
    if (!shelf) return;
    shelf.innerHTML = '';

    if (!achievements || achievements.length === 0) {
      shelf.style.display = 'none';
      return;
    }

    const maxTrophies = window.innerWidth > 600 ? 5 : 1;
    const visible = achievements.slice(0, maxTrophies);

    visible.forEach(a => {
      const key = a.achievement_key || '';
      const icon = TROPHY_ICONS[key] || TROPHY_ICONS.default;
      const meta = a.metadata || {};
      const label = meta.label || (TROPHY_META[key] ? TROPHY_META[key].title : key.replace(/_/g, ' '));
      const trophy = document.createElement('div');
      trophy.className = 'vault-trophy';
      trophy.innerHTML =
        `<div class="vault-trophy-icon">${icon}</div>` +
        `<div class="vault-trophy-label">${escapeHTML(label)}</div>`;
      shelf.appendChild(trophy);
    });

    // Divider between trophies and books
    const divider = document.createElement('div');
    divider.className = 'vault-trophy-shelf-divider';
    shelf.after(divider);

    shelf.style.display = '';

    // Tap trophy shelf to open full Trophy Wall
    shelf.style.cursor = 'pointer';
    shelf.addEventListener('click', function () {
      if (typeof openTrophyWall === 'function') openTrophyWall();
    });
  }

  // â€” Trophy Wall modal (vitrine overlay with badge hotspots) â€”
  const TROPHY_COORDS = {
    // Row 1 â€” center crown
    tempt_first:              { top: '4%',  left: '36%', width: '18%', height: '14%' },
    // Row 2 â€” core trio
    story_1:                  { top: '20%', left: '8%',  width: '18%', height: '14%' },
    story_10:                 { top: '20%', left: '40%', width: '18%', height: '14%' },
    story_100:                { top: '20%', left: '72%', width: '18%', height: '14%' },
    // Row 3 â€” special pair
    fifth_person:             { top: '36%', left: '22%', width: '18%', height: '14%' },
    tempt_disturb_fate:       { top: '36%', left: '58%', width: '18%', height: '14%' },
    // Row 4 â€” mastery trio (left)
    mastery_modern:           { top: '52%', left: '8%',  width: '18%', height: '14%' },
    mastery_fantasy:          { top: '52%', left: '40%', width: '18%', height: '14%' },
    mastery_historical:       { top: '52%', left: '72%', width: '18%', height: '14%' },
    // Row 5 â€” mastery trio (right)
    mastery_sci_fi:           { top: '68%', left: '8%',  width: '18%', height: '14%' },
    mastery_dystopia:         { top: '68%', left: '40%', width: '18%', height: '14%' },
    mastery_post_apocalyptic: { top: '68%', left: '72%', width: '18%', height: '14%' }
  };

  const TROPHY_META = {
    tempt_first:              { title: 'First Temptation',   desc: 'Invoke Tempt Fate for the first time.' },
    story_1:                  { title: 'First Chapter',      desc: 'Complete your first story.' },
    story_10:                 { title: 'Prolific Author',    desc: 'Complete 10 stories.' },
    story_100:                { title: 'Literary Legend',     desc: 'Complete 100 stories.' },
    fifth_person:             { title: 'Voice of Fate',      desc: 'Select 5th Person POV.' },
    tempt_disturb_fate:       { title: 'Fate Disturbed',     desc: 'Tempt Fate 3 times in a single story.' },
    mastery_modern:           { title: 'Modern Mastery',           desc: 'Completed a story in every Modern flavor.' },
    mastery_fantasy:          { title: 'Fantasy Mastery',          desc: 'Completed a story in every Fantasy flavor.' },
    mastery_historical:       { title: 'Historical Mastery',       desc: 'Completed a story in every Historical flavor.' },
    mastery_sci_fi:           { title: 'Sci-Fi Mastery',           desc: 'Completed a story in every Sci-Fi flavor.' },
    mastery_dystopia:         { title: 'Dystopia Mastery',         desc: 'Completed a story in every Dystopia flavor.' },
    mastery_post_apocalyptic: { title: 'Post-Apocalyptic Mastery', desc: 'Completed a story in every Post-Apocalyptic flavor.' }
  };

  // â”€â”€ Trophy Vitrine mask-reveal state â”€â”€
  let _trophyEarnedSet = new Set();
  let _trophyPreviousEarnedSet = new Set();

  /**
   * Build a CSS clip-path that reveals only earned trophy regions.
   * Uses polygon() with individual rectangular cutouts merged via union.
   * Since CSS clip-path polygon defines the VISIBLE area, we build a polygon
   * that covers each earned region as a self-closing rectangle.
   * For multiple rectangles we use multiple inset() in a single clip-path
   * â€” but CSS only supports ONE clip-path. Solution: use an SVG <clipPath>
   * with multiple <rect> elements, referenced via url().
   *
   * Approach: Dynamically update an inline SVG clipPath element.
   */
  function updateVitrineMask() {
    const container = document.querySelector('.trophy-wall-container');
    const fullImg = container?.querySelector('.vitrine-full');
    if (!fullImg) return;

    // Ensure SVG defs element exists (Safari-safe: createElementNS for all nodes)
    let svgDefs = container.querySelector('#vitrineMaskSvg');
    if (!svgDefs) {
      svgDefs = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svgDefs.id = 'vitrineMaskSvg';
      // Safari needs the SVG in the DOM with real dimensions; use 0Ã—0 + overflow:hidden
      svgDefs.setAttribute('width', '0');
      svgDefs.setAttribute('height', '0');
      svgDefs.setAttribute('style', 'position:absolute;width:0;height:0;overflow:hidden;');
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const cp = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
      cp.id = 'vitrineClip';
      cp.setAttribute('clipPathUnits', 'objectBoundingBox');
      defs.appendChild(cp);
      svgDefs.appendChild(defs);
      container.appendChild(svgDefs);
    }

    const clipPath = svgDefs.querySelector('#vitrineClip');
    // Clear existing rects (DOM removal, not innerHTML parse)
    while (clipPath.firstChild) clipPath.removeChild(clipPath.firstChild);

    // Subtle dim on greyed image when nothing is earned
    const greyImg = container.querySelector('.vitrine-grey');
    if (greyImg) {
      greyImg.classList.toggle('vitrine-all-locked', _trophyEarnedSet.size === 0);
    }

    if (_trophyEarnedSet.size === 0) {
      // Nothing earned â€” clip everything
      fullImg.style.clipPath = 'inset(100% 0 0 0)';
      fullImg.style.webkitClipPath = 'inset(100% 0 0 0)';
      return;
    }

    // Add a rect for each earned trophy region (coordinates as fractions 0-1)
    _trophyEarnedSet.forEach(badge => {
      const c = TROPHY_COORDS[badge];
      if (!c) return;
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', parseFloat(c.left) / 100);
      rect.setAttribute('y', parseFloat(c.top) / 100);
      rect.setAttribute('width', parseFloat(c.width) / 100);
      rect.setAttribute('height', parseFloat(c.height) / 100);
      clipPath.appendChild(rect);
    });

    fullImg.style.clipPath = 'url(#vitrineClip)';
    fullImg.style.webkitClipPath = 'url(#vitrineClip)';
  }

  /**
   * Sparkle burst at trophy center (uses existing dissipation sparkle system).
   * Short burst only â€” 8-12 particles scattering outward.
   */
  function trophyRevealBurst(spot) {
    const rect = spot.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    const count = 8 + Math.floor(Math.random() * 5);

    for (let i = 0; i < count; i++) {
      const sparkle = document.createElement('div');
      sparkle.className = 'dissipate-sparkle';
      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.4;
      const dist = 20 + Math.random() * 40;
      const dx = Math.cos(angle) * dist;
      const dy = Math.sin(angle) * dist - 10;
      const size = 3 + Math.random() * 3;
      const duration = 0.8 + Math.random() * 0.3;

      sparkle.style.cssText = `
        left: ${cx}px; top: ${cy}px;
        --sparkle-dx: ${dx}px; --sparkle-dy: ${dy}px;
        --sparkle-curve-x: ${(Math.random() - 0.5) * 12}px;
        --sparkle-curve-y: ${(Math.random() - 0.5) * 12}px;
        --sparkle-size: ${size}px;
        --scatter-duration: ${duration}s;
      `;
      document.body.appendChild(sparkle);
      setTimeout(() => sparkle.remove(), duration * 1000 + 100);
    }
  }

  /**
   * Animate a single trophy reveal: update mask, glow, sparkle burst.
   */
  function revealTrophy(badge) {
    const modal = $('trophyWallModal');
    if (!modal) return;
    const spot = modal.querySelector(`.trophy-hotspot[data-badge="${badge}"]`);
    if (!spot) return;

    spot.classList.remove('locked');
    spot.classList.add('earned', 'trophy-revealing');
    updateVitrineMask();
    trophyRevealBurst(spot);

    // Remove animation class after it completes
    setTimeout(() => spot.classList.remove('trophy-revealing'), 650);
  }

  // Expose for external achievement events
  window.revealTrophy = revealTrophy;

  async function openTrophyWall() {
    // Close Vault menu first (matches Profile/Library button behavior)
    document.getElementById('menuOverlay')?.classList.add('hidden');
    if (typeof resetVaultState === 'function') resetVaultState();
    _preVaultScreenId = _currentScreenId;

    const modal = $('trophyWallModal');
    if (!modal) return;

    // Snapshot previous earned set for detecting new unlocks
    _trophyPreviousEarnedSet = new Set(_trophyEarnedSet);

    // Fetch earned badges
    _trophyEarnedSet = new Set();
    if (sb && _supabaseProfileId) {
      try {
        const { data } = await sb
          .from('user_badges')
          .select('badge_id, earned')
          .eq('profile_id', _supabaseProfileId)
          .eq('earned', true);
        if (data) data.forEach(r => _trophyEarnedSet.add(r.badge_id));
      } catch (_) { /* silent */ }
    }

    // Position hotspots and apply earned/locked state
    modal.querySelectorAll('.trophy-hotspot').forEach(spot => {
      const badge = spot.dataset.badge;
      const coords = TROPHY_COORDS[badge];
      if (coords) {
        spot.style.top = coords.top;
        spot.style.left = coords.left;
        spot.style.width = coords.width;
        spot.style.height = coords.height;
      }
      spot.classList.remove('earned', 'locked', 'trophy-revealing');
      spot.classList.add(_trophyEarnedSet.has(badge) ? 'earned' : 'locked');
    });

    // Build mask for pre-earned trophies (no animation)
    updateVitrineMask();

    modal.classList.remove('hidden');

    // Animate newly earned trophies (earned now but not previously)
    // Stagger multiple reveals by 60ms each for subtle cascade
    let revealIdx = 0;
    _trophyEarnedSet.forEach(badge => {
      if (!_trophyPreviousEarnedSet.has(badge)) {
        setTimeout(() => revealTrophy(badge), 400 + revealIdx * 60);
        revealIdx++;
      }
    });
  }

  function closeTrophyWall() {
    const modal = $('trophyWallModal');
    if (modal) modal.classList.add('hidden');
    const tip = $('trophyTooltip');
    if (tip) tip.classList.add('hidden');
  }

  // â”€â”€ Trophy Hotspot Debug Mode â”€â”€
  // Enables: visible red outlines, drag-to-reposition, resize handles, live coordinate labels
  // Activate from console: window.trophyDebug(true)  |  Deactivate: window.trophyDebug(false)
  // Dump final coords: window.trophyDumpCoords()
  let _trophyDebugActive = false;

  window.trophyDebug = function(enable) {
    _trophyDebugActive = !!enable;
    const vitrine = document.querySelector('.trophy-vitrine');
    if (!vitrine) { console.warn('[TrophyDebug] No .trophy-vitrine found'); return; }

    vitrine.querySelectorAll('.trophy-hotspot').forEach(spot => {
      if (_trophyDebugActive) {
        spot.classList.add('debug-visible');
        _updateDebugLabel(spot, vitrine);
        _makeDraggable(spot, vitrine);
      } else {
        spot.classList.remove('debug-visible');
        spot.removeAttribute('data-debug-coords');
      }
    });
    console.log('[TrophyDebug]', enable ? 'ON â€” drag to reposition, resize from corner' : 'OFF');
    if (enable) console.log('[TrophyDebug] Run window.trophyDumpCoords() to copy final positions');
  };

  function _updateDebugLabel(spot, vitrine) {
    const vw = vitrine.offsetWidth;
    const vh = vitrine.offsetHeight;
    if (!vw || !vh) return;
    const top = ((spot.offsetTop / vh) * 100).toFixed(1);
    const left = ((spot.offsetLeft / vw) * 100).toFixed(1);
    const width = ((spot.offsetWidth / vw) * 100).toFixed(1);
    const height = ((spot.offsetHeight / vh) * 100).toFixed(1);
    spot.setAttribute('data-debug-coords', `${top}% ${left}% ${width}Ã—${height}%`);
  }

  function _makeDraggable(spot, vitrine) {
    if (spot._debugDragBound) return;
    spot._debugDragBound = true;
    let startX, startY, origLeft, origTop;

    spot.addEventListener('mousedown', (e) => {
      if (!_trophyDebugActive) return;
      e.preventDefault();
      e.stopPropagation();
      startX = e.clientX;
      startY = e.clientY;
      origLeft = spot.offsetLeft;
      origTop = spot.offsetTop;

      function onMove(ev) {
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;
        const vw = vitrine.offsetWidth;
        const vh = vitrine.offsetHeight;
        spot.style.left = (((origLeft + dx) / vw) * 100) + '%';
        spot.style.top = (((origTop + dy) / vh) * 100) + '%';
        _updateDebugLabel(spot, vitrine);
      }
      function onUp() {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
      }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });

    // Watch for CSS resize handle changes
    const ro = new ResizeObserver(() => {
      if (!_trophyDebugActive) return;
      const vw = vitrine.offsetWidth;
      const vh = vitrine.offsetHeight;
      spot.style.width = ((spot.offsetWidth / vw) * 100) + '%';
      spot.style.height = ((spot.offsetHeight / vh) * 100) + '%';
      _updateDebugLabel(spot, vitrine);
    });
    ro.observe(spot);
  }

  window.trophyDumpCoords = function() {
    const vitrine = document.querySelector('.trophy-vitrine');
    if (!vitrine) return;
    const coords = {};
    vitrine.querySelectorAll('.trophy-hotspot').forEach(spot => {
      const badge = spot.dataset.badge;
      const vw = vitrine.offsetWidth;
      const vh = vitrine.offsetHeight;
      coords[badge] = {
        top:    ((spot.offsetTop / vh) * 100).toFixed(1) + '%',
        left:   ((spot.offsetLeft / vw) * 100).toFixed(1) + '%',
        width:  ((spot.offsetWidth / vw) * 100).toFixed(1) + '%',
        height: ((spot.offsetHeight / vh) * 100).toFixed(1) + '%'
      };
    });
    console.log('[TrophyDebug] Current TROPHY_COORDS:');
    console.log(JSON.stringify(coords, null, 2));
    // Also copy-friendly format
    let code = 'const TROPHY_COORDS = {\n';
    Object.entries(coords).forEach(([k, v]) => {
      code += `    ${(k + ':').padEnd(30)} { top: '${v.top}',${' '.repeat(Math.max(1, 6 - v.top.length))}left: '${v.left}',${' '.repeat(Math.max(1, 6 - v.left.length))}width: '${v.width}',${' '.repeat(Math.max(1, 6 - v.width.length))}height: '${v.height}' },\n`;
    });
    code += '};';
    console.log(code);
    return coords;
  };

  // Close button
  $('trophyWallClose')?.addEventListener('click', closeTrophyWall);

  // Click overlay background to close
  $('trophyWallModal')?.addEventListener('click', function (e) {
    if (e.target === this) closeTrophyWall();
  });

  // Escape key
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && !$('trophyWallModal')?.classList.contains('hidden')) {
      closeTrophyWall();
    }
  });

  // Exit Achievements button â€” close trophy wall and return to pre-vault screen
  $('exitAchievementsBtn')?.addEventListener('click', () => {
    closeTrophyWall();
    if (_preVaultScreenId && _preVaultScreenId !== 'vaultLibraryScreen') {
      window.showScreen(_preVaultScreenId);
    }
    _preVaultScreenId = null;
  });

  // Exit Forbidden Library button â€” return to setup screen
  $('exitForbiddenLibraryBtn')?.addEventListener('click', () => {
    window.showScreen('setup');
  });

  // Exit Library button â€” return to pre-vault screen
  $('exitLibraryBtn')?.addEventListener('click', () => {
    if (_preVaultScreenId && _preVaultScreenId !== 'vaultLibraryScreen') {
      window.showScreen(_preVaultScreenId);
    }
    _preVaultScreenId = null;
  });

  // Tooltip on hotspot hover
  $('trophyWallModal')?.querySelectorAll('.trophy-hotspot').forEach(spot => {
    spot.addEventListener('mouseenter', function () {
      const badge = this.dataset.badge;
      const meta = TROPHY_META[badge];
      const tip = $('trophyTooltip');
      if (!meta || !tip) return;
      const isLocked = this.classList.contains('locked');
      tip.innerHTML =
        `<div class="trophy-tooltip-title">${escapeHTML(meta.title)}</div>` +
        `<div class="trophy-tooltip-desc">${escapeHTML(meta.desc)}</div>` +
        (isLocked ? `<div class="trophy-tooltip-locked">Locked \u2014 Complete requirements to earn this.</div>` : '');

      // Position tooltip above hotspot
      const spotRect = this.getBoundingClientRect();
      const containerRect = this.parentElement.getBoundingClientRect();
      tip.style.left = (this.offsetLeft + this.offsetWidth / 2 - 110) + 'px';
      tip.style.top = (this.offsetTop - 70) + 'px';
      tip.classList.remove('hidden');
    });
    spot.addEventListener('mouseleave', function () {
      const tip = $('trophyTooltip');
      if (tip) tip.classList.add('hidden');
    });
  });

  window.openTrophyWall = openTrophyWall;

  // â€” Render vault 3D book shelf (reuses same DOM structure as Forbidden Library) â€”
  function renderVaultBookList() {
    const loadingEl = $('vaultLibraryLoading');
    const listEl = $('vaultLibraryList');
    if (loadingEl) loadingEl.style.display = 'none';
    if (!listEl) return;
    listEl.style.display = '';
    listEl.innerHTML = '';

    // Determine forward-facing capacity (evaluated once per render)
    const MAX_FORWARD = window.innerWidth > 1400 ? 8 :
                        window.innerWidth > 1100 ? 6 :
                        window.innerWidth > 900  ? 4 :
                        window.innerWidth > 600  ? 3 :
                        2;

    // Priority sort: authored first, then highest scene_count, then most recently updated
    const sorted = _vaultLibraryEntries.slice().sort((a, b) => {
      const aAuthored = a._authored ? 1 : 0;
      const bAuthored = b._authored ? 1 : 0;
      if (bAuthored !== aAuthored) return bAuthored - aAuthored;
      if ((b.scene_count || 0) !== (a.scene_count || 0)) return (b.scene_count || 0) - (a.scene_count || 0);
      return new Date(b.updated_at || 0) - new Date(a.updated_at || 0);
    });

    sorted.forEach((entry, index) => {
      const bookTitle = entry.title || 'Untitled';
      const bookAuthor = entry._borrowed ? '' : 'You';
      const scenes = entry.scene_count || 0;
      const isCollector = scenes >= COLLECTOR_EDITION_THRESHOLD;
      const isForward = index < MAX_FORWARD;

      // "Last opened" relative timestamp
      let lastOpened = '';
      if (entry.updated_at) {
        const diff = Date.now() - new Date(entry.updated_at).getTime();
        const days = Math.floor(diff / 86400000);
        if (days === 0) lastOpened = 'Today';
        else if (days === 1) lastOpened = '1 day ago';
        else lastOpened = days + ' days ago';
      }

      const book = document.createElement('div');
      book.className = 'library-book initializing' + (isCollector ? ' collector-edition' : '') + (isForward ? ' mode-cover' : ' mode-spine');
      book.dataset.storyId = entry.story_id;
      if (entry._borrowed) book.dataset.borrowed = 'true';

      // Back cover includes vault-specific meta
      const metaLines = [`Scenes: ${scenes}`];
      if (lastOpened) metaLines.push(`Last opened: ${lastOpened}`);
      if (entry._borrowed) metaLines.push('Borrowed');

      book.innerHTML = `<div class="book-3d">
  <div class="book-front"><div class="book-front-text"><div class="book-front-title">${escapeHTML(bookTitle)}</div>${bookAuthor ? `<div class="book-front-author">${escapeHTML(bookAuthor)}</div>` : ''}</div></div>
  <div class="book-back"><div class="back-content"><h3 class="back-title">${escapeHTML(bookTitle)}</h3>${bookAuthor ? `<p class="back-synopsis">${escapeHTML(bookAuthor)}</p>` : ''}<p class="back-meta">${scenes} scenes</p><p class="back-meta-vault">${metaLines.join('<br>')}</p></div></div>
  <div class="book-spine"><div class="spine-text">${escapeHTML(bookTitle)}${bookAuthor ? ` <span class="spine-author">${escapeHTML(bookAuthor)}</span>` : ''}</div></div>
  <div class="book-pages"></div>
  <div class="page-shimmer"></div>
</div>`;

      // Depth variance and lean (deterministic, no randomness)
      const depthVariance = (index % 3) - 1;
      book.style.transform = `translateY(6px) translateZ(${depthVariance * 2}px)`;
      const isMobile = window.innerWidth < 900;
      if (!isMobile && (index % 7 === 0) && isForward) {
        book.classList.add('mode-lean');
      }

      // Hover sound
      let _hoverPlayed = false;
      book.addEventListener('mouseenter', () => {
        if (!_hoverPlayed) { _hoverPlayed = true; _playLibrarySound('book-hover'); }
      });
      book.addEventListener('mouseleave', () => { _hoverPlayed = false; });

      // Click to zoom â€” mark source as vault
      book.addEventListener('click', (e) => {
        e.stopPropagation();
        _zoomSource = 'vault';
        _openLibraryZoom(entry, book);
      });
      listEl.appendChild(book);
    });

    // Remove .initializing after layout pass to enable future transitions
    requestAnimationFrame(() => {
      listEl.querySelectorAll('.library-book.initializing').forEach(b => b.classList.remove('initializing'));
    });
  }

  // Hook into showScreen: load library when screen opens
  const _origShowScreen = window.showScreen;
  window.showScreen = function(id, isBack) {
    _origShowScreen(id, isBack);
    if (id === 'forbiddenLibraryScreen' && !_libraryLoaded) {
      loadLibraryEntries();
    }
    if (id === 'vaultLibraryScreen' && !_vaultLibraryLoaded) {
      loadVaultLibrary();
    }
    // Exit library mode if navigating away from reader
    if (id !== 'libraryReaderScreen' && state.libraryMode) {
      state.libraryMode = false;
    }
  };

  $('ageYes')?.addEventListener('click', () => window.showScreen('legalGate'));

  // Tier card hover-flip + click-to-proceed
  function initTierCards() {
    const tasteCard = $('btnTaste');
    const premiumCard = $('btnPremium');
    const tierCards = [tasteCard, premiumCard].filter(Boolean);

    tierCards.forEach(card => {
      card.addEventListener('mouseenter', () => {
        if (!card.classList.contains('flipped')) card.classList.add('flipped');
      });
      card.addEventListener('mouseleave', () => {
        card.classList.remove('flipped');
      });
    });

    tasteCard?.addEventListener('click', () => {
      if (!tasteCard.classList.contains('flipped')) {
        tasteCard.classList.add('flipped');
        return;
      }
      state.tier = 'free';
      state.access = 'free';
      applyAccessLocks();

      // Dissipate the unselected tier card before navigating
      const unselected = [premiumCard].filter(c => c && c !== tasteCard);
      if (unselected.length && typeof dissipateCards === 'function') {
        dissipateCards(unselected, () => {
          window.showScreen('modeSelect');
          if(window.initCards) window.initCards();
        });
      } else {
        window.showScreen('modeSelect');
        if(window.initCards) window.initCards();
      }
    });

    premiumCard?.addEventListener('click', () => {
      if (!premiumCard.classList.contains('flipped')) {
        premiumCard.classList.add('flipped');
        return;
      }

      // Dissipate the unselected tier card before showing paywall
      const unselected = [tasteCard].filter(c => c && c !== premiumCard);
      if (unselected.length && typeof dissipateCards === 'function') {
        dissipateCards(unselected, () => {
          window.showPaywall('sub_only');
        });
      } else {
        window.showPaywall('sub_only');
      }
    });
  }
  initTierCards();

  // Reset tier cards when returning to tierGate
  window.resetTierCards = function() {
    document.querySelectorAll('.tier-card').forEach(c => c.classList.remove('flipped'));
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARALLEL COVER + STORY GENERATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // When "Generate Cover" is clicked:
  //   - Start cover generation
  //   - Start story generation in background
  //   - Add sparkle FX to button
  // When cover completes:
  //   - Stop sparkle FX with fade
  //   - Replace button with "See Your Book Cover"
  // When "See Your Book Cover" clicked:
  //   - Navigate to Cover View (book display with buttons)
  // Cover View has:
  //   - "See Your Story Setting" (paywalled, generates setting image)
  //   - "Begin Story" (goes directly to Scene 1)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FORTUNE SYSTEM â€” All content-generating actions cost Fortunes
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // - 1 fortune per scene, visualization, cover regen
  // - Subscription fortunes consumed first, then purchased fortunes
  // - If fortunes = 0 â†’ show purchase modal
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Verboten terms that may cause image generation to fail
  const COVER_BLOCKED_TERMS = [
      'nude', 'naked', 'sex', 'explicit', 'pornographic', 'nsfw',
      'child', 'minor', 'underage', 'gore', 'blood', 'violence',
      'weapon', 'gun', 'knife', 'death', 'kill', 'murder',
      'drugs', 'cocaine', 'heroin', 'meth', 'racist', 'hate'
  ];

  // Check if user has fortunes available
  function hasFortunes() {
      return (state.fortunes || 0) > 0;
  }

  // Consume fortunes via server-side atomic decrement
  async function consumeFortune(amount = 1, context = 'general') {
      if ((state.fortunes || 0) < amount) {
          console.warn('[Fortunes] Attempted consumption with insufficient balance');
          return false;
      }
      try {
          const resp = await fetch('/api/consume-fortune', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ userId: _supabaseProfileId, amount, context })
          });
          const data = await resp.json();
          if (!resp.ok) {
              console.warn('[Fortunes] Server declined fortune consumption:', data.error);
              if (data.fortunesRemaining !== undefined) state.fortunes = data.fortunesRemaining;
              return false;
          }
          if (data.fortunesRemaining !== null && data.fortunesRemaining !== undefined) {
              state.fortunes = data.fortunesRemaining;
          }
          console.log(`[Fortunes] ${amount} fortune(s) consumed (context: ${context}). Remaining:`, state.fortunes);
          logEvent('fortune_spent', { amount, context });
          if (window.updateFortuneDisplay) window.updateFortuneDisplay();
          return true;
      } catch (err) {
          console.error('[Fortunes] Server fortune consumption failed:', err);
          return false;
      }
  }

  // Update the fortune display UI
  function updateFortuneDisplay() {
      const display = $('coverCreditDisplay');
      if (display) {
          const f = state.fortunes || 0;
          display.textContent = `${f} Fortune${f !== 1 ? 's' : ''} remaining`;
      }
      // Also update the persistent fortune counter in game UI
      const gameDisplay = $('fortuneBalanceDisplay');
      if (gameDisplay) {
          gameDisplay.textContent = state.fortunes || 0;
      }
  }

  // Check if prompt contains blocked terms
  function checkPromptSafety(prompt) {
      const lower = (prompt || '').toLowerCase();
      const found = COVER_BLOCKED_TERMS.filter(term => lower.includes(term));
      return {
          safe: found.length === 0,
          blockedTerms: found
      };
  }

  // Auto-sanitize prompt by removing blocked terms
  function sanitizeCoverPrompt(prompt) {
      let sanitized = prompt;
      let modified = false;
      for (const term of COVER_BLOCKED_TERMS) {
          const regex = new RegExp(term, 'gi');
          if (regex.test(sanitized)) {
              sanitized = sanitized.replace(regex, '').replace(/\s+/g, ' ').trim();
              modified = true;
          }
      }
      return { sanitized, modified };
  }

  // Build the cover prompt for user display/editing (paid covers only)
  function buildEditableCoverPrompt() {
      const world = state.picks?.world || 'Modern';
      const genre = state.picks?.genre || 'Billionaire';
      const tone = state.picks?.tone || 'Earnest';
      // Title resolution: render no title if not finalized (no placeholder prose)
      const rawTitle = $('storyTitle')?.textContent?.trim() || state._backgroundStoryTitle?.trim() || '';
      const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';

      // Determine world key and get Assembly object
      const worldKey = world.toLowerCase().includes('fantasy') ? 'fantasy'
          : world.toLowerCase().includes('histor') ? 'historical'
          : world.toLowerCase().includes('sci') ? 'scifi'
          : world.toLowerCase().includes('paranormal') || world.toLowerCase().includes('vampire') ? 'paranormal'
          : 'modern';

      const ASSEMBLY_OBJECTS = {
          modern: ['vintage key', 'silk ribbon', 'pearl earring', 'champagne glass', 'red lipstick', 'leather journal', 'single rose', 'antique locket'],
          fantasy: ['ornate dagger', 'crystal vial', 'wax-sealed letter', 'jeweled crown', 'silver mask', 'enchanted mirror', 'golden chalice', 'raven feather'],
          historical: ['quill pen', 'pocket watch', 'cameo brooch', 'candelabra', 'love letter', 'silk fan', 'brass compass', 'velvet glove'],
          scifi: ['holographic card', 'chrome ring', 'data chip', 'neural interface', 'crystal shard', 'metallic rose', 'quantum locket', 'star map'],
          paranormal: ['blood vial', 'moonstone pendant', 'black candle', 'silver dagger', 'tarot card', 'obsidian mirror', 'wolf fang', 'crimson ribbon']
      };

      const objectList = ASSEMBLY_OBJECTS[worldKey] || ASSEMBLY_OBJECTS.modern;
      const selectedObject = state._coverAssemblyObject || objectList[Math.floor(Math.random() * objectList.length)];

      return {
          title,
          world: worldKey,
          genre,
          tone,
          focalObject: selectedObject,
          prompt: `Book cover for "${title}" - a ${tone.toLowerCase()} ${genre.toLowerCase()} story set in a ${worldKey} world. Focal object: ${selectedObject}. Elegant, cinematic, painterly style. No people or faces.`
      };
  }

  // Show fortune purchase modal
  function openFortunePurchaseModal() {
      const modal = $('fortunePurchaseModal');
      if (!modal) {
          console.error('[Fortunes] Purchase modal not found');
          return;
      }
      const bal = $('fortuneModalBalance');
      if (bal) bal.textContent = state.fortunes || 0;
      modal.classList.remove('hidden');
  }

  // Hide fortune purchase modal
  function closeFortunePurchaseModal() {
      const modal = $('fortunePurchaseModal');
      if (modal) modal.classList.add('hidden');
  }

  // Handle fortune pack purchase (Stripe integration)
  function purchaseFortunePack(packSize, priceLabel) {
      if (window._devBypass) {
        console.log(`%c[DEV] Faking fortune purchase: +${packSize}`, 'color: #ffd700');
        state.fortunes = (state.fortunes || 0) + packSize;
        closeFortunePurchaseModal();
        if (window.updateFortuneDisplay) window.updateFortuneDisplay();
        showToast(`+${packSize} Fortunes added (dev mode)`);
        return;
      }
      console.log(`[Fortunes] Purchase requested: ${packSize} fortunes (${priceLabel})`);
      showToast('Fortune purchase coming soon. Check back shortly!');
      closeFortunePurchaseModal();
  }

  // Generate cover with custom (paid) prompt
  async function generatePaidCover(customPrompt) {
      const btn = $('btnGenerateCover');
      const loading = $('coverGenLoading');
      const complete = $('coverGenComplete');

      if (btn) {
          btn.disabled = true;
          btn.textContent = 'Generating...';
      }
      if (loading) loading.style.display = 'flex';
      if (complete) complete.classList.add('hidden');

      startCoverButtonEmitter(btn);

      // Start background story if not started
      if (!_backgroundStoryStarted) {
          console.log('[PARALLEL:GEN] Starting background story generation');
          _backgroundStoryStarted = true;
          _backgroundStoryPromise = startBackgroundStoryGeneration();
      }

      try {
          // Build full prompt with user customization
          // Title resolution: render no title if not finalized (no placeholder prose)
          const rawTitle = $('storyTitle')?.textContent?.trim() || state._backgroundStoryTitle?.trim() || '';
          const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';
          const world = state.picks?.world || 'Modern';
          const worldKey = world.toLowerCase().includes('fantasy') ? 'fantasy'
              : world.toLowerCase().includes('histor') ? 'historical'
              : world.toLowerCase().includes('sci') ? 'scifi'
              : world.toLowerCase().includes('paranormal') ? 'paranormal' : 'modern';

          const fullPrompt = `BOOK COVER IMAGE â€” PAID CUSTOM GENERATION

TITLE: "${title}"
AUTHOR LINE: "by S. Tory Bound"

USER PROMPT:
${customPrompt}

ABSOLUTE RULES:
- NO people, NO faces, NO figures anywhere in the image
- A subtle human SHADOW is allowed but must be secondary
- Title text: large, high contrast, readable at thumbnail size
- Author line: smaller, elegant, below the title
- Elegant, painterly realism, NOT illustration
- Premium published novel aesthetic

WORLD MATERIAL TREATMENT (${worldKey}):
${worldKey === 'fantasy' ? '- Aged stone, tarnished metal, worn fabric textures' :
  worldKey === 'historical' ? '- Wood, brass, parchment, oil-stained cloth textures' :
  worldKey === 'scifi' ? '- Brushed alloy, polymer, subtle luminescence' :
  worldKey === 'paranormal' ? '- Dark velvet, oxidized silver, candlelit warmth' :
  '- Concrete, glass, leather, modern luxury textures'}

The final image must look like a real published novel cover.`;

          // REGRESSION GUARD: Block cinematic drift for Wry Confessional
          assertWryConfessionalVisual(fullPrompt, 'generatePaidCover');

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: fullPrompt,
                  imageIntent: 'book_cover',
                  size: '1024x1536', // 5:7 portrait ratio (matches Minimal v1)
                  _minimalV1: true   // Use same backend path as free covers
              })
          });

          if (!res.ok) throw new Error(`Image API error: ${res.status}`);

          const data = await res.json();
          const coverUrl = data.url || data.image || data.data?.[0]?.url;

          if (!coverUrl) {
              throw new Error('No cover URL returned');
          }

          _preGeneratedCoverUrl = coverUrl;
          _coverGenUsed = true;
          _lastCoverShapeHash = computeStoryShapeHash();

          stopCoverButtonEmitter();
          if (loading) loading.style.display = 'none';
          if (complete) complete.classList.remove('hidden');

          if (btn) {
              btn.textContent = 'See Your Book Cover';
              btn.disabled = false;
              btn.classList.add('begin-story-ready');
          }
          _coverBtnIsBeginStory = true;

          console.log('[COVER$] Paid cover generated successfully');
          return true;

      } catch (err) {
          console.error('[COVER$] Paid cover generation failed:', err);
          stopCoverButtonEmitter();

          if (btn) {
              btn.textContent = 'Generation Failed';
              btn.disabled = false;
          }
          if (loading) loading.style.display = 'none';

          showToast('Cover generation failed. No Fortune consumed â€” please retry.');
          return false;
      }
  }

  // Expose Fortune purchase functions
  window.openFortunePurchaseModal = openFortunePurchaseModal;
  window.closeFortunePurchaseModal = closeFortunePurchaseModal;
  window.purchaseFortunePack = purchaseFortunePack;
  window.hasFortunes = hasFortunes;
  window.updateFortuneDisplay = updateFortuneDisplay;

  // EARNED COVER SYSTEM exports
  window.getCurrentCoverStage = getCurrentCoverStage;
  window.getMaxCoverStage = getMaxCoverStage;
  window.isCoverStageUnlocked = isCoverStageUnlocked;
  window.updateReaderCoverButton = updateReaderCoverButton;
  window.checkCoverStageUpgrade = checkCoverStageUpgrade;
  window.COVER_STAGES = COVER_STAGES;
  window.COVER_STAGE_LABELS = COVER_STAGE_LABELS;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _coverGenUsed = false;
  let _preGeneratedCoverUrl = null;
  let _backgroundStoryPromise = null;      // Promise for background story generation
  let _backgroundStoryStarted = false;     // Flag: story generation in progress
  let _coverBtnIsBeginStory = false;       // Flag: button has transitioned to "Begin Story"

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER BUTTON SPARKLE EMITTER â€” Multi-tone gold radial emission
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Trigger: Generate Cover button click (runs while generation is in progress)
  // Scope: Anchored to button PERIMETER, particles radiate outward
  // Style: Multi-tone gold palette, per-sparkle variance, short lifetimes
  // Stop: When generation completes, stop spawning, let existing particles fade
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _coverSparkleContainerId = null;

  function startCoverButtonEmitter(btn) {
      if (!btn || _coverSparkleContainerId) return;

      // Create fixed overlay for sparkles (prevents opacity inheritance from button)
      const rect = btn.getBoundingClientRect();
      const overlay = document.createElement('div');
      overlay.id = 'coverBtnSparkles';
      overlay.className = 'authorship-sparkle-container';
      overlay.style.cssText = `
          position:fixed;left:${rect.left}px;top:${rect.top}px;
          width:${rect.width}px;height:${rect.height}px;
          pointer-events:none;z-index:2500;overflow:visible;
          opacity:1 !important;filter:none !important;
      `;
      document.body.appendChild(overlay);
      _coverSparkleContainerId = 'coverBtnSparkles';

      startSparkleEmitter(_coverSparkleContainerId, 'coverButton', 5, { initialBurst: 5 });
      console.log('[FX:COVER-BTN] Sparkle emitter started (unified)');
  }

  function stopCoverButtonEmitter() {
      if (!_coverSparkleContainerId) return;
      removeAnchoredSparkleContainer(_coverSparkleContainerId);
      _coverSparkleContainerId = null;
      console.log('[FX:COVER-BTN] Sparkle emitter stopped (unified)');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY SHAPE HASH â€” Track selections to gate cover regeneration
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _lastCoverShapeHash = null;

  function computeStoryShapeHash() {
      // Combine all Story Shape selections into a deterministic string
      const parts = [
          state.picks?.world || '',
          state.picks?.genre || '',
          state.picks?.tone || '',
          state.picks?.dynamic || '',
          state.picks?.pov || '',
          state.archetype?.primary || '',
          state.archetype?.modifier || '',
          state.intensity || '',
          state.storyLength || ''
      ];
      return parts.join('|');
  }

  // Expose function to clear hash when Story Shape changes (called from card click handlers)
  window.clearCoverShapeHash = function() {
      _lastCoverShapeHash = null;
      console.log('[COVER:HASH] Cleared â€” regeneration enabled');
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GENERATE COVER BUTTON CLICK HANDLER â€” DISABLED (Earned Cover Phase B)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Pre-story cover generation is permanently disabled.
  // Use btnReaderCover in Reader mode instead.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnGenerateCover')?.addEventListener('click', async () => {
      // HARD BLOCK: Pre-story cover generation disabled (Earned Cover Phase B)
      console.warn('[COVER:BLOCKED] Pre-story cover generation disabled â€” use Reader cover button');
      showToast('Cover generation is available after starting your story');
      return;

      // === LEGACY CODE BELOW â€” UNREACHABLE ===
      const btn = $('btnGenerateCover');
      const status = $('coverGenStatus');
      const loading = $('coverGenLoading');
      const complete = $('coverGenComplete');
      const locked = $('coverGenLocked');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // IF BUTTON IS IN "SEE COVER" MODE, NAVIGATE TO COVER VIEW
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (_coverBtnIsBeginStory) {
          console.log('[COVER:NAV] Navigating to Cover View');
          showCoverView();
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STORY EXISTENCE GATE â€” Block cover generation if no story exists
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const storyContent = StoryPagination.getAllContent();
      if (!state.storyId || !storyContent || storyContent.trim().length === 0) {
          console.warn('[COVER:GATE] No story exists â€” cover generation blocked');
          showToast('Generate your story first before creating a cover');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STORY SHAPE HASH CHECK â€” Block regeneration if selections unchanged
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const currentHash = computeStoryShapeHash();
      if (_lastCoverShapeHash && _lastCoverShapeHash === currentHash && _coverGenUsed) {
          console.log('[COVER:HASH] Story Shape unchanged â€” regeneration blocked');
          showToast('Change your Story Shape selections to generate a new cover');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FORTUNE CHECK â€” First cover is free, subsequent regens cost 1 fortune
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (_coverGenUsed && !hasFortunes()) {
          console.log('[Fortunes] No fortunes for cover regen â€” showing purchase modal');
          openFortunePurchaseModal();
          return;
      }

      // NOTE: Fortune consumed AFTER successful generation (see below)

      // Show loading state
      btn.disabled = true;
      btn.textContent = 'Generating...';
      if (status) status.classList.remove('hidden');
      if (loading) loading.style.display = 'flex';
      if (complete) complete.classList.add('hidden');
      if (locked) locked.classList.add('hidden');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TITLE RESOLUTION CHECK â€” Wait for title, proceed with empty if timeout
      // No placeholder prose on covers â€” title renders only when finalized
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const MAX_TITLE_WAIT_MS = 8000; // 8 seconds max wait

      let resolvedTitle = $('storyTitle')?.textContent?.trim() || '';
      const isUnresolved = !resolvedTitle || resolvedTitle === 'Untitled' || resolvedTitle === '';

      if (isUnresolved) {
          console.log('[COVER:TITLE] Title unresolved, waiting for pipeline...');
          btn.textContent = 'Generating title...';

          // Poll for title resolution
          const startWait = Date.now();
          while (Date.now() - startWait < MAX_TITLE_WAIT_MS) {
              await new Promise(r => setTimeout(r, 300));
              resolvedTitle = $('storyTitle')?.textContent?.trim()
                  || state._backgroundStoryTitle?.trim()
                  || '';
              if (resolvedTitle && resolvedTitle !== 'Untitled' && resolvedTitle !== '') {
                  console.log('[COVER:TITLE] Title resolved:', resolvedTitle);
                  break;
              }
          }

          // If still unresolved after timeout, proceed with no title (no placeholder)
          if (!resolvedTitle || resolvedTitle === 'Untitled' || resolvedTitle === '') {
              resolvedTitle = '';
              console.log('[COVER:TITLE] Timeout, proceeding with no title');
          }

          btn.textContent = 'Generating...';
      }

      console.log('[COVER:TITLE] Proceeding with title:', resolvedTitle || '(none)');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // START FIREFLY EMITTER ON BUTTON (continuous while generating)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      startCoverButtonEmitter(btn);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // START STORY GENERATION IN BACKGROUND (parallel with cover)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!_backgroundStoryStarted) {
          console.log('[PARALLEL:GEN] Starting background story generation');
          _backgroundStoryStarted = true;
          _backgroundStoryPromise = startBackgroundStoryGeneration();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // START COVER GENERATION (fire and forget, but await for UI update)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      try {
          const coverUrl = await generateMinimalCoverV1({
              synopsis: state._synopsisMetadata || '',
              title: resolvedTitle,
              authorName: CANONICAL_AUTHOR_NAME,
              world: state.picks?.world || 'Modern',
              genre: state.picks?.genre || 'Billionaire',
              tone: state.picks?.tone || 'Earnest',
              intensity: state.intensity || 'Naughty'
          });

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // VALIDATE COVER URL â€” Only proceed if we got a valid image
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (!coverUrl) {
              console.error('[COVER:GEN] Generation returned null/empty URL');
              stopCoverButtonEmitter();
              btn.textContent = 'Generation Failed - Try Again';
              btn.disabled = false;
              if (loading) loading.style.display = 'none';
              // NOTE: No Fortune consumed on failure
              return;
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // FORTUNE CONSUMPTION â€” First cover free, subsequent regens cost 1
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (_coverGenUsed) {
              await consumeFortune(1, 'cover_regen');
          }
          if (window.updateFortuneDisplay) window.updateFortuneDisplay();

          _preGeneratedCoverUrl = coverUrl;
          _coverGenUsed = true;

          // Save Story Shape hash to gate future regeneration
          _lastCoverShapeHash = computeStoryShapeHash();
          console.log('[COVER:HASH] Saved hash:', _lastCoverShapeHash);

          console.log('[COVER:GEN] Cover URL acquired:', coverUrl.substring(0, 80) + '...');

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // COVER COMPLETE: Show success state, stop emitter
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          stopCoverButtonEmitter(); // Stop spawning, let existing particles fade
          if (loading) loading.style.display = 'none';
          if (complete) complete.classList.remove('hidden');

          // Replace button with "See Your Book Cover"
          btn.textContent = 'See Your Book Cover';
          btn.disabled = false;
          // PLAQUE REGIME: No opacity mutation â€” material is static
          btn.classList.add('begin-story-ready');
          _coverBtnIsBeginStory = true; // Mark button as ready to navigate

          console.log('[COVER:GEN] Cover complete, button now "See Your Book Cover"');

      } catch (err) {
          console.error('[COVER:PREGEN] Failed:', err);
          stopCoverButtonEmitter(); // Stop spawning on failure too
          btn.textContent = 'Generation Failed - Try Again';
          btn.disabled = false;
          if (loading) loading.style.display = 'none';
      }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // READER COVER BUTTON â€” Earned Cover System (Reader UI only)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // This is the ONLY authorized cover generation entry point.
  // Requires: state.storyId exists, story content exists
  // Cover stage is determined by story progress (turnCount + storyLength)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // READER COVER BUTTON â€” Opens Cover Gallery Modal (does NOT generate directly)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnReaderCover')?.addEventListener('click', () => {
      // STORY EXISTENCE GATE
      const storyContent = StoryPagination.getAllContent();
      if (!state.storyId || !storyContent || storyContent.trim().length === 0) {
          console.warn('[COVER:READER] No story exists â€” blocked');
          showToast('Generate your story first');
          return;
      }

      // PART B: Start generation IMMEDIATELY before modal opens
      const nextStage = getNextGeneratableStage();
      if (nextStage) {
          // Start generation now (async, don't await)
          _gallerySelectedStage = nextStage;
          generateCoverInGallery();
          console.log('[COVER:READER] Started generation for', nextStage, 'before modal open');
      }

      // Open the Cover Gallery Modal (generation already in progress)
      openCoverGalleryModal();
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER GALLERY MODAL BUTTON WIRING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnGalleryClose')?.addEventListener('click', closeCoverGalleryModal);
  $('btnGalleryGenerate')?.addEventListener('click', generateCoverInGallery);
  $('btnGalleryPrimary')?.addEventListener('click', selectCoverAsPrimary);
  $('btnGalleryPrev')?.addEventListener('click', galleryPrevStage);
  $('btnGalleryNext')?.addEventListener('click', galleryNextStage);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BACKGROUND STORY GENERATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // This function starts story generation in the background.
  // Returns a promise that resolves when story text is ready.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * Resolve world flavors: classify manual pick, auto-stack probabilistically.
   * Returns array of {val, type} (max length 2).
   * type = 'systemic' | 'contextual' | 'unclassified'
   */
  function resolveWorldFlavors(world, manualPick) {
      if (!manualPick) {
          // Modern auto-resolution: modern_core as default systemic + 90% contextual auto-pick
          if (world === 'Modern') {
              const result = [{ val: 'modern_core', type: 'systemic' }];
              if (Math.random() < 0.90) {
                  const pool = WORLD_CONTEXTUAL_POOL.Modern;
                  const pick = pool[Math.floor(Math.random() * pool.length)];
                  result.push({ val: pick, type: 'contextual' });
              }
              return result;
          }
          // Fantasy auto-resolution: fantasy_core always active + 90% contextual auto-pick
          if (world === 'Fantasy') {
              const result = [{ val: 'fantasy_core', type: 'systemic' }];
              if (Math.random() < 0.90) {
                  const pool = WORLD_CONTEXTUAL_POOL.Fantasy;
                  const pick = pool[Math.floor(Math.random() * pool.length)];
                  result.push({ val: pick, type: 'contextual' });
              }
              return result;
          }
          return [];
      }

      const type = SYSTEMIC_FLAVORS.has(manualPick) ? 'systemic'
                 : CONTEXTUAL_FLAVORS.has(manualPick) ? 'contextual'
                 : 'unclassified';
      const result = [{ val: manualPick, type }];

      // Fantasy: always prepend fantasy_core as systemic baseline
      if (world === 'Fantasy' && manualPick !== 'fantasy_core') {
          result.unshift({ val: 'fantasy_core', type: 'systemic' });
      }

      // Dystopia: inject systemic core, no auto-stack
      if (world === 'Dystopia') {
        result.unshift({ type: 'systemic', val: 'dystopia_core' });
        return result;
      }

      // PostApocalyptic: no auto-stack
      if (world === 'PostApocalyptic') return result;

      // Historical: inject systemic core, no auto-stack
      if (world === 'Historical') {
        result.unshift({ type: 'systemic', val: 'historical_core' });
        return result;
      }

      // Fantasy / SciFi / Modern: 25% chance of auto-stacking a 2nd contextual
      const pool = WORLD_CONTEXTUAL_POOL[world];
      if (pool && Math.random() < 0.25) {
          const candidates = pool.filter(v => v !== manualPick && CONTEXTUAL_FLAVORS.has(v));
          if (candidates.length > 0) {
              const pick = candidates[Math.floor(Math.random() * candidates.length)];
              result.push({ val: pick, type: 'contextual' });
          }
      }

      return result;
  }

  /**
   * Build world flavor directives for LLM system prompt.
   * Accepts resolved flavor array from resolveWorldFlavors().
   * Systemic â†’ World Flavor + World Pressure; Contextual â†’ World Context + Context Effect.
   * Max 4 flavor-related prompt lines. Never exposes classification labels.
   */
  function buildWorldFlavorDirectives(world, resolvedFlavors) {
      // Custom text flavor â€” user-entered free text, interpreted through the world lens
      const customText = state.worldCustomTexts?.[world] || '';
      const hasManualPick = resolvedFlavors && resolvedFlavors.some(f => f.val === state.picks?.worldSubtype);
      if (!hasManualPick && customText) {
          return `
WORLD FLAVOR (custom): "${customText}"
INTERPRETATION RULES:
- This is a user-supplied setting hint. Interpret it through the lens of the ${world || 'chosen'} world.
- If it names a recognizable setting, franchise, or concept, extract the TONAL and STRUCTURAL qualities â€” never reproduce copyrighted characters, dialogue, or plot.
- If it is a real place, treat it as a setting with authentic local texture.
- If it is nonsensical or unrecognizable, ignore it gracefully â€” do not mention it in prose.
- The custom flavor modifies WHERE and HOW the story feels, not what happens.`;
      }

      if (!resolvedFlavors || resolvedFlavors.length === 0) return '';

      // Sort: systemic before contextual
      const sorted = [...resolvedFlavors].sort((a, b) => {
          const order = { systemic: 0, contextual: 1, unclassified: 2 };
          return (order[a.type] ?? 2) - (order[b.type] ?? 2);
      });

      // Promote first systemic flavor to PRIMARY WORLD LENS (overrides generic genre tropes)
      const primaryFlavor = sorted.find(f => f.type === 'systemic');
      let block = '';
      if (primaryFlavor) {
          const primaryLabel = getWorldLabel(primaryFlavor.val);
          const primaryPressure = SYSTEMIC_PRESSURE_LINES[primaryFlavor.val] || '';
          const hardConstraints = FLAVOR_HARD_CONSTRAINTS[primaryFlavor.val] || '';
          block += `\nPRIMARY WORLD LENS: ${primaryLabel}`;
          if (primaryPressure) block += `\nWorld Pressure: ${primaryPressure}`;
          block += `\nBase Genre: ${world}`;
          block += `\nIf PRIMARY WORLD LENS exists, it overrides generic ${world} tropes. Do not default to generic genre imagery unless explicitly part of the selected flavor.`;
          if (hardConstraints) block += `\n${hardConstraints}`;
          // World Bible â€” full on Scene 1, compressed anchor on subsequent turns
          if (primaryFlavor.val === 'glass_house') {
              const isScene1 = !state.turnCount || state.turnCount === 0;
              if (isScene1) {
                  block += `\n\n${WORLD_BIBLE.glass_house}`;
                  block += buildGlassHouseSurfaceDirective();
              } else {
                  block += `\n\n${GLASS_HOUSE_CANON_ANCHOR}`;
              }
          }
          // World bellwether (structural anchor for drift-prone flavors)
          const worldBellwether = BELLWETHERS.world[primaryFlavor.val];
          if (worldBellwether) {
              block += `\n\nBELLWETHER â€” STRUCTURAL REFERENCE:\n${worldBellwether}\nDo not copy wording from this example. Use it only to guide structural logic.`;
          }
      }
      for (const flavor of sorted) {
          if (flavor === primaryFlavor) continue; // Already emitted as primary lens
          const label = getWorldLabel(flavor.val);
          if (flavor.type === 'systemic') {
              const pressure = SYSTEMIC_PRESSURE_LINES[flavor.val] || '';
              block += `\nWorld Flavor: ${label}`;
              if (pressure) block += `\nWorld Pressure: ${pressure}`;
          } else if (flavor.type === 'contextual') {
              const effect = CONTEXT_GRAVITY[flavor.val] || '';
              block += `\nWorld Context: ${label}`;
              if (effect) block += `\nContext Effect: ${effect}`;
          } else {
              block += `\nWorld Flavor: ${label}`;
          }
      }

      // Flavor-specific narrative engine directives
      if (sorted.some(f => f.val === 'quieting_event')) {
          block += `
QUIETING EVENT DIRECTIVES:
- Tone: destabilizing, thrilling, rising volatility. Romance feels electrically disruptive.
- Attraction behaves like contagion â€” emotional intensity spreads outward socially.
- Government and institutions prefer calm, not repression. Conflict escalates as instability metrics rise.
- NEVER frame desire as coercion or non-consent. The suppression is biochemical and ambient, not authoritarian force.
- Focus on longing, obsession, jealousy, creativity returning â€” the return of full emotional range.
- Scene bias: moderate pacing early, escalating intensity, social destabilization consequences, public calm vs private ignition contrast.`;
      }

      // Blue Blood structural contract (variant selected at story start)
      if (world === 'Modern' && sorted.some(f => f.val === 'blue_blood')) {
          const bbData = MODERN_FLAVOR_STRUCTURAL_DATA.BlueBlood;
          const variantKey = state._blueBloodVariant || 'royal';
          const variant = bbData?.variants?.[variantKey];
          if (variant) {
              block += `\n\nBLUE BLOOD STRUCTURAL CONTRACT (MANDATORY):`;
              block += `\nCORE POWER ASYMMETRY: ${variant.core_power_asymmetry}`;
              block += `\nSTRUCTURAL STAKES ENGINE: ${variant.structural_stakes_engine}`;
              block += `\nSOCIAL PRESSURE MECHANISM: ${variant.social_pressure_mechanism}`;
              block += `\nFORBIDDEN COLLAPSE PATTERNS:\n- ${variant.forbidden_collapse_patterns.join('\n- ')}`;
          }
      }

      // Modern flavor structural contracts (non-Blue-Blood)
      const modernStructuralMap = [
          { val: 'modern_core', key: 'modern_core', label: 'MODERN CORE' },
          { val: 'small_town', key: 'small_town', label: 'SMALL TOWN' },
          { val: 'college', key: 'college', label: 'COLLEGE' },
          { val: 'office', key: 'office', label: 'OFFICE' },
          { val: 'friends', key: 'friends', label: 'FRIENDS' },
          { val: 'supernatural_modern', key: 'supernatural_modern', label: 'SUPERNATURAL' },
          { val: 'superheroic_modern', key: 'superheroic_modern', label: 'SUPERHEROIC' }
      ];
      if (world === 'Modern') {
          for (const { val, key, label } of modernStructuralMap) {
              if (sorted.some(f => f.val === val)) {
                  const data = MODERN_FLAVOR_STRUCTURAL_DATA[key];
                  if (data) {
                      block += `\n\n${label} STRUCTURAL CONTRACT (MANDATORY):`;
                      block += `\nCORE POWER ASYMMETRY: ${data.core_power_asymmetry}`;
                      block += `\nSTRUCTURAL STAKES ENGINE: ${data.structural_stakes_engine}`;
                      block += `\nSOCIAL PRESSURE MECHANISM: ${data.social_pressure_mechanism}`;
                      block += `\nFORBIDDEN COLLAPSE PATTERNS: ${data.forbidden_collapse_patterns}`;
                  }
              }
          }
      }

      // Fantasy core structural contract
      if (world === 'Fantasy' && sorted.some(f => f.val === 'fantasy_core')) {
          const data = FANTASY_FLAVOR_STRUCTURAL_DATA.fantasy_core;
          if (data) {
              block += `\n\nFANTASY CORE STRUCTURAL CONTRACT (MANDATORY):`;
              block += `\nCORE POWER ASYMMETRY: ${data.core_power_asymmetry}`;
              block += `\nSTRUCTURAL STAKES ENGINE: ${data.structural_stakes_engine}`;
              block += `\nSOCIAL PRESSURE MECHANISM: ${data.social_pressure_mechanism}`;
              block += `\nFORBIDDEN COLLAPSE PATTERNS: ${data.forbidden_collapse_patterns}`;
          }
      }

      // Template collapse prevention â€” anti-repeat directive
      const primaryVal = primaryFlavor?.val || (sorted[0] && sorted[0].val);
      if (primaryVal) {
          block += getAntiRepeatDirective(world, primaryVal);
      }

      return block;
  }

  async function startBackgroundStoryGeneration() {
      console.log('[BACKGROUND:STORY] Starting background story generation');

      try {
          // Gather required state (same as Begin Story flow)
          const playerInputVal = $('playerNameInput')?.value.trim() || '';
          const partnerInputVal = $('partnerNameInput')?.value.trim() || '';
          const playerNameBlank = !playerInputVal;
          const partnerNameBlank = !partnerInputVal;
          const rawPlayerName = playerInputVal || "The Protagonist";
          const rawPartnerName = partnerInputVal || "The Love Interest";
          const pGen = $('customPlayerGender')?.value.trim() || $('playerGender')?.value || 'Female';
          const lGen = $('customLoveInterest')?.value.trim() || $('loveInterestGender')?.value || 'Male';
          const pPro = $('customPlayerPronouns')?.value.trim() || $('playerPronouns')?.value || 'She/Her';
          const lPro = $('customLovePronouns')?.value.trim() || $('lovePronouns')?.value || 'He/Him';
          const pAge = $('playerAgeInput')?.value.trim() || '';
          const lAge = $('partnerAgeInput')?.value.trim() || '';

          // Normalization (skip for blank names â€” AI will invent)
          let pKernel, lKernel;
          try {
              if (!playerNameBlank) {
                  const playerNorm = await callNormalizationLayer({
                      axis: 'character',
                      user_text: rawPlayerName,
                      context_signals: state.picks?.world || []
                  });
                  pKernel = playerNorm.normalized_text || playerNorm.archetype || rawPlayerName;
              } else {
                  pKernel = rawPlayerName;
              }
              if (!partnerNameBlank) {
                  const partnerNorm = await callNormalizationLayer({
                      axis: 'character',
                      user_text: rawPartnerName,
                      context_signals: state.picks?.world || []
                  });
                  lKernel = partnerNorm.normalized_text || partnerNorm.archetype || rawPartnerName;
              } else {
                  lKernel = rawPartnerName;
              }
          } catch (normError) {
              console.warn('[BACKGROUND:STORY] Normalization failed, using raw names:', normError);
              pKernel = rawPlayerName;
              lKernel = rawPartnerName;
          }

          // Build name-invention directives for blank names
          const nameInventionDirectives = [
              playerNameBlank ? buildNameInventionDirective('Protagonist', pGen, pPro) : '',
              partnerNameBlank ? buildNameInventionDirective('Love Interest', lGen, lPro) : ''
          ].filter(Boolean).join('\n\n');

          // Store in state
          state.normalizedPlayerKernel = pKernel;
          state.normalizedPartnerKernel = lKernel;
          state.rawPlayerName = rawPlayerName;
          state.rawPartnerName = rawPartnerName;
          state.gender = pGen;
          state.loveInterest = lGen;

          // Build system prompt (simplified version for background)
          const storyWorld = state.picks?.world || 'Modern';
          const storyGenre = state.picks?.genre || 'Billionaire';
          const storyPowerRole = resolvePowerRole(storyWorld, null, storyGenre);
          const storyPowerFrame = resolvePowerFrame(storyWorld, storyGenre);
          const archetypeDirectives = buildArchetypeDirectives(state.archetype?.primary, state.archetype?.modifier, lGen);
          const safetyStr = buildConsentDirectives();

          // Resolve world flavors (classify + auto-stack) and build prompt directives
          const resolvedFlavors1 = resolveWorldFlavors(storyWorld, state.picks?.worldSubtype);
          state.resolvedWorldFlavors = resolvedFlavors1; // persist for story lifetime

          // Blue Blood variant selection â€” once per story, weighted random
          if (storyWorld === 'Modern' && resolvedFlavors1.some(f => f.val === 'blue_blood') && !state._blueBloodVariant) {
              const weights = MODERN_FLAVOR_STRUCTURAL_DATA.BlueBlood.variant_weights;
              const roll = Math.random();
              state._blueBloodVariant = roll < weights.royal ? 'royal' : 'aristocratic';
              console.log(`[BLUE_BLOOD] Variant selected: ${state._blueBloodVariant} (roll=${roll.toFixed(3)})`);
          }

          // Blue Blood entropy initialization â€” once per story
          if (storyWorld === 'Modern' && state._blueBloodVariant && !state._blueBloodEntropy) {
              const axes = MODERN_FLAVOR_STRUCTURAL_DATA.BlueBlood.variants[state._blueBloodVariant]?.entropy_axes;
              if (axes) {
                  const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
                  state._blueBloodEntropy = {
                      entry_state: pick(axes.entry_state),
                      pressure_origin: pick(axes.pressure_origin),
                      polarity_orientation: pick(axes.polarity_orientation),
                      exposure_level: pick(axes.exposure_level),
                      structural_timeline_mode: pick(axes.structural_timeline_mode)
                  };
                  if (axes.monarchy_model) {
                      state._blueBloodEntropy.monarchy_model = pick(axes.monarchy_model);
                  }
                  console.log('[BLUE_BLOOD] Entropy initialized:', JSON.stringify(state._blueBloodEntropy));
              }
          }

          // Modern flavor entropy initialization â€” once per story, per flavor
          if (storyWorld === 'Modern') {
              const modernFlavorMap = [
                  { val: 'modern_core', key: 'modern_core', stateKey: '_modernCoreEntropy' },
                  { val: 'small_town', key: 'small_town', stateKey: '_smallTownEntropy' },
                  { val: 'college', key: 'college', stateKey: '_collegeEntropy' },
                  { val: 'office', key: 'office', stateKey: '_officeEntropy' },
                  { val: 'friends', key: 'friends', stateKey: '_friendsEntropy' },
                  { val: 'supernatural_modern', key: 'supernatural_modern', stateKey: '_supernaturalEntropy' },
                  { val: 'superheroic_modern', key: 'superheroic_modern', stateKey: '_superheroicEntropy' }
              ];
              for (const { val, key, stateKey } of modernFlavorMap) {
                  if (resolvedFlavors1.some(f => f.val === val) && !state[stateKey]) {
                      const axes = MODERN_FLAVOR_STRUCTURAL_DATA[key]?.entropy_axes;
                      if (axes) {
                          state[stateKey] = {};
                          Object.keys(axes).forEach(axis => {
                              const arr = axes[axis];
                              state[stateKey][axis] = arr[Math.floor(Math.random() * arr.length)];
                          });
                          console.log(`[${key.toUpperCase()}] Entropy initialized:`, JSON.stringify(state[stateKey]));
                      }
                  }
              }
          }

          // Fantasy flavor entropy initialization â€” once per story
          if (storyWorld === 'Fantasy' && resolvedFlavors1.some(f => f.val === 'fantasy_core') && !state._fantasyCoreEntropy) {
              const axes = FANTASY_FLAVOR_STRUCTURAL_DATA.fantasy_core?.entropy_axes;
              if (axes) {
                  state._fantasyCoreEntropy = {};
                  Object.keys(axes).forEach(axis => {
                      const arr = axes[axis];
                      state._fantasyCoreEntropy[axis] = arr[Math.floor(Math.random() * arr.length)];
                  });
                  console.log('[FANTASY_CORE] Entropy initialized:', JSON.stringify(state._fantasyCoreEntropy));

                  // Bind canonical Fatelands region metadata
                  const region = state._fantasyCoreEntropy.fantasy_region_focus;
                  const meta = FATELANDS_CANON.regions[region];
                  if (meta) {
                      state.fantasyRegion = region;
                      state.fantasyRegionSeat = meta.seat;  // null for unconfirmed seats
                      state.fantasyRegionGovernance = meta.governance;
                      state.fantasyRegionStatus = meta.status;
                      state.fantasyRegionReality = meta.reality;  // null if status is face value
                      state.fantasyMagicExpressionBias = meta.magicBias;
                      console.log('[FANTASY_CORE] Fatelands region bound:', region, meta);
                  }
              }
          }

          // Historical entropy initialization (single systemic axis) â€” once per story
          if (
            storyWorld === 'Historical' &&
            resolvedFlavors1.some(f => f.val === 'historical_core') &&
            !state._historicalCoreEntropy
          ) {
            state._historicalCoreEntropy = {};
            const axes = HISTORICAL_FLAVOR_STRUCTURAL_DATA.historical_core.entropy_axes;
            Object.keys(axes).forEach(axis => {
              const values = axes[axis];
              state._historicalCoreEntropy[axis] =
                values[Math.floor(Math.random() * values.length)];
            });
            console.log('[HISTORICAL_CORE] Entropy initialized:', JSON.stringify(state._historicalCoreEntropy));

            // Prehistoric cognitive band assignment (immutable once set)
            if (storyWorld === 'Historical' && (state.picks?.worldSubtype === 'prehistoric') && !state.historicalCognitiveBand) {
              const bandMap = {
                prehistoric_presymbolic:  { maxAbstraction: 'concrete_only',   dialogueLength: 'minimal',  introspection: 'none',    symbolism: 'none' },
                prehistoric_early_tribal: { maxAbstraction: 'immediate_causal', dialogueLength: 'short',    introspection: 'somatic', symbolism: 'emergent' },
                prehistoric_proto_mythic: { maxAbstraction: 'analogic',         dialogueLength: 'moderate', introspection: 'pattern', symbolism: 'allowed' },
                prehistoric_oral_memory:  { maxAbstraction: 'narrative_causal', dialogueLength: 'extended', introspection: 'minimal', symbolism: 'structured' }
              };
              const bands = Object.keys(bandMap);
              const selectedBand = bands[Math.floor(Math.random() * bands.length)];
              state.historicalCognitiveBand = selectedBand;
              state._prehistoricBandMeta = bandMap[selectedBand];
              state.historicalCognitiveModulation = 0.25;
              console.log('[HISTORICAL_CORE] Prehistoric cognitive band assigned:', selectedBand, bandMap[selectedBand]);
            }
          }

          // Dystopia entropy initialization (single systemic axis) â€” once per story
          if (
            storyWorld === 'Dystopia' &&
            resolvedFlavors1.some(f => f.val === 'dystopia_core') &&
            !state._dystopiaCoreEntropy
          ) {
            state._dystopiaCoreEntropy = {};
            const axes = DYSTOPIA_FLAVOR_STRUCTURAL_DATA.dystopia_core.entropy_axes;
            Object.keys(axes).forEach(axis => {
              const values = axes[axis];
              state._dystopiaCoreEntropy[axis] =
                values[Math.floor(Math.random() * values.length)];
            });
            console.log('[DYSTOPIA_CORE] Entropy initialized:', JSON.stringify(state._dystopiaCoreEntropy));

            // Dystopia attention level initialization (subtype-dependent baseline)
            if (!state.dystopianAttentionLevel) {
              const attentionBaselines = {
                glass_house:    0.5,   // high baseline â€” total transparency
                human_capital:  0.3,   // moderate â€” market surveillance
                dogma:          0.4,   // moderate-high â€” doctrinal monitoring
                quieting_event: 0.35,  // moderate â€” volatility detection
                endless_edit:   0.2,   // low â€” passive identity monitoring
                thirst:         0.3    // moderate â€” resource auditing
              };
              const enforcementModes = {
                glass_house:    'social',
                human_capital:  'algorithmic',
                dogma:          'social',
                quieting_event: 'biological',
                endless_edit:   'algorithmic',
                thirst:         'mechanical'
              };
              const sub = state.picks?.worldSubtype || 'human_capital';
              state.dystopianAttentionLevel = attentionBaselines[sub] || 0.25;
              state.dystopianEnforcementMode = enforcementModes[sub] || 'mixed';
              console.log('[DYSTOPIA_CORE] Attention initialized:', state.dystopianAttentionLevel, 'mode:', state.dystopianEnforcementMode);
            }
          }

          // Fortune's Favor â€” initialize story-scoped spotlight tracking
          initializeFortuneFavor();

          const worldFlavorDirectives = buildWorldFlavorDirectives(storyWorld, resolvedFlavors1);

          // Pre-compute probabilistic injections so polarity can check suppression
          const _tone1 = state.picks?.tone || 'Earnest';
          const _fracture1 = buildTonalFracture(_tone1);
          const _pullBlock1 = buildStoryPullBlock(_fracture1);
          const _polarityBlock1 = buildPolarityBlock(_fracture1, _pullBlock1);

          const sysPrompt = `You are a bestselling romance author.

LONG-FORM STORY ARC RULES (CRITICAL):
You are writing a serialized narrative, not a vignette.
Each response must advance character psychology, not just physical tension.
End most responses with a complication, choice, or destabilizing revelation.

You are writing a story with the following configuration:
- World: ${storyWorld}${state.worldCustomTexts?.[storyWorld] && !state.picks?.worldSubtype ? ` (Custom: ${state.worldCustomTexts[storyWorld]})` : ''}
- Tone: ${_tone1}${_fracture1}
- Genre: ${storyPowerRole}
- Power Frame: ${storyPowerFrame}${_pullBlock1}
${_polarityBlock1}
- POV: ${state.picks?.pov || 'First'}
${worldFlavorDirectives}

Protagonist: ${playerNameBlank ? '[TO BE INVENTED â€” see NAME INVENTION rules]' : pKernel} (${pGen}, ${pPro}${pAge ? `, age ${pAge}` : ''}).
Love Interest: ${partnerNameBlank ? '[TO BE INVENTED â€” see NAME INVENTION rules]' : lKernel} (${lGen}, ${lPro}${lAge ? `, age ${lAge}` : ''}).
${nameInventionDirectives ? '\n' + nameInventionDirectives : ''}
${archetypeDirectives}
${safetyStr}

Intimacy is authorized ONLY when the narrative reaches ST3, the scene gate is open, and the player initiates.

RULES:
1. Write in the selected POV.
2. Respond to the player's actions naturally.
3. Keep pacing slow and tense (unless Dirty).
4. Focus on sensory details, longing, and chemistry.
5. Be creative, surprising, and emotionally resonant.
6. BANNED WORDS/TOPICS: ${(state.constraints?.bannedWords || []).join(', ')}.
7. TONE ADJUSTMENTS: ${(state.constraints?.tone || []).join(', ')}.`;

          const introPrompt = buildScene1IntroPrompt(pKernel, lKernel, pGen, lGen, pPro, lPro);

          // Store system prompt for later use
          state.sysPrompt = sysPrompt;

          // â”€â”€ Title + Synopsis pre-generation (GPT-4o, before Scene 1) â”€â”€
          let preTitle = null, preSynopsis = null;
          if (!state.story?.title && !state.immutableTitle && window.StoryboundOrchestration?.callChatGPT) {
              try {
                  console.log('[BACKGROUND:TITLE] Generating title + synopsis via GPT-4o...');
                  const tsResult = await window.StoryboundOrchestration.callChatGPT([
                      { role: 'system', content: `You are writing the official Title and Title Page Synopsis for a romance novel. The goal is emotional magnetism, not summary.

TITLE: 2â€“6 words. Evocative, memorable, archetype-aligned. Suggest tension or inevitability. No subtitles. No punctuation gimmicks. Avoid generic romance phrasing.

SYNOPSIS: 120â€“170 words. Present tense. Focus on emotional stakes and relational gravity. Highlight what each character risks losing. Emphasize tension, imbalance, temptation, or restraint. Hint at escalation without revealing outcomes. Avoid plot chronology â€” promise, not recap. Avoid clichÃ©s, vague abstraction, explicit content. Do not reference story mechanics.

Craft: Open with tension, not exposition. Center the archetype dynamic. Use specific emotional language. End on a charged unresolved note. Make the reader feel inevitability.

Anti-clichÃ©: No "unexpected love", "sparks fly", "will they risk it all", "forbidden passion", "fate brings them together", "their worlds collide", "a love like no other". No vague abstractions without concrete emotional context. No marketing-tagline language. No rhetorical questions. No interchangeable phrases.

Return JSON only: { "title": "...", "synopsis": "..." }` },
                      { role: 'user', content: `World: ${storyWorld}, Tone: ${_tone1}, Genre: ${storyPowerRole}, Archetype: ${ARCHETYPES[state.archetype?.primary]?.name || 'The Beautiful Ruin'}, Protagonist: ${pKernel} (${pGen}), Love Interest: ${lKernel} (${lGen}), Length: ${state.storyLength || 'taste'}` }
                  ], 'PRIMARY_AUTHOR', { model: 'gpt-4o', max_tokens: 400, jsonMode: true });
                  const parsed = JSON.parse(tsResult);
                  if (parsed.title && parsed.synopsis) {
                      preTitle = parsed.title.replace(/"/g, '').trim();
                      preSynopsis = parsed.synopsis.trim();
                      state.immutableTitle = preTitle;
                      console.log('[BACKGROUND:TITLE] Pre-generated:', preTitle);
                  }
              } catch (tsErr) {
                  console.warn('[BACKGROUND:TITLE] Pre-generation failed, will use parsed:', tsErr.message);
              }
          }

          console.log('[BACKGROUND:STORY] Calling ChatGPT for Scene 1...');

          // Generate Scene 1
          let text = await callChat([
              { role: 'system', content: sysPrompt },
              { role: 'user', content: introPrompt }
          ]);

          // Check for prose refusal
          const refusalCheck = detectProseRefusal(text);
          if (refusalCheck.isRefusal) {
              console.error('[BACKGROUND:STORY] Prose refusal detected:', refusalCheck.reason);
              throw new ProseRefusalError(refusalCheck.reason, text);
          }

          // Parse and store result â€” pre-generated title/synopsis take priority
          const { title: parsedTitle, synopsis: parsedSynopsis, blurb, body } = parseScene1Response(text);
          const title = preTitle || parsedTitle;
          const synopsis = preSynopsis || parsedSynopsis;

          state.story = state.story || {};
          state.story.title = title;
          state.story.synopsis = synopsis;
          state._synopsisMetadata = synopsis;
          state._synopsisBlurb = blurb || synopsis || '';
          state._backgroundStoryText = body;
          state._backgroundStoryTitle = title;
          state._backgroundStorySynopsis = synopsis;

          // Record user-provided names so they're never reused by AI
          if (!playerNameBlank) addUsedName(pKernel);
          if (!partnerNameBlank) addUsedName(lKernel);

          console.log('[BACKGROUND:STORY] Scene 1 generated successfully');
          console.log('[BACKGROUND:STORY] Title:', title);

          return { success: true, title, synopsis, body };

      } catch (err) {
          console.error('[BACKGROUND:STORY] Generation failed:', err);
          return { success: false, error: err.message };
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PARSE SCENE 1 RESPONSE (extract title, synopsis, body)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function parseScene1Response(text) {
      let title = 'Untitled';
      let synopsis = '';
      let blurb = '';
      let body = text;

      // Try to extract title from [TITLE:...] or **Title:** patterns
      const titleMatch = text.match(/\[TITLE:\s*"?([^"\]]+)"?\]/i) ||
                         text.match(/\*\*Title:\*\*\s*(.+)/i) ||
                         text.match(/^#\s*(.+)/m);
      if (titleMatch) {
          title = titleMatch[1].trim().replace(/^["']|["']$/g, '');
          body = text.replace(titleMatch[0], '').trim();
      }

      // Try to extract synopsis
      const synopsisMatch = text.match(/\[SYNOPSIS:\s*"?([^"\]]+)"?\]/i) ||
                            text.match(/\*\*Synopsis:\*\*\s*(.+)/i);
      if (synopsisMatch) {
          synopsis = synopsisMatch[1].trim();
          body = body.replace(synopsisMatch[0], '').trim();
      }

      // Try to extract blurb block [BLURB]...[/BLURB]
      const blurbMatch = body.match(/\[BLURB\]\s*([\s\S]*?)\s*\[\/BLURB\]/i);
      if (blurbMatch) {
          blurb = blurbMatch[1].trim();
          body = body.replace(blurbMatch[0], '').trim();
      }

      return { title, synopsis, blurb, body };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BUILD SCENE 1 INTRO PROMPT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function buildScene1IntroPrompt(pKernel, lKernel, pGen, lGen, pPro, lPro) {
      return `Write Scene 1 of this story.

Begin with a captivating opening that establishes:
1. The world and setting through sensory details
2. The protagonist's emotional state and immediate situation
3. The first glimpse or mention of the love interest
4. A hook or tension that draws the reader forward

Include at the start of your response:
[TITLE: "Your chosen title"]
[SYNOPSIS: "A one-sentence hook for this story"]
[BLURB]
Write a title-page synopsis (40-60 words, 2-3 sentences MAX).
Short, moody, enticing. Establish atmosphere, name the tension, end on a charged note.
No exposition, no lore, no plot summary, no rhetorical questions, no clichÃ©s.
[/BLURB]

Then write the scene prose (800-1200 words).

Remember: This is the beginning of a longer story. Plant seeds, don't harvest.`;
  }

  // Expose for use in Begin Story flow
  window.getPreGeneratedCover = () => _preGeneratedCoverUrl;
  window.clearPreGeneratedCover = () => { _preGeneratedCoverUrl = null; };
  window.getBackgroundStoryPromise = () => _backgroundStoryPromise;
  window.isBackgroundStoryStarted = () => _backgroundStoryStarted;
  window.resetBackgroundStory = () => {
      _backgroundStoryPromise = null;
      _backgroundStoryStarted = false;
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RESET COVER GENERATION FLAGS â€” Re-arm system for new cover/story generation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Called by: AUTH RESET, BACK-TO-CONFIG RESET
  // Clears all "already generated" flags to allow fresh generation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window.resetCoverGenerationFlags = () => {
      console.log('[COVER:RESET] Resetting all cover/story generation flags');
      _coverGenUsed = false;
      _preGeneratedCoverUrl = null;
      _backgroundStoryPromise = null;
      _backgroundStoryStarted = false;
      _coverBtnIsBeginStory = false;

      // Reset button UI to initial state
      const btn = document.getElementById('btnGenerateCover');
      if (btn) {
          btn.textContent = 'Generate Your Cover';
          btn.disabled = false;
          // PLAQUE REGIME: No opacity mutation â€” material is static
          btn.classList.remove('begin-story-ready');
      }

      // Hide any completion indicators
      const complete = document.getElementById('coverGenComplete');
      if (complete) complete.classList.add('hidden');
      const locked = document.getElementById('coverGenLocked');
      if (locked) locked.classList.add('hidden');
      const status = document.getElementById('coverGenStatus');
      if (status) status.classList.add('hidden');
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER VIEW â€” Display generated cover with navigation buttons
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function showCoverView() {
      console.log('[COVER:VIEW] Showing Cover View');
      console.log('[COVER:VIEW] _preGeneratedCoverUrl:', _preGeneratedCoverUrl ? 'present' : 'NULL');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SCREEN TRANSITION: Enter 'game' screen for proper navigation
      // This ensures back button returns to setup correctly
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      window.showScreen('game');

      // Enter Cover View mode (disables click-to-open on book)
      if (window.enterCoverViewMode) window.enterCoverViewMode();

      // Update breadcrumb
      if (window.updateBreadcrumb) window.updateBreadcrumb('cover');

      // Set reader page to cover (page 0)
      if (typeof _readerPage !== 'undefined') _readerPage = 0;

      // Show book cover page elements
      const bookCoverPage = $('bookCoverPage');
      const bookObject = $('bookObject');
      const coverButtons = $('coverViewButtons');
      const storyContent = $('storyContent');

      if (bookCoverPage) bookCoverPage.classList.remove('hidden');
      if (bookObject) bookObject.classList.remove('hidden');
      if (coverButtons) coverButtons.classList.remove('hidden');
      if (storyContent) storyContent.classList.add('hidden');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // COVER IMAGE OR FALLBACK â€” Never blocks progression
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const coverImg = $('bookCoverImg');
      const fallback = $('coverFallback');
      const fallbackTitle = $('fallbackTitle');

      // Always populate fallback title with current story title
      // Priority: state.story.title â†’ state._backgroundStoryTitle â†’ storyTitle DOM â†’ state.title â†’ fallback
      if (fallbackTitle) {
          const resolvedTitle = state.story?.title
              || state._backgroundStoryTitle
              || $('storyTitle')?.textContent
              || state.title
              || 'Your Story';
          fallbackTitle.textContent = resolvedTitle.replace(/^["']|["']$/g, '');
      }

      if (_preGeneratedCoverUrl) {
          // Show generated cover, hide fallback
          if (coverImg) {
              coverImg.src = _preGeneratedCoverUrl;
              coverImg.style.display = 'block';
              console.log('[COVER:VIEW] Generated cover displayed');
          }
          if (fallback) fallback.classList.add('hidden');
      } else {
          // Show intentional fallback design (no error messaging)
          console.log('[COVER:VIEW] Showing intentional fallback cover');
          if (fallback) fallback.classList.remove('hidden');
          if (coverImg) coverImg.style.display = 'none';
      }

      // Update Setting button state based on entitlement
      updateSettingButtonState();
  }

  function updateSettingButtonState() {
      const btnSeeSetting = $('btnSeeSetting');
      const notice = $('settingBtnDisabledNotice');
      if (!btnSeeSetting) return;

      // Check entitlement: StoryPass OR Subscriber
      const hasAccess = state.subscribed || (state.storyId && hasStoryPass(state.storyId)) || state.access === 'pass' || state.access === 'sub';

      // ALWAYS keep button enabled and clickable â€” paywall on click
      // Button must NEVER be disabled; click handler shows paywall for non-entitled users
      btnSeeSetting.disabled = false;
      btnSeeSetting.classList.remove('disabled');

      // Show/hide premium indicator notice (informational only, doesn't block click)
      if (hasAccess) {
          if (notice) notice.classList.add('hidden');
          btnSeeSetting.classList.remove('premium-locked');
      } else {
          if (notice) notice.classList.remove('hidden');
          btnSeeSetting.classList.add('premium-locked');
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SETTING VIEW â€” Generate and display setting image
  // NON-BLOCKING: User can always proceed; abort-aware; no charges on cancel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // TEST PLAN:
  // 1. Start setting image gen â†’ immediately click "Begin Story â†’" â†’ story loads fast;
  //    toast shows "Setting image skipped. You were not charged."
  // 2. Start setting image gen â†’ wait for success â†’ image shows; no modal trap
  // 3. Provider returns null / timeout â†’ fallback shows "Setting image unavailable";
  //    toast shows "Setting image unavailable. Continue without it.";
  //    "Try Again" button works.
  // 4. Fortunes do not decrement unless image URL is received and committed (success path only)
  // 5. After 10s, "Still workingâ€¦" hint appears; user can skip at any time
  // 6. "Back to Cover" aborts generation cleanly (no error logs)
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _settingAbortController = null;
  let _settingGenStartTime = null;

  function showSettingView() {
      console.log('[SETTING:VIEW] Showing Setting View');

      // Update breadcrumb
      if (window.updateBreadcrumb) window.updateBreadcrumb('setting');

      const settingView = $('settingView');
      const settingLoading = $('settingViewLoading');
      const settingContent = $('settingViewContent');
      const settingFallback = $('settingViewFallback');

      if (settingView) settingView.classList.remove('hidden');
      if (settingLoading) settingLoading.style.display = 'block';
      if (settingContent) settingContent.classList.add('hidden');
      if (settingFallback) settingFallback.classList.add('hidden');

      // Generate setting image
      generateSettingImage();
  }

  // Abort any in-flight setting image request
  function abortSettingImageGeneration() {
      if (_settingAbortController) {
          console.log('[SETTING:GEN] Aborting in-flight request');
          _settingAbortController.abort();
          _settingAbortController = null;
      }
  }

  // Check if error is an abort (user-initiated cancel)
  function isAbortError(err) {
      if (!err) return false;
      if (err.name === 'AbortError') return true;
      const msg = (err.message || '').toLowerCase();
      return msg.includes('abort') || msg.includes('signal is aborted');
  }

  async function generateSettingImage() {
      console.log('[SETTING:GEN] Starting setting image generation');

      // Abort any previous request
      abortSettingImageGeneration();

      // Create new abort controller for this request
      _settingAbortController = new AbortController();
      _settingGenStartTime = Date.now();

      // Show "still working" hint after 10s
      const longWaitTimer = setTimeout(() => {
          const hint = $('settingLongWaitHint');
          if (hint) hint.classList.remove('hidden');
      }, 10000);

      try {
          // Build a setting description from state
          const world = state.picks?.world || 'Modern';
          const genre = state.picks?.genre || 'Romance';
          const tone = state.picks?.tone || 'Earnest';
          const desc = `A ${tone.toLowerCase()} ${genre.toLowerCase()} setting in a ${world.toLowerCase()} world. Atmospheric, establishing shot. No characters visible.`;

          // Use the existing generateSettingShot function
          const rawUrl = await generateImageWithFallback({
              prompt: `Cinematic establishing shot. ${desc} Rich atmospheric lighting, detailed environment, professional composition. Landscape orientation.`,
              tier: 'Clean',
              shape: 'landscape',
              context: 'setting-view',
              intent: 'setting',
              signal: _settingAbortController?.signal
          });

          clearTimeout(longWaitTimer);

          // Check if aborted during generation
          if (_settingAbortController?.signal?.aborted) {
              console.log('[SETTING:GEN] CANCELLED by user');
              return; // Exit cleanly, no error
          }

          if (rawUrl) {
              let imageUrl = rawUrl;
              if (!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
                  imageUrl = `data:image/png;base64,${rawUrl}`;
              }

              const settingLoading = $('settingViewLoading');
              const settingContent = $('settingViewContent');
              const settingImg = $('settingViewImg');

              if (settingImg) settingImg.src = imageUrl;
              if (settingLoading) settingLoading.style.display = 'none';
              if (settingContent) settingContent.classList.remove('hidden');

              console.log('[SETTING:GEN] Setting image generated successfully');
              // BILLING: Only here would Fortunes be charged (if applicable)
          } else {
              throw new Error('No image URL returned');
          }
      } catch (err) {
          clearTimeout(longWaitTimer);

          // Distinguish CANCELLED from FAILED
          if (isAbortError(err)) {
              console.log('[SETTING:GEN] CANCELLED (user navigation or abort)');
              // No toast needed here â€” shown by the function that triggered abort
              return;
          }

          console.error('[SETTING:GEN] FAILED:', err);
          // Show fallback view with "Begin Story" button (never blocks progression)
          const settingLoading = $('settingViewLoading');
          const settingFallback = $('settingViewFallback');
          if (settingLoading) settingLoading.style.display = 'none';
          if (settingFallback) settingFallback.classList.remove('hidden');
          console.log('[SETTING:GEN] Showing fallback - image unavailable');
          showToast('Setting image unavailable. Continue without it.');
      } finally {
          _settingAbortController = null;
          const hint = $('settingLongWaitHint');
          if (hint) hint.classList.add('hidden');
      }
  }

  function hideSettingView() {
      // Abort any in-flight setting image generation
      abortSettingImageGeneration();

      const settingView = $('settingView');
      const settingFallback = $('settingViewFallback');
      const settingContent = $('settingViewContent');
      const settingLoading = $('settingViewLoading');
      const settingLongWaitHint = $('settingLongWaitHint');
      if (settingView) settingView.classList.add('hidden');
      if (settingFallback) settingFallback.classList.add('hidden');
      if (settingContent) settingContent.classList.add('hidden');
      if (settingLoading) settingLoading.style.display = 'block'; // Reset for next time
      if (settingLongWaitHint) settingLongWaitHint.classList.add('hidden');
  }

  function hideCoverView() {
      const bookCoverPage = $('bookCoverPage');
      const coverButtons = $('coverViewButtons');
      if (bookCoverPage) bookCoverPage.classList.add('hidden');
      if (coverButtons) coverButtons.classList.add('hidden');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY ENTRY â€” Begin Scene 1 immediately
  // Aborts any in-flight setting image; user was not charged if cancelled
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  async function beginStoryEntry() {
      console.log('[STORY:ENTRY] Beginning story');

      // Check if setting image was still generating (user skipped)
      const wasGenerating = _settingAbortController !== null;

      // Exit Cover View mode (re-enables click navigation on book)
      if (window.exitCoverViewMode) window.exitCoverViewMode();

      // Update breadcrumb
      if (window.updateBreadcrumb) window.updateBreadcrumb('story');

      hideCoverView();
      hideSettingView(); // This aborts any in-flight setting image

      // Show toast if user skipped an in-progress generation
      if (wasGenerating) {
          showToast('Setting image skipped. You were not charged.');
      }

      // Trigger the actual Begin Story flow
      if (typeof handleBeginStory === 'function') handleBeginStory();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER VIEW BUTTON HANDLERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  $('btnSeeSetting')?.addEventListener('click', () => {
      // Check entitlement
      const hasAccess = state.subscribed || (state.storyId && hasStoryPass(state.storyId)) || state.access === 'pass' || state.access === 'sub';
      if (!hasAccess) {
          // CANONICAL: Use story metadata for paywall mode (persisted, immutable per-story)
          window.showPaywall(getPaywallMode());
          return;
      }
      showSettingView();
  });

  $('btnBeginStory')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  $('btnSettingBack')?.addEventListener('click', () => {
      hideSettingView();
      // Stay on cover view â€” restore breadcrumb to cover
      if (window.updateBreadcrumb) window.updateBreadcrumb('cover');
  });

  // Setting image click â†’ Begin Story
  $('settingViewContent')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  // Setting fallback "Begin Story" button
  $('btnSettingBeginStory')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  // Setting loading "Skip / Begin Story" button â€” non-blocking escape hatch
  $('btnSettingSkip')?.addEventListener('click', () => {
      beginStoryEntry();
  });

  // Setting fallback "Try Again" button â€” retry generation
  $('btnSettingRetry')?.addEventListener('click', () => {
      const settingFallback = $('settingViewFallback');
      const settingLoading = $('settingViewLoading');
      if (settingFallback) settingFallback.classList.add('hidden');
      if (settingLoading) settingLoading.style.display = 'block';
      generateSettingImage();
  });

  // Expose for external use
  window.showCoverView = showCoverView;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB INDICATOR â€” Non-clickable orientation display
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Updates visual state only. No click handlers, no navigation, no state mutation.
  // Steps: shape â†’ cover â†’ setting â†’ story
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const BREADCRUMB_STEPS = ['shape', 'cover', 'setting', 'story'];

  function updateBreadcrumb(currentStep) {
      const breadcrumb = $('storyBreadcrumb');
      if (!breadcrumb) return;

      const stepIndex = BREADCRUMB_STEPS.indexOf(currentStep);
      if (stepIndex === -1) {
          // Unknown step â€” hide breadcrumb
          breadcrumb.classList.add('hidden');
          return;
      }

      // Show breadcrumb
      breadcrumb.classList.remove('hidden');

      // Update each step's visual state
      BREADCRUMB_STEPS.forEach((step, idx) => {
          const stepEl = breadcrumb.querySelector(`[data-step="${step}"]`);
          if (!stepEl) return;

          // Clear previous states
          stepEl.classList.remove('breadcrumb-current', 'breadcrumb-past', 'breadcrumb-future');

          if (idx === stepIndex) {
              stepEl.classList.add('breadcrumb-current');
          } else if (idx < stepIndex) {
              stepEl.classList.add('breadcrumb-past');
          } else {
              stepEl.classList.add('breadcrumb-future');
          }
      });

      // Update arrows between steps
      const arrows = breadcrumb.querySelectorAll('.breadcrumb-arrow');
      arrows.forEach((arrow, idx) => {
          arrow.classList.remove('breadcrumb-past');
          // Arrow index 0 is between cover and setting (step indices 1 and 2)
          // Arrow index 1 is between setting and story (step indices 2 and 3)
          const afterStepIndex = idx + 2; // arrows start after "cover" (index 1)
          if (afterStepIndex <= stepIndex) {
              arrow.classList.add('breadcrumb-past');
          }
      });

      console.log('[BREADCRUMB] Updated to:', currentStep);
  }

  function hideBreadcrumb() {
      const breadcrumb = $('storyBreadcrumb');
      if (breadcrumb) breadcrumb.classList.add('hidden');
  }

  // Expose for state updates
  window.updateBreadcrumb = updateBreadcrumb;
  window.hideBreadcrumb = hideBreadcrumb;

  document.querySelectorAll('.preview-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      $('previewText').textContent = btn.dataset.txt || '';
      document.getElementById('previewModal').classList.remove('hidden');
    });
  });

  // MODULE-SCOPE: Zoom state variables (accessible to all card systems)
  let currentOpenCard = null;
  let zoomBackdrop = null;
  let zoomPortal = null;
  // Store original parent/sibling for restoring card after zoom
  let zoomOriginalParent = null;
  let zoomOriginalNextSibling = null;

  function initSelectionHandlers(){
    // Initialize default dynamic (single-select in 4-axis system)
    if (!state.picks.dynamic) {
        state.picks.dynamic = 'Enemies';
    }

    // Bind Visual Auto-Lock
    const chkLock = document.getElementById('chkAutoLockVisual');
    if(chkLock && chkLock.dataset.bound !== '1') {
        chkLock.dataset.bound = '1';
        chkLock.addEventListener('change', (e) => { state.visual.autoLock = e.target.checked; saveStorySnapshot(); });
    }

    bindLengthHandlers();

    // ==========================================================================
    // CANONICAL ORDER: World â†’ Flavor â†’ Tone â†’ Genre â†’ Dynamic
    // ==========================================================================

    // Layer prerequisites - which selections must exist for a layer to be active
    const LAYER_PREREQUISITES = {
      world: [],           // Always active
      worldSubtype: ['world'],  // Requires World
      tone: ['world'],     // Requires World
      pressure: ['world', 'tone'], // Requires World + Tone (replaces genre as primary)
      flavor: ['world', 'tone', 'pressure'], // Requires Pressure
      genre: ['world', 'tone'], // LEGACY: derived from pressure+flavor, kept for compatibility
      dynamic: ['world', 'tone', 'pressure'], // Requires Pressure (not genre)
      era: ['world'],      // Requires World (Historical)
      pov: []              // Always active
    };

    // Tone Ã— Genre compatibility - null means all compatible
    // Format: { tone: [incompatible genres] }
    const TONE_GENRE_INCOMPATIBLE = {
      Earnest: [],        // Earnest works with everything
      WryConfession: [],  // Wry works broadly
      Dark: [],           // Dark fits everything
      Mythic: []          // Mythic is flexible
    };

    // Genre Ã— Dynamic compatibility - null means all compatible
    // Format: { genre: [incompatible dynamics] }
    const GENRE_DYNAMIC_INCOMPATIBLE = {
      Noir: [],
      Heist: [],
      CrimeSyndicate: [],
      Billionaire: [],
      Espionage: [],
      Political: []
    };

    // Check if a genre is compatible with the current tone
    function isGenreCompatible(genre, tone) {
      if (!tone) return true;
      const incompatible = TONE_GENRE_INCOMPATIBLE[tone] || [];
      return !incompatible.includes(genre);
    }

    // Check if a dynamic is compatible with the current genre and tone
    function isDynamicCompatible(dynamic, genre, tone) {
      if (!genre) return true;
      const incompatible = GENRE_DYNAMIC_INCOMPATIBLE[genre] || [];
      return !incompatible.includes(dynamic);
    }

    // Check if a layer has its prerequisites met
    function isLayerUnlocked(grp) {
      const prereqs = LAYER_PREREQUISITES[grp] || [];
      return prereqs.every(p => !!state.picks[p]);
    }

    // Update layer visual state (inert/active)
    function updateLayerStates() {
      const layers = ['world', 'worldSubtype', 'tone', 'pressure', 'flavor', 'genre', 'dynamic'];

      layers.forEach(layer => {
        const cards = document.querySelectorAll(`.sb-card[data-grp="${layer}"]`);
        const unlocked = isLayerUnlocked(layer);

        cards.forEach(card => {
          if (!unlocked) {
            card.classList.add('layer-locked');
          } else {
            card.classList.remove('layer-locked');

            // Additional compatibility checks
            const val = card.dataset.val;
            if (layer === 'pressure') {
              const compatible = isPressureCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'flavor') {
              const compatible = isFlavorCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'genre') {
              const compatible = isGenreCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'dynamic') {
              const compatible = isDynamicCompatible(val, state.picks.genre, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            }
          }
        });

        // Update helper text for locked layers
        updateLayerHelperText(layer, unlocked);
      });
    }

    // Show/hide helper text for locked layers
    function updateLayerHelperText(layer, unlocked) {
      const helperTexts = {
        tone: 'Choose a World to continue',
        pressure: 'Choose a Tone to continue',
        genre: 'Choose a Tone to continue', // Legacy
        dynamic: 'Choose a Pressure to continue'
      };

      const sectionTitles = {
        tone: 'Tone',
        pressure: 'Pull',
        genre: 'Genre', // Legacy
        dynamic: 'Story Polarity'
      };

      // Find section title element
      const sections = document.querySelectorAll('.section-title');
      sections.forEach(section => {
        if (section.textContent.includes(sectionTitles[layer])) {
          let helper = section.querySelector('.layer-helper');
          if (!unlocked && helperTexts[layer]) {
            if (!helper) {
              helper = document.createElement('span');
              helper.className = 'layer-helper';
              section.appendChild(helper);
            }
            helper.textContent = ` â€” ${helperTexts[layer]}`;
            helper.style.display = 'inline';
          } else if (helper) {
            helper.style.display = 'none';
          }
        }
      });
    }

    // Re-evaluate downstream selections and clear only incompatible ones
    function evaluateDownstreamSelections(changedLayer) {
      const order = ['world', 'worldSubtype', 'tone', 'pressure', 'flavor', 'genre', 'dynamic'];
      const changedIdx = order.indexOf(changedLayer);

      // Check each downstream layer
      for (let i = changedIdx + 1; i < order.length; i++) {
        const layer = order[i];
        const currentVal = state.picks[layer];

        if (!currentVal) continue;

        let compatible = true;

        // Check pressure compatibility with tone
        if (layer === 'pressure' && state.picks.tone) {
          compatible = isPressureCompatible(currentVal, state.picks.tone);
        }

        // Check flavor compatibility with tone
        if (layer === 'flavor' && state.picks.tone) {
          compatible = isFlavorCompatible(currentVal, state.picks.tone);
        }

        // Check genre compatibility with tone (legacy)
        if (layer === 'genre' && state.picks.tone) {
          compatible = isGenreCompatible(currentVal, state.picks.tone);
        }

        // Check dynamic compatibility with genre/pressure
        if (layer === 'dynamic' && state.picks.genre) {
          compatible = isDynamicCompatible(currentVal, state.picks.genre, state.picks.tone);
        }

        // Auto-clear only if incompatible
        if (!compatible) {
          autoClearSelection(layer, currentVal);
        }
      }

      // Update flavor grid when tone changes
      if (changedLayer === 'tone' && state.picks.pressure) {
        updateFlavorGridState();
      }

      updateLayerStates();
    }

    // Auto-clear a selection with subtle feedback
    function autoClearSelection(layer, clearedVal) {
      // Clear from state
      state.picks[layer] = null;

      // Update UI
      const card = document.querySelector(`.sb-card[data-grp="${layer}"][data-val="${clearedVal}"]`);
      if (card) {
        card.classList.remove('selected');
        card.classList.add('auto-cleared');

        // Remove feedback after brief moment
        setTimeout(() => {
          card.classList.remove('auto-cleared');
        }, 1500);
      }

      // Dev-only warning
      if (typeof console !== 'undefined' && console.warn) {
        console.warn(`[State Repair] Auto-cleared incompatible ${layer}: ${clearedVal}`);
      }
    }

    // ==========================================================================
    // SELECTION CARD SYSTEM (5Ã—7 Flip Cards)
    // ==========================================================================

    // Sub-options data for each World type
    // Modern: NO custom field | All others: HAS custom field
    const WORLD_SUB_OPTIONS = {
      Modern: [
        { val: 'small_town', label: 'Small Town' },
        { val: 'college', label: 'College' },
        { val: 'friends', label: 'Friends' },
        { val: 'blue_blood', label: 'Blue Blood' },
        { val: 'office', label: '9-5 / Office' },
        { val: 'supernatural_modern', label: 'Supernatural' },
        { val: 'superheroic_modern', label: 'Superheroic' }
      ],
      Historical: [
        { val: 'prehistoric', label: 'Prehistoric' },
        { val: 'bronze_age', label: 'Bronze Age' },
        { val: 'classical', label: 'Classical' },
        { val: 'medieval', label: 'Medieval' },
        { val: 'renaissance', label: 'Renaissance' },
        { val: 'victorian', label: 'Victorian' },
        { val: '20th_century', label: '20th Century' }
      ],
      Fantasy: [
        { val: 'arcane_binding', label: 'Arcane Binding' },
        { val: 'fated_blood', label: 'Fated Blood' },
        { val: 'the_inhuman', label: 'The Inhuman' },
        { val: 'the_beyond', label: 'The Beyond' },
        { val: 'cursed', label: 'Cursed' }
      ],
      SciFi: [
        { val: 'galactic_civilizations', label: 'Galactic Conflict' },
        { val: 'future_of_science', label: 'Science Future' },
        { val: 'cyberpunk', label: 'Cyberpunk' },
        { val: 'post_human', label: 'Post-Human' },
        { val: 'first_contact', label: 'First Contact' },
        { val: 'simulation', label: 'Simulation' },
        { val: 'final_frontier', label: 'Final Frontier' }
      ],
      Dystopia: [
        { val: 'glass_house', label: 'Glass House' },
        { val: 'human_capital', label: 'Human Capital' },
        { val: 'dogma', label: 'Dogma' },
        { val: 'quieting_event', label: 'The Quieting' },
        { val: 'endless_edit', label: 'Erasure' },
        { val: 'thirst', label: 'Thirst' }
      ],
      PostApocalyptic: [
        { val: 'ashfall', label: 'Ashfall' },
        { val: 'year_zero', label: 'Year 0' },
        { val: 'dystimulation', label: 'Dystimulation' },
        { val: 'predation', label: 'Predation' },
        { val: 'hunger', label: 'Hunger' }
      ]
    };

    // Worlds that have custom text fields (all except Modern)
    // PASS 9F: Added Modern to enable custom modifier text field
    const WORLDS_WITH_CUSTOM_FIELD = ['Modern', 'Historical', 'Fantasy', 'SciFi', 'Dystopia', 'PostApocalyptic'];

    // Historical era remapping (legacy values â†’ new values)
    const HISTORICAL_ERA_REMAP = {
      'Ancient': 'prehistoric',
      'ancient': 'prehistoric',
      'Bronze Age': 'bronze_age',
      'bronze age': 'bronze_age',
      'Bronze': 'bronze_age',
      'Classical': 'classical',
      'Biblical': 'classical',
      'Medieval': 'medieval',
      'Renaissance': 'renaissance',
      'Early Modern': 'renaissance',
      'Victorian': 'victorian',
      'Industrial': 'victorian',
      'Early20th': '20th_century',
      'Mid20th': '20th_century',
      'Early 20th': '20th_century',
      'Mid-20th': '20th_century',
      '20th Century': '20th_century'
    };

    // Normalize custom field input (IP-safe transformation)
    // Accepts any input, returns normalized kernel
    function normalizeWorldCustom(input) {
      if (!input || typeof input !== 'string') return '';

      // Trim and clean whitespace
      let normalized = input.trim().replace(/\s+/g, ' ');

      // Cap length to prevent abuse
      if (normalized.length > 500) {
        normalized = normalized.substring(0, 500);
      }

      return normalized;
    }

    // Apply Historical era remapping (legacy â†’ new values)
    function applyHistoricalEraRemap() {
      // Check if we have a legacy era value that needs remapping
      if (state.picks.era && !state.picks.worldSubtype) {
        const remapped = HISTORICAL_ERA_REMAP[state.picks.era];
        if (remapped) {
          state.picks.worldSubtype = remapped;
        }
      }

      // Also check worldSubtype itself for legacy values
      if (state.picks.worldSubtype && HISTORICAL_ERA_REMAP[state.picks.worldSubtype]) {
        state.picks.worldSubtype = HISTORICAL_ERA_REMAP[state.picks.worldSubtype];
      }
    }

    function initSelectionCardSystem() {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ZOOM PORTAL ARCHITECTURE
      // Structure: body > backdrop (dims) > portal (holds zoomed card)
      // Backdrop: pointer-events:auto to catch clicks for closing
      // Portal: pointer-events:auto, sits ABOVE backdrop
      // Zoomed card: moved INTO portal, completely isolated from ancestors
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Create zoom backdrop (dims background, catches clicks to close)
      if (!document.getElementById('sbZoomBackdrop')) {
        zoomBackdrop = document.createElement('div');
        zoomBackdrop.id = 'sbZoomBackdrop';
        zoomBackdrop.className = 'sb-zoom-backdrop';
        document.body.appendChild(zoomBackdrop);

        // Close zoom on backdrop click
        zoomBackdrop.addEventListener('click', () => {
          closeZoomedCard();
        });
      } else {
        zoomBackdrop = document.getElementById('sbZoomBackdrop');
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Zoom Portal Invariant:
      // All zoomed cards MUST be moved into this portal.
      // No zoomed card may remain inside dimmed or transformed ancestors.
      // Do not replace with CSS-based isolation.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!document.getElementById('sbZoomPortal')) {
        zoomPortal = document.createElement('div');
        zoomPortal.id = 'sbZoomPortal';
        zoomPortal.className = 'sb-zoom-portal';
        document.body.appendChild(zoomPortal);
      } else {
        zoomPortal = document.getElementById('sbZoomPortal');
      }

      // Keyboard handler for Escape and arrow keys
      document.addEventListener('keydown', (e) => {
        if (!currentOpenCard) return;
        if (e.key === 'Escape') {
          closeZoomedCard();
          return;
        }
        // Arrow key navigation for archetype zoom
        if (currentOpenCard.classList.contains('archetype-card') && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
          const curId = currentOpenCard.dataset.archetype;
          if (!curId) return;
          const idx = ARCHETYPE_ORDER.indexOf(curId);
          if (idx === -1) return;
          const newIdx = e.key === 'ArrowLeft'
            ? (idx - 1 + ARCHETYPE_ORDER.length) % ARCHETYPE_ORDER.length
            : (idx + 1) % ARCHETYPE_ORDER.length;
          navigateZoomedArchetype(ARCHETYPE_ORDER[newIdx]);
        }
      });

      // REMOVED: convertCardsToSelectionCards() - World, Tone, Genre, Dynamic now use .sb-card system
    }

    function convertCardsToSelectionCards() {
      // Process each layer's card grid
      const grids = [
        { id: 'worldGrid', grp: 'world' },
        { id: 'toneGrid', grp: 'tone' },
        { id: 'genreGrid', grp: 'genre' }
      ];

      grids.forEach(({ id, grp }) => {
        const grid = document.getElementById(id);
        if (!grid) return;

        // Get existing cards
        const oldCards = grid.querySelectorAll('.sb-card[data-grp]');
        const cardData = [];

        oldCards.forEach(card => {
          cardData.push({
            val: card.dataset.val,
            title: card.querySelector('h3')?.textContent || '',
            desc: card.querySelector('p')?.textContent || '',
            selected: card.classList.contains('selected')
          });
        });

        // Clear and convert to selection grid
        grid.classList.remove('style-cards');
        grid.classList.add('selection-grid');
        grid.innerHTML = '';

        cardData.forEach(data => {
          const selCard = createSelectionCard(grp, data);
          grid.appendChild(selCard);
        });
      });

      // Handle dynamic cards (grouped structure)
      const dynamicGrid = document.getElementById('dynamicGrid');
      if (dynamicGrid) {
        const allDynamicCards = dynamicGrid.querySelectorAll('.sb-card[data-grp="dynamic"]');
        const cardData = [];

        allDynamicCards.forEach(card => {
          cardData.push({
            val: card.dataset.val,
            title: card.querySelector('h3')?.textContent || '',
            desc: card.querySelector('p')?.textContent || '',
            selected: card.classList.contains('selected')
          });
        });

        // Replace with flat selection grid
        dynamicGrid.innerHTML = '';
        dynamicGrid.classList.add('selection-grid');
        dynamicGrid.classList.remove('dynamic-grouped');

        cardData.forEach(data => {
          const selCard = createSelectionCard('dynamic', data);
          dynamicGrid.appendChild(selCard);
        });
      }

      // Update layer states for new cards
      updateSelectionCardStates();
    }

    function createSelectionCard(grp, data) {
      const card = document.createElement('div');
      card.className = 'selection-card';
      card.dataset.grp = grp;
      card.dataset.val = data.val;
      if (data.selected) card.classList.add('selected');

      card.innerHTML = `
        <div class="selection-card-inner">
          <div class="selection-card-face selection-card-front">
            <span class="card-title">${data.title}</span>
          </div>
          <div class="selection-card-face selection-card-back">
            <h4 class="card-title">${data.title}</h4>
            <p class="card-desc">${data.desc}</p>
          </div>
        </div>
      `;

      card.addEventListener('click', () => openSelectionCard(card, grp, data));

      return card;
    }

    // Legacy openSelectionCard - now uses portal zoom for .selection-card elements
    // NOTE: .selection-card system is deprecated - .sb-card is the canonical system
    function openSelectionCard(card, grp, data) {
      // Check if layer is unlocked
      if (!isLayerUnlocked(grp)) return;

      // Check if card is incompatible
      if (card.classList.contains('incompatible')) return;

      // Close any currently open card
      if (currentOpenCard) {
        closeZoomedCard();
      }

      currentOpenCard = card;

      // Dim all other cards
      document.querySelectorAll('.selection-card').forEach(c => {
        if (c !== card) c.classList.add('dimmed');
      });

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Store original DOM position for restoration
      zoomOriginalParent = card.parentNode;
      zoomOriginalNextSibling = card.nextElementSibling;

      // Store original position for animation reference
      card.dataset.zoomOriginalLeft = rect.left;
      card.dataset.zoomOriginalTop = rect.top;

      // TAROT ASPECT RATIO: 2.75 / 4.75 (canonical proportions)
      // Calculate zoomed size based on aspect ratio, not original rect
      const tarotAspect = 2.75 / 4.75;
      const sidePadding = 60;
      const topPadding = 40;
      const bottomPadding = 90; // modifier box + continue button + portal padding
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;

      // Calculate max dimensions that fit viewport while maintaining aspect ratio
      let zoomedWidth, zoomedHeight;
      if (maxWidth / maxHeight > tarotAspect) {
        // Height-constrained: fill height, calculate width from aspect
        zoomedHeight = maxHeight;
        zoomedWidth = zoomedHeight * tarotAspect;
      } else {
        // Width-constrained: fill width, calculate height from aspect
        zoomedWidth = maxWidth;
        zoomedHeight = zoomedWidth / tarotAspect;
      }

      // PORTAL MOVE: Move card into zoom portal
      if (zoomPortal) {
        zoomPortal.appendChild(card);
      }

      // Apply zoom styling - flexbox in portal handles centering
      card.classList.add('zoomed');
      card.style.width = `${zoomedWidth}px`;
      card.style.height = `${zoomedHeight}px`;
      card.style.transform = 'none';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';

      // Show backdrop
      if (zoomBackdrop) {
        zoomBackdrop.classList.add('active');
      }
    }

    function selectFromZoomedCard(grp, val) {
      // Update state (canonicalize tone)
      state.picks[grp] = grp === 'tone' ? canonicalizeTone(val) : val;

      // Derive tone bias when structural axes change
      if (grp === 'tone' || grp === 'world' || grp === 'pressure') deriveToneBias();

      // Clear cover shape hash â€” selection changed, enable regeneration
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();

      // Update card selection states
      document.querySelectorAll(`.selection-card[data-grp="${grp}"]`).forEach(c => {
        const isSelected = c.dataset.val === val;
        c.classList.toggle('selected', isSelected);
        c.classList.toggle('flipped', isSelected);
      });

      // Also update old-style cards if any remain
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        const isSelected = c.dataset.val === val;
        c.classList.toggle('selected', isSelected);
        c.classList.toggle('flipped', isSelected);
      });

      // Handle World-specific updates
      if (grp === 'world') {
        updateWorldSubtypeVisibility(val, state.picks.tone);
        // Clear subtype if world changed
        if (state.picks.worldSubtype && !WORLD_SUB_OPTIONS[val]?.some(o => o.val === state.picks.worldSubtype)) {
          state.picks.worldSubtype = null;
        }
      }

      // Handle Tone-specific updates
      if (grp === 'tone') {
        updateWorldSubtypeVisibility(state.picks.world, val);
      }

      // Evaluate downstream selections
      evaluateDownstreamSelections(grp);

      // Increment DSP activation count (explicit Story Shape choice)
      incrementDSPActivation();

      // Update synopsis
      updateSynopsisPanel(true); // User action: card selection

      // Close after brief delay
      setTimeout(() => closeSelectionCard(), 300);
    }

    // Close zoomed card - returns card to original DOM position
    function closeZoomedCard() {
      if (!currentOpenCard) return;

      const wasArchetype = currentOpenCard.classList.contains('archetype-card');

      // Stop and remove zoom sparkle emitter
      stopSparkleEmitter('zoomCardSparkles');
      const sparkleEl = currentOpenCard.querySelector('#zoomCardSparkles');
      if (sparkleEl) sparkleEl.remove();

      // Remove zoom nav arrows and zoom continue button from portal
      if (zoomPortal) {
        zoomPortal.querySelectorAll('.zoom-nav-arrow, .zoom-continue-btn').forEach(el => el.remove());
      }

      // Remove any dynamically added zoom content
      const zoomContent = currentOpenCard.querySelector('.sb-zoom-content');
      if (zoomContent) {
        zoomContent.remove();
      }
      // Remove zoom flavor arc (world/pressure cards)
      const zoomFlavorArc = currentOpenCard.querySelector('.sb-zoom-flavor-arc');
      if (zoomFlavorArc) {
        zoomFlavorArc.remove();
      }
      // Remove baked-art overlay (Modern and other PNG-button cards)
      const bakedOverlay = currentOpenCard.querySelector('.sb-zoom-baked-overlay');
      if (bakedOverlay) {
        bakedOverlay.remove();
      }
      // Restore card title hidden during baked-art zoom (front face only)
      const hiddenTitle = currentOpenCard.querySelector('.sb-card-front .sb-card-title');
      if (hiddenTitle && hiddenTitle.style.display === 'none') {
        hiddenTitle.style.display = '';
      }

      // Remove zoom class and restore original positioning
      currentOpenCard.classList.remove('zoomed');
      currentOpenCard.style.transform = '';
      currentOpenCard.style.transformOrigin = '';
      currentOpenCard.style.left = '';
      currentOpenCard.style.top = '';
      currentOpenCard.style.width = '';
      currentOpenCard.style.height = '';
      currentOpenCard.style.position = '';

      // Remove inlined backgrounds (grid-scoped selectors take over once card is back)
      removeInlinedBackgrounds(currentOpenCard);

      // PORTAL RESTORE: Move card back to original DOM position
      if (zoomOriginalParent) {
        if (zoomOriginalNextSibling) {
          zoomOriginalParent.insertBefore(currentOpenCard, zoomOriginalNextSibling);
        } else {
          zoomOriginalParent.appendChild(currentOpenCard);
        }
      }
      zoomOriginalParent = null;
      zoomOriginalNextSibling = null;

      // Clean up stored position data
      delete currentOpenCard.dataset.zoomOriginalLeft;
      delete currentOpenCard.dataset.zoomOriginalTop;
      delete currentOpenCard.dataset.zoomOriginalWidth;
      delete currentOpenCard.dataset.zoomOriginalHeight;

      // Remove dimming from all cards (both .sb-card and .selection-card)
      document.querySelectorAll('.sb-card.dimmed, .selection-card.dimmed').forEach(c => {
        c.classList.remove('dimmed');
      });

      // Hide backdrop
      if (zoomBackdrop) {
        zoomBackdrop.classList.remove('active');
      }

      currentOpenCard = null;

      // Re-apply layer states
      updateSelectionCardStates();

      // Post-close: start corridor sparkles for archetype cards
      if (wasArchetype) {
        startLastZoomedSparkles();
      }
    }

    // Resize zoomed card on window resize (flexbox handles centering)
    function recenterZoomedCard() {
      if (!currentOpenCard || !currentOpenCard.classList.contains('zoomed')) return;

      const origWidth = parseFloat(currentOpenCard.dataset.zoomOriginalWidth) || 140;
      const origHeight = parseFloat(currentOpenCard.dataset.zoomOriginalHeight) || 193;
      const sidePadding = 60;
      const topPadding = 20;
      const bottomPadding = 60;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / origWidth, maxHeight / origHeight);

      // Flexbox handles centering, just update scale
      currentOpenCard.style.transform = `scale(${scale})`;
      currentOpenCard.style.setProperty('--zoom-scale', scale);
    }

    // Add resize listener for zoomed card centering
    window.addEventListener('resize', recenterZoomedCard);

    // Legacy alias for compatibility
    function closeSelectionCard() {
      closeZoomedCard();
    }

    // Inline computed background properties on card faces before portal move.
    // Grid-scoped selectors (#worldGrid .sb-card .sb-card-front, etc.) break
    // when the card is moved to the zoom portal, so we bake styles inline.
    function inlineCardFaceBackgrounds(card) {
      card.querySelectorAll('.sb-card-face').forEach(face => {
        if (face.dataset.bgInlined) return;
        const cs = getComputedStyle(face);
        const bg = cs.backgroundImage;
        if (bg && bg !== 'none') {
          face.style.backgroundImage = bg;
          face.style.backgroundSize = cs.backgroundSize;
          face.style.backgroundPosition = cs.backgroundPosition;
          face.style.backgroundRepeat = cs.backgroundRepeat;
          face.dataset.bgInlined = '1';
        }
      });
    }

    // Remove inlined backgrounds when card returns to grid
    function removeInlinedBackgrounds(card) {
      card.querySelectorAll('.sb-card-face').forEach(face => {
        if (face.dataset.bgInlined) {
          face.style.backgroundImage = '';
          face.style.backgroundSize = '';
          face.style.backgroundPosition = '';
          face.style.backgroundRepeat = '';
          delete face.dataset.bgInlined;
        }
      });
    }

    // STATE 3: Open zoomed view for .sb-card elements
    // PORTAL ARCHITECTURE: Card is MOVED into zoom portal (not just position:fixed)
    // This breaks out of ALL ancestor stacking contexts and filters
    function openSbCardZoom(card, grp, val) {
      // Close any currently open card
      if (currentOpenCard) {
        closeZoomedCard();
      }

      currentOpenCard = card;

      // Dim all other cards in same group
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        if (c !== card) c.classList.add('dimmed');
      });

      // For World cards, add flavor content to the front face
      if (grp === 'world') {
        populateWorldZoomContent(card, val);
      }

      // For Story Pull (pressure) cards, add flavor content to the front face
      if (grp === 'pressure') {
        populatePressureZoomContent(card, val);
      }

      // Inline background-image before portal move (grid-scoped selectors break in portal)
      inlineCardFaceBackgrounds(card);

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Store original DOM position for restoration
      zoomOriginalParent = card.parentNode;
      zoomOriginalNextSibling = card.nextElementSibling;

      // Store original position and dimensions for scale calculation
      card.dataset.zoomOriginalLeft = rect.left;
      card.dataset.zoomOriginalTop = rect.top;
      card.dataset.zoomOriginalWidth = rect.width;
      card.dataset.zoomOriginalHeight = rect.height;

      // SCALE ZOOM: Card stays at original size, scale() enlarges uniformly
      // This preserves the PNG art contract â€” text, buttons, art all scale together
      const sidePadding = 60;
      const topPadding = 20;
      const bottomPadding = 60;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / rect.width, maxHeight / rect.height);

      // PORTAL MOVE: Move card into zoom portal (breaks ALL ancestor contexts)
      if (zoomPortal) {
        zoomPortal.appendChild(card);
      }

      // Apply zoom: lock original dimensions, scale uniformly like a physical card
      card.classList.add('zoomed');
      card.style.width = `${rect.width}px`;
      card.style.height = `${rect.height}px`;
      card.style.transform = `scale(${scale})`;
      card.style.setProperty('--zoom-scale', scale);
      card.style.transformOrigin = 'center center';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';

      // Show backdrop
      if (zoomBackdrop) {
        zoomBackdrop.classList.add('active');
      }

      // Add left/right navigation arrows
      if (zoomPortal) {
        const siblings = zoomOriginalParent
          ? Array.from(zoomOriginalParent.querySelectorAll(`.sb-card[data-grp="${grp}"]`))
          : [];

        if (siblings.length > 1) {
          const leftArrow = document.createElement('div');
          leftArrow.className = 'zoom-nav-arrow zoom-nav-left';
          leftArrow.innerHTML = '&#8249;';
          leftArrow.addEventListener('click', (e) => {
            e.stopPropagation();
            navigateZoomedSbCard(-1);
          });
          zoomPortal.appendChild(leftArrow);

          const rightArrow = document.createElement('div');
          rightArrow.className = 'zoom-nav-arrow zoom-nav-right';
          rightArrow.innerHTML = '&#8250;';
          rightArrow.addEventListener('click', (e) => {
            e.stopPropagation();
            navigateZoomedSbCard(1);
          });
          zoomPortal.appendChild(rightArrow);
        }

        // Add Continue button
        const zoomContinueBtn = document.createElement('button');
        zoomContinueBtn.className = 'zoom-continue-btn';
        zoomContinueBtn.textContent = 'Proceed';
        zoomContinueBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          commitSbCardFromZoom();
        });
        zoomPortal.appendChild(zoomContinueBtn);
      }

      // Add sparkle emitter to all zoomed corridor cards (anchored to card, not front face)
      {
        const sparkleContainer = document.createElement('div');
        sparkleContainer.className = 'zoom-card-sparkles';
        sparkleContainer.id = 'zoomCardSparkles';
        card.appendChild(sparkleContainer);
        startSparkleEmitter('zoomCardSparkles', 'zoomCard', 8);
      }
    }

    /**
     * Navigate between corridor cards while in zoom view.
     * direction: -1 for previous, +1 for next
     */
    function navigateZoomedSbCard(direction) {
      if (!currentOpenCard || !zoomPortal || !zoomOriginalParent) return;

      const grp = currentOpenCard.dataset.grp;
      const oldCard = currentOpenCard;

      // Get all sibling cards from the original grid (includes old card which is in portal)
      // Old card is in portal, so query grid siblings + include old card
      const gridSiblings = Array.from(
        zoomOriginalParent.querySelectorAll(`.sb-card[data-grp="${grp}"]`)
      );
      // Add old card back in to determine index
      const allCards = [...gridSiblings];
      // Find where old card WAS by looking at zoomOriginalNextSibling
      let oldIdx = -1;
      if (zoomOriginalNextSibling) {
        const nextIdx = allCards.indexOf(zoomOriginalNextSibling);
        oldIdx = nextIdx >= 0 ? nextIdx : allCards.length;
      } else {
        oldIdx = allCards.length;
      }
      // Insert old card reference at its original position
      allCards.splice(oldIdx, 0, oldCard);

      const currentIdx = allCards.indexOf(oldCard);
      const newIdx = (currentIdx + direction + allCards.length) % allCards.length;
      const newCard = allCards[newIdx];
      if (!newCard || newCard === oldCard) return;

      const newGrp = newCard.dataset.grp;
      const newVal = newCard.dataset.val;

      // Remove old zoom content and flavor arc
      const oldZoomContent = oldCard.querySelector('.sb-zoom-content');
      if (oldZoomContent) oldZoomContent.remove();
      const oldFlavorArc = oldCard.querySelector('.sb-zoom-flavor-arc');
      if (oldFlavorArc) oldFlavorArc.remove();

      // Stop and remove zoom sparkle emitter from old card
      stopSparkleEmitter('zoomCardSparkles');
      const oldSparkleEl = oldCard.querySelector('#zoomCardSparkles');
      if (oldSparkleEl) oldSparkleEl.remove();

      // Remove inlined backgrounds and restore old card to grid
      removeInlinedBackgrounds(oldCard);
      oldCard.classList.remove('zoomed');
      oldCard.style.transform = '';
      oldCard.style.width = '';
      oldCard.style.height = '';
      oldCard.style.position = '';
      if (zoomOriginalParent) {
        if (zoomOriginalNextSibling) {
          zoomOriginalParent.insertBefore(oldCard, zoomOriginalNextSibling);
        } else {
          zoomOriginalParent.appendChild(oldCard);
        }
      }
      delete oldCard.dataset.zoomOriginalLeft;
      delete oldCard.dataset.zoomOriginalTop;

      // Dim/undim cards
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        c.classList.toggle('dimmed', c !== newCard);
      });

      // Populate zoom content for new card
      if (newGrp === 'world') populateWorldZoomContent(newCard, newVal);
      if (newGrp === 'pressure') populatePressureZoomContent(newCard, newVal);

      // Inline backgrounds before portal move
      inlineCardFaceBackgrounds(newCard);

      // Store new card's position and move to portal
      const rect = newCard.getBoundingClientRect();
      zoomOriginalParent = newCard.parentNode;
      zoomOriginalNextSibling = newCard.nextElementSibling;
      newCard.dataset.zoomOriginalLeft = rect.left;
      newCard.dataset.zoomOriginalTop = rect.top;

      // SCALE ZOOM: Card stays at original size, scale() enlarges uniformly
      const sidePadding = 60;
      const topPadding = 20;
      const bottomPadding = 60;
      const maxWidth = window.innerWidth - sidePadding * 2;
      const maxHeight = window.innerHeight - topPadding - bottomPadding;
      const scale = Math.min(maxWidth / rect.width, maxHeight / rect.height);

      newCard.dataset.zoomOriginalWidth = rect.width;
      newCard.dataset.zoomOriginalHeight = rect.height;

      // Insert before nav arrows
      const firstArrow = zoomPortal.querySelector('.zoom-nav-arrow');
      if (firstArrow) {
        zoomPortal.insertBefore(newCard, firstArrow);
      } else {
        zoomPortal.appendChild(newCard);
      }

      newCard.classList.add('zoomed');
      newCard.style.width = `${rect.width}px`;
      newCard.style.height = `${rect.height}px`;
      newCard.style.transform = `scale(${scale})`;
      newCard.style.setProperty('--zoom-scale', scale);
      newCard.style.transformOrigin = 'center center';
      newCard.style.position = '';
      newCard.style.left = '';
      newCard.style.top = '';

      currentOpenCard = newCard;

      // Add sparkle emitter to new card (anchored to card, not front face)
      {
        const sparkleContainer = document.createElement('div');
        sparkleContainer.className = 'zoom-card-sparkles';
        sparkleContainer.id = 'zoomCardSparkles';
        newCard.appendChild(sparkleContainer);
        startSparkleEmitter('zoomCardSparkles', 'zoomCard', 8);
      }
    }

    /**
     * Commit selection from zoomed corridor card view.
     * Selects the card, creates breadcrumb, closes zoom, advances corridor.
     */
    function commitSbCardFromZoom() {
      if (!currentOpenCard) return;

      const grp = currentOpenCard.dataset.grp;
      const val = currentOpenCard.dataset.val;
      if (!grp || !val) return;

      // Update state (canonicalize tone)
      state.picks[grp] = grp === 'tone' ? canonicalizeTone(val) : val;
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();

      // Derive tone bias when structural axes change
      if (grp === 'tone' || grp === 'world' || grp === 'pressure') deriveToneBias();

      // Mark card as selected
      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
        const isSelected = c.dataset.val === val;
        c.classList.toggle('selected', isSelected);
        c.classList.toggle('flipped', isSelected);
      });

      // Handle World-specific updates
      if (grp === 'world') {
        state.resolvedWorldFlavors = null; // force recomputation on next generation
        updateWorldSubtypeVisibility(val, state.picks.tone);
        if (state.picks.worldSubtype && !WORLD_SUB_OPTIONS[val]?.some(o => o.val === state.picks.worldSubtype)) {
          state.picks.worldSubtype = null;
        }
      }
      if (grp === 'tone') {
        updateWorldSubtypeVisibility(state.picks.world, val);
      }

      evaluateDownstreamSelections(grp);
      incrementDSPActivation();
      updateSynopsisPanel(true);

      // Get card title for breadcrumb
      const titleEl = currentOpenCard.querySelector('.sb-card-title');
      const selectedTitle = titleEl ? titleEl.textContent : val;

      // Capture zoomed card position BEFORE closing zoom for sparkle trail
      const zoomedRect = currentOpenCard.getBoundingClientRect();
      const fromX = zoomedRect.left + zoomedRect.width / 2;
      const fromY = zoomedRect.top + zoomedRect.height / 2;

      // Close zoom
      closeZoomedCard();

      // Fire sparkle trail from zoomed card position to breadcrumb target
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      if (breadcrumbRow) {
        const stageIdx = STAGE_INDEX[grp];
        const ghostStep = breadcrumbRow.querySelector(`.ghost-step[data-ghost-index="${stageIdx}"]`);
        let toX, toY;
        if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          toX = ghostRect.left + ghostRect.width / 2;
          toY = ghostRect.top + ghostRect.height / 2;
        } else {
          const brRect = breadcrumbRow.getBoundingClientRect();
          toX = brRect.left + brRect.width / 2;
          toY = brRect.top + brRect.height / 2;
        }
        fireSparkleTrail(fromX, fromY, zoomedRect.width, zoomedRect.height, toX, toY);
      }

      // Create breadcrumb and advance corridor
      createBreadcrumbDirect(grp, val, selectedTitle);

      // Find and hide the corridor continue button for this stage
      const stageMap = { world: 'world', tone: 'tone', pressure: 'pressure', pov: 'pov', length: 'length', dynamic: 'dynamic' };
      const stage = stageMap[grp] || grp;
      hideCorridorContinueButton(stage);

      setTimeout(() => advanceCorridorRow(), 1300);
    }

    // Populate World card zoom view with flavor buttons and optional custom field
    // Baked-in button positions for world cards with custom PNG art.
    // Positions are percentages of the card face. Hit zones are transparent
    // overlays that map clicks to the buttons baked into the PNG.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BAKED-ART HIT ZONES â€” Transparent click regions over zoomed card art
    // 2-column layout: left col ~17.6%, right col ~53%, rows spaced ~6.5%
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const BAKED_ART_BUTTONS = {
      Modern: [
        { val: 'small_town',          top: 56.7, left: 17.6, width: 29.1, height: 4.9 },
        { val: 'college',             top: 56.7, left: 53.3, width: 29.1, height: 4.5 },
        { val: 'friends',             top: 63.4, left: 17.6, width: 29.4, height: 4.5 },
        { val: 'blue_blood',          top: 63.2, left: 53,   width: 29.4, height: 4.8 },
        { val: 'office',              top: 69.8, left: 17.4, width: 29.6, height: 4.9 },
        { val: 'superheroic_modern',  top: 70,   left: 53,   width: 30.2, height: 4.6 },
        { val: 'supernatural_modern', top: 76.5, left: 17.6, width: 29.4, height: 5 }
      ],
      Historical: [
        { val: '20th_century',  top: 56.7, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'victorian',     top: 56.7, left: 53,   width: 29.2, height: 4.8 },
        { val: 'renaissance',   top: 63.3, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'medieval',      top: 63.3, left: 53,   width: 29.2, height: 4.8 },
        { val: 'classical',     top: 69.9, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'bronze_age',    top: 69.9, left: 53,   width: 29.2, height: 4.8 },
        { val: 'prehistoric',   top: 76.5, left: 17.6, width: 29.2, height: 4.8 }
      ],
      Fantasy: [
        { val: 'arcane_binding', top: 63.3, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'fated_blood',    top: 63.3, left: 53,   width: 29.2, height: 4.8 },
        { val: 'the_beyond',     top: 69.9, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'the_inhuman',    top: 69.9, left: 53,   width: 29.2, height: 4.8 },
        { val: 'cursed',         top: 76.5, left: 17.6, width: 29.2, height: 4.8 }
      ],
      SciFi: [
        { val: 'final_frontier',         top: 56.7, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'first_contact',          top: 56.7, left: 53,   width: 29.2, height: 4.8 },
        { val: 'future_of_science',      top: 63.3, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'simulation',             top: 63.3, left: 53,   width: 29.2, height: 4.8 },
        { val: 'post_human',             top: 69.9, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'cyberpunk',              top: 69.9, left: 53,   width: 29.2, height: 4.8 },
        { val: 'galactic_civilizations', top: 76.5, left: 17.6, width: 29.2, height: 4.8 }
      ],
      Dystopia: [
        { val: 'glass_house',     top: 57.8, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'human_capital',      top: 64.3, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'dogma',    top: 64.3, left: 53,   width: 29.2, height: 4.8 },
        { val: 'endless_edit',    top: 70.8, left: 53,   width: 29.2, height: 4.8 },
        { val: 'quieting_event',  top: 77.3, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'thirst',          top: 57.8, left: 53,   width: 29.2, height: 4.8 }
      ],
      PostApocalyptic: [
        { val: 'ashfall',        top: 63.3, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'year_zero',      top: 63.3, left: 53,   width: 29.2, height: 4.8 },
        { val: 'dystimulation',  top: 69.9, left: 17.6, width: 29.2, height: 4.8 },
        { val: 'predation',      top: 69.9, left: 53,   width: 29.2, height: 4.8 },
        { val: 'hunger',         top: 76.5, left: 17.6, width: 29.2, height: 4.8 }
      ]
    };
    const BAKED_ART_SCROLL_ZONE = {
      Modern:          { top: 76.7, left: 54,   width: 27.5, height: 4.1 },
      Historical:      { top: 76.5, left: 53,   width: 29.2, height: 4.1 },
      Fantasy:         { top: 76.5, left: 53,   width: 29.2, height: 4.1 },
      SciFi:           { top: 76.5, left: 53,   width: 29.2, height: 4.1 },
      Dystopia:        { top: 78.0, left: 53,   width: 29.2, height: 4.1 },
      PostApocalyptic: { top: 76.5, left: 53,   width: 29.2, height: 4.1 }
    };
    // Scrolling suggestions for baked-art cards â€” themes NOT already in the buttons
    const BAKED_ART_SUGGESTIONS = {
      Modern: [
        'Western', 'Moviestar', 'Rockstar', 'Artist', 'Treasure Hunter',
        'Astronaut', 'Activist', 'Agent', 'Retirement', 'World Travel',
        'West Wing', 'Undercover', 'Firefighter', 'Chef', 'Journalist',
        'Architect', 'Pilot', 'Deep Sea', 'Vineyard', 'Festival Circuit'
      ],
      Historical: [
        'Ancient Rome', 'Silk Road', 'Viking Age', 'Samurai', 'Ottoman Court',
        'Egyptian Dynasty', 'Crusades', 'Pirate Age', 'Wild West', 'Tudor Court',
        'Byzantine', 'Ming Dynasty', 'Aztec Empire', 'French Revolution',
        'Edo Japan', 'Colonial India', 'Ancient Greece', 'Mongol Empire',
        'Roaring Twenties', 'Spartan'
      ],
      Fantasy: [
        'Dragon Keep', 'Fae Court', 'Necromancer', 'Shapeshifter', 'Dark Academy',
        'Witch Coven', 'Dragon Rider', 'Sunken Kingdom', 'Forbidden Library',
        'Shadow Realm', 'Spirit World', 'Elf Kingdom', 'Portal World',
        'Alchemist', 'Rune Magic', 'Blood Oath', 'Dream Walker',
        'Enchanted Forest', 'Siren Sea', 'Golem War'
      ],
      SciFi: [
        'Generation Ship', 'AI Uprising', 'Mars Colony', 'Space Station',
        'Time Loop', 'Android Love', 'Parallel Universe', 'Asteroid Mining',
        'Alien Embassy', 'Cryo Ship', 'Neural Interface', 'Orbital City',
        'Quantum Realm', 'Wormhole', 'Clone Wars', 'Dyson Sphere',
        'Mech Pilot', 'Virtual Reality', 'Terraform', 'Rogue Planet'
      ],
      Dystopia: [
        'Surveillance State', 'Memory Trade', 'Caste System', 'Dream Police',
        'Fertility Lottery', 'Happiness Tax', 'Clone Labor', 'Thought Crime',
        'Body Auction', 'Loyalty Score', 'Emotion Ban', 'Sleep Ration',
        'Name Lottery', 'Pain Economy', 'Truth Serum', 'Love License',
        'Beauty Standard', 'Age Limit', 'Silence Law', 'Pleasure Debt'
      ],
      PostApocalyptic: [
        'Nuclear Winter', 'Overgrown Ruins', 'Warlord Territory', 'Bunker Society',
        'Mutant Frontier', 'Flooded Earth', 'Frozen Wasteland', 'Desert Expanse',
        'Last Outpost', 'Nomad Caravan', 'Plague Survivor', 'Robot Uprising',
        'Solar Collapse', 'Underground Haven', 'Ghost City', 'Tribal Rebirth',
        'Quarantine Zone', 'Rad Storm', 'Sunken Metropolis', 'Feral Coast'
      ]
    };

    // Verbatim tooltip microtext for baked-art flavor hit zones
    const BAKED_ART_TOOLTIPS = {
      // Modern flavors
      small_town: 'Everyone knows, remembers, and judges who you love.',
      college: 'Ambition and connection collide before the world settles.',
      friends: 'Crossing the line risks everything you already have.',
      blue_blood: 'Love threatens legacy, inheritance, and unspoken rules.',
      office: 'Attraction grows where it could cost everything.',
      superheroic_modern: 'Love lives beside secrets, danger, and impossible responsibility.',
      supernatural_modern: 'Desire entangles hidden worlds just beneath ordinary life.',
      // Historical flavors
      '20th_century': 'Love strained by war, progress, and modern disillusionment.',
      victorian: 'Desire hidden beneath manners, reputation, and restraint.',
      renaissance: 'Passion collides with ambition, art, and dangerous politics.',
      medieval: 'Honor, faith, and duty stand between lovers.',
      classical: 'Love challenged by fate, glory, and immortal ideals.',
      bronze_age: 'Desire, caught between gods and empires.',
      prehistoric: 'Instinct, hunger, and passion before any rule but survival.',
      // Sci-Fi flavors
      final_frontier: 'Close quarters, endless stars.',
      first_contact: 'Contact changes everything.',
      future_of_science: 'Love is just another law of the universe.',
      simulation: 'Through layers of unreality, love endures.',
      cyberpunk: 'Even your backup heart can ache.',
      post_human: 'Desire outpaces bodies, identity, and human limits.',
      galactic_civilizations: 'Love can save a world, or burn a galaxy.',
      // Dystopia flavors
      glass_house: 'You will never love alone \u2014 you will love us.',
      human_capital: 'You can bet on anything \u2014 especially love.',
      dogma: 'Desire is sacred energy. Let it flow.',
      quieting_event: 'In a world of engineered calm, desire is dangerous.',
      endless_edit: 'Remember Love?',
      thirst: 'Water sustains the world. Desire destabilizes it.',
      // Post-Apocalyptic flavors
      ashfall: 'The world burns between you.',
      year_zero: 'Love is the aftermath.',
      dystimulation: 'You must risk everything to feel anything.',
      predation: 'Love makes you prey.',
      hunger: 'Love competes with survival.',
      // Fantasy flavors
      arcane_binding: 'Magic binds them to choices love cannot undo.',
      fated_blood: 'Their blood decides who they may love.',
      the_inhuman: 'Non-human norms rewrite desire and devotion.',
      the_beyond: 'Love survives death, distance, or worlds apart.',
      cursed: 'A spell stands between them, waiting to be broken.'
    };

    // Pressure flavor tooltips â€” literary descriptions of how each flavor manifests
    const PRESSURE_FLAVOR_TOOLTIPS = {
      // Power & Control
      Billionaire: 'Wealth becomes the cage â€” and the key.',
      CrimeSyndicate: 'Loyalty is currency; betrayal costs blood.',
      Political: 'Every alliance is a leash with two ends.',
      Espionage: 'Love is the one secret they cannot afford.',
      CultOrder: 'Devotion demanded before desire is permitted.',
      // Risk & Exposure
      Noir: 'Every shadow hides a choice already made.',
      ForbiddenKnowledge: 'The truth demands its price in innocence.',
      PublicScandal: 'Privacy is the first casualty of desire.',
      Surveillance: 'Every glance is witnessed; every touch, evidence.',
      DoubleLife: 'Two selves, one heart, no room for both.',
      // Escape & Pursuit
      Heist: 'Trust is the heist within the heist.',
      Rescue: 'Saving someone changes who you become.',
      OnTheRun: 'Every safe place is temporary; every bond, a risk.',
      Captivity: 'Confinement sharpens every feeling.',
      BorderCrossing: 'Freedom waits beyond the line they dare not cross.',
      // Obligation & Burden
      ChosenBurdened: 'Destiny chose them. They would have chosen differently.',
      DutyToFamily: 'Blood demands what the heart cannot afford.',
      Prophecy: 'The future is written. Defiance is the only freedom.',
      CommandRank: 'Authority makes every tenderness a compromise.',
      Inheritance: 'What was given poisons what was earned.',
      // Desire & Obsession
      Obsession: 'Want becomes need becomes gravity.',
      ForbiddenRomance: 'The rule exists because the desire is that strong.',
      Rivalry: 'They compete because surrender terrifies them both.',
      Addiction: 'The only thing worse than having it is stopping.',
      Jealousy: 'Possession disguised as passion, corroding from within.',
      // Reckoning & Past
      RelentlessPast: 'Who they were never stops reaching for who they are.',
      Redemption: 'Forgiveness begins with deserving it less.',
      OldDebts: 'The past always sends a bill.',
      BetrayalHistory: 'Trust, once shattered, cuts with every piece.',
      LostRelationship: 'What ended between them never truly stopped.',
      // Transformation
      BecomingPowerful: 'Strength arrives. Tenderness may not survive the crossing.',
      MoralCorruption: 'Each line crossed redraws the map of who they are.',
      Awakening: 'Something dormant stirs â€” and hunger follows.',
      IdentityShift: 'The self dissolves. What emerges may not remember love.',
      Ascension: 'Evolution has no reverse. Neither does loss.',
      // Survival
      WarZone: 'Between bombardments, desire is the only defiance.',
      Castaway: 'No shore in sight. Only each other.',
      Lost: 'The trail vanished. So did certainty.',
      Trapped: 'The walls close in. So does the distance between them.',
      Afflicted: 'The body fails. What remains refuses to quit.',
      Scarcity: 'When there is not enough, love becomes the hardest luxury.'
    };

    function populateWorldZoomContent(card, worldVal) {
      const frontFace = card.querySelector('.sb-card-front');
      if (!frontFace) return;

      // Dystopia has separate zoomed/unzoomed PNGs â€” set zoomed art explicitly
      // so inlineCardFaceBackgrounds() captures the correct (zoomed) art.
      // Must run BEFORE the early-return guard below.
      if (worldVal === 'Dystopia') {
        frontFace.style.backgroundImage = "url('/assets/card-art/cards/Tarot-Gold-on-Black-DYSTOPIAzoomed.png')";
      } else if (worldVal === 'Fantasy') {
        frontFace.style.backgroundImage = "url('/assets/card-art/cards/Tarot-Gold-on-Black-FANTASYzoomed.png')";
      } else if (worldVal === 'Historical') {
        frontFace.style.backgroundImage = "url('/assets/card-art/cards/Tarot-Gold-on-Black-HISTORICALzoomed.png')";
      } else if (worldVal === 'Modern') {
        frontFace.style.backgroundImage = "url('/assets/card-art/cards/Tarot-Gold-on-Black-MODERNzoomed.png')";
      } else if (worldVal === 'PostApocalyptic') {
        frontFace.style.backgroundImage = "url('/assets/card-art/cards/Tarot-Gold-on-Black-PostApoczoomed.png')";
      } else if (worldVal === 'SciFi') {
        frontFace.style.backgroundImage = "url('/assets/card-art/cards/Tarot-Gold-on-Black-SciFizoomed.png')";
      }

      // If baked-art overlay already exists for this world, preserve it
      // (prevents re-creation that would destroy user's selection state)
      const existingBaked = frontFace.querySelector('.sb-zoom-baked-overlay');
      if (existingBaked && existingBaked.dataset.world === worldVal) return;
      if (existingBaked) existingBaked.remove();

      // Remove any existing standard zoom content and flavor arc
      const existing = frontFace.querySelector('.sb-zoom-content');
      if (existing) existing.remove();
      const existingArc = frontFace.querySelector('.sb-zoom-flavor-arc');
      if (existingArc) existingArc.remove();

      const flavors = WORLD_SUB_OPTIONS[worldVal] || [];
      const hasCustomField = WORLDS_WITH_CUSTOM_FIELD.includes(worldVal);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BAKED-ART CARDS: Use invisible hit zones over PNG buttons
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (BAKED_ART_BUTTONS[worldVal]) {
        const bakedButtons = BAKED_ART_BUTTONS[worldVal];
        const scrollZone = BAKED_ART_SCROLL_ZONE[worldVal];
        const suggestions = BAKED_ART_SUGGESTIONS[worldVal] || [];

        // Hide the card title text (baked into PNG)
        const titleEl = frontFace.querySelector('.sb-card-title');
        if (titleEl) titleEl.style.display = 'none';

        const overlay = document.createElement('div');
        overlay.className = 'sb-zoom-baked-overlay';
        overlay.dataset.world = worldVal;
        // Absorb clicks so they never reach the parent card handler
        overlay.style.pointerEvents = 'auto';
        overlay.addEventListener('click', (e) => { e.stopPropagation(); });

        // Gleam slowdown helper â€” halve gleam speed while hovering any hit zone
        function slowGleam() {
          card.querySelectorAll('.card-gleam-layer').forEach(g => {
            const t = g.style.transition || '';
            // Double the duration in the current transition string
            g.style.transition = t.replace(/([\d.]+)s/, (_, d) => (parseFloat(d) * 2).toFixed(2) + 's');
          });
        }
        function restoreGleam() {
          card.querySelectorAll('.card-gleam-layer').forEach(g => {
            const t = g.style.transition || '';
            g.style.transition = t.replace(/([\d.]+)s/, (_, d) => (parseFloat(d) / 2).toFixed(2) + 's');
          });
        }

        // Create hit zones over each baked-in button
        bakedButtons.forEach(btn => {
          const zone = document.createElement('div');
          zone.className = 'baked-hitzone';
          zone.dataset.val = btn.val;
          zone.style.top = btn.top + '%';
          zone.style.left = btn.left + '%';
          zone.style.width = btn.width + '%';
          zone.style.height = btn.height + '%';

          // Tooltip microtext (Fantasy flavors)
          if (BAKED_ART_TOOLTIPS[btn.val]) {
            zone.dataset.tooltip = BAKED_ART_TOOLTIPS[btn.val];
          }

          if (state.picks.worldSubtype === btn.val) {
            zone.classList.add('selected');
          }

          zone.addEventListener('mouseenter', slowGleam);
          zone.addEventListener('mouseleave', restoreGleam);

          zone.addEventListener('click', (e) => {
            e.stopPropagation();
            state.resolvedWorldFlavors = null; // force recomputation on next generation
            if (state.picks.worldSubtype === btn.val) {
              state.picks.worldSubtype = null;
              zone.classList.remove('selected');
            } else {
              overlay.querySelectorAll('.baked-hitzone').forEach(z => z.classList.remove('selected'));
              state.picks.worldSubtype = btn.val;
              zone.classList.add('selected');
              // Clear custom text when selecting a preset flavor
              if (!state.worldCustomTexts) state.worldCustomTexts = {};
              state.worldCustomTexts[worldVal] = '';
              const scrollEl = overlay.querySelector('.baked-scroll-zone');
              if (scrollEl) {
                scrollEl.classList.remove('editing', 'committed');
                const inp = scrollEl.querySelector('.baked-scroll-input');
                if (inp) inp.value = '';
                const ph = scrollEl.querySelector('.baked-scroll-placeholder');
                if (ph) ph.classList.remove('hidden');
              }
            }
            incrementDSPActivation();
            updateSynopsisPanel(true);
            if (typeof updateWorldBreadcrumbFlavor === 'function') updateWorldBreadcrumbFlavor();
          });

          overlay.appendChild(zone);
        });

        // Scroll zone â€” shows scrolling suggestions, click to enter custom flavor
        if (scrollZone) {
          const allSuggestions = suggestions.length > 0 ? suggestions : ['Custom'];
          const scrollContainer = document.createElement('div');
          scrollContainer.className = 'baked-scroll-zone';
          scrollContainer.style.top = scrollZone.top + '%';
          scrollContainer.style.left = scrollZone.left + '%';
          scrollContainer.style.width = scrollZone.width + '%';
          scrollContainer.style.height = scrollZone.height + '%';

          const inputWrapper = document.createElement('div');
          inputWrapper.className = 'baked-scroll-input-wrapper';

          // Single-line input (not textarea â€” no newlines, no vertical shift)
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'baked-scroll-input';
          if (!state.worldCustomTexts) state.worldCustomTexts = {};
          input.value = state.worldCustomTexts[worldVal] || '';

          // Scrolling placeholder â€” doubled for seamless loop
          const phWrap = document.createElement('div');
          phWrap.className = 'baked-scroll-placeholder';
          const doubled = [...allSuggestions, ...allSuggestions];
          const phInner = document.createElement('span');
          phInner.className = 'baked-scroll-inner';
          phInner.innerHTML = doubled.map(s => `<span>${s}</span>`).join('<span class="separator">\u00b7</span>');
          phWrap.appendChild(phInner);

          function commitCustomText() {
            const text = input.value.trim();
            if (text) {
              state.worldCustomTexts[worldVal] = normalizeWorldCustom(text);
              // Deselect preset buttons â€” custom overrides
              overlay.querySelectorAll('.baked-hitzone').forEach(z => z.classList.remove('selected'));
              state.picks.worldSubtype = null;
              // Show committed state â€” depressed bevel on scroll zone
              scrollContainer.classList.add('committed');
              input.blur();
            } else {
              state.worldCustomTexts[worldVal] = '';
              scrollContainer.classList.remove('editing', 'committed');
              phWrap.classList.remove('hidden');
            }
            incrementDSPActivation();
            updateSynopsisPanel(true);
            if (typeof updateWorldBreadcrumbFlavor === 'function') updateWorldBreadcrumbFlavor();
          }

          // Click the zone â†’ enter editing mode and deselect preset buttons
          scrollContainer.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!scrollContainer.classList.contains('editing')) {
              scrollContainer.classList.add('editing');
              scrollContainer.classList.remove('committed');
              phWrap.classList.add('hidden');
              // Deselect preset flavor buttons â€” custom field takes priority
              overlay.querySelectorAll('.baked-hitzone').forEach(z => z.classList.remove('selected'));
              state.picks.worldSubtype = null;
              input.focus();
            }
          });

          input.addEventListener('click', (e) => e.stopPropagation());
          input.addEventListener('mousedown', (e) => e.stopPropagation());

          // Enter commits the custom text
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              commitCustomText();
            }
            e.stopPropagation();
          });

          input.addEventListener('input', () => {
            // Live update while typing
            state.worldCustomTexts[worldVal] = normalizeWorldCustom(input.value);
            if (input.value.trim().length > 0) {
              overlay.querySelectorAll('.baked-hitzone').forEach(z => z.classList.remove('selected'));
              state.picks.worldSubtype = null;
            }
          });

          input.addEventListener('blur', () => {
            // Commit on blur if text exists, otherwise revert to scrolling
            if (input.value.trim()) {
              commitCustomText();
            } else {
              scrollContainer.classList.remove('editing', 'committed');
              phWrap.classList.remove('hidden');
              state.worldCustomTexts[worldVal] = '';
              if (typeof updateWorldBreadcrumbFlavor === 'function') updateWorldBreadcrumbFlavor();
            }
          });

          // Restore state if custom text was previously entered for THIS world
          if (state.worldCustomTexts[worldVal]) {
            scrollContainer.classList.add('editing', 'committed');
            phWrap.classList.add('hidden');
          }

          inputWrapper.appendChild(input);
          inputWrapper.appendChild(phWrap);
          scrollContainer.appendChild(inputWrapper);
          overlay.appendChild(scrollContainer);
        }

        frontFace.appendChild(overlay);
        return; // Baked-art card done â€” skip standard overlay generation
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STANDARD CARDS: Generated overlay buttons (Blank-Black-Face PNG)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // === FLAVOR ARC in the half-circle: number only (label baked into art) ===
      if (flavors.length > 0) {
        var arcContainer = document.createElement('div');
        arcContainer.className = 'sb-zoom-flavor-arc';

        var num = document.createElement('span');
        num.className = 'arc-flavor-number';
        num.textContent = flavors.length;
        arcContainer.appendChild(num);
        frontFace.appendChild(arcContainer);
      }

      // === ZOOM CONTENT: flavor buttons + custom setting ===
      const zoomContent = document.createElement('div');
      zoomContent.className = 'sb-zoom-content';

      // Flavor buttons
      if (flavors.length > 0) {
        const flavorGrid = document.createElement('div');
        flavorGrid.className = 'sb-zoom-flavors';

        flavors.forEach(flavor => {
          const btn = document.createElement('button');
          btn.className = 'sb-flavor-btn';
          btn.textContent = flavor.label;
          btn.dataset.val = flavor.val;

          if (state.picks.worldSubtype === flavor.val) {
            btn.classList.add('selected');
          }

          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            state.resolvedWorldFlavors = null; // force recomputation on next generation
            if (state.picks.worldSubtype === flavor.val) {
              state.picks.worldSubtype = null;
              btn.classList.remove('selected');
            } else {
              flavorGrid.querySelectorAll('.sb-flavor-btn').forEach(b => b.classList.remove('selected'));
              state.picks.worldSubtype = flavor.val;
              btn.classList.add('selected');
            }
            incrementDSPActivation();
            updateSynopsisPanel(true);
          });

          flavorGrid.appendChild(btn);
        });

        zoomContent.appendChild(flavorGrid);
      }

      // Custom setting box (above the bottom title text box)
      if (hasCustomField) {
        const customWrapper = document.createElement('div');
        customWrapper.className = 'sb-zoom-custom';

        const customLabel = document.createElement('label');
        customLabel.className = 'sb-zoom-custom-label';
        customLabel.textContent = 'Custom Setting:';

        const inputWrapper = document.createElement('div');
        inputWrapper.className = 'sb-zoom-custom-wrapper';

        const customInput = document.createElement('textarea');
        customInput.className = 'sb-zoom-custom-input';
        customInput.id = 'worldCustomInput-' + Date.now();
        if (!state.worldCustomTexts) state.worldCustomTexts = {};
        customInput.value = state.worldCustomTexts[worldVal] || '';
        customInput.rows = 2;

        // Scrolling flavor examples â€” show this world's flavor labels in grey italic
        const rotatingPlaceholder = document.createElement('div');
        rotatingPlaceholder.className = 'sb-zoom-rotating-placeholder';

        const flavorLabels = (WORLD_SUB_OPTIONS[worldVal] || []).map(f => f.label);
        if (flavorLabels.length > 0) {
          const doubled = [...flavorLabels, ...flavorLabels];
          let html = '<span class="sb-zoom-placeholder-inner">';
          doubled.forEach((s, i) => {
            html += `<span class="suggestion">${s}</span>`;
            if (i < doubled.length - 1) html += '<span class="separator">\u2022</span>';
          });
          html += '</span>';
          rotatingPlaceholder.innerHTML = html;
        }

        const updatePlaceholderVisibility = () => {
          if (customInput.value.trim().length > 0) {
            rotatingPlaceholder.classList.add('hidden');
          } else {
            rotatingPlaceholder.classList.remove('hidden');
          }
        };

        customInput.addEventListener('input', (e) => {
          if (!state.worldCustomTexts) state.worldCustomTexts = {};
          state.worldCustomTexts[worldVal] = normalizeWorldCustom(e.target.value);
          updatePlaceholderVisibility();
        });

        customInput.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        customInput.addEventListener('focus', () => {
          const inner = rotatingPlaceholder.querySelector('.sb-zoom-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'paused';
        });

        customInput.addEventListener('blur', () => {
          const inner = rotatingPlaceholder.querySelector('.sb-zoom-placeholder-inner');
          if (inner) inner.style.animationPlayState = 'running';
          updatePlaceholderVisibility();
        });

        inputWrapper.appendChild(customInput);
        inputWrapper.appendChild(rotatingPlaceholder);
        customWrapper.appendChild(customLabel);
        customWrapper.appendChild(inputWrapper);
        zoomContent.appendChild(customWrapper);

        updatePlaceholderVisibility();
      }

      frontFace.appendChild(zoomContent);
    }

    // Populate Story Pull (pressure) card zoom view with flavor buttons
    function populatePressureZoomContent(card, pressureVal) {
      const frontFace = card.querySelector('.sb-card-front');
      if (!frontFace) return;

      // Remove any existing zoom content and flavor arc
      const existing = frontFace.querySelector('.sb-zoom-content');
      if (existing) existing.remove();
      const existingArc = frontFace.querySelector('.sb-zoom-flavor-arc');
      if (existingArc) existingArc.remove();

      const flavors = PRESSURE_FLAVORS[pressureVal] || [];
      if (flavors.length === 0) return;

      // === FLAVOR ARC: number only (label baked into art) ===
      var arcContainer = document.createElement('div');
      arcContainer.className = 'sb-zoom-flavor-arc';

      var num = document.createElement('span');
      num.className = 'arc-flavor-number';
      num.textContent = flavors.length;
      arcContainer.appendChild(num);

      frontFace.appendChild(arcContainer);

      // === ZOOM CONTENT: flavor buttons with tooltips ===
      const zoomContent = document.createElement('div');
      zoomContent.className = 'sb-zoom-content';

      const flavorGrid = document.createElement('div');
      flavorGrid.className = 'sb-zoom-flavors';

      flavors.forEach(flavor => {
        const btn = document.createElement('button');
        btn.className = 'sb-flavor-btn';
        btn.dataset.val = flavor.id;
        btn.title = flavor.description || '';

        // Tooltip for literary description
        if (PRESSURE_FLAVOR_TOOLTIPS[flavor.id]) {
          btn.dataset.tooltip = PRESSURE_FLAVOR_TOOLTIPS[flavor.id];
        }

        // Text node inside a span so gleam layer doesn't affect text flow
        const textSpan = document.createElement('span');
        textSpan.className = 'sb-flavor-btn-text';
        textSpan.textContent = flavor.label;
        btn.appendChild(textSpan);

        if (state.picks.flavor === flavor.id) {
          btn.classList.add('selected');
        }

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (state.picks.flavor === flavor.id) {
            state.picks.flavor = null;
            btn.classList.remove('selected');
          } else {
            flavorGrid.querySelectorAll('.sb-flavor-btn').forEach(b => b.classList.remove('selected'));
            state.picks.flavor = flavor.id;
            btn.classList.add('selected');
          }
          state.picks.genre = getEffectiveGenre(pressureVal, state.picks.flavor);
          incrementDSPActivation();
          updateSynopsisPanel(true);
          syncPressureFrontFlavors();
        });

        flavorGrid.appendChild(btn);
      });

      zoomContent.appendChild(flavorGrid);
      frontFace.appendChild(zoomContent);

      // === BUTTON GLEAM: individual gleam layers offset 5px from card gleam ===
      if (window.applyGleamToElement) {
        flavorGrid.querySelectorAll('.sb-flavor-btn').forEach(btn => {
          window.applyGleamToElement(btn, 5);
        });
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UNZOOMED PRESSURE FRONT FLAVORS â€” Miniature buttons on the card face
    // Lets users pick a flavor without entering zoom view.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function initPressureFrontFlavors() {
      document.querySelectorAll('#pressureGrid .sb-card[data-grp="pressure"]').forEach(card => {
        if (card.dataset.val === 'destiny') return; // Skip Destiny's Choice card
        const pressureVal = card.dataset.val;
        const flavors = PRESSURE_FLAVORS[pressureVal];
        if (!flavors || flavors.length === 0) return;

        const frontFace = card.querySelector('.sb-card-front');
        if (!frontFace) return;

        // Flavor arc number in half-circle arch
        if (!frontFace.querySelector('.sb-card-arc-flavors')) {
          const arc = buildFlavorArc(flavors.length);
          arc.dataset.permanent = '1';
          frontFace.appendChild(arc);
        }

        // Already populated?
        if (frontFace.querySelector('.pressure-front-flavors')) return;

        // Miniature flavor button column
        const container = document.createElement('div');
        container.className = 'pressure-front-flavors';

        flavors.forEach(flavor => {
          const btn = document.createElement('button');
          btn.className = 'sb-flavor-btn';
          btn.textContent = flavor.label;
          btn.dataset.val = flavor.id;
          btn.title = flavor.description || '';

          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Only allow selection on the currently active (flipped) pressure card
            if (!card.classList.contains('selected')) return;

            if (state.picks.flavor === flavor.id) {
              state.picks.flavor = null;
              btn.classList.remove('selected');
            } else {
              container.querySelectorAll('.sb-flavor-btn').forEach(b => b.classList.remove('selected'));
              state.picks.flavor = flavor.id;
              btn.classList.add('selected');
            }
            state.picks.genre = getEffectiveGenre(pressureVal, state.picks.flavor);
            incrementDSPActivation();
            updateSynopsisPanel(true);
            syncPressureZoomFlavors();
          });

          container.appendChild(btn);
        });

        frontFace.appendChild(container);
      });
    }

    // Sync unzoomed pressure flavor button highlights with current state
    function syncPressureFrontFlavors() {
      document.querySelectorAll('#pressureGrid .pressure-front-flavors').forEach(container => {
        container.querySelectorAll('.sb-flavor-btn').forEach(btn => {
          btn.classList.toggle('selected', state.picks.flavor === btn.dataset.val);
        });
      });
    }

    // Sync zoom-view flavor buttons with current state
    function syncPressureZoomFlavors() {
      const zoomFlavors = document.querySelector('.sb-zoom-content .sb-zoom-flavors');
      if (!zoomFlavors) return;
      zoomFlavors.querySelectorAll('.sb-flavor-btn').forEach(btn => {
        btn.classList.toggle('selected', state.picks.flavor === btn.dataset.val);
      });
    }

    /**
     * Inject Destiny's Choice card into pressureGrid (9th card, bottom-right)
     * Mirrors archetype Destiny card structure with stack layers + sparkles
     */
    function injectPressureDestinyCard() {
      const grid = document.getElementById('pressureGrid');
      if (!grid || grid.querySelector('#pressureDestinyChoiceCard')) return;

      const destinyCard = document.createElement('div');
      destinyCard.className = 'sb-card destiny-choice-card pressure-destiny-card';
      destinyCard.id = 'pressureDestinyChoiceCard';
      destinyCard.dataset.grp = 'pressure';
      destinyCard.dataset.val = 'destiny';
      destinyCard.innerHTML = `
        <div class="destiny-stack-layer layer-5"></div>
        <div class="destiny-stack-layer layer-4"></div>
        <div class="destiny-stack-layer layer-3"></div>
        <div class="destiny-stack-layer layer-2"></div>
        <div class="sb-card-inner">
          <div class="sb-card-face sb-card-back destiny-choice-back">
            <span class="sb-card-title">Destiny's Choice</span>
            <div class="destiny-choice-sparkle-container" id="pressureDestinySparkles"></div>
          </div>
          <div class="sb-card-face sb-card-front destiny-choice-front">
            <span class="sb-card-title">Destiny's Choice</span>
            <div class="destiny-embossed-nameplate">
              <div class="destiny-embossed-line"></div>
              <div class="destiny-embossed-line"></div>
            </div>
          </div>
        </div>
      `;

      destinyCard.addEventListener('click', () => triggerPressureDestinySequence());

      grid.appendChild(destinyCard);
      if (window.applyCardGleam) window.applyCardGleam(destinyCard);

      // Start sparkles after brief delay
      setTimeout(() => {
        if (typeof startSparkleEmitter === 'function') {
          startSparkleEmitter('pressureDestinySparkles', 'destinyDeck', 3);
        }
      }, 100);
    }

    /**
     * Inject Destiny's Choice card into dynamicGrid (last group, bottom-right)
     */
    function injectDynamicDestinyCard() {
      const dynamicGrid = document.getElementById('dynamicGrid');
      if (!dynamicGrid || dynamicGrid.querySelector('#dynamicDestinyChoiceCard')) return;

      // Find the last sb-grid inside the last dynamic-group
      const groups = dynamicGrid.querySelectorAll('.dynamic-group');
      const lastGroup = groups[groups.length - 1];
      const lastGrid = lastGroup?.querySelector('.sb-grid');
      if (!lastGrid) return;

      const destinyCard = document.createElement('div');
      destinyCard.className = 'sb-card destiny-choice-card dynamic-destiny-card';
      destinyCard.id = 'dynamicDestinyChoiceCard';
      destinyCard.dataset.grp = 'dynamic';
      destinyCard.dataset.val = 'destiny';
      destinyCard.innerHTML = `
        <div class="destiny-stack-layer layer-5"></div>
        <div class="destiny-stack-layer layer-4"></div>
        <div class="destiny-stack-layer layer-3"></div>
        <div class="destiny-stack-layer layer-2"></div>
        <div class="sb-card-inner">
          <div class="sb-card-face sb-card-back destiny-choice-back">
            <span class="sb-card-title">Destiny's Choice</span>
            <div class="destiny-choice-sparkle-container" id="dynamicDestinySparkles"></div>
          </div>
          <div class="sb-card-face sb-card-front destiny-choice-front">
            <span class="sb-card-title">Destiny's Choice</span>
            <div class="destiny-embossed-nameplate">
              <div class="destiny-embossed-line"></div>
              <div class="destiny-embossed-line"></div>
            </div>
          </div>
        </div>
      `;

      destinyCard.addEventListener('click', () => triggerDynamicDestinySequence());

      lastGrid.appendChild(destinyCard);
      if (window.applyCardGleam) window.applyCardGleam(destinyCard);

      setTimeout(() => {
        if (typeof startSparkleEmitter === 'function') {
          startSparkleEmitter('dynamicDestinySparkles', 'destinyDeck', 3);
        }
      }, 100);
    }

    function updateSelectionCardStates() {
      const layers = ['world', 'tone', 'genre', 'dynamic'];

      layers.forEach(layer => {
        const cards = document.querySelectorAll(`.selection-card[data-grp="${layer}"]`);
        const unlocked = isLayerUnlocked(layer);

        cards.forEach(card => {
          const val = card.dataset.val;

          // Layer locking
          card.classList.toggle('layer-locked', !unlocked);

          // Compatibility check for genre/dynamic
          if (unlocked) {
            if (layer === 'genre') {
              const compatible = isGenreCompatible(val, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else if (layer === 'dynamic') {
              const compatible = isDynamicCompatible(val, state.picks.genre, state.picks.tone);
              card.classList.toggle('incompatible', !compatible);
            } else {
              card.classList.remove('incompatible');
            }
          }

          // Selection state - toggle both selected and flipped
          const isSelected = state.picks[layer] === val;
          card.classList.toggle('selected', isSelected);
          card.classList.toggle('flipped', isSelected);
        });
      });
    }

    // UNIFIED SINGLE-SELECT: ALL card groups use this handler - NO separate handlers
    const SINGLE_SELECT_AXES = ['world', 'tone', 'pressure', 'flavor', 'genre', 'dynamic', 'era', 'pov', 'worldSubtype', 'intensity', 'length'];

    document.querySelectorAll('.sb-card[data-grp]').forEach(card => {
      if(card.dataset.bound === '1') return;
      card.dataset.bound = '1';
      card.addEventListener('click', (e) => {
        if(e.target.closest('.preview-btn')) return;
        const grp = card.dataset.grp;
        const val = card.dataset.val;
        if(!grp || !val) return;

        // Length cards locked after game starts
        if (grp === 'length' && state.turnCount > 0) return;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SUBSCRIPTION SHORT-CIRCUIT: Subscribers bypass all paywall checks
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!state.subscribed) {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // DATA-LEVEL STORYPASS CHECK: Read from card's data attribute
          // Cards with data-storypass-allowed="false" ONLY show Subscribe
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const storypassAllowedAttr = card.dataset.storypassAllowed;
          const isSubOnlyCard = storypassAllowedAttr === 'false';

          if (isSubOnlyCard) {
            console.log(`[PAYWALL:DATA] Card ${grp}/${val} has storypassAllowed=false, Subscribe-only`);
            window.showPaywall('sub_only');
            return;
          }

          // Length paywall check using canonical eligibility
          if (grp === 'length') {
            const tempState = { ...state, storyLength: val };
            if (!isStorypassAllowed(tempState)) {
              window.showPaywall('sub_only'); return;
            }
          }

          // Locked card: use correct paywall mode based on canonical eligibility
          if(card.classList.contains('locked')) {
            // CANONICAL: Use story metadata for paywall mode (persisted, immutable per-story)
            window.showPaywall(getPaywallMode());
            return;
          }
        }

        // Check if layer is unlocked (prerequisites met)
        if (!isLayerUnlocked(grp)) {
          // Layer is inert - do nothing
          return;
        }

        // Check if card is incompatible
        if (card.classList.contains('incompatible')) {
          // Incompatible selection - do nothing
          return;
        }

        // THREE-STATE CARD INTERACTION MODEL:
        // STATE 1 (face-down) â†’ STATE 2 (face-up/selected): First click on unselected card
        // STATE 2 (face-up) â†’ STATE 3 (zoomed): Second click on already-selected card
        // NEVER deselect by clicking same card - only another card in group can deselect

        const isAlreadySelected = card.classList.contains('selected') && card.classList.contains('flipped');

        if (isAlreadySelected) {
          // Destiny's Choice has no zoom view â€” it auto-selects only
          if (grp === 'pressure' && val === 'destiny') return;
          // STATE 2 â†’ STATE 3: Open zoom view (NEVER deselect)
          openSbCardZoom(card, grp, val);
          return;
        }

        // STATE 1 â†’ STATE 2: Select this card, deselect others in same group

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DESTRUCTIVE CHANGE CHECK: Warn before changing locked fields
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (typeof wouldDestroyStory === 'function' && wouldDestroyStory(grp, val)) {
          // Show warning modal, defer actual selection until confirmed
          showDestructiveChangeWarning(grp, val, card, (confirmedGrp, confirmedVal, confirmedCard) => {
            // Execute the selection after confirmation
            executeCardSelection(confirmedGrp, confirmedVal, confirmedCard);
          });
          return;
        }

        // Proceed with selection
        executeCardSelection(grp, val, card);
      });
    });

    // Build flavor arc element: number only (label baked into art)
    function buildFlavorArc(count) {
      var container = document.createElement('div');
      container.className = 'sb-card-arc-flavors';

      var num = document.createElement('span');
      num.className = 'arc-flavor-number';
      num.textContent = count;
      container.appendChild(num);

      return container;
    }

    /**
     * Execute a card selection (extracted to allow deferred execution after destructive change confirmation)
     */
    function executeCardSelection(grp, val, card) {
        // Update state based on card group
        if (grp === 'intensity') {
          state.intensity = val;
          state.picks.intensity = val;
          // NOTE: intensity is a RUNTIME MODIFIER â€” does NOT invalidate story shape
        } else if (grp === 'length') {
          state.storyLength = val;
          applyLengthLocks(); // Re-apply locks after selection
          // NOTE: storyLength is a RUNTIME MODIFIER â€” does NOT invalidate story shape
        } else {
          state.picks[grp] = grp === 'tone' ? canonicalizeTone(val) : val;
          // STORY-DEFINING INPUT: Invalidate snapshot â†’ forces "Begin Story"
          if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();
        }

        // Derive tone bias when structural axes change
        if (grp === 'tone' || grp === 'world' || grp === 'pressure') {
          deriveToneBias();
        }

        // Clear cover shape hash â€” selection changed, enable regeneration
        if (window.clearCoverShapeHash) window.clearCoverShapeHash();

        // Deselect all other cards in this group, select this one
        document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(c => {
          c.classList.remove('selected', 'flipped');
          // Remove any flavor count indicators (old pill + new arc)
          const oldFlavorCount = c.querySelector('.sb-card-flavor-count');
          if (oldFlavorCount) oldFlavorCount.remove();
          const oldArc = c.querySelector('.sb-card-arc-flavors');
          if (oldArc && !oldArc.dataset.permanent) oldArc.remove();
          // Fade out sparkles on deselected cards
          const oldSparkleContainer = c.querySelector('.card-selection-sparkles');
          if (oldSparkleContainer && typeof stopSparkleEmitter === 'function') {
            stopSparkleEmitter(oldSparkleContainer.id);
            oldSparkleContainer.classList.add('sparkles-fading');
            setTimeout(() => oldSparkleContainer.remove(), 1200);
          }
        });
        card.classList.add('selected', 'flipped');

        // Start sparkles on selected card
        let sparkleContainer = card.querySelector('.card-selection-sparkles');
        if (!sparkleContainer) {
          sparkleContainer = document.createElement('div');
          sparkleContainer.className = 'card-selection-sparkles';
          sparkleContainer.id = `cardSparkles_${grp}_${val}`;
          card.appendChild(sparkleContainer);
        }
        if (typeof startSparkleEmitter === 'function') {
          startSparkleEmitter(sparkleContainer.id, 'chooseHand', 6);
        }

        if (grp === 'world') {
          // Add flavor arc number (skip baked-art cards â€” art already includes it)
          const worldFlavors = WORLD_SUB_OPTIONS[val] || [];
          if (worldFlavors.length > 0 && !BAKED_ART_BUTTONS[val]) {
            const frontFace = card.querySelector('.sb-card-front');
            if (frontFace && !frontFace.querySelector('.sb-card-arc-flavors')) {
              frontFace.appendChild(buildFlavorArc(worldFlavors.length));
            }
          }
          updateWorldSubtypeVisibility(val, state.picks.tone);
        }

        // PRESSURE SELECTION: Flavor lives INSIDE zoomed pressure card, NOT as separate row
        // Flavor options rendered via populatePressureZoomContent() when card is zoomed
        if (grp === 'pressure') {
          // Override Destiny's Choice if user manually selects
          pressureSelectedViaDestiny = false;
          // Clear any previous flavor selection (new pressure = fresh slate)
          state.picks.flavor = null;
          // Sync to legacy genre using pressure's default
          state.picks.genre = getEffectiveGenre(val, null);
          // Add flavor arc number to selected pressure card
          const flavors = PRESSURE_FLAVORS[val] || [];
          if (flavors.length > 0) {
            const frontFace = card.querySelector('.sb-card-front');
            if (frontFace && !frontFace.querySelector('.sb-card-arc-flavors')) {
              frontFace.appendChild(buildFlavorArc(flavors.length));
            }
          }
          // Sync unzoomed flavor button highlights (all cleared)
          syncPressureFrontFlavors();
        }

        // FLAVOR SELECTION: Sync to legacy genre and update world breadcrumb
        if (grp === 'flavor') {
          state.picks.genre = getEffectiveGenre(state.picks.pressure, val);
          // Update world breadcrumb to show nested flavor
          if (typeof updateWorldBreadcrumbFlavor === 'function') {
            updateWorldBreadcrumbFlavor();
          }
        }

        // POV SELECTION: Dissolve ephemeral breadcrumbs (Mode)
        if (grp === 'pov') {
          // Ephemeral layers (Solo/Couple mode) dissolve when POV is committed
          if (typeof dissolveEphemeralBreadcrumbs === 'function') {
            dissolveEphemeralBreadcrumbs();
            console.log('[Breadcrumb] POV selected â€” ephemeral breadcrumbs dissolving');
          }
        }

        // DYNAMIC SELECTION: Override Destiny's Choice if user manually selects
        if (grp === 'dynamic') {
          dynamicSelectedViaDestiny = false;
        }

        // Update world subtype visibility when Tone changes
        if (grp === 'tone') {
          updateWorldSubtypeVisibility(state.picks.world, val);
        }

        // Evaluate downstream selections for compatibility
        evaluateDownstreamSelections(grp);

        // Increment DSP activation count (explicit Story Shape choice)
        incrementDSPActivation();

        // Update DSP segment based on selection axis
        if (grp === 'world' && DSP_WORLD_PHRASES[val]) {
          activateDSPSegment('world', 'In ' + DSP_WORLD_PHRASES[val]);
        } else if (grp === 'pressure') {
          // Pressure selection: use pressure DSP phrase (flavor may override later)
          const dspPhrase = getPressureDSPPhrase(val, state.picks.flavor);
          activateDSPSegment('genre', ', shaped by ' + dspPhrase);
        } else if (grp === 'flavor') {
          // Flavor selection: update DSP with flavor-specific phrase
          const dspPhrase = getPressureDSPPhrase(state.picks.pressure, val);
          activateDSPSegment('genre', ', shaped by ' + dspPhrase);
        } else if (grp === 'genre' && DSP_GENRE_PARAPHRASES[val]) {
          // Legacy genre selection (backward compatibility)
          activateDSPSegment('genre', ', shaped by ' + DSP_GENRE_PARAPHRASES[val]);
        } else if (grp === 'dynamic' && state.archetype?.primary && DSP_ARCHETYPE_ADJECTIVES[state.archetype.primary]) {
          activateDSPSegment('archetype', ', a question awaits: Will ' + DSP_ARCHETYPE_ADJECTIVES[state.archetype.primary]);
        } else if (grp === 'tone' && DSP_TONAL_ADJECTIVES[val]) {
          activateDSPSegment('tone', ' desire redeem this ' + DSP_TONAL_ADJECTIVES[val]);
        } else if (grp === 'length') {
          const AFFAIR_WORD_MAP = { taste: 'taste', fling: 'fling', affair: 'affair', soulmates: 'cosmic connection' };
          activateDSPSegment('length', ' ' + (AFFAIR_WORD_MAP[val] || 'affair') + '\u2009\u2014\u2009or ruin it?');
        } else if (grp === 'pov') {
          // POV changes the pronoun in the archetype clause â€” full re-render
        }

        // Update floating synopsis panel
        updateSynopsisPanel(true); // User action: card click

        // Update corridor Continue button visibility (card selected â†’ show Continue)
        if (typeof window.updateCorridorContinueButtonVisibility === 'function') {
          window.updateCorridorContinueButtonVisibility();
        }
    }

    // Initialize World Subtype visibility based on initial selections
    updateWorldSubtypeVisibility(state.picks.world, state.picks.tone);
    // Flavor: Lives INSIDE zoomed pressure card, no global initialization needed
    // Initialize synopsis panel (not a user action - keeps placeholder)
    updateSynopsisPanel();
    // Initialize layer states (gating, compatibility)
    updateLayerStates();
    // Initialize selection card system
    initSelectionCardSystem();
    // Apply any legacy Historical era remapping
    applyHistoricalEraRemap();
    // Initialize Breadcrumb Flow System
    initBreadcrumbFlow();
    // Initialize Archetype System BEFORE corridor (corridor unmounts the grid from DOM)
    initArchetypeUI();
    // Initialize Corridor State Machine (9-row single-screen selection)
    if (typeof initCorridor === 'function') {
      initCorridor();
    }
    // Initialize Destructive Change Modal
    if (typeof initDestructiveChangeModal === 'function') {
      initDestructiveChangeModal();
    }

    // Name refining indicator helpers
    function showNameRefiningIndicator(inputEl) {
      let indicator = inputEl.parentElement?.querySelector('.name-refining-indicator');
      if (!indicator) {
        indicator = document.createElement('span');
        indicator.className = 'name-refining-indicator';
        indicator.innerHTML = '<span class="refining-dot">â—</span> Refining nameâ€¦';
        inputEl.parentElement?.appendChild(indicator);
      }
      indicator.style.display = 'inline';
    }

    function hideNameRefiningIndicator(inputEl) {
      const indicator = inputEl.parentElement?.querySelector('.name-refining-indicator');
      if (indicator) indicator.style.display = 'none';
    }

    // Player name normalization (DSP no longer includes names â€” no DSP refresh needed)
    const playerNameInput = $('playerNameInput');
    if (playerNameInput) {
      playerNameInput.addEventListener('input', () => {
        state.normalizedPlayerKernel = playerNameInput.value.trim() || 'the one who carries the story';
        // Name entry does NOT trigger DSP update â€” names are not in DSP
      });
      playerNameInput.addEventListener('blur', async () => {
        const raw = playerNameInput.value.trim();
        if (!raw) return;
        showNameRefiningIndicator(playerNameInput);
        const norm = await callNormalizationLayer({
          axis: 'character',
          user_text: raw,
          context_signals: state.picks?.world || []
        });
        hideNameRefiningIndicator(playerNameInput);
        const kernel = norm.normalized_text || norm.archetype || 'the one who carries the story';
        state.normalizedPlayerKernel = kernel;
        state.rawPlayerName = raw;
        playerNameInput.value = kernel;
        // Name entry does NOT trigger DSP update â€” names are not in DSP
      });
    }

    // Normalize partner name on blur (DSP no longer includes names â€” no DSP refresh needed)
    const partnerNameInput = $('partnerNameInput');
    if (partnerNameInput) {
      partnerNameInput.addEventListener('input', () => {
        // Update archetype row title with Love Interest name
        if (typeof updateArchetypeSectionTitle === 'function') {
          updateArchetypeSectionTitle();
        }
      });
      partnerNameInput.addEventListener('blur', async () => {
        const raw = partnerNameInput.value.trim();
        if (!raw) return;
        showNameRefiningIndicator(partnerNameInput);
        const norm = await callNormalizationLayer({
          axis: 'character',
          user_text: raw,
          context_signals: state.picks?.world || []
        });
        hideNameRefiningIndicator(partnerNameInput);
        const kernel = norm.normalized_text || norm.archetype || 'the one who draws them forward';
        state.normalizedPartnerKernel = kernel;
        state.rawPartnerName = raw;
        partnerNameInput.value = kernel;
        // Update archetype row title with normalized name
        if (typeof updateArchetypeSectionTitle === 'function') {
          updateArchetypeSectionTitle();
        }
      });
    }

    // Expose closeZoomedCard for module-scope callers (archetype overlay, zoom continue)
    window.closeZoomedCard = closeZoomedCard;
    window.initPressureFrontFlavors = initPressureFrontFlavors;
    window.injectPressureDestinyCard = injectPressureDestinyCard;
    window.injectDynamicDestinyCard = injectDynamicDestinyCard;
  }

  // Debounce utility for input handlers
  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WORLD SUBTYPE VISIBILITY - Show/hide subtype selections per world
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /**
   * Maps world values to their subtype selection container IDs.
   * Only these worlds have subtype options:
   * - SciFi, Fantasy, Horror (tone-based), Dystopia, PostApocalyptic
   */
  const WORLD_SUBTYPE_MAP = {
    Modern: 'modernSubtypeSelection',
    SciFi: 'scifiSubtypeSelection',
    Fantasy: 'fantasySubtypeSelection',
    Dystopia: 'dystopiaSubtypeSelection',
    PostApocalyptic: 'apocalypseSubtypeSelection'
  };

  // Horror subtypes are shown when Horror TONE is selected with certain worlds
  const HORROR_ELIGIBLE_WORLDS = ['Fantasy', 'Modern'];

  function updateWorldSubtypeVisibility(worldValue, toneValue) {
    // CORRECTIVE: World flavors now appear ONLY in the zoomed card popup
    // Hide all below-card subtype sections permanently
    Object.values(WORLD_SUBTYPE_MAP).forEach(id => {
      const section = document.getElementById(id);
      if (section) section.classList.add('hidden');
    });
    const horrorSection = document.getElementById('horrorSubtypeSelection');
    if (horrorSection) horrorSection.classList.add('hidden');

    // Clear worldSubtype from state when world changes
    if (state.picks.worldSubtype) {
      delete state.picks.worldSubtype;
    }

    // DISABLED: Below-card sections are no longer shown
    // Flavors now only appear in the zoomed world card popup
    return;

    // Show relevant subtype section based on world
    const subtypeSectionId = WORLD_SUBTYPE_MAP[worldValue];
    if (subtypeSectionId) {
      const section = document.getElementById(subtypeSectionId);
      if (section) section.classList.remove('hidden');
    }

    // Show horror subtypes if Horror tone is selected with eligible world
    if (toneValue === 'Horror' && HORROR_ELIGIBLE_WORLDS.includes(worldValue)) {
      if (horrorSection) horrorSection.classList.remove('hidden');
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FLAVOR GRID â€” Optional refinement for Primary Pressure selection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Show or hide the flavor grid
   * @param {boolean} show - Whether to show the grid
   */
  function showFlavorGrid(show) {
    const flavorTitle = document.getElementById('flavorTitle');
    const flavorGrid = document.getElementById('flavorGrid');
    if (flavorTitle) flavorTitle.style.display = show ? '' : 'none';
    if (flavorGrid) flavorGrid.style.display = show ? '' : 'none';
  }

  /**
   * Populate the flavor grid with options for the selected pressure
   * @param {string} pressureId - The selected primary pressure
   */
  function populateFlavorGrid(pressureId) {
    const flavorGrid = document.getElementById('flavorGrid');
    if (!flavorGrid) return;

    const flavors = PRESSURE_FLAVORS[pressureId] || [];
    flavorGrid.innerHTML = '';

    if (flavors.length === 0) {
      showFlavorGrid(false);
      return;
    }

    flavors.forEach(flavor => {
      const card = document.createElement('div');
      card.className = 'sb-card';
      card.dataset.grp = 'flavor';
      card.dataset.val = flavor.id;

      // Check if this flavor is currently selected
      if (state.picks.flavor === flavor.id) {
        card.classList.add('selected', 'flipped');
      }

      // Check flavor compatibility with current tone
      if (!isFlavorCompatible(flavor.id, state.picks.tone)) {
        card.classList.add('incompatible');
      }

      card.innerHTML = `
        <div class="sb-card-inner">
          <div class="sb-card-face sb-card-back">
            <span class="sb-card-title">${flavor.label}</span>
          </div>
          <div class="sb-card-face sb-card-front">
            <span class="sb-card-title">${flavor.label}</span>
            <span class="sb-card-desc">${flavor.description}</span>
          </div>
        </div>
      `;

      // Bind click handler (same as other sb-cards)
      card.dataset.bound = '1';
      card.addEventListener('click', (e) => {
        if (e.target.closest('.preview-btn')) return;
        const grp = card.dataset.grp;
        const val = card.dataset.val;

        // Check layer unlock
        if (!isLayerUnlocked(grp)) return;
        if (card.classList.contains('incompatible')) return;

        // FLAVOR TOGGLE: Clicking selected flavor deselects it (flavors are optional)
        if (card.classList.contains('selected') && card.classList.contains('flipped')) {
          // Deselect flavor
          card.classList.remove('selected', 'flipped');
          state.picks.flavor = null;
          state.picks.genre = getEffectiveGenre(state.picks.pressure, null);
          // Update DSP with pressure-only phrase
          const dspPhrase = getPressureDSPPhrase(state.picks.pressure, null);
          activateDSPSegment('genre', ', shaped by ' + dspPhrase);
          updateSynopsisPanel(true);
          return;
        }

        // Select this flavor, deselect others
        state.picks[grp] = val;
        state.picks.genre = getEffectiveGenre(state.picks.pressure, val);

        // Clear cover shape hash
        if (window.clearCoverShapeHash) window.clearCoverShapeHash();

        // Update card states
        flavorGrid.querySelectorAll('.sb-card[data-grp="flavor"]').forEach(c => {
          c.classList.remove('selected', 'flipped');
        });
        card.classList.add('selected', 'flipped');

        // Update DSP
        const dspPhrase = getPressureDSPPhrase(state.picks.pressure, val);
        activateDSPSegment('genre', ', shaped by ' + dspPhrase);

        // Invalidate shape snapshot
        if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();
        incrementDSPActivation();
        updateSynopsisPanel(true);
      });

      flavorGrid.appendChild(card);
      if (window.applyCardGleam) window.applyCardGleam(card);
    });
  }

  /**
   * Update flavor grid when pressure or tone changes
   * Called after pressure selection or tone change to refresh compatibility
   */
  function updateFlavorGridState() {
    const flavorGrid = document.getElementById('flavorGrid');
    if (!flavorGrid) return;

    flavorGrid.querySelectorAll('.sb-card[data-grp="flavor"]').forEach(card => {
      const val = card.dataset.val;
      // Update compatibility
      const compatible = isFlavorCompatible(val, state.picks.tone);
      card.classList.toggle('incompatible', !compatible);
      // Update selection state
      const isSelected = state.picks.flavor === val;
      card.classList.toggle('selected', isSelected);
      card.classList.toggle('flipped', isSelected);
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB FLOW SYSTEM â€” Sequential card selection with committed breadcrumbs
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // INTERACTION MODEL:
  // 1. One row of cards at a time
  // 2. Selection â†’ Continue â†’ Breadcrumb
  // 3. Selected card animates to breadcrumb row
  // 4. Other cards dissipate with sparkles
  // 5. Next row fades in
  //
  // FLOW ORDER: pressure â†’ world â†’ tone â†’ dynamic
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB PERSISTENCE AUTHORITY (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PERSISTENT BREADCRUMBS (Final State - 8Â±1 items):
  //   guidedFate, storybeau, length, world, tone, pressure, pov, dynamic
  //   Flavor is NESTED inside World breadcrumb (sub-label), not its own item
  //
  // DROPPED AFTER USE (Dissolve at POV selection):
  //   mode (Solo/Couple) â€” temporary mode indicator
  //   Note: Taste is a Story Length value, persists if selected
  //
  // NEVER BECOMES BREADCRUMB:
  //   intensity (arousal) â€” NEVER collapses to breadcrumb at any phase
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Layers that persist as final breadcrumbs
   * Order matches approximate selection flow
   */
  const BREADCRUMB_PERSISTENT_LAYERS = [
    'guidedFate',  // Destiny card click (special handling)
    'archetype',   // Storybeau selection
    'length',      // Story length (taste/fling/affair/soulmates)
    'world',       // World setting
    'tone',        // Narrative tone
    'pressure',    // Story pressure
    'pov',         // Point of view
    'dynamic'      // Relationship dynamic
  ];

  /**
   * Layers that show temporarily but dissolve at POV selection
   * These sparkle-dissipate when POV is committed
   */
  const BREADCRUMB_EPHEMERAL_LAYERS = [
    'mode'         // Solo/Couple â€” dissolves at POV
  ];

  /**
   * Layers that NEVER become breadcrumbs
   * Arousal is the primary exclusion â€” it can change without destroying cover
   */
  const BREADCRUMB_EXCLUDED_LAYERS = [
    // (intensity/arousal now gets a breadcrumb)
  ];

  /**
   * Check if a layer should become a breadcrumb
   * @param {string} grp - The layer group name
   * @returns {boolean} True if layer can become breadcrumb
   */
  function canBecomeBreadcrumb(grp) {
    // EXCLUDED: Never becomes breadcrumb
    if (BREADCRUMB_EXCLUDED_LAYERS.includes(grp)) {
      console.log(`[Breadcrumb] EXCLUDED: ${grp} â€” never becomes breadcrumb`);
      return false;
    }
    // PERSISTENT or EPHEMERAL: Can become breadcrumb
    return BREADCRUMB_PERSISTENT_LAYERS.includes(grp) ||
           BREADCRUMB_EPHEMERAL_LAYERS.includes(grp);
  }

  /**
   * Check if a layer should dissolve at POV selection
   * @param {string} grp - The layer group name
   * @returns {boolean} True if layer dissolves at POV
   */
  function shouldDissolveAtPOV(grp) {
    return BREADCRUMB_EPHEMERAL_LAYERS.includes(grp);
  }

  /**
   * Dissolve ephemeral breadcrumbs when POV is selected
   * Called when POV selection is committed
   */
  function dissolveEphemeralBreadcrumbs() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    BREADCRUMB_EPHEMERAL_LAYERS.forEach(grp => {
      const ephemeralCard = breadcrumbRow.querySelector(`.breadcrumb-card[data-grp="${grp}"]`);
      if (ephemeralCard) {
        console.log(`[Breadcrumb] Dissolving ephemeral: ${grp}`);

        // Create sparkle effect before removal
        createDissipationSparkles(ephemeralCard);

        // Add dissolve animation
        ephemeralCard.classList.add('breadcrumb-dissolving');

        // Remove after animation
        setTimeout(() => {
          ephemeralCard.remove();
          console.log(`[Breadcrumb] Ephemeral removed: ${grp}`);
        }, 600);
      }
    });
  }

  /**
   * Get display label for a breadcrumb, with flavor nested in world
   * @param {string} grp - The layer group
   * @param {string} val - The selected value
   * @returns {object} { title, subtitle } for breadcrumb display
   */
  // Human-readable display names for pressure breadcrumbs (matching card back text)
  const PRESSURE_DISPLAY = {
    PowerControl: 'Power & Control',
    EscapePursuit: 'Escape & Pursuit',
    DesireObsession: 'Desire & Obsession',
    Survival: 'Survival'
  };

  // Human-readable display names for dynamic/polarity breadcrumbs
  const DYNAMIC_DISPLAY = {
    Proximity: 'Forced Proximity',
    SecretIdentity: 'Secret Identity',
    Friends: 'Friends to Lovers',
    Enemies: 'Enemies to Lovers',
    SecondChance: '2nd Chance',
    Forbidden: 'Forbidden Love'
  };

  function getBreadcrumbLabel(grp, val) {
    const labels = {
      authorship: { title: val === 'manual' ? 'Choose Your Hand' : 'Guided Fate', subtitle: null },
      identity: {
        // Use displayName for UI (breadcrumb), canonicalName stored separately for prose
        title: state.picks?.identity?.displayPlayerName
          ? state.picks.identity.displayPlayerName
          : (state.picks?.identity?.playerName || val),
        subtitle: 'Character'
      },
      archetype: { title: val, subtitle: 'Storybeau' },
      length: { title: val, subtitle: 'Story Length' },
      world: {
        title: val,
        subtitle: state.picks?.worldSubtype ? getWorldLabel(state.picks.worldSubtype) : (state.worldCustomTexts?.[val] || null)
      },
      tone: { title: val === 'WryConfession' ? 'Wry' : val, subtitle: 'Story Tone' },
      pressure: {
        title: PRESSURE_DISPLAY[val] || val,
        subtitle: 'Story Pull'
      },
      pov: { title: val, subtitle: 'Story POV' },
      dynamic: { title: DYNAMIC_DISPLAY[val] || val, subtitle: 'Story Polarity' },
      intensity: { title: val, subtitle: 'Intensity' },
      safety: { title: 'Safety', subtitle: null },
      beginstory: { title: 'Begin Story', subtitle: null },
      mode: { title: val, subtitle: 'Mode' }
    };

    return labels[grp] || { title: val, subtitle: grp };
  }

  /**
   * Update world breadcrumb to include nested flavor
   * Called when flavor selection changes
   */
  function updateWorldBreadcrumbFlavor() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    const worldBreadcrumb = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="world"]');
    if (!worldBreadcrumb) return;

    const worldVal = worldBreadcrumb.dataset.val;
    const flavorLabel = state.picks?.worldSubtype
      ? getWorldLabel(state.picks.worldSubtype)
      : (state.worldCustomTexts?.[worldVal] || null);
    const subtitleEl = worldBreadcrumb.querySelector('.breadcrumb-subtitle');
    const backFace = worldBreadcrumb.querySelector('.sb-card-back');

    if (flavorLabel) {
      if (subtitleEl) {
        subtitleEl.textContent = flavorLabel;
      } else {
        // Create subtitle element in the back face (visible face for breadcrumbs)
        const target = backFace || worldBreadcrumb;
        const newSubtitle = document.createElement('span');
        newSubtitle.className = 'breadcrumb-subtitle';
        newSubtitle.textContent = flavorLabel;
        target.appendChild(newSubtitle);
      }
      console.log(`[Breadcrumb] World flavor nested: ${flavorLabel}`);
    } else if (subtitleEl) {
      subtitleEl.remove();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB CORRIDOR STATE MACHINE (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // CORRIDOR ORDER (9 rows, single-screen one-at-a-time):
  // 0: guidedFate   â€” Destiny card (auto-select or manual)
  // 1: storybeau    â€” Archetype selection
  // 2: world        â€” Story world setting
  // 3: tone         â€” Narrative tone
  // 4: pressure     â€” Story pressure axis
  // 5: pov          â€” Story point of view
  // 6: length       â€” Story length selection
  // 7: dynamic      â€” Relationship dynamic
  // 8: arousal      â€” Intensity (EXCLUDED from breadcrumbs)
  //
  // BREADCRUMBS: Rows 0-7 become breadcrumbs on selection
  // Arousal (row 8) NEVER becomes a breadcrumb
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const CORRIDOR_STAGES = [
    'authorship',  // Row 0 - Authorship choice (Choose Your Hand / Guided Fate)
    'identity',    // Row 1 - Character names (only shown if Choose Your Hand)
    'storybeau',   // Row 2 - Archetype
    'world',       // Row 3 - Story world
    'tone',        // Row 4 - Narrative tone
    'pressure',    // Row 5 - Story Pull
    'pov',         // Row 6 - Point of view
    'length',      // Row 7 - Story length
    'dynamic',     // Row 8 - Polarity
    'beginstory'   // Row 9 - Begin Story (terminal row)
  ];

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STAGE_INDEX â€” SINGLE AUTHORITATIVE MAP: grp â†’ fixed corridor index
  // All breadcrumb placement MUST use this map. No positional inference or fallbacks.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const STAGE_INDEX = {
    authorship: 0,   // Choice I: Authorship (Choose Your Hand / Guided Fate)
    identity: 1,     // Choice II: Character names (only if Choose Your Hand)
    storybeau: 2,    // Choice III: Archetype/Storybeau
    archetype: 2,    // Alias for storybeau
    world: 3,        // Choice IV: Story World
    tone: 4,         // Choice V: Narrative Tone
    pressure: 5,     // Choice VI: Story Pull
    pov: 6,          // Choice VII: Point of View
    length: 7,       // Choice VIII: Story Length
    dynamic: 8,      // Choice IX: Polarity/Dynamic
    beginstory: 9    // Terminal: Begin Story (no breadcrumb)
  };

  // Map corridor stage names to their data-grp values (for DOM queries)
  const CORRIDOR_GRP_MAP = {
    authorship: 'authorship',
    identity: 'identity',
    storybeau: 'archetype',
    world: 'world',
    tone: 'tone',
    pressure: 'pressure',
    pov: 'pov',
    length: 'length',
    dynamic: 'dynamic',
    beginstory: 'beginstory'
  };

  // Expose STAGE_INDEX globally for breadcrumb system
  window.STAGE_INDEX = STAGE_INDEX;

  // Map corridor stage names to their container IDs
  const CORRIDOR_ROW_IDS = {
    authorship: 'authorshipChoiceRow',
    storybeau: 'corridorRowStorybeau',
    world: 'corridorRowWorld',
    tone: 'corridorRowTone',
    pressure: 'corridorRowPressure',
    pov: 'corridorRowPov',
    length: 'corridorRowLength',
    dynamic: 'corridorRowDynamic',
    beginstory: 'beginStoryRow'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORRIDOR CONTRACT (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INVARIANT 1: Exactly ONE corridor row may be active at any time
  // INVARIANT 2: All completed/future rows must be unmounted from DOM, not CSS-hidden
  // INVARIANT 3: corridorActiveRowIndex is the ONLY source of truth for visibility
  // INVARIANT 4: No visual fix may mask a state or logic bug
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Corridor state machine - SINGLE SOURCE OF TRUTH
  let corridorActiveRowIndex = 0;
  const corridorSelections = new Map();

  // DOM mount/unmount storage - stores elements and their insertion anchors
  // Structure: Map<stage, { elements: Element[], anchors: Comment[] }>
  const corridorRowStore = new Map();

  // Legacy BREADCRUMB_FLOW_STAGES kept for button ID compatibility only
  const BREADCRUMB_FLOW_STAGES = ['pressure', 'world', 'tone', 'dynamic'];

  /**
   * Initialize the breadcrumb flow system
   */
  function initBreadcrumbFlow() {
    // Bind continue buttons
    const continueButtons = {
      pressure: document.getElementById('continueFromPressure'),
      world: document.getElementById('continueFromWorld'),
      tone: document.getElementById('continueFromTone'),
      dynamic: document.getElementById('continueFromDynamic')
    };

    Object.entries(continueButtons).forEach(([stage, btn]) => {
      if (btn) {
        btn.addEventListener('click', () => handleFlowContinue(stage));
      }
    });

    // Update continue button visibility on card selection
    document.querySelectorAll('.card-flow-row .sb-card[data-grp]').forEach(card => {
      card.addEventListener('click', () => {
        setTimeout(() => updateContinueButtonVisibility(), 100);
      });
    });

    // Initialize first stage
    updateFlowStageIndicator();
    updateContinueButtonVisibility();
  }

  /**
   * Check if a selection exists for the current flow stage
   */
  function hasSelectionForStage(stage) {
    const grp = stage; // pressure, world, tone, dynamic map directly
    const selectedCard = document.querySelector(
      `#flowRow${stage.charAt(0).toUpperCase() + stage.slice(1)} .sb-card[data-grp="${grp}"].selected`
    );
    return !!selectedCard;
  }

  /**
   * Update continue button visibility based on selection state
   * Uses corridorActiveRowIndex as single source of truth
   */
  function updateContinueButtonVisibility() {
    const activeStage = CORRIDOR_STAGES[corridorActiveRowIndex];

    BREADCRUMB_FLOW_STAGES.forEach((stage) => {
      const btn = document.getElementById(`continueFrom${stage.charAt(0).toUpperCase() + stage.slice(1)}`);
      if (btn) {
        const hasSelection = hasSelectionForStage(stage);
        // Map legacy stage to corridor stage for comparison
        const isCurrentStage = (stage === activeStage) ||
          (stage === 'storybeau' && activeStage === 'storybeau') ||
          (CORRIDOR_GRP_MAP[activeStage] === stage);
        btn.classList.toggle('visible', hasSelection && isCurrentStage);
      }
    });
  }

  /**
   * Update flow stage indicator dots
   * DEPRECATED: Breadcrumbs are the ONLY progress indicator per authoritative spec
   * This function now uses corridorActiveRowIndex for any residual dot elements
   */
  function updateFlowStageIndicator() {
    // Breadcrumbs are the only indicator - dots should not exist
    // If dots exist, update them using corridorActiveRowIndex as source of truth
    const dots = document.querySelectorAll('.flow-stage-dot');
    dots.forEach((dot, idx) => {
      dot.classList.remove('active', 'completed');
      if (idx < corridorActiveRowIndex) {
        dot.classList.add('completed');
      } else if (idx === corridorActiveRowIndex) {
        dot.classList.add('active');
      }
    });
  }

  /**
   * Handle continue button click â€” commit selection and advance flow
   * Uses corridorActiveRowIndex as SINGLE SOURCE OF TRUTH
   */
  function handleFlowContinue(stage) {
    // Safety: if pressure was selected via Destiny, breadcrumb already exists â€” just advance
    if (stage === 'pressure' && pressureSelectedViaDestiny) {
      if (typeof hideCorridorContinueButton === 'function') hideCorridorContinueButton('pressure');
      advanceCorridorRow();
      return;
    }
    // Safety: if dynamic was selected via Destiny, breadcrumb already exists â€” just advance
    if (stage === 'dynamic' && dynamicSelectedViaDestiny) {
      if (typeof hideCorridorContinueButton === 'function') hideCorridorContinueButton('dynamic');
      advanceCorridorRow();
      return;
    }

    // Map legacy stage to corridor index
    const corridorIdx = CORRIDOR_STAGES.indexOf(stage);
    if (corridorIdx === -1) {
      // Try mapping via CORRIDOR_GRP_MAP
      const mappedIdx = CORRIDOR_STAGES.findIndex(s => CORRIDOR_GRP_MAP[s] === stage);
      if (mappedIdx === -1 || mappedIdx !== corridorActiveRowIndex) return;
    } else if (corridorIdx !== corridorActiveRowIndex) {
      return;
    }

    const activeStage = CORRIDOR_STAGES[corridorActiveRowIndex];
    const selectors = CORRIDOR_SECTION_SELECTORS[activeStage];
    if (!selectors) return;

    // Find the flow row element (may be stored or mounted)
    const stored = corridorRowStore.get(activeStage);
    const flowRow = stored?.elements?.[0] || document.querySelector(selectors.split(',')[0].trim());
    if (!flowRow) return;

    const grp = CORRIDOR_GRP_MAP[activeStage] || activeStage;
    const selectedCard = flowRow.querySelector(`.sb-card[data-grp="${grp}"].selected`) ||
                         flowRow.querySelector('.sb-card.selected');
    if (!selectedCard) return;

    // Get selected value for breadcrumb label
    const selectedVal = selectedCard.dataset.val;
    const titleEl = selectedCard.querySelector('.sb-card-title');
    const selectedTitle = titleEl ? titleEl.textContent : selectedVal;

    // Hide continue button
    const continueBtn = document.getElementById(`continueFrom${stage.charAt(0).toUpperCase() + stage.slice(1)}`);
    if (continueBtn) continueBtn.classList.remove('visible');

    // Animate selected card to breadcrumb
    animateCardToBreadcrumb(selectedCard, grp, selectedVal, selectedTitle, () => {
      // Dissipate other cards
      const otherCards = flowRow.querySelectorAll(`.sb-card[data-grp="${grp}"]:not(.selected)`);
      dissipateCards(otherCards, () => {
        // Advance corridor using SINGLE SOURCE OF TRUTH
        corridorActiveRowIndex++;
        updateCorridorVisibility();  // DOM mount/unmount
        updateFlowStageIndicator();

        // Check if flow complete
        if (corridorActiveRowIndex >= CORRIDOR_STAGES.length) {
          onBreadcrumbFlowComplete();
        } else {
          updateContinueButtonVisibility();
        }
      });
    });
  }

  /**
   * JS-driven sparkle trail from source to target (requestAnimationFrame).
   * Mirrors the fate card triggerGoldenFlow approach for reliable travel animation.
   */
  function fireSparkleTrail(fromX, fromY, fromW, fromH, toX, toY) {
    const particleCount = 14;
    const streamDuration = 900;
    const particleDuration = 1000;

    for (let i = 0; i < particleCount; i++) {
      const delay = (i / particleCount) * streamDuration;

      setTimeout(() => {
        const sparkle = document.createElement('div');
        sparkle.className = 'traveling-sparkle';
        document.body.appendChild(sparkle);

        // Random offset from source center
        const offX = (Math.random() - 0.5) * (fromW || 80) * 0.5;
        const offY = (Math.random() - 0.5) * (fromH || 120) * 0.5;
        const startX = fromX + offX;
        const startY = fromY + offY;

        // Slight wave amplitude per particle
        const waveAmp = 6 + Math.random() * 12;
        const wavePhase = Math.random() * Math.PI * 2;

        const pStartTime = performance.now();

        function animateParticle(currentTime) {
          const elapsed = currentTime - pStartTime;
          const progress = Math.min(elapsed / particleDuration, 1);

          // Ease-in-out
          const eased = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;

          // Sine wave for organic feel
          const wave = Math.sin(progress * Math.PI * 2 + wavePhase) * waveAmp;

          const currentX = startX + (toX - startX) * eased + wave;
          const currentY = startY + (toY - startY) * eased;

          sparkle.style.left = currentX + 'px';
          sparkle.style.top = currentY + 'px';

          // Fade in/out
          if (progress < 0.15) {
            sparkle.style.opacity = progress / 0.15;
          } else if (progress > 0.75) {
            sparkle.style.opacity = (1 - progress) / 0.25;
          } else {
            sparkle.style.opacity = '1';
          }

          // Scale down toward end
          const scale = 1 + 0.3 * Math.sin(progress * Math.PI) - progress * 0.4;
          sparkle.style.transform = `scale(${Math.max(scale, 0.3)})`;

          if (progress < 1) {
            requestAnimationFrame(animateParticle);
          } else {
            sparkle.remove();
          }
        }

        requestAnimationFrame(animateParticle);
      }, delay);
    }
  }

  /**
   * Animate selected card to breadcrumb row via SPARKLE TELEPORT
   * Phase 1: Card dissolves in place with sparkles
   * Phase 2: Sparkles travel to breadcrumb position
   * Phase 3: Breadcrumb materializes from sparkles
   * BREADCRUMB PERSISTENCE AUTHORITY applies â€” excluded layers skip breadcrumb
   */
  function animateCardToBreadcrumb(card, grp, val, title, onComplete) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) {
      onComplete?.();
      return;
    }

    // BREADCRUMB EXCLUSION CHECK â€” intensity (arousal) never becomes breadcrumb
    if (!canBecomeBreadcrumb(grp)) {
      console.log(`[Breadcrumb] Skipping excluded layer: ${grp}`);
      onComplete?.();
      return;
    }

    // Get positions
    const cardRect = card.getBoundingClientRect();
    const cardCenterX = cardRect.left + cardRect.width / 2;
    const cardCenterY = cardRect.top + cardRect.height / 2;

    // Target the ghost step that this breadcrumb will replace
    const stageIdx = STAGE_INDEX[grp];
    const ghostStep = breadcrumbRow.querySelector(`.ghost-step[data-ghost-index="${stageIdx}"]`);
    let targetX, targetY;
    if (ghostStep) {
      const ghostRect = ghostStep.getBoundingClientRect();
      targetX = ghostRect.left + ghostRect.width / 2;
      targetY = ghostRect.top + ghostRect.height / 2;
    } else {
      // Fallback: center of breadcrumb row
      const breadcrumbRect = breadcrumbRow.getBoundingClientRect();
      targetX = breadcrumbRect.left + breadcrumbRect.width / 2;
      targetY = breadcrumbRect.top + breadcrumbRect.height / 2;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: Dissolve card in place
    // Card stays put, emits sparkles, fades to 0
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    card.classList.add('dissolving-to-breadcrumb');

    // Create dissolution sparkles from card surface
    const dissolutionCount = 12 + Math.floor(Math.random() * 6);
    for (let i = 0; i < dissolutionCount; i++) {
      setTimeout(() => {
        const sparkle = document.createElement('div');
        sparkle.className = 'dissolution-sparkle';

        // Random position on card surface
        const startX = cardRect.left + Math.random() * cardRect.width;
        const startY = cardRect.top + Math.random() * cardRect.height;

        sparkle.style.cssText = `
          left: ${startX}px;
          top: ${startY}px;
        `;
        document.body.appendChild(sparkle);

        // Remove after brief glow
        setTimeout(() => sparkle.remove(), 400);
      }, i * 30); // Stagger sparkle creation
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: Sparkle travel (teleport illusion) â€” JS-driven like fate cards
    // Sparkles arc from card to breadcrumb via requestAnimationFrame
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      fireSparkleTrail(cardCenterX, cardCenterY, cardRect.width, cardRect.height, targetX, targetY);
    }, 250); // Start travel after dissolution begins

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: Breadcrumb materializes
    // Sparkles converge, breadcrumb appears with reveal animation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      // Hide original card completely
      card.style.visibility = 'hidden';
      card.classList.remove('dissolving-to-breadcrumb');

      // Get structured label with optional subtitle
      const label = getBreadcrumbLabel(grp, val);
      const subtitleHtml = label.subtitle
        ? `<span class="breadcrumb-subtitle">${label.subtitle}</span>`
        : '';

      // Mark ephemeral layers for later dissolution
      const ephemeralClass = shouldDissolveAtPOV(grp) ? ' breadcrumb-ephemeral' : '';

      // Create breadcrumb card with materializing class
      const breadcrumb = document.createElement('div');
      breadcrumb.className = 'breadcrumb-card materializing' + ephemeralClass;
      breadcrumb.dataset.grp = grp;
      breadcrumb.dataset.val = val;
      breadcrumb.dataset.stageIndex = STAGE_INDEX[grp];
      breadcrumb.dataset.breadcrumbLabel = grp.charAt(0).toUpperCase() + grp.slice(1);

      // Archetype/mask breadcrumbs use PNG art instead of text
      const archetypePngMap = {
        'HEART_WARDEN': 'Tarot-Gold-front-HeartWarden.png',
        'OPEN_VEIN': 'Tarot-Gold-front-OpenVein.png',
        'SPELLBINDER': 'Tarot-Gold-front-Spellbinder.png',
        'ARMORED_FOX': 'Tarot-Gold-front-AFox.png',
        'DARK_VICE': 'Tarot-Gold-front-DarkVice.png',
        'BEAUTIFUL_RUIN': 'Tarot-Gold-front-BRuin.png',
        'ETERNAL_FLAME': 'Tarot-Gold-front-EternalFlame.png'
      };

      if (grp === 'archetype' && archetypePngMap[val]) {
        breadcrumb.classList.add('archetype-breadcrumb-png');
        breadcrumb.style.backgroundImage = `url('/assets/card-art/cards/${archetypePngMap[val]}')`;
        breadcrumb.style.backgroundSize = 'cover';
        breadcrumb.style.backgroundPosition = 'center';
      } else {
        breadcrumb.innerHTML = `
          <div class="sb-card-inner">
            <div class="sb-card-face sb-card-back">
              <span class="sb-card-title">${label.title}</span>
              ${subtitleHtml}
            </div>
            <div class="sb-card-face sb-card-front">
              <span class="sb-card-title">${label.title}</span>
              ${subtitleHtml}
            </div>
          </div>
        `;
      }
      // Insert before the first ghost step (breadcrumbs accumulate on left)
      const firstGhost = breadcrumbRow.querySelector('.ghost-step');
      if (firstGhost) {
        breadcrumbRow.insertBefore(breadcrumb, firstGhost);
      } else {
        breadcrumbRow.appendChild(breadcrumb);
      }

      // Remove the corresponding ghost step
      const stageIdxForGhost = STAGE_INDEX[grp];
      if (stageIdxForGhost >= 0) {
        removeGhostStep(stageIdxForGhost);
      }

      // Create convergence sparkles at breadcrumb
      for (let i = 0; i < 6; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'convergence-sparkle';
        const angle = (Math.PI * 2 * i) / 6;
        const dist = 20 + Math.random() * 15;
        sparkle.style.cssText = `
          left: ${targetX + Math.cos(angle) * dist}px;
          top: ${targetY + Math.sin(angle) * dist}px;
        `;
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 500);
      }

      // Remove materializing class after animation
      setTimeout(() => {
        breadcrumb.classList.remove('materializing');
      }, 400);

      // DESTRUCTIVE NAVIGATION: Attach click handler for breadcrumb navigation
      attachBreadcrumbNavigation(breadcrumb);

      console.log(`[Breadcrumb] Created via sparkle-teleport: ${grp}=${val}${label.subtitle ? ` (${label.subtitle})` : ''}`);
      onComplete?.();
    }, 1300); // Total time for dissolution + travel (synced with fireSparkleTrail)
  }

  /**
   * Dissipate unselected cards with sparkle effect
   */
  function dissipateCards(cards, onComplete) {
    if (!cards || cards.length === 0) {
      onComplete?.();
      return;
    }

    let completed = 0;
    cards.forEach((card, idx) => {
      // Stagger the dissipation
      setTimeout(() => {
        card.classList.add('dissipating');

        // Create sparkle particles
        createDissipationSparkles(card);

        // Mark completion after animation
        setTimeout(() => {
          completed++;
          if (completed === cards.length) {
            onComplete?.();
          }
        }, 1400);
      }, idx * 80); // 80ms stagger between cards
    });
  }

  /**
   * Create sparkle particles for card dissipation
   */
  function createDissipationSparkles(card) {
    const rect = card.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Dense surface-covering sparkles (30-40)
    const particleCount = 30 + Math.floor(Math.random() * 11);
    for (let i = 0; i < particleCount; i++) {
      const sparkle = document.createElement('div');
      sparkle.className = 'dissipate-sparkle';

      // Spawn across entire card surface
      const spawnX = rect.left + Math.random() * rect.width;
      const spawnY = rect.top + Math.random() * rect.height;

      // Scatter outward from card center with upward bias
      const angle = Math.atan2(spawnY - centerY, spawnX - centerX) + (Math.random() - 0.5) * 0.8;
      const distance = 50 + Math.random() * 80;
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance - 30; // Slight upward bias

      // Perpendicular curve for firefly wiggle
      const perpAngle = angle + Math.PI / 2;
      const curveMag = (Math.random() - 0.5) * 20;
      const curveX = Math.cos(perpAngle) * curveMag;
      const curveY = Math.sin(perpAngle) * curveMag;

      // Varied sizes and durations
      const size = 3 + Math.random() * 4;
      const duration = 1.0 + Math.random() * 0.4;

      sparkle.style.cssText = `
        left: ${spawnX}px;
        top: ${spawnY}px;
        --sparkle-dx: ${dx}px;
        --sparkle-dy: ${dy}px;
        --sparkle-curve-x: ${curveX}px;
        --sparkle-curve-y: ${curveY}px;
        --sparkle-size: ${size}px;
        --scatter-duration: ${duration}s;
      `;

      // Stagger spawn over ~200ms for bloom effect
      const delay = Math.random() * 200;
      sparkle.style.animationDelay = `${delay}ms`;

      document.body.appendChild(sparkle);

      // Remove after animation completes
      setTimeout(() => sparkle.remove(), (duration * 1000) + delay + 50);
    }
  }

  /**
   * Called when all breadcrumb flow stages are complete
   */
  function onBreadcrumbFlowComplete() {
    // All core selections made â€” user can now proceed to character setup
    // Show any remaining setup sections (intensity, length, etc.)
    console.log('[BreadcrumbFlow] Flow complete. All core selections committed.');

    // Optionally trigger story begin or show remaining options
    // For now, the flow ends here and user can proceed with Begin Story
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BREADCRUMB INTERACTION â€” DESTRUCTIVE NAVIGATION (AUTHORITATIVE)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Breadcrumbs are clickable. On click:
  //   - Navigate to the selected breadcrumb's section
  //   - DESTROY all downstream breadcrumbs
  //   - Resume corridor flow from that point
  // No confirmation dialogs â€” visual signaling alone is sufficient.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Navigate to a breadcrumb's section (NON-DESTRUCTIVE)
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * AUTHORITATIVE RULES:
   * - Breadcrumbs are PERMANENT navigation anchors
   * - Clicking a breadcrumb ONLY navigates to that stage
   * - NO deletions, NO resets, NO state mutations beyond navigation
   * - If target is invalid/unlocked, redirect to last valid stage
   * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   * @param {string} grp - The data-grp value of the clicked breadcrumb
   */
  function navigateToBreadcrumb(grp) {
    // Find the corridor stage for this grp
    let targetRowIndex = -1;
    for (let i = 0; i < CORRIDOR_STAGES.length; i++) {
      const stage = CORRIDOR_STAGES[i];
      const stageGrp = CORRIDOR_GRP_MAP[stage];
      if (stageGrp === grp || stage === grp) {
        targetRowIndex = i;
        break;
      }
    }

    // Special handling for authorship/identity grps that map to early rows
    if (targetRowIndex === -1) {
      if (grp === 'authorship' || grp === 'mode') {
        targetRowIndex = 0;
      } else if (grp === 'identity' || grp === 'names') {
        targetRowIndex = 1;
      }
    }

    if (targetRowIndex === -1) {
      console.warn(`[Breadcrumb Nav] Unknown grp: ${grp}, staying at current row`);
      return;
    }

    // Validate target is accessible (has been visited or has selection)
    // If not, redirect to last valid stage
    const isValidTarget = visitedRows.has(targetRowIndex) ||
                          corridorSelections.has(CORRIDOR_STAGES[targetRowIndex]) ||
                          targetRowIndex <= corridorActiveRowIndex;

    if (!isValidTarget) {
      console.warn(`[Breadcrumb Nav] Target row ${targetRowIndex} is not valid, redirecting to current`);
      return; // Stay at current row
    }

    console.log(`[Breadcrumb Nav] Navigating to row ${targetRowIndex} (${grp})`);

    // Clear downstream breadcrumbs and selections so user can re-choose
    if (targetRowIndex < corridorActiveRowIndex) {
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      for (let i = targetRowIndex + 1; i < CORRIDOR_STAGES.length; i++) {
        const downstreamStage = CORRIDOR_STAGES[i];
        const downstreamGrp = CORRIDOR_GRP_MAP[downstreamStage];

        // Remove breadcrumb from DOM
        if (breadcrumbRow) {
          const bc = breadcrumbRow.querySelector(`.breadcrumb-card[data-grp="${downstreamGrp}"]`);
          if (bc) {
            bc.remove();
            // Restore ghost step for this slot
            const stageIdx = STAGE_INDEX[downstreamGrp];
            if (stageIdx >= 0 && !breadcrumbRow.querySelector(`.ghost-step[data-ghost-index="${stageIdx}"]`)) {
              const ghost = document.createElement('div');
              ghost.className = 'ghost-step';
              ghost.dataset.ghostIndex = stageIdx;
              ghost.dataset.ghostGrp = downstreamGrp;
              ghost.innerHTML = `
                <span class="ghost-step-label">CHOICE</span>
                <span class="ghost-step-number">${GHOST_STEP_NUMERALS[stageIdx] || stageIdx + 1}</span>
              `;
              // Insert in correct order among existing ghosts
              const allGhosts = breadcrumbRow.querySelectorAll('.ghost-step');
              let inserted = false;
              for (const g of allGhosts) {
                if (parseInt(g.dataset.ghostIndex) > stageIdx) {
                  breadcrumbRow.insertBefore(ghost, g);
                  inserted = true;
                  break;
                }
              }
              if (!inserted) breadcrumbRow.appendChild(ghost);
            }
            console.log(`[Breadcrumb Nav] Removed downstream breadcrumb: ${downstreamGrp}`);
          }
        }

        // Clear corridor selection
        corridorSelections.delete(downstreamStage);

        // Restore ALL cards in stored corridor rows (dissipated + selected + dissolved)
        const stored = corridorRowStore.get(i);
        if (stored) {
          stored.elements.forEach(el => {
            el.querySelectorAll('.sb-card').forEach(card => {
              card.classList.remove('dissipating', 'selected', 'flipped', 'dissolving-to-breadcrumb');
              card.style.opacity = '';
              card.style.visibility = '';
              card.style.animation = '';
              card.style.animationFillMode = '';
              card.style.pointerEvents = '';
              card.style.filter = '';
            });
          });
        }
      }
    }

    corridorActiveRowIndex = targetRowIndex;
    updateCorridorVisibility();
    updateCorridorContinueButtonVisibility();

    // Update DSP visibility (only shows during World, Tone, Pressure, POV, Length)
    updateDSPCorridorVisibility();

    // Ensure exactly one valid stage row is rendered
    ensureValidRowRendered();

    console.log(`[Breadcrumb Nav] Now at row ${corridorActiveRowIndex}`);
  }

  // ensureValidRowRendered defined later in navigation section

  /**
   * Attach click handler to a breadcrumb for NON-DESTRUCTIVE navigation
   * AUTHORITATIVE: Breadcrumbs are permanent anchors, never deleted
   * @param {HTMLElement} breadcrumb - The breadcrumb element
   */
  function attachBreadcrumbNavigation(breadcrumb) {
    breadcrumb.addEventListener('click', (e) => {
      e.stopPropagation();
      const grp = breadcrumb.dataset.grp;
      if (grp) {
        navigateToBreadcrumb(grp);
      }
    });
  }

  // Export for global access
  window.navigateToBreadcrumb = navigateToBreadcrumb;

  /**
   * Reset breadcrumb flow to initial state
   * Called when starting a new story
   * Uses corridorActiveRowIndex as SINGLE SOURCE OF TRUTH
   */
  function resetBreadcrumbFlow() {
    // Reset corridor state - SINGLE SOURCE OF TRUTH
    corridorActiveRowIndex = 0;
    corridorSelections.clear();
    // Reset Fortune's Favor prelude gate so it re-triggers on next World visit
    if (typeof resetFortuneFavorPrelude === 'function') resetFortuneFavorPrelude();

    // Clear breadcrumb row
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (breadcrumbRow) breadcrumbRow.innerHTML = '';

    // Reset card state in all stored rows before remounting
    corridorRowStore.forEach((stored) => {
      stored.elements.forEach(el => {
        el.querySelectorAll('.sb-card').forEach(card => {
          card.style.visibility = '';
          card.style.opacity = '';
          card.classList.remove('dissipating', 'selected', 'flipped', 'becoming-breadcrumb');
        });
      });
    });

    // Clear state selections
    state.picks.pressure = null;
    state.picks.world = null;
    state.picks.tone = null;
    state.picks.dynamic = null;
    state.picks.pov = null;
    state.picks.length = null;
    state.picks.intensity = null;

    // Apply corridor visibility via DOM mount/unmount
    updateCorridorVisibility();
    updateFlowStageIndicator();
    updateContinueButtonVisibility();

    // DSP VISIBILITY GATE: Hide DSP on reset (corridor back to row 0)
    if (typeof updateDSPCorridorVisibility === 'function') {
      updateDSPCorridorVisibility();
    }
  }

  // Expose reset function globally for restart functionality
  window.resetBreadcrumbFlow = resetBreadcrumbFlow;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORRIDOR STATE MACHINE â€” 9-row single-screen selection system
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Map corridor stages to their actual DOM container selectors
   * These are the existing HTML elements that contain each row's cards
   * Note: Using IDs and classes that exist in the current HTML structure
   *
   * ALL rows follow the same visibility rules - only active row is shown.
   * Guided Fate is row 0 and obeys corridor visibility like all others.
   */
  const CORRIDOR_SECTION_SELECTORS = {
    // Authorship choice row (Continue button inside row)
    authorship: '#authorshipChoiceRow, #continueFromAuthorship',
    // Identity/character section (shown after Choose Your Hand)
    identity: '#characterSectionRow, #continueFromCharacters',
    storybeau: '#archetypeSectionTitle, #archetypeCardGrid, .archetype-header-text, .archetype-subtext, #archetypeSelectionSummary, #continueFromStorybeau',
    world: '#flowRowWorld',
    tone: '#flowRowTone',
    pressure: '#flowRowPressure',
    pov: '#povSectionTitle, #povGrid, #continueFromPov',
    length: '#lengthSection, #continueFromLength',
    dynamic: '#flowRowDynamic, #continueFromDynamic',
    beginstory: '#beginStoryRow'
  };

  /**
   * Measure sticky header height and set CSS variable for corridor centering
   * Called on init and resize to keep centering accurate
   */
  function measureAndSetHeaderHeight() {
    const header = document.querySelector('.shape-your-story-header');
    if (header) {
      const height = header.offsetHeight;
      document.documentElement.style.setProperty('--sb-header-height', `${height}px`);
      console.log(`[Corridor] Header height measured: ${height}px`);
    }
  }

  /**
   * Initialize the corridor system
   * Implements DOM mount/unmount for corridor contract enforcement
   */
  function initCorridor() {
    console.log('[Corridor] Initializing 9-row corridor system with DOM mount/unmount...');

    // MEASURE HEADER HEIGHT: Set CSS variable for corridor centering
    measureAndSetHeaderHeight();
    window.addEventListener('resize', debounce(measureAndSetHeaderHeight, 100));

    // VIEWPORT ISOLATION: Prevent body scrolling during corridor stages
    document.body.classList.add('corridor-mode');
    document.body.classList.remove('corridor-complete');

    // Reset state - start at row 0 (Guided Fate)
    corridorActiveRowIndex = 0;
    corridorSelections.clear();

    // Initialize DOM row store with elements and insertion anchors
    // INIT SAFETY GUARD: Do NOT clear if already populated (prevents orphaned anchors)
    initCorridorRowStore();

    // Apply initial visibility via DOM mount/unmount
    updateCorridorVisibility();

    // Bind corridor card click handlers
    bindCorridorCardHandlers();

    // Bind corridor continue buttons
    bindCorridorContinueButtons();

    // Initialize ghost step placeholders
    initGhostSteps();

    // Update continue button visibility for initial state
    updateCorridorContinueButtonVisibility();

    // DSP VISIBILITY GATE: Ensure DSP is hidden at corridor start
    updateDSPCorridorVisibility();

    // Start sparkle emitters for authorship cards (first row)
    initAuthorshipSparkles();

    // Initialize row navigation affordances (swipe + arrows)
    initCorridorNavigation();

    console.log('[Corridor] Initialization complete. Active row:', corridorActiveRowIndex);
    console.log('[Corridor] Row store initialized with', corridorRowStore.size, 'stages');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORRIDOR ROW NAVIGATION â€” Free navigation without auto-commit
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Navigation allows browsing all rows without selecting or committing.
  // Breadcrumbs are memory only â€” navigation does not create breadcrumbs.
  // Unresolved required rows tracked but enforced only at Begin Story.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Track which rows have been visited (for validation at Begin Story)
  const visitedRows = new Set();

  /**
   * Navigate to a specific corridor row (no selection, no commit)
   * @param {number} targetIndex - Target row index
   */
  // Track navigation attempts per stage (for tooltip logic)
  // Key: stage name, Value: number of navigation attempts without Continue
  const navigationAttemptsPerStage = new Map();
  // Track which stages have shown the tooltip (shows once ever)
  const tooltipShownForStage = new Set();

  function navigateToCorridorRow(targetIndex) {
    // Bounds check
    if (targetIndex < 0 || targetIndex >= CORRIDOR_STAGES.length) {
      return false;
    }

    // Skip if already at target
    if (targetIndex === corridorActiveRowIndex) {
      return false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SOFT NAVIGATION FEEDBACK (no hard blocking)
    // Navigation is always allowed. Uncommitted stages show Continue feedback.
    // First attempt: pulse Continue button
    // Second attempt: show tooltip "Continue locks this choice into your story."
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const currentStage = CORRIDOR_STAGES[corridorActiveRowIndex];
    const currentRowCommitted = corridorSelections.has(currentStage);

    if (!currentRowCommitted) {
      const continueBtn = findContinueButtonForStage(currentStage);
      if (continueBtn) {
        // Track navigation attempts for this stage
        const attempts = (navigationAttemptsPerStage.get(currentStage) || 0) + 1;
        navigationAttemptsPerStage.set(currentStage, attempts);

        if (attempts === 1) {
          // First attempt: pulse Continue button only
          triggerContinueButtonFeedback(continueBtn.id);
          console.log(`[Corridor Nav] Soft feedback: pulsed Continue for ${currentStage}`);
        } else if (attempts === 2 && !tooltipShownForStage.has(currentStage)) {
          // Second attempt: show tooltip (once per stage, ever)
          triggerContinueButtonFeedback(continueBtn.id);
          showContinueTooltip(continueBtn);
          tooltipShownForStage.add(currentStage);
          console.log(`[Corridor Nav] Soft feedback: showed tooltip for ${currentStage}`);
        }
        // Navigation proceeds regardless
      }
    }

    // Track current row as visited
    visitedRows.add(corridorActiveRowIndex);

    // Update active row index
    corridorActiveRowIndex = targetIndex;

    // RESTORE CORRIDOR MODE: If navigating back from corridor-complete,
    // re-enter corridor mode to restore viewport isolation (one row visible)
    if (document.body.classList.contains('corridor-complete')) {
      document.body.classList.remove('corridor-complete');
      document.body.classList.add('corridor-mode');
      // Re-hide post-arousal sections (Safety/Begin row shown by onCorridorComplete)
      const postArousalSection = document.getElementById('postArousalSection');
      if (postArousalSection) postArousalSection.classList.add('hidden');
      // Restore DSP visibility
      const synopsisPanel = document.getElementById('synopsisPanel');
      if (synopsisPanel) synopsisPanel.classList.remove('corridor-complete');
    }

    // Update visibility (DOM mount/unmount)
    updateCorridorVisibility();
    updateCorridorContinueButtonVisibility();

    // Update DSP visibility (only shows during World, Tone, Pressure, POV, Length)
    updateDSPCorridorVisibility();

    // Track new row as visited
    visitedRows.add(targetIndex);

    // INVARIANT: Ensure exactly one valid row is rendered
    ensureValidRowRendered();

    console.log(`[Corridor Nav] Navigated to row ${targetIndex}: ${CORRIDOR_STAGES[targetIndex]}`);
    return true;
  }

  /**
   * Find the Continue button for a given corridor stage
   */
  function findContinueButtonForStage(stage) {
    const stageToButton = {
      'authorship': 'continueFromAuthorship',
      'identity': 'continueFromCharacters',
      'storybeau': 'continueFromStorybeau',
      'archetype': 'continueFromStorybeau',
      'world': 'continueFromWorld',
      'tone': 'continueFromTone',
      'pressure': 'continueFromPressure',
      'pov': 'continueFromPov',
      'length': 'continueFromLength',
      'dynamic': 'continueFromDynamic',
      'beginstory': 'beginBtn'
    };
    const buttonId = stageToButton[stage];
    return buttonId ? $(buttonId) : null;
  }

  /**
   * Ensure exactly one valid stage row is rendered (INVARIANT)
   * Prevents blank corridor view - if no row is mounted, remount current
   */
  function ensureValidRowRendered() {
    const mountedRows = document.querySelectorAll('.corridor-section.corridor-active');
    const uniqueStages = new Set();
    mountedRows.forEach(el => uniqueStages.add(el.dataset.corridorStage));
    if (uniqueStages.size !== 1) {
      console.error(`[Corridor INVARIANT] Expected 1 mounted stage, found ${uniqueStages.size}`);
      // Force remount of current row
      updateCorridorVisibility();
    }
  }

  /**
   * Trigger visual feedback on Continue button when navigation is blocked
   */
  function triggerContinueButtonFeedback(buttonId) {
    const btn = $(buttonId);
    if (!btn) return;

    // Add shake/pulse class
    btn.classList.add('navigation-blocked');
    btn.classList.add('visible'); // Ensure it's visible

    // Remove after animation
    setTimeout(() => {
      btn.classList.remove('navigation-blocked');
    }, 600);
  }

  /**
   * Show tooltip on Continue button explaining commitment
   * Tooltip: "Continue locks this choice into your story."
   * Shows once per stage, then never again.
   */
  function showContinueTooltip(btnElement) {
    if (!btnElement) return;

    // Remove any existing tooltip
    const existingTooltip = document.querySelector('.continue-commitment-tooltip');
    if (existingTooltip) existingTooltip.remove();

    // Create tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'continue-commitment-tooltip';
    tooltip.textContent = 'Continue locks this choice into your story.';

    // Position tooltip above the button
    document.body.appendChild(tooltip);

    const btnRect = btnElement.getBoundingClientRect();
    tooltip.style.left = `${btnRect.left + btnRect.width / 2}px`;
    tooltip.style.top = `${btnRect.top - 10}px`;

    // Animate in
    requestAnimationFrame(() => {
      tooltip.classList.add('visible');
    });

    // Auto-hide after 4 seconds
    setTimeout(() => {
      tooltip.classList.remove('visible');
      setTimeout(() => tooltip.remove(), 300);
    }, 4000);
  }

  /**
   * Navigate to next row (right)
   */
  function navigateNextRow() {
    return navigateToCorridorRow(corridorActiveRowIndex + 1);
  }

  /**
   * Navigate to previous row (left)
   */
  function navigatePrevRow() {
    return navigateToCorridorRow(corridorActiveRowIndex - 1);
  }

  /**
   * Get list of unresolved required rows
   * @returns {Array} Array of { stage, index } for unresolved rows
   */
  function getUnresolvedRows() {
    const unresolved = [];
    CORRIDOR_STAGES.forEach((stage, idx) => {
      // Skip these stages (not required â€” they don't have card-based selection)
      if (stage === 'identity' || stage === 'beginstory') return;

      let hasSelection = corridorSelections.has(stage);

      // Special cases that don't use state.picks
      if (stage === 'authorship') {
        hasSelection = hasSelection || !!state.mode;
      } else if (stage === 'storybeau') {
        hasSelection = hasSelection || !!state.archetype?.primary;
      } else if (stage === 'length') {
        // Length is stored in state.storyLength, not state.picks.length
        hasSelection = hasSelection || !!state.storyLength;
      } else {
        // Standard corridor stages use state.picks
        const grp = CORRIDOR_GRP_MAP[stage];
        hasSelection = hasSelection ||
          (grp && state.picks && state.picks[grp]) ||
          !!document.querySelector(`.sb-card[data-grp="${grp}"].selected`);
      }

      if (!hasSelection) {
        unresolved.push({ stage, index: idx, grp: CORRIDOR_GRP_MAP[stage] });
      }
    });
    return unresolved;
  }

  /**
   * Validate all required rows are resolved (called at Begin Story)
   * @returns {boolean} True if all required rows are resolved
   */
  function validateCorridorComplete() {
    const unresolved = getUnresolvedRows();
    if (unresolved.length === 0) {
      return true;
    }

    console.warn('[Corridor] Unresolved rows:', unresolved.map(r => r.stage).join(', '));
    // Show missing selections modal
    showMissingSelectionsModal(unresolved);
    return false;
  }

  /**
   * Human-readable labels for corridor stages
   */
  const STAGE_DISPLAY_NAMES = {
    authorship: 'Authorship',
    identity: 'Characters',
    storybeau: 'Archetype',
    archetype: 'Archetype',
    world: 'World',
    tone: 'Tone',
    pressure: 'Story Pull',
    pov: 'POV',
    length: 'Length',
    dynamic: 'Dynamic',
    arousal: 'Intensity',
    safety: 'Safety',
    beginstory: 'Begin Story'
  };

  /**
   * Show modal listing missing selections with clickable navigation
   * Each item navigates to that stage. Offers "Let Fate Choose" option.
   */
  function showMissingSelectionsModal(unresolvedRows) {
    // Remove existing modal if any
    const existingModal = document.querySelector('.missing-selections-modal');
    if (existingModal) existingModal.remove();

    // Create modal
    const modal = document.createElement('div');
    modal.className = 'missing-selections-modal';

    const content = document.createElement('div');
    content.className = 'missing-selections-content';

    const title = document.createElement('h3');
    title.textContent = 'Missing Selections';
    content.appendChild(title);

    const list = document.createElement('ul');
    list.className = 'missing-selections-list';

    unresolvedRows.forEach(row => {
      const item = document.createElement('li');
      item.className = 'missing-selection-item';
      item.textContent = STAGE_DISPLAY_NAMES[row.stage] || row.stage;
      item.addEventListener('click', () => {
        closeMissingSelectionsModal();
        navigateToCorridorRow(row.index);
      });
      list.appendChild(item);
    });
    content.appendChild(list);

    // "Let Fate Choose" button
    const fateBtn = document.createElement('button');
    fateBtn.className = 'missing-selections-fate-btn';
    fateBtn.textContent = 'Let Fate Choose for Me';
    fateBtn.addEventListener('click', () => {
      closeMissingSelectionsModal();
      fillMissingWithFate(unresolvedRows);
    });
    content.appendChild(fateBtn);

    // Close button
    const closeBtn = document.createElement('button');
    closeBtn.className = 'missing-selections-close-btn';
    closeBtn.textContent = 'Close';
    closeBtn.addEventListener('click', closeMissingSelectionsModal);
    content.appendChild(closeBtn);

    modal.appendChild(content);

    // Backdrop click closes modal
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeMissingSelectionsModal();
    });

    document.body.appendChild(modal);
    requestAnimationFrame(() => modal.classList.add('visible'));
  }

  function closeMissingSelectionsModal() {
    const modal = document.querySelector('.missing-selections-modal');
    if (modal) {
      modal.classList.remove('visible');
      setTimeout(() => modal.remove(), 300);
    }
  }

  // ========================================
  // SCI-FI FLAVOR GATE MODAL
  // ========================================

  function showSciFiFlavorModal() {
    // Remove existing modal if any
    const existing = document.querySelector('.scifi-flavor-modal');
    if (existing) existing.remove();

    const SCIFI_FLAVORS = [
      { val: 'galactic_civilizations', label: 'Galactic Conflict', tip: 'Love can save a world, or burn a galaxy.' },
      { val: 'future_of_science', label: 'Science Future', tip: 'Love is just another law of the universe.' },
      { val: 'cyberpunk', label: 'Cyberpunk', tip: 'Even your backup heart can ache.' },
      { val: 'post_human', label: 'Post-Human', tip: 'Desire outpaces bodies, identity, and human limits.' },
      { val: 'first_contact', label: 'First Contact', tip: 'Contact changes everything.' },
      { val: 'simulation', label: 'Simulation', tip: 'Through layers of unreality, love endures.' },
      { val: 'final_frontier', label: 'Final Frontier', tip: 'Close quarters, endless stars.' }
    ];

    // Inject styles once
    if (!document.getElementById('scifi-flavor-modal-styles')) {
      const style = document.createElement('style');
      style.id = 'scifi-flavor-modal-styles';
      style.textContent = `
        .scifi-flavor-modal {
          position: fixed;
          inset: 0;
          z-index: 10000;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          align-items: center;
          justify-content: center;
          opacity: 0;
          transition: opacity 0.3s ease;
        }
        .scifi-flavor-modal.visible {
          opacity: 1;
        }
        .scifi-flavor-modal-content {
          background: var(--panel);
          border: 2px double gold;
          padding: 28px 32px;
          max-width: 420px;
          width: 90%;
          text-align: center;
          box-shadow: 0 0 0 1px #0a0a0a, 0 0 20px rgba(0, 0, 0, 0.2);
        }
        .scifi-flavor-modal-content h3 {
          color: var(--gold);
          font-family: 'Lora', serif;
          font-variant: small-caps;
          font-size: 1.4rem;
          margin: 0 0 8px 0;
          letter-spacing: 0.1em;
          text-shadow:
            -1px -1px 0 rgba(218, 165, 32, 0.4),
            1px -1px 0 rgba(218, 165, 32, 0.4),
            -1px 1px 0 rgba(218, 165, 32, 0.4),
            1px 1px 0 rgba(218, 165, 32, 0.4),
            0 0 4px rgba(218, 165, 32, 0.2);
        }
        .scifi-flavor-modal-content .scifi-flavor-subtitle {
          color: #bbb;
          font-family: 'Lora', serif;
          font-size: 0.85rem;
          margin: 0 0 20px 0;
          font-style: italic;
        }
        .scifi-flavor-grid {
          display: flex;
          flex-direction: column;
          gap: 6px;
          margin: 0 0 20px 0;
        }
        .scifi-flavor-btn {
          padding: 10px 16px;
          background-image: url('/assets/ui/DSP-Gold-Blk-1800x440.png');
          background-size: 100% 100%;
          background-repeat: no-repeat;
          background-position: center;
          border: none;
          color: #111;
          font-family: 'Lora', serif;
          font-variant: small-caps;
          font-size: 0.95rem;
          letter-spacing: 0.05em;
          cursor: pointer;
          transition: filter 0.15s ease;
          text-shadow:
            -1px -1px 0 rgba(218, 165, 32, 0.4),
            1px -1px 0 rgba(218, 165, 32, 0.4),
            -1px 1px 0 rgba(218, 165, 32, 0.4),
            1px 1px 0 rgba(218, 165, 32, 0.4);
          text-align: center;
        }
        .scifi-flavor-btn:hover {
          filter: brightness(1.15);
        }
        .scifi-flavor-btn .scifi-flavor-tip {
          display: block;
          font-size: 0.75rem;
          font-variant: normal;
          font-style: italic;
          color: #333;
          margin-top: 2px;
          letter-spacing: 0;
        }
        .scifi-flavor-close-btn {
          background: transparent;
          border: 1px solid rgba(218, 165, 32, 0.3);
          color: var(--gold);
          font-family: 'Lora', serif;
          font-variant: small-caps;
          font-size: 0.85rem;
          padding: 6px 24px;
          cursor: pointer;
          letter-spacing: 0.05em;
          transition: border-color 0.15s ease;
        }
        .scifi-flavor-close-btn:hover {
          border-color: var(--gold);
        }
      `;
      document.head.appendChild(style);
    }

    // Build modal DOM
    const modal = document.createElement('div');
    modal.className = 'scifi-flavor-modal';

    const content = document.createElement('div');
    content.className = 'scifi-flavor-modal-content';

    const title = document.createElement('h3');
    title.textContent = 'Sci-Fi requires a vector.';
    content.appendChild(title);

    const subtitle = document.createElement('p');
    subtitle.className = 'scifi-flavor-subtitle';
    subtitle.textContent = 'Choose the scientific or cosmic pressure shaping this story.';
    content.appendChild(subtitle);

    const grid = document.createElement('div');
    grid.className = 'scifi-flavor-grid';

    SCIFI_FLAVORS.forEach(flavor => {
      const btn = document.createElement('div');
      btn.className = 'scifi-flavor-btn';

      const labelSpan = document.createTextNode(flavor.label);
      btn.appendChild(labelSpan);

      const tipSpan = document.createElement('span');
      tipSpan.className = 'scifi-flavor-tip';
      tipSpan.textContent = flavor.tip;
      btn.appendChild(tipSpan);

      btn.addEventListener('click', () => {
        state.picks.worldSubtype = flavor.val;
        // Close modal and re-trigger begin story
        modal.classList.remove('visible');
        setTimeout(() => {
          modal.remove();
          if (typeof handleBeginStory === 'function') handleBeginStory();
        }, 300);
      });
      grid.appendChild(btn);
    });
    content.appendChild(grid);

    const closeBtn = document.createElement('button');
    closeBtn.className = 'scifi-flavor-close-btn';
    closeBtn.textContent = 'Close';
    closeBtn.addEventListener('click', () => {
      modal.classList.remove('visible');
      setTimeout(() => modal.remove(), 300);
    });
    content.appendChild(closeBtn);

    modal.appendChild(content);

    // Backdrop click closes
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.remove('visible');
        setTimeout(() => modal.remove(), 300);
      }
    });

    document.body.appendChild(modal);
    requestAnimationFrame(() => modal.classList.add('visible'));
  }

  /**
   * Auto-fill missing selections with random fate choices
   */
  function fillMissingWithFate(unresolvedRows) {
    unresolvedRows.forEach(row => {
      switch (row.stage) {
        case 'authorship':
          state.mode = 'manual';
          corridorSelections.set('authorship', 'manual');
          break;
        case 'storybeau':
          const randomArch = weightedArchetypeSelection();
          state.archetype = state.archetype || {};
          state.archetype.primary = randomArch;
          corridorSelections.set('storybeau', randomArch);
          createArchetypeBreadcrumbWithMask(randomArch, false);
          break;
        case 'world':
          const worlds = ['Modern', 'Fantasy', 'SciFi', 'Historical'];
          const randomWorld = worlds[Math.floor(Math.random() * worlds.length)];
          state.picks.world = randomWorld;
          corridorSelections.set('world', randomWorld);
          createBreadcrumbDirect('world', randomWorld, randomWorld);
          break;
        case 'tone':
          const tones = ['Earnest', 'WryConfession', 'Dark', 'Mythic'];
          const randomTone = tones[Math.floor(Math.random() * tones.length)];
          state.picks.tone = randomTone;
          deriveToneBias();
          corridorSelections.set('tone', randomTone);
          createBreadcrumbDirect('tone', randomTone, randomTone);
          break;
        case 'pressure':
          const pressures = Array.from(VISIBLE_PULLS);
          const randomPressure = pressures[Math.floor(Math.random() * pressures.length)];
          state.picks.pressure = randomPressure;
          corridorSelections.set('pressure', randomPressure);
          createBreadcrumbDirect('pressure', randomPressure, randomPressure);
          break;
        case 'pov':
          const povs = ['1st', '3rdLimited', '3rdOmni'];
          const randomPov = povs[Math.floor(Math.random() * povs.length)];
          state.picks.pov = randomPov;
          corridorSelections.set('pov', randomPov);
          createBreadcrumbDirect('pov', randomPov, randomPov);
          break;
        case 'length':
          const lengths = ['Short', 'Medium', 'Long'];
          const randomLength = lengths[Math.floor(Math.random() * lengths.length)];
          state.storyLength = randomLength;
          corridorSelections.set('length', randomLength);
          createBreadcrumbDirect('length', randomLength, randomLength);
          break;
        case 'dynamic':
          const dynamics = ['Friends', 'Enemies', 'SecondChance', 'Forbidden', 'Proximity', 'SecretIdentity'];
          const randomDynamic = dynamics[Math.floor(Math.random() * dynamics.length)];
          state.picks.dynamic = randomDynamic;
          corridorSelections.set('dynamic', randomDynamic);
          createBreadcrumbDirect('dynamic', randomDynamic, DYNAMIC_DISPLAY[randomDynamic] || randomDynamic);
          break;
      }
    });

    console.log('[Fate Fill] Auto-filled missing selections:', unresolvedRows.map(r => r.stage).join(', '));

    // Trigger Begin Story again now that selections are complete
    if (typeof handleBeginStory === 'function') handleBeginStory();
  }

  // Expose validation function
  window.validateCorridorComplete = validateCorridorComplete;
  window.getUnresolvedRows = getUnresolvedRows;

  /**
   * Initialize corridor navigation (swipe + arrows)
   */
  function initCorridorNavigation() {
    // Create navigation arrows for desktop
    createNavigationArrows();

    // Bind swipe handlers for mobile
    bindSwipeNavigation();

    console.log('[Corridor Nav] Navigation affordances initialized');
  }

  /**
   * Create left/right navigation arrows (desktop)
   */
  function createNavigationArrows() {
    const setupSection = document.getElementById('setup');
    if (!setupSection) return;

    // Remove existing arrows
    setupSection.querySelectorAll('.corridor-nav-arrow').forEach(a => a.remove());

    // Left arrow
    const leftArrow = document.createElement('button');
    leftArrow.className = 'corridor-nav-arrow corridor-nav-left';
    leftArrow.innerHTML = '&#8249;'; // Single left angle bracket
    leftArrow.setAttribute('aria-label', 'Previous row');
    leftArrow.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      navigatePrevRow();
      updateNavigationArrowVisibility();
    });

    // Right arrow
    const rightArrow = document.createElement('button');
    rightArrow.className = 'corridor-nav-arrow corridor-nav-right';
    rightArrow.innerHTML = '&#8250;'; // Single right angle bracket
    rightArrow.setAttribute('aria-label', 'Next row');
    rightArrow.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      navigateNextRow();
      updateNavigationArrowVisibility();
    });

    setupSection.appendChild(leftArrow);
    setupSection.appendChild(rightArrow);

    // Initial visibility update
    updateNavigationArrowVisibility();
  }

  /**
   * Update arrow visibility based on current position
   */
  function updateNavigationArrowVisibility() {
    const leftArrow = document.querySelector('.corridor-nav-left');
    const rightArrow = document.querySelector('.corridor-nav-right');

    if (leftArrow) {
      leftArrow.classList.toggle('hidden', corridorActiveRowIndex === 0);
    }
    if (rightArrow) {
      rightArrow.classList.toggle('hidden', corridorActiveRowIndex >= CORRIDOR_STAGES.length - 1);
    }
  }

  /**
   * Bind horizontal swipe navigation for mobile
   */
  function bindSwipeNavigation() {
    const setupSection = document.getElementById('setup');
    if (!setupSection) return;

    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 50;
    const maxVerticalDistance = 100;

    setupSection.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    setupSection.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;

      const deltaX = touchEndX - touchStartX;
      const deltaY = Math.abs(touchEndY - touchStartY);

      // Only handle horizontal swipes (not vertical scrolling)
      if (deltaY > maxVerticalDistance) return;

      if (Math.abs(deltaX) >= minSwipeDistance) {
        if (deltaX < 0) {
          // Swipe left â†’ next row
          navigateNextRow();
        } else {
          // Swipe right â†’ previous row
          navigatePrevRow();
        }
        updateNavigationArrowVisibility();
      }
    }, { passive: true });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GHOST STEP PLACEHOLDERS â€” Pre-breadcrumb progress indicators
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ghost steps show remaining steps before selection.
  // They are NOT interactive â€” purely presentational scaffolding.
  // Real breadcrumbs replace ghost steps left-to-right as corridor advances.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Ghost step Roman numerals - matches STAGE_INDEX (excluding beginstory which has no breadcrumb)
  const GHOST_STEP_NUMERALS = [
    'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'
  ];

  // STAGE_DISPLAY_NAMES defined earlier â€” used for ghost step display names

  /**
   * Initialize ghost step placeholders in the breadcrumb row
   * Ghost steps match STAGE_INDEX slots (excluding intensity)
   */
  function initGhostSteps() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    // Clear any existing ghost steps
    breadcrumbRow.querySelectorAll('.ghost-step').forEach(g => g.remove());

    // Create ghost step for each STAGE_INDEX entry (except aliases and non-breadcrumb stages)
    const stageEntries = Object.entries(STAGE_INDEX).filter(([grp]) =>
      grp !== 'archetype' && grp !== 'beginstory'
    );
    stageEntries.sort((a, b) => a[1] - b[1]); // Sort by index

    stageEntries.forEach(([grp, idx]) => {
      const ghost = document.createElement('div');
      ghost.className = 'ghost-step';
      ghost.dataset.ghostIndex = idx;
      ghost.dataset.ghostGrp = grp;
      ghost.innerHTML = `
        <span class="ghost-step-label">CHOICE</span>
        <span class="ghost-step-number">${GHOST_STEP_NUMERALS[idx] || idx + 1}</span>
      `;
      breadcrumbRow.appendChild(ghost);
    });

    console.log('[Ghost Steps] Initialized', stageEntries.length, 'ghost step placeholders');
  }

  /**
   * Remove a ghost step when it's replaced by a real breadcrumb
   * @param {number} stepIndex - The corridor stage index being replaced
   */
  function removeGhostStep(stepIndex) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    const ghost = breadcrumbRow.querySelector(`.ghost-step[data-ghost-index="${stepIndex}"]`);
    if (ghost) {
      ghost.classList.add('replacing');
      setTimeout(() => ghost.remove(), 200);
      console.log(`[Ghost Steps] Removed ghost step ${stepIndex + 1}`);
    }
  }

  /**
   * Clear all remaining ghost steps (called on corridor complete)
   */
  function clearAllGhostSteps() {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    breadcrumbRow.querySelectorAll('.ghost-step').forEach(ghost => {
      ghost.classList.add('replacing');
      setTimeout(() => ghost.remove(), 200);
    });
    console.log('[Ghost Steps] Cleared all remaining ghost steps');
  }

  /**
   * Initialize the DOM row store
   * Captures element references and creates insertion anchors for mount/unmount
   * CORRIDOR CONTRACT: Elements will be removed from DOM when not active
   * INIT SAFETY GUARD: Safe to call multiple times - returns early if already populated
   */
  function initCorridorRowStore() {
    // INIT SAFETY GUARD: If store already populated, do not recreate anchors
    if (corridorRowStore.size > 0) {
      console.log('[Corridor] Row store already initialized, skipping anchor creation');
      return;
    }

    CORRIDOR_STAGES.forEach((stage, idx) => {
      const selectors = CORRIDOR_SECTION_SELECTORS[stage];

      // Skip stages with null selectors
      if (!selectors) {
        console.log(`[Corridor] Stage ${stage} has no selectors, skipping store`);
        return;
      }

      const selectorList = selectors.split(',').map(s => s.trim());
      const elements = [];
      const anchors = [];

      selectorList.forEach(selector => {
        const els = document.querySelectorAll(selector);
        els.forEach(el => {
          if (el && el.parentNode) {
            // Tag element with corridor metadata
            el.dataset.corridorStage = stage;
            el.dataset.corridorIndex = idx;
            el.classList.add('corridor-section');

            // Create anchor comment node for re-insertion position
            const anchor = document.createComment(`corridor-anchor:${stage}:${elements.length}`);
            el.parentNode.insertBefore(anchor, el.nextSibling);

            elements.push(el);
            anchors.push(anchor);
          }
        });
      });

      if (elements.length > 0) {
        corridorRowStore.set(stage, { elements, anchors });
        console.log(`[Corridor] Stored ${elements.length} elements for stage: ${stage}`);
      }
    });
  }

  /**
   * Update which corridor row is visible via DOM mount/unmount
   * CORRIDOR CONTRACT ENFORCEMENT:
   *   - INVARIANT 1: Exactly ONE row mounted at any time
   *   - INVARIANT 2: All other rows UNMOUNTED from DOM (not CSS-hidden)
   *   - INVARIANT 3: corridorActiveRowIndex is ONLY source of truth
   */
  function updateCorridorVisibility() {
    let mountedCount = 0;

    CORRIDOR_STAGES.forEach((stage, idx) => {
      const stored = corridorRowStore.get(stage);

      // Skip stages not in store (null selectors)
      if (!stored) return;

      if (idx === corridorActiveRowIndex) {
        // MOUNT: Insert elements back into DOM at anchor positions
        stored.elements.forEach((el, i) => {
          const anchor = stored.anchors[i];
          if (anchor && anchor.parentNode) {
            // Only insert if not already in DOM at correct position
            if (!el.parentNode || el.nextSibling !== anchor) {
              anchor.parentNode.insertBefore(el, anchor);
            }
            // Ensure visible state
            el.classList.remove('corridor-hidden', 'flow-hidden', 'hidden');
            el.classList.add('corridor-active');
            el.style.display = '';
            el.style.visibility = '';
            el.style.opacity = '';
            el.style.pointerEvents = '';
            // Clean up ALL cards from Guided Fate autoplay / breadcrumb animation:
            // - dissipating cards (non-selected, faded via CSS animation forwards)
            // - selected cards (visibility:hidden set by animateCardToBreadcrumb)
            // - dissolving cards (dissolving-to-breadcrumb class with CSS animation)
            el.querySelectorAll('.sb-card').forEach(card => {
              card.classList.remove('dissipating', 'selected', 'flipped', 'dissolving-to-breadcrumb');
              card.style.opacity = '';
              card.style.visibility = '';
              card.style.animation = '';
              card.style.animationFillMode = '';
              card.style.pointerEvents = '';
              card.style.filter = '';
            });
          }
        });
        mountedCount++;

        // Trigger stage-specific mount handlers
        if (stage === 'storybeau' && typeof window.onArchetypeRowMount === 'function') {
            window.onArchetypeRowMount();
        }

        // PRESSURE MOUNT: Init front flavors + re-inject Destiny card if removed during animation
        if (stage === 'pressure') {
            if (typeof window.initPressureFrontFlavors === 'function') window.initPressureFrontFlavors();
            if (!document.getElementById('pressureDestinyChoiceCard') && typeof window.injectPressureDestinyCard === 'function') {
                window.injectPressureDestinyCard();
            }
            // If selected via Destiny, keep all cards face-down (secret)
            if (pressureSelectedViaDestiny) {
                document.querySelectorAll('#pressureGrid .sb-card[data-grp="pressure"]:not(.destiny-choice-card)').forEach(c => {
                    c.classList.remove('selected', 'flipped');
                });
            }
        }

        // DYNAMIC MOUNT: Re-inject Destiny card if removed during animation
        if (stage === 'dynamic') {
            if (!document.getElementById('dynamicDestinyChoiceCard') && typeof window.injectDynamicDestinyCard === 'function') {
                window.injectDynamicDestinyCard();
            }
            if (dynamicSelectedViaDestiny) {
                document.querySelectorAll('#dynamicGrid .sb-card[data-grp="dynamic"]:not(.destiny-choice-card)').forEach(c => {
                    c.classList.remove('selected', 'flipped');
                });
            }
        }

        // IDENTITY MOUNT: Restore mini-deck when navigating back
        if (stage === 'identity') {
          const miniDeck = document.getElementById('destinyMiniDeck');
          if (miniDeck) {
            miniDeck.classList.remove('retracted');
            // Restart sparkles on mini-deck
            if (typeof startSparkleEmitter === 'function') {
              startSparkleEmitter('destinyDeckSparkles', 'destinyDeck', 3);
            }
          }
          // Initialize ancestry rotating placeholders (identity row was unmounted
          // when initFateHandSystem ran, so these were skipped)
          ['ancestryInputPlayer', 'ancestryInputLI'].forEach(id => {
            const ph = document.querySelector(`.rotating-placeholder[data-for="${id}"]`);
            if (ph && !ph.innerHTML.trim() && typeof window.initRotatingPlaceholder === 'function') {
              window.initRotatingPlaceholder(id, 'ancestry');
            }
          });
          console.log('[Corridor] Identity mount: Restored mini-deck');
        }

        // WORLD MOUNT: Fortune's Favor prelude overlay (suppress during Guided Fate autoplay)
        if (stage === 'world' && !_fateAutoplayActive) {
          showFortuneFavorPrelude();
        }

        // LENGTH MOUNT: Re-evaluate length locks (subscription may have changed)
        if (stage === 'length') {
            if (typeof applyLengthLocks === 'function') {
                applyLengthLocks();
                console.log('[Corridor] Length mount: Re-applied length locks');
            }
        }


        // BEGIN STORY MOUNT: Start sparkles around Begin Story button
        if (stage === 'beginstory') {
          if (typeof startSparkleEmitter === 'function') {
            startSparkleEmitter('beginBtnSparkles', 'beginStory', 8);
          }
          console.log('[Corridor] Begin Story mount: Started sparkles');
        }

        // AUTHORSHIP MOUNT: Restore authorship cards when navigating back
        // resetAuthorshipChoice() handles: card visibility, character section, post-arousal section
        if (stage === 'authorship' && typeof window.resetAuthorshipChoice === 'function') {
          window.resetAuthorshipChoice();
          console.log('[Corridor] Authorship mount: Reset authorship choice for re-selection');
        }
      } else {
        // UNMOUNT: Remove elements from DOM (keep references in store)
        stored.elements.forEach(el => {
          if (el.parentNode) {
            el.classList.remove('corridor-active');
            el.classList.add('corridor-hidden');
            el.parentNode.removeChild(el);
          }
        });
      }
    });

    // POST-AROUSAL WRAPPER: Begin Story row lives inside #postArousalSection
    // which starts hidden. Unhide it when the corridor reaches that row.
    const postArousalSection = document.getElementById('postArousalSection');
    if (postArousalSection) {
      if (corridorActiveRowIndex >= STAGE_INDEX.beginstory) {
        postArousalSection.classList.remove('hidden');
      } else {
        postArousalSection.classList.add('hidden');
      }
    }

    // INVARIANT ASSERTION: Exactly one row should be mounted
    if (mountedCount !== 1) {
      console.error(`[CORRIDOR INVARIANT VIOLATION] Expected 1 mounted row, found ${mountedCount}`);
      console.error(`  corridorActiveRowIndex: ${corridorActiveRowIndex}`);
      console.error(`  Active stage: ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
    }

    // Verify DOM state matches expected state
    const mountedInDOM = document.querySelectorAll('.corridor-section.corridor-active');
    if (mountedInDOM.length > 0) {
      const actualStages = new Set();
      mountedInDOM.forEach(el => actualStages.add(el.dataset.corridorStage));
      if (actualStages.size > 1) {
        console.error(`[CORRIDOR INVARIANT VIOLATION] Multiple stages active in DOM:`, Array.from(actualStages));
      }
    }

    // Update stage indicator (no-op, breadcrumbs only)
    updateCorridorStageIndicator();

    // Update navigation arrow visibility based on current position
    if (typeof updateNavigationArrowVisibility === 'function') {
      updateNavigationArrowVisibility();
    }

    console.log(`[Corridor] DOM updated. Mounted row ${corridorActiveRowIndex}: ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
  }

  /**
   * Update corridor stage indicator
   * REMOVED: Breadcrumbs are the ONLY progress indicator
   * This function is now a no-op for backwards compatibility
   */
  function updateCorridorStageIndicator() {
    // Breadcrumbs are the only progress indicator - no dots
  }

  /**
   * Verify corridor contract invariants (for debugging/testing)
   * Call this to assert all invariants are satisfied
   * @returns {boolean} True if all invariants pass
   */
  function verifyCorridorContract() {
    let valid = true;
    const errors = [];

    // INVARIANT 1: Exactly ONE corridor row mounted in DOM
    const mountedSections = document.querySelectorAll('.corridor-section');
    const mountedByStage = new Map();
    mountedSections.forEach(el => {
      const stage = el.dataset.corridorStage;
      if (stage) {
        if (!mountedByStage.has(stage)) mountedByStage.set(stage, 0);
        mountedByStage.set(stage, mountedByStage.get(stage) + 1);
      }
    });

    const mountedStages = Array.from(mountedByStage.keys());
    if (mountedStages.length > 1) {
      errors.push(`INVARIANT 1 VIOLATION: Multiple stages mounted: [${mountedStages.join(', ')}]`);
      valid = false;
    } else if (mountedStages.length === 1) {
      const expectedStage = CORRIDOR_STAGES[corridorActiveRowIndex];
      if (mountedStages[0] !== expectedStage) {
        errors.push(`INVARIANT 3 VIOLATION: Mounted stage (${mountedStages[0]}) != expected (${expectedStage})`);
        valid = false;
      }
    }

    // INVARIANT 2: No CSS-hidden corridor sections (all should be unmounted)
    const hiddenInDOM = document.querySelectorAll('.corridor-section.corridor-hidden');
    if (hiddenInDOM.length > 0) {
      errors.push(`INVARIANT 2 VIOLATION: ${hiddenInDOM.length} sections CSS-hidden instead of unmounted`);
      valid = false;
    }

    // INVARIANT 3: corridorActiveRowIndex consistency
    if (corridorActiveRowIndex < 0 || corridorActiveRowIndex > CORRIDOR_STAGES.length) {
      errors.push(`INVARIANT 3 VIOLATION: corridorActiveRowIndex out of bounds: ${corridorActiveRowIndex}`);
      valid = false;
    }

    // Report results
    if (valid) {
      console.log('[Corridor Contract] All invariants satisfied âœ“');
    } else {
      errors.forEach(err => console.error(`[Corridor Contract] ${err}`));
    }

    return valid;
  }

  // Expose for testing
  window.verifyCorridorContract = verifyCorridorContract;

  /**
   * Get the current stage name
   */
  function getCurrentCorridorStage() {
    return CORRIDOR_STAGES[corridorActiveRowIndex] || null;
  }

  /**
   * Check if current corridor row has a selection
   */
  function hasCorridorSelectionForCurrentRow() {
    const stage = getCurrentCorridorStage();
    if (!stage) return false;

    const grp = CORRIDOR_GRP_MAP[stage];

    // Check if there's a selected card for this group
    const selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"].selected`);
    return !!selectedCard;
  }

  /**
   * Bind click handlers to corridor cards
   */
  function bindCorridorCardHandlers() {
    // For each corridor stage, bind selection handlers
    CORRIDOR_STAGES.forEach((stage, idx) => {
      const grp = CORRIDOR_GRP_MAP[stage];

      // Find all cards for this group
      const cards = document.querySelectorAll(`.sb-card[data-grp="${grp}"]`);
      cards.forEach(card => {
        card.addEventListener('click', () => {
          // Only handle clicks for the active row
          if (idx === corridorActiveRowIndex) {
            handleCorridorCardClick(stage, card);
          }
        });
      });
    });
  }

  /**
   * Handle card click in corridor
   */
  function handleCorridorCardClick(stage, card) {
    const grp = CORRIDOR_GRP_MAP[stage];
    const val = card.dataset.val;

    // Skip if card is locked
    if (card.classList.contains('locked')) {
      return;
    }

    // Update selection state
    corridorSelections.set(stage, {
      grp: grp,
      val: val,
      card: card
    });

    // Update continue button visibility
    updateCorridorContinueButtonVisibility();

    console.log(`[Corridor] Selection: ${stage} = ${val}`);
  }

  /**
   * Bind corridor continue buttons
   * CONTROL PLANE: Single #continueButton dispatches to current active stage
   */
  function bindCorridorContinueButtons() {
    // CONTROL PLANE: Bind the single Continue button to dispatch based on active stage
    const controlPlaneBtn = document.getElementById('continueButton');
    if (controlPlaneBtn) {
      controlPlaneBtn.addEventListener('click', () => {
        const stage = CORRIDOR_STAGES[corridorActiveRowIndex];
        if (stage) {
          console.log(`[Control Plane] Continue clicked for stage: ${stage}`);

          // SPECIAL CASE: Character section (identity stage or during authorship)
          // Dispatch to continueFromCharacters button
          const characterSection = document.getElementById('characterSectionRow');
          if ((stage === 'identity' || stage === 'authorship') && characterSection && !characterSection.classList.contains('hidden')) {
            const charContinueBtn = document.getElementById('continueFromCharacters');
            if (charContinueBtn) {
              console.log('[Control Plane] Dispatching to character section Continue');
              charContinueBtn.click();
              return;
            }
          }

          // AUTHORSHIP: Has a separate animation handler on continueFromAuthorship
          // (bound at module scope when row 0 is in DOM). Dispatch to it.
          if (stage === 'authorship') {
            const authBtn = document.getElementById('continueFromAuthorship');
            if (authBtn) { authBtn.click(); return; }
          }

          // ALL OTHER STAGES: Call handleCorridorContinue directly.
          // Legacy per-row buttons are unmounted at init (only row 0 is in DOM),
          // so bindCorridorContinueButtons never binds handlers to them.
          // Clicking an unbound button does nothing â€” dispatch directly instead.
          handleCorridorContinue(stage);
        }
      });
    }

    // Legacy: Keep per-stage button bindings for any remaining direct handlers
    CORRIDOR_STAGES.forEach((stage) => {
      const buttonIds = [
        `corridorContinue${stage.charAt(0).toUpperCase() + stage.slice(1)}`,
        `continueFrom${stage.charAt(0).toUpperCase() + stage.slice(1)}`
      ];

      buttonIds.forEach(btnId => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.addEventListener('click', () => handleCorridorContinue(stage));
        }
      });
    });
  }

  /**
   * Update continue button visibility for current corridor row
   * CONTROL PLANE: Uses single #continueButton, not per-corridor buttons
   */
  function updateCorridorContinueButtonVisibility() {
    const controlPlaneBtn = document.getElementById('continueButton');
    if (!controlPlaneBtn) return;

    const stage = CORRIDOR_STAGES[corridorActiveRowIndex];
    if (!stage) {
      controlPlaneBtn.classList.remove('visible');
      return;
    }

    const grp = CORRIDOR_GRP_MAP[stage];

    // Check for selection via multiple sources (handles auto-filled selections)
    let hasSelection =
      corridorSelections.has(stage) ||
      (grp === 'length' && !!state.storyLength) ||
      (grp && state.picks && state.picks[grp]) ||
      document.querySelector(`.sb-card[data-grp="${grp}"].selected`);

    // AUTHORSHIP STAGE: Check state.authorship for pending selection
    // Also check if character section is visible (always show Continue when it is)
    if (stage === 'authorship') {
      const characterSection = document.getElementById('characterSectionRow');
      const charSectionVisible = characterSection && !characterSection.classList.contains('hidden');
      hasSelection = !!state.authorship || charSectionVisible;
    }

    // ARCHETYPE STAGE: Check for primary archetype selection OR last-zoomed card
    if (stage === 'storybeau') {
      hasSelection = (state.archetype && state.archetype.primary != null) ||
                     (lastZoomedArchetype != null);
    }

    // These rows always show their button when active (not card-based selection)
    const alwaysShowForRow = (stage === 'authorship' || stage === 'identity');

    controlPlaneBtn.classList.toggle('visible', hasSelection || alwaysShowForRow);
  }

  /**
   * Handle continue from a corridor stage
   * CORRIDOR INTERACTION: Pure state advance, no animation delays
   * a) Finalizes the current row selection
   * b) Advances corridorActiveRowIndex
   * c) Mounts the next corridor row
   */
  function handleCorridorContinue(stage) {
    const stageIdx = CORRIDOR_STAGES.indexOf(stage);
    if (stageIdx !== corridorActiveRowIndex) {
      console.log(`[Corridor] Ignoring continue for non-active stage: ${stage}`);
      return;
    }

    const grp = CORRIDOR_GRP_MAP[stage];

    // Find selection from DOM or state (handles auto-filled selections)
    let selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"].selected`);
    let selectedVal = selectedCard?.dataset.val ||
      (grp === 'length' ? state.storyLength : null) ||
      (grp && state.picks ? state.picks[grp] : null);

    // Special case: Authorship stage â€” breadcrumb created by animateAuthorshipCardToBreadcrumb
    // Only hide button here; corridor advancement handled by custom authorship handler
    if (stage === 'authorship') {
      if (!state.authorship) {
        console.log(`[Corridor] No authorship selection yet`);
        return;
      }
      console.log(`[Corridor] Authorship selected: ${state.authorship} â€” breadcrumb via animation`);
      hideCorridorContinueButton(stage);
      // Do NOT advanceCorridorRow here â€” the custom authorship handler does it
      return;
    }

    // Special case: Storybeau (archetype) â€” Continue selects the last-zoomed card
    if (stage === 'storybeau') {
      // Check for last-zoomed card (from zoom view)
      const zoomedId = lastZoomedArchetype;

      // If no card has been zoomed and no prior selection, pulse Continue and block
      if (!zoomedId && !state.archetype?.primary) {
        console.log(`[Corridor] No archetype zoomed â€” blocking Continue`);
        triggerContinueButtonFeedback('continueFromStorybeau');
        return;
      }

      // Use last-zoomed card if available, otherwise use prior selection
      const archetypeId = zoomedId || state.archetype?.primary;

      // Commit the selection (if not already committed)
      if (state.archetype?.primary !== archetypeId) {
        commitArchetypeSelection(archetypeId, false);
      }

      // Stop the focus sparkle emitter
      if (lastZoomedSparkleEmitterId) {
        stopSparkleEmitter(lastZoomedSparkleEmitterId);
        lastZoomedSparkleEmitterId = null;
      }
      // Remove focus indicator
      const focusedCard = document.querySelector('.archetype-card.last-zoomed');
      if (focusedCard) {
        focusedCard.classList.remove('last-zoomed');
        const sparkleContainer = focusedCard.querySelector('.archetype-focus-sparkles');
        if (sparkleContainer) sparkleContainer.remove();
      }

      console.log(`[Corridor] Archetype committed via Continue: ${archetypeId}`);

      const archetype = ARCHETYPES[archetypeId];
      const archetypeName = archetype?.name || archetypeId;

      hideCorridorContinueButton(stage);

      // If selected via Destiny's Choice, breadcrumb was already created â€” just advance
      if (archetypeSelectedViaDestiny) {
        setTimeout(() => advanceCorridorRow(), 600);
        return;
      }

      // Sparkle teleport from selected card to breadcrumb III
      const selectedCard = document.querySelector(
        `#archetypeCardGrid .archetype-card[data-archetype="${archetypeId}"]`
      );
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const archGhostIdx = STAGE_INDEX['storybeau'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${archGhostIdx}"]`);

      let targetX, targetY;
      if (ghostStep) {
        const ghostRect = ghostStep.getBoundingClientRect();
        targetX = ghostRect.left + ghostRect.width / 2;
        targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
        const brRect = breadcrumbRow.getBoundingClientRect();
        targetX = brRect.left + brRect.width / 2;
        targetY = brRect.top + brRect.height / 2;
      }

      if (selectedCard && targetX !== undefined) {
        const cardRect = selectedCard.getBoundingClientRect();
        const cardCenterX = cardRect.left + cardRect.width / 2;
        const cardCenterY = cardRect.top + cardRect.height / 2;

        // Phase 1: Dissolution sparkles + fade card
        selectedCard.style.opacity = '0.3';
        const dissolutionCount = 12 + Math.floor(Math.random() * 5);
        for (let i = 0; i < dissolutionCount; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'dissolution-sparkle';
            const sx = cardRect.left + Math.random() * cardRect.width;
            const sy = cardRect.top + Math.random() * cardRect.height;
            sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 400);
          }, i * 25);
        }

        // Phase 2: Sparkle travel to breadcrumb target
        setTimeout(() => {
          const travelCount = 6 + Math.floor(Math.random() * 3);
          for (let i = 0; i < travelCount; i++) {
            setTimeout(() => {
              const sparkle = document.createElement('div');
              sparkle.className = 'traveling-sparkle';
              const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
              const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
              const sx = cardCenterX + offX;
              const sy = cardCenterY + offY;
              const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
              const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
              sparkle.style.cssText = `
                left: ${sx}px; top: ${sy}px;
                --target-x: ${targetX - sx}px;
                --target-y: ${targetY - sy}px;
                --arc-x: ${midX - sx}px;
                --arc-y: ${midY - sy}px;
              `;
              document.body.appendChild(sparkle);
              setTimeout(() => sparkle.remove(), 600);
            }, i * 40);
          }
        }, 200);

        // Phase 3: Convergence sparkles + breadcrumb + advance
        setTimeout(() => {
          for (let i = 0; i < 5; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'convergence-sparkle';
            const angle = (Math.PI * 2 * i) / 5;
            const dist = 15 + Math.random() * 10;
            sparkle.style.cssText = `
              left: ${targetX + Math.cos(angle) * dist}px;
              top: ${targetY + Math.sin(angle) * dist}px;
            `;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 500);
          }

          selectedCard.style.opacity = '';
          createArchetypeBreadcrumbWithMask(archetypeId, false);

          // Advance after materializing animation
          setTimeout(() => advanceCorridorRow(), 600);
        }, 600);

      } else {
        // Fallback: no animation
        createArchetypeBreadcrumbWithMask(archetypeId, false);
        setTimeout(() => advanceCorridorRow(), 600);
      }
      return;
    }

    // Special case: Begin Story â€” terminal row, dispatch to handler directly
    if (stage === 'beginstory') {
      console.log(`[Corridor] Begin Story row â€” dispatching to handleBeginStory`);
      if (typeof handleBeginStory === 'function') handleBeginStory();
      return;
    }

    if (!selectedVal) {
      console.log(`[Corridor] No selection for stage: ${stage}`);
      return;
    }

    console.log(`[Corridor] Continuing from ${stage}: ${selectedVal}`);

    // Record selection in corridorSelections (corridor card click handlers may not be bound
    // for unmounted rows, so set it here as the authoritative commit point)
    corridorSelections.set(stage, { grp, val: selectedVal, card: selectedCard });

    // Hide continue button immediately
    hideCorridorContinueButton(stage);

    // Stop sparkles on the selected card before advancing
    if (selectedCard) {
      const sparkleContainer = selectedCard.querySelector('.card-selection-sparkles');
      if (sparkleContainer && typeof stopSparkleEmitter === 'function') {
        stopSparkleEmitter(sparkleContainer.id);
      }
    }

    // Create breadcrumb for this selection
    if (selectedCard) {
      const titleEl = selectedCard.querySelector('.sb-card-title');
      const selectedTitle = titleEl ? titleEl.textContent : selectedVal;
      createBreadcrumbDirect(grp, selectedVal, selectedTitle);
    }

    // Advance after breadcrumb materializes so user sees it land
    setTimeout(() => advanceCorridorRow(), 600);
  }

  /**
   * Hide the continue button (control plane)
   */
  function hideCorridorContinueButton(stage) {
    const controlPlaneBtn = document.getElementById('continueButton');
    if (controlPlaneBtn) controlPlaneBtn.classList.remove('visible');
  }

  /**
   * Scale breadcrumb title font if text is too long
   * Never clip, truncate, or ellipsize â€” scale font down instead
   * @param {HTMLElement} breadcrumb - The breadcrumb card element
   */
  function scaleBreadcrumbTitle(breadcrumb) {
    const titleEl = breadcrumb.querySelector('.sb-card-title');
    if (!titleEl) return;

    const text = (titleEl.textContent || '').trim();
    if (!text) return;

    // Find the longest word â€” that's the minimum width we must fit
    const words = text.split(/\s+/);
    const cardWidth = breadcrumb.offsetWidth || 45; // fallback to CSS width
    const availWidth = cardWidth - 4; // subtract padding (0 2px each side)

    // Use a canvas to measure text width at a given font size
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontFamily = "'Cinzel', 'Lora', serif";

    function longestWordWidth(size) {
      ctx.font = `700 ${size}px ${fontFamily}`;
      let maxW = 0;
      for (const w of words) {
        const m = ctx.measureText(w).width;
        if (m > maxW) maxW = m;
      }
      return maxW;
    }

    // Start at base size, scale down until the longest word fits
    let fontSize = 7;
    const minSize = 3;
    while (fontSize > minSize && longestWordWidth(fontSize) > availWidth) {
      fontSize -= 0.5;
    }

    titleEl.style.fontSize = `${fontSize}px`;
    titleEl.style.lineHeight = '1.3';
  }

  /**
   * Create a breadcrumb directly without animation
   * CORRIDOR INTERACTION: Pure state, no delays
   * GHOST STEP: Replaces corresponding ghost step placeholder
   */
  function createBreadcrumbDirect(grp, val, title) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    // Check if breadcrumb should be excluded (these stages don't become breadcrumbs)
    if (grp === 'beginstory') {
      console.log(`[Breadcrumb] EXCLUDED: ${grp} â€” never becomes breadcrumb`);
      // Still remove the ghost step for this stage (if any)
      const ghostIdx = STAGE_INDEX[grp];
      if (ghostIdx !== undefined && ghostIdx >= 0) removeGhostStep(ghostIdx);
      return;
    }

    // AUTHORITATIVE: Use STAGE_INDEX for fixed corridor index
    // No positional inference, no fallbacks, no "next available slot" logic
    const stageIdx = STAGE_INDEX[grp];
    if (stageIdx === undefined) {
      console.warn(`[Breadcrumb] Unknown grp: ${grp} â€” not in STAGE_INDEX`);
      return;
    }

    // Remove existing breadcrumb for this stage (prevents duplicates on re-navigation)
    const existingCard = breadcrumbRow.querySelector(`.breadcrumb-card[data-grp="${grp}"]`);
    if (existingCard) existingCard.remove();

    // Get structured label
    const label = typeof getBreadcrumbLabel === 'function'
      ? getBreadcrumbLabel(grp, val)
      : { title: title || val, subtitle: null };

    const subtitleHtml = label.subtitle
      ? `<span class="breadcrumb-subtitle">${label.subtitle}</span>`
      : '';

    // Create breadcrumb card
    const breadcrumb = document.createElement('div');
    breadcrumb.className = 'breadcrumb-card materializing';
    breadcrumb.dataset.grp = grp;
    breadcrumb.dataset.val = val;
    breadcrumb.dataset.stageIndex = stageIdx;
    breadcrumb.dataset.breadcrumbLabel = grp.charAt(0).toUpperCase() + grp.slice(1);
    breadcrumb.innerHTML = `
      <div class="sb-card-inner">
        <div class="sb-card-face sb-card-back">
          <span class="sb-card-title">${label.title}</span>
          ${subtitleHtml}
        </div>
        <div class="sb-card-face sb-card-front">
          <span class="sb-card-title">${label.title}</span>
          ${subtitleHtml}
        </div>
      </div>
    `;

    // Insert breadcrumb at correct position based on stage index
    // Find the first breadcrumb or ghost step with a HIGHER stage index
    const allSlots = breadcrumbRow.querySelectorAll('.breadcrumb-card, .ghost-step');
    let insertBefore = null;
    for (const slot of allSlots) {
      const slotIdx = parseInt(slot.dataset.stageIndex ?? slot.dataset.ghostIndex, 10);
      if (!isNaN(slotIdx) && slotIdx > stageIdx) {
        insertBefore = slot;
        break;
      }
    }
    if (insertBefore) {
      breadcrumbRow.insertBefore(breadcrumb, insertBefore);
    } else {
      breadcrumbRow.appendChild(breadcrumb);
    }

    // Scale font for long titles (never clip/truncate)
    scaleBreadcrumbTitle(breadcrumb);

    // Remove the corresponding ghost step
    if (stageIdx >= 0) {
      removeGhostStep(stageIdx);
    }

    // Remove materializing class after animation completes
    setTimeout(() => breadcrumb.classList.remove('materializing'), 400);

    // Attach destructive navigation handler
    if (typeof attachBreadcrumbNavigation === 'function') {
      attachBreadcrumbNavigation(breadcrumb);
    }

    // Sparkles on the active (most recent) breadcrumb
    updateActiveBreadcrumbSparkles(breadcrumb);

    console.log(`[Breadcrumb] Created: ${grp}=${val} (replaces ghost step ${stageIdx + 1})`);
  }

  /**
   * Move sparkles to the most recently created breadcrumb
   * Removes sparkles from any previous breadcrumb, adds to the new one
   */
  function updateActiveBreadcrumbSparkles(newBreadcrumb) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!breadcrumbRow) return;

    // Stop and remove sparkles from all breadcrumbs
    breadcrumbRow.querySelectorAll('.breadcrumb-card .breadcrumb-active-sparkles').forEach(container => {
      if (typeof stopSparkleEmitter === 'function') {
        stopSparkleEmitter(container.id);
      }
      container.remove();
    });

    if (!newBreadcrumb) return;

    // Add sparkle container to the new breadcrumb
    const sparkleContainer = document.createElement('div');
    sparkleContainer.className = 'breadcrumb-active-sparkles';
    sparkleContainer.id = `breadcrumbSparkle_${newBreadcrumb.dataset.grp}_${Date.now()}`;
    newBreadcrumb.appendChild(sparkleContainer);

    if (typeof startSparkleEmitter === 'function') {
      startSparkleEmitter(sparkleContainer.id, 'chooseHand', 2);
    }
  }

  /**
   * Advance to the next corridor row
   */
  function advanceCorridorRow() {
    corridorActiveRowIndex++;

    if (corridorActiveRowIndex < CORRIDOR_STAGES.length) {
      console.log(`[Corridor] Advancing to row ${corridorActiveRowIndex}: ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
      updateCorridorVisibility();
      updateCorridorContinueButtonVisibility();
      // DSP VISIBILITY GATE: Show DSP only after World is committed (index >= 3)
      // Authorship=0, Archetype=1, World=2 â†’ DSP hidden
      // Tone=3 and beyond â†’ DSP visible
      updateDSPCorridorVisibility();
    } else {
      console.log('[Corridor] All rows complete. Flow finished.');
      onCorridorComplete();
    }
  }

  /**
   * DSP VISIBILITY GATE â€” DSP only visible during World, Tone, Pressure, POV, Length
   * Hidden before World and after Length (Dynamic, Arousal, Safety, etc.)
   */
  function updateDSPCorridorVisibility() {
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (!synopsisPanel) return;

    // DSP visible ONLY during these stages:
    // 3=world, 4=tone, 5=pressure, 6=pov, 7=length
    // Hidden during: 0=authorship, 1=identity, 2=storybeau, 8=dynamic, 9=arousal, 10+=safety/beginstory
    const DSP_START_INDEX = 3;  // World
    const DSP_END_INDEX = 7;    // Length

    if (corridorActiveRowIndex >= DSP_START_INDEX && corridorActiveRowIndex <= DSP_END_INDEX) {
      showDSP(); // Populates content AND adds .visible
      console.log(`[DSP] Visible â€” stage ${CORRIDOR_STAGES[corridorActiveRowIndex]}`);
    } else {
      hideDSP(); // Removes .visible
      console.log(`[DSP] Hidden â€” stage ${CORRIDOR_STAGES[corridorActiveRowIndex] || corridorActiveRowIndex}`);
    }
  }

  /**
   * Called when all corridor rows are complete
   */
  function onCorridorComplete() {
    console.log('[Corridor] Corridor complete. Proceeding to Safety/Begin Story.');

    // Clear any remaining ghost steps
    clearAllGhostSteps();

    // Show the post-arousal sections (Safety, Begin Story)
    // These are now wrapped in a single container that starts hidden
    const postArousalSection = document.getElementById('postArousalSection');
    if (postArousalSection) {
      postArousalSection.classList.remove('hidden');
      console.log('[Corridor] Post-arousal sections revealed');
    }

    // Legacy element references (for backward compatibility)
    const safetySection = document.getElementById('safetySection');
    const beginSection = document.getElementById('beginStorySection');
    if (safetySection) safetySection.classList.remove('hidden');
    if (beginSection) beginSection.classList.remove('hidden');

    // DSP: Fade out after corridor completion (AUTHORITATIVE)
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      synopsisPanel.classList.add('corridor-complete');
      console.log('[Corridor] DSP faded out after corridor completion');
    }

    // VIEWPORT ISOLATION: Exit corridor mode, allow scrolling to final sections
    document.body.classList.remove('corridor-mode');
    document.body.classList.add('corridor-complete');
  }

  /**
   * Reset corridor to initial state
   * Uses corridorRowStore to reset cards (may be unmounted from DOM)
   */
  function resetCorridor() {
    corridorActiveRowIndex = 0;
    corridorSelections.clear();

    // VIEWPORT ISOLATION: Re-enter corridor mode on reset
    document.body.classList.add('corridor-mode');
    document.body.classList.remove('corridor-complete');

    // Reset authorship choice (Choose Your Hand / Guided Fate cards)
    if (typeof window.resetAuthorshipChoice === 'function') {
      window.resetAuthorshipChoice();
    }

    // Clear breadcrumb row
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (breadcrumbRow) breadcrumbRow.innerHTML = '';

    // Reinitialize ghost steps for fresh corridor
    initGhostSteps();

    // Reset all corridor rows using stored element references
    // This works even when elements are unmounted from DOM
    corridorRowStore.forEach((stored, stage) => {
      stored.elements.forEach(el => {
        // Reset card visibility and state within this element
        el.querySelectorAll('.sb-card').forEach(card => {
          card.style.visibility = '';
          card.style.opacity = '';
          card.classList.remove('dissipating', 'selected', 'flipped', 'becoming-breadcrumb');
        });
      });
    });

    // Reset corridor visibility via DOM mount/unmount
    updateCorridorVisibility();
    updateCorridorContinueButtonVisibility();

    // DSP VISIBILITY GATE: Hide DSP on reset (corridor back to row 0)
    updateDSPCorridorVisibility();

    // Restore DSP visibility state (remove corridor-complete class)
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      synopsisPanel.classList.remove('corridor-complete');
    }

    // Clear state picks
    state.picks = state.picks || {};
    state.picks.pressure = null;
    state.picks.world = null;
    state.picks.tone = null;
    state.picks.dynamic = null;
    state.picks.pov = null;
    state.picks.length = null;
    state.picks.intensity = null;
    state.picks.archetype = null;

    console.log('[Corridor] Reset complete. Active row:', corridorActiveRowIndex);
  }

  /**
   * Autoplay corridor row-by-row when Guided Fate is selected
   * Each row appears, card is selected, animates to breadcrumb, others dissolve, advance
   */
  async function autoplayCorridorFromGuidedFate() {
    console.log('[Corridor] Starting row-by-row autoplay from Guided Fate');
    _fateAutoplayActive = true;

    // Start from row 1 (Guided Fate is row 0, already handled)
    // Advance past row 0 first
    corridorActiveRowIndex = 1;
    updateCorridorVisibility();

    // Autoplay timing (ms)
    const ROW_SHOW_DELAY = 400;      // Time to show row before selecting
    const BREADCRUMB_DELAY = 700;    // Time for breadcrumb animation
    const DISSIPATE_DELAY = 500;     // Time for card dissipation
    const INTER_ROW_DELAY = 200;     // Pause between rows

    // Helper: resolve the fate-chosen value for a stage from pre-set state
    function getFateValueForStage(stg, g) {
      if (stg === 'storybeau') return state.archetype?.primary || null;
      if (g === 'length') return state.storyLength || null;
      if (g === 'intensity') return state.intensity || null;
      if (g && state.picks) return state.picks[g] || null;
      return null;
    }

    // Process rows 1 through end
    for (let rowIdx = 1; rowIdx < CORRIDOR_STAGES.length; rowIdx++) {
      const stage = CORRIDOR_STAGES[rowIdx];
      const grp = CORRIDOR_GRP_MAP[stage];

      // Skip non-card rows (beginstory has no selectable cards)
      if (stage === 'beginstory') {
        corridorActiveRowIndex = rowIdx;
        updateCorridorVisibility();
        await new Promise(r => setTimeout(r, 100));
        console.log(`[Corridor] Autoplay skipped non-card row ${rowIdx}: ${stage}`);
        continue;
      }

      // Update active row â€” MOUNTS the row into DOM
      corridorActiveRowIndex = rowIdx;
      updateCorridorVisibility();

      // Identity row: fill character names + set dropdowns, create breadcrumb, advance
      if (stage === 'identity') {
        await new Promise(r => setTimeout(r, ROW_SHOW_DELAY));
        // Set dropdowns now that they're mounted
        const pgEl = $('playerGender'); if (pgEl) pgEl.value = state.gender || 'Female';
        const ppEl = $('playerPronouns'); if (ppEl) ppEl.value = 'She/Her';
        const lgEl = $('loveInterestGender'); if (lgEl) lgEl.value = state.loveInterest || 'Male';
        const lpEl = $('lovePronouns'); if (lpEl) lpEl.value = 'He/Him';
        // Fill character name inputs
        const mcInput = $('playerNameInput');
        const liInput = $('partnerNameInput');
        if (mcInput && state.normalizedPlayerKernel) mcInput.value = state.normalizedPlayerKernel;
        if (liInput && state.normalizedPartnerKernel) liInput.value = state.normalizedPartnerKernel;

        // Persist identity state (mirrors continueFromCharacters handler)
        const canonicalPlayerName = mcInput?.value?.trim() || 'Protagonist';
        const canonicalPartnerName = liInput?.value?.trim() || 'Love Interest';
        const displayPlayerName = typeof deriveDisplayName === 'function' ? deriveDisplayName(canonicalPlayerName) : canonicalPlayerName;
        const displayPartnerName = typeof deriveDisplayName === 'function' ? deriveDisplayName(canonicalPartnerName) : canonicalPartnerName;
        state.picks = state.picks || {};
        state.picks.identity = {
          playerName: canonicalPlayerName,
          partnerName: canonicalPartnerName,
          displayPlayerName: displayPlayerName,
          displayPartnerName: displayPartnerName
        };

        // Mark identity as resolved and create breadcrumb
        corridorSelections.set('identity', { grp: 'identity', val: 'names' });
        if (typeof createBreadcrumbDirect === 'function') {
          createBreadcrumbDirect('identity', 'names', displayPlayerName);
        }

        // Retract mini-deck
        const miniDeck = $('destinyMiniDeck');
        if (miniDeck) miniDeck.classList.add('retracted');

        console.log(`[Corridor] Autoplay completed row ${rowIdx}: ${stage} (identity)`);
        await new Promise(r => setTimeout(r, INTER_ROW_DELAY));
        continue;
      }

      // Brief pause to show the row
      await new Promise(r => setTimeout(r, ROW_SHOW_DELAY));

      // Find the selected card â€” or select from state if not pre-selected
      let selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"].selected`);

      // Cards may not be pre-selected (corridor unmount prevented runGuidedFateFill
      // from reaching grids). Use state values to select the correct card now.
      if (!selectedCard) {
        const stateVal = getFateValueForStage(stage, grp);
        if (stateVal) {
          // Archetype cards use different selector
          if (stage === 'storybeau') {
            selectedCard = document.querySelector(`.archetype-card[data-archetype="${stateVal}"]`);
          } else {
            selectedCard = document.querySelector(`.sb-card[data-grp="${grp}"][data-val="${stateVal}"]`);
          }
          if (selectedCard) {
            selectedCard.classList.add('selected', 'flipped');
          }
        }
      }

      if (selectedCard) {
        const selectedVal = selectedCard.dataset.val || selectedCard.dataset.archetype;
        const titleEl = selectedCard.querySelector('.sb-card-title');
        const selectedTitle = titleEl ? titleEl.textContent : selectedVal;

        // Store in corridor selections
        corridorSelections.set(stage, {
          grp: grp,
          val: selectedVal,
          card: selectedCard
        });

        // Get parent row for card dissipation
        // Use .dynamic-grouped first (dynamic row has multiple .sb-grid sub-groups)
        const parentRow = selectedCard.closest('.dynamic-grouped, .card-flow-row, .corridor-row, .sb-grid');

        // Archetype stage: use Destiny's Choice mask breadcrumb (don't reveal LI archetype)
        if (stage === 'storybeau') {
          createArchetypeBreadcrumbWithMask(selectedVal, true);
          await new Promise(r => setTimeout(r, BREADCRUMB_DELAY));
        } else {
          // Animate selected card to breadcrumb
          await new Promise(resolve => {
            animateCardToBreadcrumb(selectedCard, grp, selectedVal, selectedTitle, resolve);
          });

          // Wait for breadcrumb animation
          await new Promise(r => setTimeout(r, BREADCRUMB_DELAY));
        }

        // Dissipate other cards
        if (parentRow) {
          const otherCards = parentRow.querySelectorAll(`.sb-card[data-grp="${grp}"]:not(.selected)`);
          if (otherCards.length > 0) {
            await new Promise(resolve => {
              dissipateCards(otherCards, resolve);
            });
            await new Promise(r => setTimeout(r, DISSIPATE_DELAY));
          }
        }

        // Inter-row pause
        await new Promise(r => setTimeout(r, INTER_ROW_DELAY));
      }

      console.log(`[Corridor] Autoplay completed row ${rowIdx}: ${stage}`);
    }

    // All rows complete
    corridorActiveRowIndex = CORRIDOR_STAGES.length;
    console.log('[Corridor] Autoplay complete. All rows processed.');
    _fateAutoplayActive = false;
    onCorridorComplete();
  }

  // Legacy alias for backwards compatibility
  function completeCorridorFromGuidedFate() {
    autoplayCorridorFromGuidedFate();
  }

  // Expose corridor functions globally
  window.initCorridor = initCorridor;
  window.resetCorridor = resetCorridor;
  window.advanceCorridorRow = advanceCorridorRow;
  window._corridorRowStore = corridorRowStore;
  window.autoplayCorridorFromGuidedFate = autoplayCorridorFromGuidedFate;
  window.completeCorridorFromGuidedFate = completeCorridorFromGuidedFate; // Legacy alias
  window.updateDSPCorridorVisibility = updateDSPCorridorVisibility;
  window.updateCorridorContinueButtonVisibility = updateCorridorContinueButtonVisibility;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SYNOPSIS PANEL - Live-updating story preview based on 4-axis selections
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  // â•‘                    LOCKED DESIGN RULES                            â•‘
  // â•‘                                                                   â•‘
  // â•‘ 1. The floating synopsis panel must remain visually restrained   â•‘
  // â•‘    and literary. No glassmorphism, glow effects, or color-coded  â•‘
  // â•‘    highlighting. It should feel like an authorial whisper.       â•‘
  // â•‘                                                                   â•‘
  // â•‘ 2. Genres must describe narrative action or fantasy, not setting â•‘
  // â•‘    or life stage. "Sports", "College", "Small Town" are not      â•‘
  // â•‘    genresâ€”they are world modifiers.                              â•‘
  // â•‘                                                                   â•‘
  // â•‘ 3. Relationship Dynamics are single-select and represent         â•‘
  // â•‘    emotional structure, not identity. They describe how          â•‘
  // â•‘    characters relate, not who they are.                          â•‘
  // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP FIXED TEMPLATE â€” ASSEMBLED, NOT AUTHORED
  // Two-sentence ceremonial template with locked phrase injection.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP WORLD PHRASES â€” LOCKED CANON (DO NOT MODIFY)
  // Used as: "In [world] â€¦"
  // Supernatural is a Modern subtype, not a standalone world.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const DSP_WORLD_PHRASES = {
    Modern: 'a modern world of ambition and things left unsaid',
    Historical: 'an era of duty, reputation, and unyielding tradition',
    Fantasy: 'a realm of oaths, myth, and old magic',
    SciFi: 'an age of technological acceleration and alien laws',
    Dystopia: 'a world of surveillance, rationed freedom, and enforced order',
    PostApocalyptic: 'a broken world of scarcity, ruins, and hard bargains'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //                    GENRE REGIME: NESTED PRESSURE MODEL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // PHILOSOPHY:
  // Genres are PRESSURE ENGINES, not bookshelf categories.
  // They shape pacing, tension, romantic cost, and consequence timing.
  // Worlds are aesthetic lenses. Tone controls narration style.
  //
  // HIERARCHY:
  // Primary Pressure (required) â†’ Flavor (optional)
  // User sees â‰¤8 pressures, then optionally 3-5 flavors.
  //
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // VISIBLE PULLS â€” The 4 selectable Story Pull cards (hidden pulls become undercurrent modifiers)
  const VISIBLE_PULLS = new Set(['PowerControl', 'EscapePursuit', 'DesireObsession', 'Survival']);

  // PRIMARY PRESSURES â€” THE ONLY TOP-LEVEL CHOICES (max 8)
  const PRIMARY_PRESSURES = {
    PowerControl: {
      id: 'PowerControl',
      label: 'Power & Control',
      description: 'Someone has leverage. Someone else pays for it.',
      dspPhrase: 'power, leverage, and the cost of control'
    },
    RiskExposure: {
      id: 'RiskExposure',
      label: 'Risk & Exposure',
      description: 'Being seen, known, caught, or revealed is dangerous.',
      dspPhrase: 'secrets, exposure, and the danger of being known'
    },
    EscapePursuit: {
      id: 'EscapePursuit',
      label: 'Escape & Pursuit',
      description: 'Leaving, rescuing, or outrunning something.',
      dspPhrase: 'locked doors, narrow windows, and the clock'
    },
    ObligationBurden: {
      id: 'ObligationBurden',
      label: 'Obligation & Burden',
      description: 'Duty, destiny, or expectation presses inward.',
      dspPhrase: 'duty, expectation, and the weight of what must be'
    },
    DesireObsession: {
      id: 'DesireObsession',
      label: 'Desire & Obsession',
      description: 'Wanting something too much, too soon, or for the wrong reasons.',
      dspPhrase: 'fixation, escalation, and loss of control'
    },
    ReckoningPast: {
      id: 'ReckoningPast',
      label: 'Reckoning & Past',
      description: 'History, guilt, or unfinished business intrudes.',
      dspPhrase: 'old debts, buried identities, and consequences that refuse to stay buried'
    },
    Transformation: {
      id: 'Transformation',
      label: 'Transformation',
      description: 'Someone is becoming something they didn\'t plan to be.',
      dspPhrase: 'becoming, unraveling, and the stranger in the mirror'
    },
    Survival: {
      id: 'Survival',
      label: 'Survival',
      description: 'Immediate physical danger forces dependence and proximity.',
      dspPhrase: 'danger, dependence, and desperate proximity'
    }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TONAL FRACTURE â€” LLM prompt injection (never shown in UI, 10% probability)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const TONAL_FRACTURES = {
    Earnest:       'Doubt hums beneath devotion.',
    WryConfession: 'Sincerity breaks through the irony.',
    Satirical:     'Genuine ache surfaces under the mockery.',
    Dark:          'Protectiveness softens the cruelty.',
    Horror:        'Fleeting tenderness interrupts the dread.',
    Mythic:        'Grandeur is shadowed by quiet melancholy.',
    Comedic:       'A real wound flickers behind the laughter.',
    Surreal:       'Clarity pierces the dream for one breath.',
    Poetic:        'Bluntness cuts through the lyricism.'
  };

  /**
   * Build Tonal Fracture injection for LLM system prompt.
   * 10% probability. Returns empty string or single fracture line.
   */
  function buildTonalFracture(tone) {
    if (!tone || !TONAL_FRACTURES[tone]) return '';
    if (Math.random() >= 0.10) return '';
    return `\nTone Fracture: ${TONAL_FRACTURES[tone]}`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STORY PULL GRAVITY â€” LLM prompt injection (never shown in UI)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const PULL_GRAVITY = {
    PowerControl:      { axis: 'Power & Control',      gravity: 'Intimacy shifts leverage between characters.' },
    RiskExposure:      { axis: 'Risk & Exposure',      gravity: 'Being revealed carries consequence.' },
    EscapePursuit:     { axis: 'Escape & Pursuit',     gravity: 'Movement and urgency drive the connection.' },
    ObligationBurden:  { axis: 'Obligation & Burden',  gravity: 'Duty presses against desire.' },
    DesireObsession:   { axis: 'Desire & Obsession',   gravity: 'Wanting destabilizes reason and restraint.' },
    ReckoningPast:     { axis: 'Reckoning & Past',     gravity: 'History intrudes and demands response.' },
    Transformation:    { axis: 'Becoming',             gravity: 'Identity changes under emotional pressure.' },
    Survival:          { axis: 'Survival',             gravity: 'Immediate physical danger forces dependence and proximity.\nScope: Threat is situational and localized. Stakes are personal and present (terrain, injury, war zone, disease, disaster). The world is not ending unless Apocalypse is injected.\nIntimacy emerges through bodily reliance: heat, wounds, guarding, rationing, coordinated survival.\nForbidden: No global extinction framing by default. No cosmic finality language. No abstract "social survival" without physical danger.\nCore engine: Staying alive sharpens or accelerates intimacy.' }
  };

  const HIDDEN_MODIFIER_ALLOWED = {
    PowerControl:    ['ObligationBurden', 'Transformation', 'ReckoningPast', 'RiskExposure'],
    EscapePursuit:   ['RiskExposure', 'ReckoningPast', 'ObligationBurden'],
    DesireObsession: ['RiskExposure', 'Transformation', 'ReckoningPast'],
    Survival:        ['ObligationBurden', 'ReckoningPast', 'RiskExposure']
  };

  /**
   * Build Story Pull injection block for LLM system prompt.
   * Returns empty string if no pressure selected or not a visible pull.
   * 25% chance of one hidden modifier from curated compatibility matrix.
   * Suppressed when tonal fracture active AND circumstance card selected
   * (conservative pre-check for polarity Constraint + Attachment stacking).
   */
  function buildStoryPullBlock(tonalFractureStr) {
    const pressure = state.picks?.pressure;
    if (!pressure || !VISIBLE_PULLS.has(pressure) || !PULL_GRAVITY[pressure]) return '';

    const primary = PULL_GRAVITY[pressure];
    let block = `\nStory Pull: ${primary.axis}\nPull Gravity: ${primary.gravity}`;

    // 25% chance of hidden modifier
    // Petition probability tilt applied here â€” boosts hidden modifier trigger
    const _pullTilt = state._strategyPass?.petition?.probability_tilt || 0;
    if (Math.random() < (0.25 + _pullTilt * 0.15)) {
      // Suppress if fracture active AND circumstance card selected (stacking guard)
      const fractureActive = tonalFractureStr && tonalFractureStr.trim().length > 0;
      const circumstanceSelected = CIRCUMSTANCE_CARDS.has(state.picks?.dynamic);
      if (!(fractureActive && circumstanceSelected)) {
        const candidates = HIDDEN_MODIFIER_ALLOWED[pressure];
        if (candidates && candidates.length > 0) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          const undercurrent = PULL_GRAVITY[pick];
          if (undercurrent) {
            block += `\nUndercurrent: ${undercurrent.gravity}`;
          }
        }
      }
    }

    // Hidden Apocalypse flavor â€” Survival only, ~10% chance, rare escalation override
    if (pressure === 'Survival' && Math.random() < 0.10) {
      block += '\nHidden Flavor: Apocalypse â€” Global framing UNLOCKED. Civilization-level collapse permitted (bombs, plague, flood, famine). End-of-era tone allowed. Coexists with selected Survival flavor.';
    } else if (pressure === 'Survival') {
      // Safeguard: when Apocalypse is NOT injected, enforce localized framing
      block += '\nSafeguard: Apocalypse not active â€” Survival must remain localized. No global collapse, no extinction-level framing, no civilization-ending scope.';
    }

    return block;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POLARITY SYSTEM â€” Emotional Arc + Circumstance + Hidden Intensity Modifier
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const EMOTIONAL_ARCS = new Set(['Friends', 'Enemies', 'SecondChance', 'Forbidden']);
  const CIRCUMSTANCE_CARDS = new Set(['Proximity', 'SecretIdentity']);

  const POLARITY_DIRECTIVES = {
    Friends:      'Safety slowly becomes desire.',
    Enemies:      'Conflict masks attraction.',
    SecondChance: 'Past intimacy complicates reunion.',
    Forbidden:    'Desire defies external rule.'
  };

  const CIRCUMSTANCE_DIRECTIVES = {
    Proximity:      'Circumstance traps them together.',
    SecretIdentity: 'Hidden truth threatens connection.'
  };

  // Auto-resolution when only a Circumstance card is selected
  const CIRCUMSTANCE_AUTO_RESOLVE = {
    Proximity: [
      { arc: 'Enemies',      weight: 30 },
      { arc: 'Friends',      weight: 30 },
      { arc: 'Forbidden',    weight: 20 },
      { arc: 'SecondChance', weight: 20 }
    ],
    SecretIdentity: [
      { arc: 'Forbidden',    weight: 35 },
      { arc: 'Enemies',      weight: 25 },
      { arc: 'SecondChance', weight: 20 },
      { arc: 'Friends',      weight: 20 }
    ]
  };

  // Hidden intensity modifier â€” per-arc distributions (probabilities out of 100)
  const INTENSITY_MODIFIERS = {
    Friends:      [{ id: 'Risk', weight: 10 }, { id: 'Loyalty', weight: 5 }, { id: 'Obsessive', weight: 5 }],
    Enemies:      [{ id: 'Risk', weight: 20 }, { id: 'Obsessive', weight: 15 }, { id: 'Loyalty', weight: 10 }],
    SecondChance: [{ id: 'Obsessive', weight: 15 }, { id: 'Risk', weight: 10 }, { id: 'Loyalty', weight: 5 }],
    Forbidden:    [{ id: 'Risk', weight: 20 }, { id: 'Obsessive', weight: 15 }, { id: 'Loyalty', weight: 5 }]
  };

  const INTENSITY_DIRECTIVE = {
    Risk:      'Risk heightens desire.',
    Obsessive: 'Attachment becomes consuming.',
    Loyalty:   'Loyalty isolates them from others.'
  };

  function weightedPick(entries) {
    const total = entries.reduce((s, e) => s + e.weight, 0);
    let r = Math.random() * total;
    for (const e of entries) {
      r -= e.weight;
      if (r <= 0) return e;
    }
    return entries[entries.length - 1];
  }

  /**
   * Build Polarity injection block for LLM system prompt.
   * Replaces the old single `- Dynamic: [value]` line.
   * Max 3 lines: Polarity + Relational Engine, optional Constraint, optional Attachment Modifier.
   *
   * @param {string} tonalFractureStr â€” result of buildTonalFracture() (empty or "\nTone Fracture: ...")
   * @param {string} pullBlockStr â€” result of buildStoryPullBlock() (empty or "\nStory Pull: ...")
   */
  function buildPolarityBlock(tonalFractureStr, pullBlockStr) {
    const dynamic = state.picks?.dynamic;
    let emotionalArc = null;
    let circumstance = null;

    if (dynamic && EMOTIONAL_ARCS.has(dynamic)) {
      emotionalArc = dynamic;
    } else if (dynamic && CIRCUMSTANCE_CARDS.has(dynamic)) {
      circumstance = dynamic;
      // Auto-resolve emotional arc from probability table
      const table = CIRCUMSTANCE_AUTO_RESOLVE[dynamic];
      if (table) {
        emotionalArc = weightedPick(table).arc;
      } else {
        emotionalArc = 'Enemies';
      }
    } else {
      // Nothing selected or unknown value â€” default
      emotionalArc = 'Enemies';
    }

    const arcLabel = DYNAMIC_DISPLAY[emotionalArc] || emotionalArc;
    let block = `- Polarity: ${arcLabel}\n- Relational Engine: ${POLARITY_DIRECTIVES[emotionalArc] || 'Conflict masks attraction.'}`;

    // Constraint line (if Circumstance selected)
    if (circumstance && CIRCUMSTANCE_DIRECTIVES[circumstance]) {
      block += `\n- Constraint: ${CIRCUMSTANCE_DIRECTIVES[circumstance]}`;
    }

    // Hidden intensity modifier (30% base probability)
    // Petition probability tilt applied here â€” boosts modifier trigger chance
    const petitionTilt = state._strategyPass?.petition?.probability_tilt || 0;
    const modifierProbability = 0.30 + (petitionTilt * 0.20); // tilt 1.0 â†’ 50% chance
    const suppressIntensity = shouldSuppressIntensity(tonalFractureStr, pullBlockStr);
    if (!suppressIntensity && Math.random() < modifierProbability) {
      const modifiers = INTENSITY_MODIFIERS[emotionalArc];
      if (modifiers) {
        const pick = weightedPick(modifiers);
        const directive = INTENSITY_DIRECTIVE[pick.id];
        if (directive) {
          block += `\n- Attachment Modifier: ${directive}`;
        }
      }
    }

    return block;
  }

  /**
   * Check suppression rules for intensity modifier.
   * Suppress if: Tone Fracture AND Undercurrent both active,
   * or Pull = Survival with stakes dominant,
   * or Arousal tier is Clean.
   */
  function shouldSuppressIntensity(tonalFractureStr, pullBlockStr) {
    const hasFracture = tonalFractureStr && tonalFractureStr.length > 0;
    const hasUndercurrent = pullBlockStr && pullBlockStr.includes('Undercurrent:');

    // Suppress if both Tonal Fracture and Undercurrent are active
    if (hasFracture && hasUndercurrent) return true;

    // Suppress if Pull = Survival and stakes dominant
    if (state.picks?.pressure === 'Survival') return true;

    // Intensity no longer suppresses romance pull

    return false;
  }

  // PRESSURE FLAVORS â€” OPTIONAL REFINEMENTS (never required, never change authority)
  const PRESSURE_FLAVORS = {
    PowerControl: [
      { id: 'Billionaire', label: 'Billionaire', description: 'Ultra-wealth, power plays, golden cages.' },
      { id: 'CrimeSyndicate', label: 'Crime Syndicate', description: 'Organized crime, loyalty, blood oaths.' },
      { id: 'Political', label: 'Political Intrigue', description: 'Power structures, alliances, betrayal.' },
      { id: 'Espionage', label: 'Espionage', description: 'Spies, double lives, dangerous information.' },
      { id: 'CultOrder', label: 'Cult / Order', description: 'Hierarchies of belief, obedience, doctrine.' }
    ],
    RiskExposure: [
      { id: 'Noir', label: 'Noir', description: 'Shadows, moral compromise, fatalism.' },
      { id: 'ForbiddenKnowledge', label: 'Forbidden Knowledge', description: 'Curiosity, revelation, the price of knowing.' },
      { id: 'PublicScandal', label: 'Public Scandal', description: 'Reputation on the line, exposure as weapon.' },
      { id: 'Surveillance', label: 'Surveillance', description: 'Always watched, privacy as currency.' },
      { id: 'DoubleLife', label: 'Double Life', description: 'Two selves, one secret, inevitable collision.' }
    ],
    EscapePursuit: [
      { id: 'Heist', label: 'Heist', description: 'Elaborate plans, trust and betrayal.' },
      { id: 'Rescue', label: 'Rescue / Retrieval', description: 'Someone needs saving. Someone pays the price.' },
      { id: 'OnTheRun', label: 'On the Run', description: 'Fleeing, hunted, no safe harbor.' },
      { id: 'Captivity', label: 'Locked Away', description: 'Confined, isolated, escape as obsession.' },
      { id: 'BorderCrossing', label: 'Border Crossing', description: 'Thresholds, checkpoints, forbidden passage.' }
    ],
    ObligationBurden: [
      { id: 'ChosenBurdened', label: 'Chosen / Burdened', description: 'Marked by fate, weighted by purpose.' },
      { id: 'DutyToFamily', label: 'Duty to Family', description: 'Blood obligation, inherited expectation.' },
      { id: 'Prophecy', label: 'Prophecy', description: 'Foreordained, resisted, inevitable.' },
      { id: 'CommandRank', label: 'Command / Rank', description: 'Orders given, orders followed, orders defied.' },
      { id: 'Inheritance', label: 'Inheritance', description: 'Legacy, entitlement, poisoned gifts.' }
    ],
    DesireObsession: [
      { id: 'Obsession', label: 'Obsession', description: 'Fixation, escalation, loss of control.' },
      { id: 'ForbiddenRomance', label: 'Forbidden Romance', description: 'Rules say no. The heart says otherwise.' },
      { id: 'Rivalry', label: 'Rivalry', description: 'Competition as courtship, winning as need.' },
      { id: 'Addiction', label: 'Addiction', description: 'The thing you can\'t stop wanting.' },
      { id: 'Jealousy', label: 'Jealousy', description: 'Possessiveness, comparison, the green edge.' }
    ],
    ReckoningPast: [
      { id: 'RelentlessPast', label: 'Relentless Past', description: 'Identity erosion, old lives resurfacing.' },
      { id: 'Redemption', label: 'Redemption', description: 'Second chances, atonement, becoming worthy.' },
      { id: 'OldDebts', label: 'Old Debts', description: 'What\'s owed never forgets.' },
      { id: 'BetrayalHistory', label: 'Betrayal History', description: 'Trust broken, wounds reopened.' },
      { id: 'LostRelationship', label: 'Lost Relationship', description: 'What was, what ended, what might be again.' }
    ],
    Transformation: [
      { id: 'BecomingPowerful', label: 'Becoming Powerful', description: 'Strength arriving, identity shifting.' },
      { id: 'MoralCorruption', label: 'Moral Corruption', description: 'Lines crossed, self redefined.' },
      { id: 'Awakening', label: 'Awakening', description: 'Dormant becoming active, hidden becoming known.' },
      { id: 'IdentityShift', label: 'Identity Shift', description: 'Who you were is not who you are.' },
      { id: 'Ascension', label: 'Ascension / Mutation', description: 'Evolution, elevation, irreversible change.' }
    ],
    Survival: [
      { id: 'WarZone', label: 'War Zone', description: 'Combat, casualties, survival in conflict.' },
      { id: 'Castaway', label: 'Castaway', description: 'Stranded, exposed, no rescue coming.' },
      { id: 'Lost', label: 'Lost', description: 'Disoriented, off-trail, the terrain closing in.' },
      { id: 'Trapped', label: 'Trapped', description: 'Pinned, enclosed, no way out but through.' },
      { id: 'Afflicted', label: 'Afflicted', description: 'Sick, poisoned, injured â€” the body failing.' },
      { id: 'Scarcity', label: 'Scarcity', description: 'Not enough, hard choices, rationed hope.' }
    ]
  };

  // NOTE: initPressureFrontFlavors(), injectPressureDestinyCard(), and
  // injectDynamicDestinyCard() are defined inside initSelectionHandlers() â€”
  // they are called from the corridor mount handlers in updateCorridorVisibility()
  // when the pressure/dynamic rows become active (not at module scope).

  // LEGACY GENRE â†’ PRESSURE+FLAVOR MAPPING (Backward Compatibility)
  // Maps old genre values to new pressure system
  const LEGACY_GENRE_TO_PRESSURE = {
    Billionaire: { pressure: 'PowerControl', flavor: 'Billionaire' },
    CrimeSyndicate: { pressure: 'PowerControl', flavor: 'CrimeSyndicate' },
    Political: { pressure: 'PowerControl', flavor: 'Political' },
    Espionage: { pressure: 'PowerControl', flavor: 'Espionage' },
    Noir: { pressure: 'RiskExposure', flavor: 'Noir' },
    ForbiddenKnowledge: { pressure: 'RiskExposure', flavor: 'ForbiddenKnowledge' },
    Heist: { pressure: 'EscapePursuit', flavor: 'Heist' },
    Escape: { pressure: 'EscapePursuit', flavor: 'OnTheRun' },
    Obsession: { pressure: 'DesireObsession', flavor: 'Obsession' },
    RelentlessPast: { pressure: 'ReckoningPast', flavor: 'RelentlessPast' },
    Redemption: { pressure: 'ReckoningPast', flavor: 'Redemption' },
    BuildingBridges: { pressure: 'ReckoningPast', flavor: 'LostRelationship' },
    Purgatory: { pressure: 'Transformation', flavor: 'IdentityShift' },
    Survival: { pressure: 'Survival', flavor: null },
    // Removed Survival flavors â†’ remap to nearest equivalent
    Collapse: { pressure: 'Survival', flavor: 'Scarcity' },
    Exile: { pressure: 'Survival', flavor: 'Castaway' },
    EndOfEra: { pressure: 'Survival', flavor: 'Scarcity' },
    Sports: { pressure: 'DesireObsession', flavor: 'Rivalry' }
  };

  // FLAVOR â†’ DSP PARAPHRASE OVERRIDES
  // When a flavor is selected, it overrides the pressure's default DSP phrase
  const FLAVOR_DSP_OVERRIDES = {
    Billionaire: 'power, appetite, and polished threat',
    CrimeSyndicate: 'loyalty, leverage, and quiet violence',
    Political: 'alliances, betrayals, and shifting leverage',
    Espionage: 'double lives, coded truths, and invisible wars',
    CultOrder: 'doctrine, hierarchy, and absolute obedience',
    Noir: 'secrets, temptation, and moral compromise',
    ForbiddenKnowledge: 'curiosity, revelation, and the price of knowing',
    PublicScandal: 'reputation, exposure, and public ruin',
    Surveillance: 'watching, being watched, and nowhere to hide',
    DoubleLife: 'two selves, one secret, and inevitable collision',
    Heist: 'precision, misdirection, and nerve',
    Rescue: 'urgency, sacrifice, and the ones left behind',
    OnTheRun: 'flight, pursuit, and vanishing margins',
    Captivity: 'confinement, isolation, and the calculus of escape',
    BorderCrossing: 'passage, papers, and the cost of crossing',
    ChosenBurdened: 'fate, purpose, and the weight of being marked',
    DutyToFamily: 'blood, expectation, and the debts we inherit',
    Prophecy: 'foretelling, resistance, and what cannot be escaped',
    CommandRank: 'orders, hierarchy, and the limits of obedience',
    Inheritance: 'legacy, entitlement, and poisoned gifts',
    Obsession: 'fixation, escalation, and loss of control',
    ForbiddenRomance: 'taboo, defiance, and desire against judgment',
    Rivalry: 'competition, obsession, and proving worth',
    Addiction: 'craving, relapse, and the thing you cannot quit',
    Jealousy: 'possession, comparison, and the green edge of love',
    RelentlessPast: 'old debts, buried identities, and consequences that refuse to stay buried',
    Redemption: 'reckoning, mercy, and second chances',
    OldDebts: 'what is owed, what is remembered, and interest accrued',
    BetrayalHistory: 'broken trust, old wounds, and the long memory of love',
    LostRelationship: 'repair, trust, and improbable understanding',
    BecomingPowerful: 'awakening strength, shifting identity, and the cost of power',
    MoralCorruption: 'lines crossed, innocence lost, and the stranger you become',
    Awakening: 'dormant power stirring, hidden truths surfacing',
    IdentityShift: 'unfinished business, reflection, and finding the key to your own lock',
    Ascension: 'evolution, elevation, and irreversible change',
    // Survival flavors: no DSP copy at flavor level (pressure DSP phrase covers all)
  };

  /**
   * Get DSP paraphrase for current pressure/flavor selection
   * @param {string} pressure - Primary pressure ID
   * @param {string|null} flavor - Optional flavor ID
   * @returns {string} - DSP paraphrase for "shaped by..."
   */
  function getPressureDSPPhrase(pressure, flavor) {
    // If flavor is selected and has an override, use it
    if (flavor && FLAVOR_DSP_OVERRIDES[flavor]) {
      return FLAVOR_DSP_OVERRIDES[flavor];
    }
    // Otherwise use the primary pressure's phrase
    const pressureConfig = PRIMARY_PRESSURES[pressure];
    if (pressureConfig) {
      return pressureConfig.dspPhrase;
    }
    // Fallback for legacy genres
    return 'tension, desire, and unfinished business';
  }

  /**
   * Get effective genre key for legacy systems (cover, title, etc.)
   * Returns flavor if set, otherwise maps pressure to best legacy equivalent
   * @param {string} pressure - Primary pressure ID
   * @param {string|null} flavor - Optional flavor ID
   * @returns {string} - Effective genre key for legacy lookups
   */
  function getEffectiveGenre(pressure, flavor) {
    // If flavor is set, return it directly (many flavors match old genre keys)
    if (flavor) return flavor;

    // Map pressure to default legacy genre
    const PRESSURE_DEFAULT_GENRE = {
      PowerControl: 'Billionaire',
      RiskExposure: 'Noir',
      EscapePursuit: 'Heist',
      ObligationBurden: 'ChosenBurdened',
      DesireObsession: 'Obsession',
      ReckoningPast: 'RelentlessPast',
      Transformation: 'IdentityShift',
      Survival: 'Survival'
    };
    return PRESSURE_DEFAULT_GENRE[pressure] || 'Billionaire';
  }

  /**
   * Migrate legacy genre to pressure+flavor
   * Used for loading old saves
   * @param {string} legacyGenre - Old genre value
   * @returns {{ pressure: string, flavor: string|null }}
   */
  function migrateLegacyGenre(legacyGenre) {
    const mapping = LEGACY_GENRE_TO_PRESSURE[legacyGenre];
    if (mapping) {
      return { pressure: mapping.pressure, flavor: mapping.flavor };
    }
    // Default fallback for unknown genres
    return { pressure: 'PowerControl', flavor: 'Billionaire' };
  }

  /**
   * Check if a pressure is compatible with the current tone
   * @param {string} pressure - Pressure ID
   * @param {string} tone - Tone value
   * @returns {boolean}
   */
  function isPressureCompatible(pressure, tone) {
    return true;
  }

  /**
   * Check if a flavor is compatible with tone
   * @param {string} flavor - Flavor ID
   * @param {string} tone - Tone value
   * @returns {boolean}
   */
  function isFlavorCompatible(flavor, tone) {
    return true;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP GENRE PARAPHRASES â€” LOCKED CANON (DO NOT MODIFY)
  // Used as: "shaped by â€¦"
  // NOTE: This is retained for backward compatibility. New code should use
  // getPressureDSPPhrase() which understands the pressure+flavor hierarchy.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const DSP_GENRE_PARAPHRASES = {
    CrimeSyndicate: 'loyalty, leverage, and quiet violence',
    Billionaire: 'power, appetite, and polished threat',
    Noir: 'secrets, temptation, and moral compromise',
    Political: 'alliances, betrayals, and shifting leverage',
    Heist: 'precision, misdirection, and nerve',
    Espionage: 'double lives, coded truths, and invisible wars',
    Escape: 'locked doors, narrow windows, and the clock',
    Survival: 'scarcity, endurance, and brutal choices',
    Sports: 'discipline, rivalry, and everything on the line',
    Obsession: 'fixation, escalation, and loss of control',
    Redemption: 'reckoning, mercy, and second chances',
    BuildingBridges: 'repair, trust, and improbable understanding',
    RelentlessPast: 'old debts, buried identities, and consequences that refuse to stay buried',
    ForbiddenKnowledge: 'curiosity, revelation, and the price of knowing',
    Purgatory: 'unfinished business, reflection, and finding the key to your own lock'
  };

  const DSP_ARCHETYPE_ADJECTIVES = {
    HEART_WARDEN: 'controlling',
    OPEN_VEIN: 'overwhelming',
    SPELLBINDER: 'mesmerizing',
    ARMORED_FOX: 'unaccountable',
    DARK_VICE: 'consuming',
    BEAUTIFUL_RUIN: 'self-destructive',
    ETERNAL_FLAME: 'unyielding'
  };

  const DSP_TONAL_ADJECTIVES = {
    Earnest: 'heartfelt',
    WryConfession: 'self-deprecating',
    Dark: 'suffocating',
    Mythic: 'fated'
  };

  /**
   * Generate the DSP â€” fixed two-sentence ceremonial template.
   * Sentence 1: In [WORLD_PHRASE], shaped by [GENRE_PARAPHRASE], a question awaits:
   * Sentence 2: Will [ARCHETYPAL_ADJECTIVE] desire redeem this [TONAL_ADJECTIVE] affair â€” or ruin it?
   * Slots wrapped in dsp-clause spans for progressive reveal.
   * World subtypes are intentionally ignored â€” DSP uses bible phrases only.
   */
  /**
   * Generate DSP sentence from locked template.
   * HARD FAILS if any required input is missing or invalid.
   * No fallbacks, no defaults, no invented prose.
   * @returns {{ success: boolean, html: string|null, error: object|null }}
   */
  function generateDSPSentence() {
    const world = state.picks?.world;
    const genre = state.picks?.genre;
    const tone = state.picks?.tone;
    const archetypeId = state.archetype?.primary;

    // HARD FAIL: No fallback defaults â€” all inputs must be explicitly set
    if (!world) {
      const error = { code: 'DSP_MISSING_WORLD', message: 'DSP generation failed: world not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (!genre) {
      const error = { code: 'DSP_MISSING_GENRE', message: 'DSP generation failed: genre not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (!tone) {
      const error = { code: 'DSP_MISSING_TONE', message: 'DSP generation failed: tone not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (!archetypeId) {
      const error = { code: 'DSP_MISSING_ARCHETYPE', message: 'DSP generation failed: archetype not set' };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // HARD FAIL: Phrase must exist in approved list
    const worldPhrase = DSP_WORLD_PHRASES[world];
    if (!worldPhrase) {
      const error = { code: 'DSP_INVALID_WORLD', message: `DSP generation failed: no approved phrase for world "${world}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // PRESSURE REGIME: Use getPressureDSPPhrase if available, fallback to legacy DSP_GENRE_PARAPHRASES
    const pressure = state.picks?.pressure;
    const flavor = state.picks?.flavor;
    let genrePhrase;
    if (pressure && typeof getPressureDSPPhrase === 'function') {
      genrePhrase = getPressureDSPPhrase(pressure, flavor);
    } else {
      genrePhrase = DSP_GENRE_PARAPHRASES[genre];
    }
    if (!genrePhrase) {
      const error = { code: 'DSP_INVALID_GENRE', message: `DSP generation failed: no approved phrase for genre "${genre}" or pressure "${pressure}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    const archAdj = DSP_ARCHETYPE_ADJECTIVES[archetypeId];
    if (!archAdj) {
      const error = { code: 'DSP_INVALID_ARCHETYPE', message: `DSP generation failed: no approved adjective for archetype "${archetypeId}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    const toneAdj = DSP_TONAL_ADJECTIVES[tone];
    if (!toneAdj) {
      const error = { code: 'DSP_INVALID_TONE', message: `DSP generation failed: no approved adjective for tone "${tone}"` };
      console.error('[DSP] HARD FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // CANONICITY ASSERTION: All DSP components must match canonical maps EXACTLY
    // Guards against any runtime modification or corruption
    if (worldPhrase !== DSP_WORLD_PHRASES[world]) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `World phrase corrupted: expected canonical "${DSP_WORLD_PHRASES[world]}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }
    // PRESSURE REGIME: Canonicity check handles both pressure system and legacy genres
    const expectedGenrePhrase = pressure && typeof getPressureDSPPhrase === 'function'
      ? getPressureDSPPhrase(pressure, flavor)
      : DSP_GENRE_PARAPHRASES[genre];
    if (genrePhrase !== expectedGenrePhrase) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `Genre phrase corrupted: expected canonical "${expectedGenrePhrase}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (archAdj !== DSP_ARCHETYPE_ADJECTIVES[archetypeId]) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `Archetype adjective corrupted: expected canonical "${DSP_ARCHETYPE_ADJECTIVES[archetypeId]}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }
    if (toneAdj !== DSP_TONAL_ADJECTIVES[tone]) {
      const error = { code: 'DSP_CANONICITY_FAIL', message: `Tone adjective corrupted: expected canonical "${DSP_TONAL_ADJECTIVES[tone]}"` };
      console.error('[DSP] CANONICITY FAIL:', error.message);
      return { success: false, html: null, error };
    }

    // STRICT DSP ASSEMBLY â€” no invented prose, no embellishment
    // Dynamic affair word based on storyLength
    const AFFAIR_WORD_MAP = {
      taste: 'taste',
      fling: 'fling',
      affair: 'affair',
      soulmates: 'cosmic connection'
    };

    // POV pronoun mapping (inserted before archetype adjective)
    const POV_PRONOUN_MAP = {
      First: 'my ',
      Second: 'your ',
      Third: 'their ',
      Fourth: '',      // Omniscient â€” no pronoun
      Fifth: null       // Author POV â€” entirely different sentence
    };

    const pov = state.picks?.pov;
    const isFifthPerson = pov === 'Fifth';
    const povPronoun = pov ? (POV_PRONOUN_MAP[pov] ?? '') : '';

    let html = '';

    // FULL MODE: Only after story has begun (turnCount > 0)
    // SPARSE MODE: During Story Shape and Guided Fate (progressive reveal)
    const storyHasBegun = (state.turnCount || 0) > 0;

    if (isFifthPerson) {
      // 5th Person (Author POV): Different sentence structure entirely
      html = 'Fate sets the stage in <span class="dsp-clause" data-axis="world">' + worldPhrase +
        ',</span> shaped by <span class="dsp-clause" data-axis="genre">' + genrePhrase + '</span>.';
    } else if (storyHasBegun) {
      // FULL MODE: Render complete sentence (story in progress)
      const affairWord = AFFAIR_WORD_MAP[state.storyLength] || 'affair';
      html = 'In <span class="dsp-clause" data-axis="world">' + worldPhrase +
        ', shaped by ' + genrePhrase + '</span>' +
        ', a question awaits: Will ' + povPronoun +
        '<span class="dsp-clause" data-axis="archetype">' + archAdj + '</span>' +
        ' desire redeem this <span class="dsp-clause" data-axis="tone">' + toneAdj + '</span>' +
        ' ' + affairWord + '&#8201;&#8212;&#8201;or ruin it?';
    } else {
      // SPARSE MODE: Build sentence incrementally based on completed selections
      // During Guided Fate: use _revealedDSPAxes
      // During Story Shape: derive from state.picks (user-initiated selections)
      // NO greyed text, NO placeholders, NO future parts
      let hasWorld, hasArchetype, hasTone, hasLength;

      if (_revealedDSPAxes) {
        // Guided Fate mode: use explicit reveal tracking
        hasWorld = _revealedDSPAxes.has('world');
        hasArchetype = _revealedDSPAxes.has('archetype');
        hasTone = _revealedDSPAxes.has('tone');
        hasLength = _revealedDSPAxes.has('length');
      } else {
        // Story Shape mode: derive from completed selections
        // DSP activates after 2+ explicit choices â€” show all current picks
        hasWorld = isDSPActivated() && !!state.picks?.world;
        hasArchetype = isDSPActivated() && !!state.picks?.genre;
        hasTone = isDSPActivated() && !!state.picks?.tone;
        hasLength = isDSPActivated() && !!state.storyLength;
      }

      if (hasWorld) {
        html = 'In <span class="dsp-clause" data-axis="world">' + worldPhrase +
          ', shaped by ' + genrePhrase + '</span>';
      }
      if (hasWorld && hasArchetype) {
        html += ', a question awaits: Will ' + povPronoun +
          '<span class="dsp-clause" data-axis="archetype">' + archAdj + '</span>';
      }
      if (hasWorld && hasArchetype && hasTone) {
        html += ' desire redeem this <span class="dsp-clause" data-axis="tone">' + toneAdj + '</span>';
      }
      if (hasWorld && hasArchetype && hasTone && hasLength) {
        const affairWord = AFFAIR_WORD_MAP[state.storyLength] || 'affair';
        html += ' ' + affairWord + '&#8201;&#8212;&#8201;or ruin it?';
      }
    }

    return { success: true, html, error: null };
  }

  // NOTE: World subtypes are INTENTIONALLY excluded from DSP.
  // DSP uses ONLY base world phrases from DSP_WORLD_PHRASES.
  // Subtypes affect story generation prompts, NOT the DSP.

  function updateSynopsisPanel(isUserAction = false) {
    const synopsisText = document.getElementById('synopsisText');
    if (!synopsisText) return;

    // GATE: During Guided Fate, DSP updates come ONLY from revealDSPClause
    // This prevents bulk hydration or catch-up rendering
    if (_dspGuidedFateActive) return;

    // ACTIVATION THRESHOLD: DSP requires at least 2 explicit Story Shape choices
    // Block rendering until threshold is met
    if (!isDSPActivated()) return;

    const result = generateDSPSentence();

    // HARD FAIL: Do not display anything if DSP generation failed
    if (!result.success) {
      console.error('[DSP] updateSynopsisPanel blocked:', result.error?.message);
      // Keep placeholder if threshold not met
      if (!isDSPActivated()) return;
      // Clear any legacy content â€” DSP must be empty on failure
      synopsisText.innerHTML = '';
      synopsisText._lastDSP = null;
      return;
    }

    // Track first hydration for animation purposes
    const wasFirstHydration = !synopsisText._lastDSP;

    const newSentence = result.html;

    // Update with animation if content changed
    if (synopsisText._lastDSP !== newSentence) {
      synopsisText._lastDSP = newSentence;
      synopsisText.classList.add('updating');
      synopsisText.innerHTML = newSentence;

      // Sequential reveal of clauses on first hydration (non-Guided Fate only)
      if (wasFirstHydration && !_fateRunning) {
        const clauses = synopsisText.querySelectorAll('.dsp-clause');
        clauses.forEach((clause, i) => {
          clause.classList.add('dsp-pending');
          setTimeout(() => {
            clause.classList.remove('dsp-pending');
            clause.classList.add('dsp-glow');
            setTimeout(() => clause.classList.remove('dsp-glow'), 500);
          }, 300 + i * 400);
        });
      }
      // SPARSE MODE: During Guided Fate, sentence is built incrementally
      // by revealDSPClause â€” no pending classes needed here

      setTimeout(() => synopsisText.classList.remove('updating'), 500);

      // DSP text is allowed to wrap naturally â€” no line-count gate
    }
  }

  // Ceremonial DSP presentation swap â€” dissolve + re-render fully resolved
  // No prose recomposition; same authored template, just remove pending state.
  function performDSPCeremonialRewrite() {
    const synopsisText = document.getElementById('synopsisText');
    if (!synopsisText) return;

    // Phase 1: dissolve current text
    synopsisText.classList.add('dsp-dissolving');

    // Spawn a few particles near DSP during dissolve (anchored to panel)
    const panel = document.getElementById('synopsisPanel');
    if (panel) {
      const container = getOrCreateSparkleContainer(panel);
      if (container) {
        const pw = panel.offsetWidth;
        const ph = panel.offsetHeight;
        for (let i = 0; i < 8; i++) {
          const spark = document.createElement('div');
          spark.className = 'fate-dust-particle';
          spark.dataset.sparkleTag = 'dsp-rewrite';
          const sx = Math.random() * pw;
          const sy = Math.random() * ph;
          const sz = 2 + Math.random() * 3;
          const sd = 2000 + Math.random() * 1500;
          spark.style.cssText = `
            left:${sx}px; top:${sy}px;
            width:${sz}px; height:${sz}px;
            --dust-duration:${sd}ms;
            --dust-opacity:${0.5 + Math.random() * 0.3};
            --dust-dx:${(Math.random() - 0.5) * 30}px;
            --dust-dy:${-(10 + Math.random() * 20)}px;
          `;
          container.appendChild(spark);
          setTimeout(() => { if (spark.parentNode) spark.remove(); }, sd + 100);
        }
      }
    }

    // Phase 2: re-render same sentence fully resolved (no pending classes)
    setTimeout(() => {
      const result = generateDSPSentence();
      // HARD FAIL: Do not display anything if DSP generation failed
      if (!result.success) {
        console.error('[DSP] performDSPCeremonialRewrite blocked:', result.error?.message);
        synopsisText.innerHTML = '';
        synopsisText._lastDSP = null;
        synopsisText.classList.remove('dsp-dissolving');
        return;
      }
      const resolved = result.html;
      synopsisText.innerHTML = resolved;
      synopsisText._lastDSP = resolved;
      synopsisText.classList.remove('dsp-dissolving');
      synopsisText.classList.add('dsp-revealing');

      setTimeout(() => synopsisText.classList.remove('dsp-revealing'), 700);
    }, 500);
  }

  /**
   * Get selected world subtype from the subtype selection UI
   * Returns null if no subtype is selected
   */
  function getSelectedWorldSubtype(world) {
    // Map world to subtype container ID
    const subtypeContainerMap = {
      SciFi: 'scifiSubtypeGrid',
      Fantasy: 'fantasySubtypeGrid',
      Horror: 'horrorSubtypeGrid',
      Dystopia: 'dystopiaSubtypeGrid',
      PostApocalyptic: 'apocalypseSubtypeGrid'
    };

    const containerId = subtypeContainerMap[world];
    if (!containerId) return null;

    const container = document.getElementById(containerId);
    if (!container) return null;

    const selected = container.querySelector('.card.selected');
    return selected?.dataset?.val || null;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP VISIBILITY LIFECYCLE (STATE-BASED)
  // DSP is visible throughout the four-axis configuration (World â†’ Tone
  // â†’ Genre â†’ Dynamic). It disappears only after Begin Story is clicked.
  // Visibility is tied to screen state, not scroll position.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _dspActivationCount = 0; // Count of explicit Story Shape selections (activates DSP at >= 2)
  let _dspGuidedFateActive = false; // True during Guided Fate â€” prevents bulk hydration
  let _dspPhase = 0; // 0=intro, 1=placeholder, 2=live, 3=veto
  let _dspIntroTimer = null; // Timer for introâ†’placeholder transition

  // Reset DSP state for new story / mode change
  function resetDSPState() {
      _dspPhase = 0;
      _dspActivationCount = 0;
      if (_dspIntroTimer) {
          clearTimeout(_dspIntroTimer);
          _dspIntroTimer = null;
      }
      const synopsisText = document.getElementById('synopsisText');
      if (synopsisText) {
          synopsisText._dspInitialized = false;
          synopsisText._lastDSP = null;
      }
  }

  function isDSPActivated() {
      return _dspActivationCount >= 2;
  }

  function incrementDSPActivation() {
      _dspActivationCount++;
      console.log(`[DSP] Activation count: ${_dspActivationCount}`);
  }

  // Build full DSP placeholder sentence with all segments in grey (inactive) state
  function buildDSPPlaceholderHTML() {
      return '<span class="dsp-segment dsp-inactive" data-axis="world">In a world yet unchosen</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="genre">, shaped by forces unknown</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="archetype">, a question awaits:<br>Will unspoken</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="tone"> desire redeem this</span>' +
             '<span class="dsp-segment dsp-inactive" data-axis="length"> untold affair&#8201;&#8212;&#8201;or ruin it?</span>';
  }

  // Update a single DSP segment when user makes a selection
  function activateDSPSegment(axis, text) {
      if (_dspPhase < 1) return; // Not ready for updates yet
      _dspPhase = 2; // Move to live phase
      const synopsisText = document.getElementById('synopsisText');
      if (!synopsisText) return;
      const segment = synopsisText.querySelector(`.dsp-segment[data-axis="${axis}"]`);
      if (segment) {
          // Guard: prevent glow spam on reselection
          if (segment.classList.contains('dsp-active')) return;
          segment.textContent = text;
          segment.classList.remove('dsp-inactive');
          segment.classList.add('dsp-active', 'dsp-glow');
          setTimeout(() => segment.classList.remove('dsp-glow'), 500);
      }
  }

  // Veto override: reveal all remaining grey segments as white (no glow)
  function revealAllDSPSegments() {
      _dspPhase = 3;
      const synopsisText = document.getElementById('synopsisText');
      if (!synopsisText) return;
      const inactiveSegments = synopsisText.querySelectorAll('.dsp-segment.dsp-inactive');
      inactiveSegments.forEach(seg => {
          seg.classList.remove('dsp-inactive');
          seg.classList.add('dsp-active');
          // No glow for veto-revealed segments
      });
  }

  function showDSP() {
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      // HARD-DISABLE in Shape stage: DSP only shows from World stage (index 3) onward
      // Shape stage = authorship (0), identity (1), archetype (2)
      if (typeof corridorActiveRowIndex !== 'undefined' && corridorActiveRowIndex < 3) {
        synopsisPanel.classList.remove('visible');
        return;
      }
      // Inject "First Taste" header if not present (after drag handle)
      if (!synopsisPanel.querySelector('.synopsis-title')) {
        const title = document.createElement('div');
        title.className = 'synopsis-title';
        title.textContent = 'First Taste';
        const dragHandle = synopsisPanel.querySelector('.dsp-drag-handle');
        if (dragHandle && dragHandle.nextSibling) {
          synopsisPanel.insertBefore(title, dragHandle.nextSibling);
        } else {
          synopsisPanel.insertBefore(title, synopsisPanel.firstChild);
        }
      }
      const synopsisText = document.getElementById('synopsisText');
      // Phase 0: Show intro message
      if (_dspPhase === 0 && synopsisText && !synopsisText._dspInitialized) {
        synopsisText._dspInitialized = true;
        synopsisText.innerHTML = '<span class="dsp-intro">Your choices shape your story</span>';
        // Transition to Phase 1 after 5 seconds
        if (_dspIntroTimer) clearTimeout(_dspIntroTimer);
        _dspIntroTimer = setTimeout(() => {
          _dspPhase = 1;
          synopsisText.innerHTML = buildDSPPlaceholderHTML();
        }, 5000);
      }
      synopsisPanel.classList.add('visible');
    }
  }

  function hideDSP() {
    const synopsisPanel = document.getElementById('synopsisPanel');
    if (synopsisPanel) {
      synopsisPanel.classList.remove('visible');
    }
  }

  // DSP shows when user is configuring story (setup screen)
  function updateDSPVisibility(screenId) {
    if (screenId === 'setup') {
      showDSP();
    } else {
      hideDSP();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP DRAG + RESIZE â€” Reposition and scale the floating synopsis panel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function initDSPInteraction() {
    const panel = document.getElementById('synopsisPanel');
    if (!panel) return;

    // DSP collapse/expand toggle
    const collapseBtn = document.getElementById('dspCollapseBtn');
    if (collapseBtn) {
      collapseBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (panel.classList.contains('dsp-collapsed')) {
          panel.classList.remove('dsp-collapsed');
          collapseBtn.innerHTML = '&times;';
          collapseBtn.setAttribute('aria-label', 'Collapse panel');
        } else {
          panel.classList.add('dsp-collapsed');
          collapseBtn.innerHTML = '&#9675;';
          collapseBtn.setAttribute('aria-label', 'Expand panel');
        }
      });
    }

    var mode = null;        // 'drag' | 'resize'
    var resizeCorner = null; // 'nw' | 'ne' | 'sw' | 'se'
    var startX = 0, startY = 0;
    var startRect = null;

    // Switch panel from CSS-positioned to inline-positioned
    function ensureInlinePosition() {
      if (panel._dspPositioned) return;
      var rect = panel.getBoundingClientRect();
      // Clear CSS positioning â€” use inline only
      panel.style.transform = 'none';
      panel.style.left = rect.left + 'px';
      panel.style.top = rect.top + 'px';
      panel.style.right = 'auto';
      panel.style.bottom = 'auto';
      panel.style.width = rect.width + 'px';
      panel.style.maxWidth = 'none';
      panel._dspPositioned = true;
    }

    function onStart(clientX, clientY) {
      ensureInlinePosition();
      startX = clientX;
      startY = clientY;
      startRect = {
        left: parseFloat(panel.style.left),
        top: parseFloat(panel.style.top),
        width: panel.offsetWidth,
        height: panel.offsetHeight
      };
      panel.classList.add('dsp-interacting');
    }

    function onMove(clientX, clientY) {
      var dx = clientX - startX;
      var dy = clientY - startY;

      if (mode === 'drag') {
        var x = Math.max(0, Math.min(startRect.left + dx, window.innerWidth - startRect.width));
        var y = Math.max(0, Math.min(startRect.top + dy, window.innerHeight - startRect.height));
        panel.style.left = x + 'px';
        panel.style.top = y + 'px';
      } else if (mode === 'resize') {
        var minW = 160, minH = 60;
        var newLeft = startRect.left, newTop = startRect.top;
        var newW = startRect.width, newH = startRect.height;

        if (resizeCorner === 'se') {
          newW = Math.max(minW, startRect.width + dx);
          newH = Math.max(minH, startRect.height + dy);
        } else if (resizeCorner === 'sw') {
          newW = Math.max(minW, startRect.width - dx);
          newH = Math.max(minH, startRect.height + dy);
          newLeft = startRect.left + (startRect.width - newW);
        } else if (resizeCorner === 'ne') {
          newW = Math.max(minW, startRect.width + dx);
          newH = Math.max(minH, startRect.height - dy);
          newTop = startRect.top + (startRect.height - newH);
        } else if (resizeCorner === 'nw') {
          newW = Math.max(minW, startRect.width - dx);
          newH = Math.max(minH, startRect.height - dy);
          newLeft = startRect.left + (startRect.width - newW);
          newTop = startRect.top + (startRect.height - newH);
        }

        // Clamp to viewport
        newLeft = Math.max(0, newLeft);
        newTop = Math.max(0, newTop);

        panel.style.left = newLeft + 'px';
        panel.style.top = newTop + 'px';
        panel.style.width = newW + 'px';
        panel.style.height = newH + 'px';
        panel.style.maxHeight = 'none';
        panel.style.minHeight = '0';
      }
    }

    function onEnd() {
      mode = null;
      resizeCorner = null;
      panel.classList.remove('dsp-interacting');
    }

    // â”€â”€ Mouse â”€â”€
    panel.addEventListener('mousedown', function(e) {
      var corner = e.target.dataset && e.target.dataset.resize;
      if (corner) {
        e.preventDefault();
        mode = 'resize';
        resizeCorner = corner;
        onStart(e.clientX, e.clientY);
      } else if (e.target.closest('.dsp-drag-handle')) {
        e.preventDefault();
        mode = 'drag';
        onStart(e.clientX, e.clientY);
      }
    });
    document.addEventListener('mousemove', function(e) {
      if (mode) { e.preventDefault(); onMove(e.clientX, e.clientY); }
    });
    document.addEventListener('mouseup', onEnd);

    // â”€â”€ Touch â”€â”€
    panel.addEventListener('touchstart', function(e) {
      if (e.touches.length !== 1) return;
      var t = e.touches[0];
      var corner = e.target.dataset && e.target.dataset.resize;
      if (corner) {
        e.preventDefault();
        mode = 'resize';
        resizeCorner = corner;
        onStart(t.clientX, t.clientY);
      } else if (e.target.closest('.dsp-drag-handle')) {
        e.preventDefault();
        mode = 'drag';
        onStart(t.clientX, t.clientY);
      }
    }, { passive: false });
    document.addEventListener('touchmove', function(e) {
      if (mode && e.touches.length === 1) {
        e.preventDefault();
        onMove(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });
    document.addEventListener('touchend', onEnd);
    document.addEventListener('touchcancel', onEnd);
  })();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DSP MARQUEE â€” Auto-wrap synopsis text in a scrolling inner span
  // Whenever synopsisText.innerHTML changes, wrap all content inside
  // a .synopsis-text-inner span so the CSS animation scrolls it.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  (function initDSPMarquee() {
    var el = document.getElementById('synopsisText');
    if (!el) return;

    var wrapping = false;

    function wrapContent() {
      if (wrapping) return;
      // Skip if already wrapped
      if (el.children.length === 1 && el.firstElementChild &&
          el.firstElementChild.classList.contains('synopsis-text-inner')) return;
      // Skip if empty
      if (!el.innerHTML.trim()) return;
      wrapping = true;
      var inner = document.createElement('span');
      inner.className = 'synopsis-text-inner';
      // Move all child nodes into the wrapper
      while (el.firstChild) inner.appendChild(el.firstChild);
      el.appendChild(inner);
      wrapping = false;
    }

    // Observe content changes
    var obs = new MutationObserver(function() {
      if (!wrapping) requestAnimationFrame(wrapContent);
    });
    obs.observe(el, { childList: true, characterData: true, subtree: true });
    // Wrap any initial content
    wrapContent();
  })();

  // Expose for external calls
  window.showDSP = showDSP;
  window.hideDSP = hideDSP;
  window.updateDSPVisibility = updateDSPVisibility;
  window.activateDSPSegment = activateDSPSegment;
  window.revealAllDSPSegments = revealAllDSPSegments;

  // Legacy function name for compatibility
  function initSynopsisPanelScrollBehavior() {
    // Now state-based, not scroll-based
    // DSP visibility controlled by updateDSPVisibility(screenId)
    updateDSPVisibility(_currentScreenId);
  }
  window.initSynopsisPanelScrollBehavior = initSynopsisPanelScrollBehavior;

  // =========================
  // ARCHETYPE UI HANDLERS
  // =========================

  // Track last-zoomed archetype card (selected via Continue)
  let lastZoomedArchetype = null;
  // Track if archetype cards have been revealed (flip-all on row entry)
  let archetypeCardsRevealed = false;
  // Track if Destiny's Choice was used (for breadcrumb icon)
  let archetypeSelectedViaDestiny = false;
  // Track if pressure Destiny's Choice was used
  let pressureSelectedViaDestiny = false;
  // Track if dynamic/polarity Destiny's Choice was used
  let dynamicSelectedViaDestiny = false;
  // Track active sparkle emitter for last-zoomed card
  let lastZoomedSparkleEmitterId = null;

  // Mask SVG for Destiny's Choice breadcrumb (inline data URI)
  const MASK_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="24" height="24">
    <ellipse cx="16" cy="16" rx="12" ry="10" fill="none" stroke="goldenrod" stroke-width="2"/>
    <circle cx="11" cy="14" r="3" fill="none" stroke="goldenrod" stroke-width="1.5"/>
    <circle cx="21" cy="14" r="3" fill="none" stroke="goldenrod" stroke-width="1.5"/>
    <path d="M8 20 Q16 26 24 20" fill="none" stroke="goldenrod" stroke-width="1.5"/>
  </svg>`;

  function initArchetypeUI() {
      renderArchetypeCards();
      bindArchetypeHandlers();
      bindLoveInterestGenderWatcher();
      updateArchetypeSectionTitle();
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CARD GLEAM SYSTEM â€” Subtle shift-and-hold radial spokes per card

     Applied to ALL card types: .sb-card, .authorship-card, .mode-card.
     One .card-gleam-layer per face, inserted as first child.
     Seeded from card's data-val for deterministic, non-uniform results.

     Animation: quick ~15Â° swing â†’ pause â†’ swing back â†’ longer pause.
     Simulates a viewer shifting their gaze, not a spinning light.

     Blend: mix-blend-mode: screen (additive light, safe for dark text).
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  (function initGleamSystem() {
    function gleamHash(str) {
      var h = 0;
      for (var i = 0; i < str.length; i++) {
        h = ((h << 5) - h) + str.charCodeAt(i);
        h |= 0;
      }
      return Math.abs(h) || 1;
    }

    function gleamRng(seed) {
      var s = seed;
      return function() {
        s = (s * 1103515245 + 12345) & 0x7fffffff;
        return s / 0x7fffffff;
      };
    }

    // Build conic-gradient with 6 spokes at 30Â°, 90Â°, 150Â°, 210Â°, 270Â°, 330Â°
    // 5 gold spokes + 1 dark spoke (70% black) for subtle contrast variation
    // Each spoke: transparent â†’ edge â†’ peak â†’ edge â†’ transparent
    function buildGleamGradient(rng, angleOffset) {
      // Vertical bands tilted 15Â° off vertical (105Â° in CSS gradient space)
      // Per-card angle variation: Â±5Â° from base 105Â°
      var angle = 105 + (angleOffset || 0);
      // Dark band + gold band, per-card variation in width and opacity
      var goldCenter = 48 + rng() * 6;            // gold band center: 48-54%
      var goldHW = 2 + rng() * 2;                 // gold half-width: 2-4%
      var goldPeak = 0.3 + rng() * 0.15;           // white peak: 0.3-0.45
      var goldEdge = goldPeak * 0.4;

      var darkCenter = goldCenter - 8 - rng() * 4; // dark band: 8-12% left of gold
      var darkHW = 2 + rng() * 2;                  // dark half-width: 2-4%
      var darkPeak = 0.25 + rng() * 0.15;          // dark peak: 0.25-0.4
      var darkEdge = darkPeak * 0.3;

      var feather = 3;                              // feather zone in %

      return 'linear-gradient(' + angle.toFixed(1) + 'deg, ' +
        'transparent ' + (darkCenter - darkHW - feather).toFixed(1) + '%, ' +
        'rgba(0, 0, 0, ' + darkEdge.toFixed(2) + ') ' + (darkCenter - darkHW).toFixed(1) + '%, ' +
        'rgba(0, 0, 0, ' + darkPeak.toFixed(2) + ') ' + darkCenter.toFixed(1) + '%, ' +
        'rgba(0, 0, 0, ' + darkEdge.toFixed(2) + ') ' + (darkCenter + darkHW).toFixed(1) + '%, ' +
        'transparent ' + (darkCenter + darkHW + feather).toFixed(1) + '%, ' +
        'transparent ' + (goldCenter - goldHW - feather).toFixed(1) + '%, ' +
        'rgba(255, 255, 255, ' + goldEdge.toFixed(2) + ') ' + (goldCenter - goldHW).toFixed(1) + '%, ' +
        'rgba(255, 255, 255, ' + goldPeak.toFixed(2) + ') ' + goldCenter.toFixed(1) + '%, ' +
        'rgba(255, 255, 255, ' + goldEdge.toFixed(2) + ') ' + (goldCenter + goldHW).toFixed(1) + '%, ' +
        'transparent ' + (goldCenter + goldHW + feather).toFixed(1) + '%)';
    }

    /**
     * Global gleam controller â€” all bands move in lockstep (simulated light reflection).
     * Each card's band has unique thickness/opacity, but position is shared.
     */
    var gleamRegistry = [];
    var gleamPos = 0;
    var gleamCycleRunning = false;

    function registerGleam(gleamEl) {
      gleamRegistry.push(gleamEl);
      // Sync new element to current global position (with per-card offset)
      var off = gleamEl._gleamOffset || 0;
      gleamEl.style.transform = 'translateX(' + (gleamPos + off) + 'px)';
      if (!gleamCycleRunning) {
        gleamCycleRunning = true;
        gleamCycle();
      }
    }

    function setAllGleams(px, dur, easing) {
      gleamPos = px;
      var e = easing || 'ease-in-out';
      var t = 'transform ' + dur.toFixed(2) + 's ' + e;
      for (var i = 0; i < gleamRegistry.length; i++) {
        var off = gleamRegistry[i]._gleamOffset || 0;
        gleamRegistry[i].style.transition = t;
        gleamRegistry[i].style.transform = 'translateX(' + (px + off) + 'px)';
      }
      // Shift debossed text shadow to simulate light moving over pressed-in letters
      updateDebossedShadow(px, dur, e);
    }

    function updateDebossedShadow(px, dur, easing) {
      // Query live DOM â€” only visible (mounted) elements get updated
      var els = document.querySelectorAll(
        '#pressureGrid .sb-card .sb-card-back .sb-card-desc,' +
        '#povGrid .sb-card .sb-card-back .sb-card-desc,' +
        '#dynamicGrid .sb-card .sb-card-back .sb-card-desc'
      );
      if (!els.length) return;
      // Scale gleam position (Â±13px) to shadow offset (Â±0.8px)
      var hx = (px * 0.06).toFixed(2);
      var shadow =
        hx + 'px 0.5px 0.5px rgba(255,255,255,0.1), ' +
        (-hx).toFixed(2) + 'px -0.5px 0.5px rgba(0,0,0,0.2)';
      var t = 'text-shadow ' + dur.toFixed(2) + 's ' + easing;
      for (var i = 0; i < els.length; i++) {
        els[i].style.transition = t;
        els[i].style.textShadow = shadow;
      }
    }

    function gleamBreathe(count, baseOffset, cb) {
      if (count <= 0) { cb(); return; }
      var dist = 2 + Math.random();   // 2-3px
      var target = baseOffset + (gleamPos >= baseOffset ? -dist : dist);
      var dur = 1.8 + Math.random() * 0.4; // ~2s per sway
      setAllGleams(target, dur, 'ease-in-out');
      setTimeout(function() { gleamBreathe(count - 1, baseOffset, cb); }, dur * 1000);
    }

    function gleamCycle() {
      // Phase 1: breathe at center for 5-7s (2-3 breaths)
      var b1 = 2 + Math.floor(Math.random() * 2);
      gleamBreathe(b1, 0, function() {
        // Phase 2: slide left 13px (0.6-0.9s, ease-in-out for soft landing)
        setAllGleams(-13, 0.6 + Math.random() * 0.3, 'ease-in-out');
        setTimeout(function() {
          // Phase 3: breathe at -13px for 0-7s (0-3 breaths)
          var b2 = Math.floor(Math.random() * 4);
          gleamBreathe(b2, -13, function() {
            // Phase 4: slide right back to center (0.5-0.8s, ease-in-out for soft landing)
            setAllGleams(0, 0.5 + Math.random() * 0.3, 'ease-in-out');
            setTimeout(function() {
              // Phase 5: breathe at center for 5-10s (2-4 breaths)
              var b3 = 2 + Math.floor(Math.random() * 3);
              gleamBreathe(b3, 0, gleamCycle);
            }, 400);
          });
        }, 500);
      });
    }

    // Face selectors for multi-face card types
    var FACE_SELECTORS = '.sb-card-face, .authorship-card-face, .mode-card-back, .mode-card-front, .tier-card-back, .tier-card-face, .pact-card-back, .pact-card-front';

    // Card types that ARE their own face (no child face elements)
    var SELF_FACE_CLASSES = ['character-tarot-card'];

    /**
     * Apply gleam to a single card element. Idempotent.
     * Works on .sb-card, .authorship-card, .mode-card, .tier-card, .character-tarot-card, .pact-card.
     */
    function applyCardGleam(card) {
      if (!card || card.dataset.gleamApplied) return;
      card.dataset.gleamApplied = '1';

      var seedStr = card.dataset.val || card.dataset.choice || card.dataset.mode || card.id || String(Math.random());
      var seed = gleamHash(seedStr);
      var rng = gleamRng(seed);

      var speed = 10;                          // fixed 10s cycle (all cards in sync)
      var swayAmp = 10;                        // fixed 10Â° rotation
      var opacityMult = 0.85 + rng() * 0.15;  // 0.85â€“1.0 (visual variety only)
      var posOffset = (rng() - 0.5) * 50;     // Â±25px per-card position offset
      var angleOffset = (rng() - 0.5) * 10;   // Â±5Â° per-card angle variation
      var gradient = buildGleamGradient(rng, angleOffset);

      // Determine target faces: child faces or the card itself
      var isSelfFace = SELF_FACE_CLASSES.some(function(cls) { return card.classList.contains(cls); });
      var faces = isSelfFace ? [card] : Array.from(card.querySelectorAll(FACE_SELECTORS));
      if (!faces.length) return;

      faces.forEach(function(face) {
        if (face.querySelector('.card-gleam-layer')) return;

        var gleam = document.createElement('div');
        gleam.className = 'card-gleam-layer';
        gleam.style.setProperty('--gleam-opacity-multiplier', opacityMult.toFixed(2));
        gleam.style.backgroundImage = gradient;
        gleam._gleamOffset = posOffset; // per-card position offset for variety

        // Wrap gleam in a non-rotating clip container so overflow:hidden
        // clips the rotating gleam to the face boundary (clip-path on the
        // gleam itself would rotate with it, making motion invisible)
        var clip = document.createElement('div');
        clip.className = 'card-gleam-clip';
        clip.appendChild(gleam);
        face.insertBefore(clip, face.firstChild);

        // Register with global gleam controller (all bands move in sync)
        registerGleam(gleam);
      });
    }

    /** Bulk-apply to all card elements in the DOM. */
    function initAllCardGleams() {
      document.querySelectorAll('.sb-card, .authorship-card, .mode-card, .tier-card, .character-tarot-card, .pact-card').forEach(applyCardGleam);
    }

    // Expose globally for dynamic card creation
    window.applyCardGleam = applyCardGleam;
    window.initAllCardGleams = initAllCardGleams;

    /**
     * Apply a gleam layer to an arbitrary element (e.g., flavor buttons).
     * Reads the parent card's existing gleam gradient and applies it with an offset.
     * @param {HTMLElement} el - Target element (needs position:relative; overflow:hidden in CSS)
     * @param {number} extraOffset - Additional px offset from the card's gleam
     */
    window.applyGleamToElement = function(el, extraOffset) {
      if (!el || el.querySelector('.card-gleam-clip')) return;
      var sbCard = el.closest('.sb-card');
      var cardGleam = sbCard ? sbCard.querySelector('.card-gleam-layer') : null;
      var gradient = cardGleam ? cardGleam.style.backgroundImage : '';
      var opacity = cardGleam ? cardGleam.style.getPropertyValue('--gleam-opacity-multiplier') : '0.85';
      var cardOffset = cardGleam ? (cardGleam._gleamOffset || 0) : 0;

      var clip = document.createElement('div');
      clip.className = 'card-gleam-clip';
      var gleam = document.createElement('div');
      gleam.className = 'card-gleam-layer';
      gleam._gleamOffset = cardOffset + (extraOffset || 0);
      if (gradient) gleam.style.backgroundImage = gradient;
      gleam.style.setProperty('--gleam-opacity-multiplier', opacity);
      clip.appendChild(gleam);
      el.insertBefore(clip, el.firstChild);
      registerGleam(gleam);
    };

    // Apply to static HTML cards on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initAllCardGleams);
    } else {
      initAllCardGleams();
    }
  })();

  function renderArchetypeCards() {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid) return;

      grid.innerHTML = '';
      lastZoomedArchetype = null;
      archetypeCardsRevealed = false;

      // Stop any previous last-zoomed sparkle emitter
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }

      // Render 7 archetype cards (start face-down, reveal together after delay)
      ARCHETYPE_ORDER.forEach(id => {
          const arch = ARCHETYPES[id];
          if (!arch) return;

          const card = document.createElement('div');
          card.className = 'sb-card archetype-card';
          card.dataset.archetype = id;
          card.dataset.grp = 'archetype';
          card.dataset.val = id;

          // If explicitly selected (user chose, not just default), show as selected+flipped
          // Destiny's Choice: mask is SECRET â€” all cards stay face-down, no selection shown
          const hasExplicitSelection = corridorSelections.has('storybeau') || corridorSelections.has('archetype');
          if (hasExplicitSelection && state.archetype.primary === id && !archetypeSelectedViaDestiny) {
              card.classList.add('selected', 'flipped');
              lastZoomedArchetype = id;
              archetypeCardsRevealed = true; // Skip auto-reveal if already selected
          }

          // Card structure: BACK = Black PNG art, FRONT = Gold PNG art + description (visible when zoomed)
          const resolvedDesireStyle = resolveLIPronouns(arch.desireStyle);

          card.innerHTML = `
              <div class="sb-card-inner">
                  <div class="sb-card-face sb-card-back" data-archetype="${id}"></div>
                  <div class="sb-card-face sb-card-front" data-archetype="${id}">
                      <span class="archetype-printed-desc">${resolvedDesireStyle}</span>
                  </div>
              </div>
          `;

          // NO hover listeners â€” cards don't flip on hover
          // CLICK opens zoom view only (does NOT select)
          card.addEventListener('click', () => handleArchetypeClick(card, id));

          grid.appendChild(card);
          if (window.applyCardGleam) window.applyCardGleam(card);
      });

      // Add Destiny's Choice card (slot 8)
      const destinyCard = document.createElement('div');
      destinyCard.className = 'sb-card archetype-card destiny-choice-card';
      destinyCard.id = 'destinyChoiceCard';
      destinyCard.dataset.grp = 'archetype';
      destinyCard.dataset.val = 'destiny';
      destinyCard.innerHTML = `
          <div class="destiny-stack-layer layer-5"></div>
          <div class="destiny-stack-layer layer-4"></div>
          <div class="destiny-stack-layer layer-3"></div>
          <div class="destiny-stack-layer layer-2"></div>
          <div class="sb-card-inner">
              <div class="sb-card-face sb-card-back destiny-choice-back">
                  <span class="sb-card-title">Destiny's Choice</span>
                  <div class="destiny-choice-sparkle-container" id="destinyChoiceSparkles"></div>
              </div>
              <div class="sb-card-face sb-card-front destiny-choice-front">
                  <span class="sb-card-title">Destiny's Choice</span>
                  <div class="destiny-embossed-nameplate">
                      <div class="destiny-embossed-line"></div>
                      <div class="destiny-embossed-line"></div>
                  </div>
              </div>
          </div>
      `;

      // Destiny's Choice click triggers selection sequence
      destinyCard.addEventListener('click', () => triggerDestinyChoiceSequence());

      grid.appendChild(destinyCard);
      if (window.applyCardGleam) window.applyCardGleam(destinyCard);

      // Start sparkles on Destiny's Choice card in archetype grid
      setTimeout(() => startSparkleEmitter('destinyChoiceSparkles', 'destinyDeck', 3), 100);

      // Schedule automatic reveal of all archetype cards (after row mount delay)
      if (!archetypeCardsRevealed) {
          scheduleArchetypeReveal();
      }
  }

  /**
   * Schedule automatic reveal of all archetype cards
   * All 7 cards flip together after 600-1000ms delay
   * Only reveals if the archetype row is currently active/visible
   */
  function scheduleArchetypeReveal() {
      const revealDelay = 600 + Math.random() * 400; // 600-1000ms
      setTimeout(() => {
          if (archetypeCardsRevealed) return; // Already revealed or selected
          // Only reveal if archetype row is active
          const grid = document.getElementById('archetypeCardGrid');
          if (grid && grid.classList.contains('corridor-active')) {
              revealAllArchetypeCards();
          }
      }, revealDelay);
  }

  /**
   * Trigger archetype reveal when storybeau row becomes active
   * Called from updateCorridorVisibility or when navigating to storybeau
   * Handles both initial reveal AND back-navigation restoration
   */
  function onArchetypeRowMount() {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid) return;

      // Check if cards need to be restored (back-navigation after Destiny's Choice dissolved them)
      const currentCardCount = grid.querySelectorAll('.archetype-card:not(.destiny-choice-card)').length;
      const expectedCardCount = ARCHETYPE_ORDER ? ARCHETYPE_ORDER.length : 7;
      const needsRestoration = currentCardCount < expectedCardCount;

      if (needsRestoration) {
          console.log('[Archetype] Cards missing â€” restoring for back-navigation');
          // Re-render all archetype cards (this will mark selected one and reset state)
          renderArchetypeCards();
          // Destiny's Choice: mask is SECRET â€” no sparkles, no face, just backs like the others
          if (state.archetype && state.archetype.primary && !archetypeSelectedViaDestiny) {
              const selectedId = state.archetype.primary;
              lastZoomedArchetype = selectedId;
              // Start sparkles on selected card after a brief delay for DOM update
              setTimeout(() => {
                  startLastZoomedSparkles();
              }, 100);
          }
          return;
      }

      // First visit - reveal cards if not yet revealed
      if (!archetypeCardsRevealed) {
          scheduleArchetypeReveal();
      } else if (state.archetype && state.archetype.primary) {
          // Cards already revealed, but ensure sparkles on selected card
          const selectedId = state.archetype.primary;
          if (lastZoomedArchetype !== selectedId) {
              lastZoomedArchetype = selectedId;
          }
          startLastZoomedSparkles();
      }
  }

  // Expose for corridor system
  window.onArchetypeRowMount = onArchetypeRowMount;

  /**
   * Reveal all 7 archetype cards SIMULTANEOUSLY
   * Cards flip from back to front TOGETHER â€” no stagger
   * Spec: "Cards ALWAYS reveal together (never one by one)"
   */
  function revealAllArchetypeCards() {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid) return;

      archetypeCardsRevealed = true;

      // Flip ALL cards at the exact same moment â€” no stagger
      const cards = grid.querySelectorAll('.archetype-card:not(.destiny-choice-card)');
      cards.forEach(card => {
          card.classList.add('flipped');
      });

      console.log('[Archetype] All cards revealed TOGETHER');
  }

  /**
   * Handle archetype card click â€” opens zoom view only (no selection)
   * Cards are already revealed (flipped) on row entry
   * Selection happens via Continue button using lastZoomedArchetype
   */
  function handleArchetypeClick(card, archetypeId) {
      // If already zoomed, ignore (don't re-open same card)
      if (card.classList.contains('zoomed')) return;

      // Open zoom overlay for this archetype
      openArchetypeOverlay(archetypeId);

      // Track as last-zoomed (for Continue button selection)
      setLastZoomedArchetype(archetypeId);
  }

  /**
   * Set the last-zoomed archetype and start sparkle indicator
   * Called when zoom view is opened for an archetype
   */
  function setLastZoomedArchetype(archetypeId) {
      // Stop previous sparkle emitter
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }

      // Clear previous focus indicator
      const prevFocused = document.querySelector('.archetype-card.last-zoomed');
      if (prevFocused) {
          prevFocused.classList.remove('last-zoomed');
          const prevSparkleContainer = prevFocused.querySelector('.archetype-focus-sparkles');
          if (prevSparkleContainer) prevSparkleContainer.remove();
      }

      lastZoomedArchetype = archetypeId;

      // Update Continue button visibility
      if (typeof updateCorridorContinueButtonVisibility === 'function') {
          updateCorridorContinueButtonVisibility();
      }
  }

  /**
   * Start sparkle emitter on last-zoomed card after zoom exit
   * Called when archetype zoom overlay is closed
   */
  function startLastZoomedSparkles() {
      if (!lastZoomedArchetype) return;

      const card = document.querySelector(
          `#archetypeCardGrid .archetype-card[data-archetype="${lastZoomedArchetype}"]`
      );
      if (!card) return;

      // Add focus indicator class
      card.classList.add('last-zoomed');

      // Create sparkle container if not exists
      let sparkleContainer = card.querySelector('.archetype-focus-sparkles');
      if (!sparkleContainer) {
          sparkleContainer = document.createElement('div');
          sparkleContainer.className = 'archetype-focus-sparkles';
          sparkleContainer.id = `archetypeFocusSparkles_${lastZoomedArchetype}`;
          card.appendChild(sparkleContainer);
      }

      // Start sparkle emitter on selected archetype card (high intensity when all masks visible)
      lastZoomedSparkleEmitterId = sparkleContainer.id;
      startSparkleEmitter(sparkleContainer.id, 'destinyDeck', 18);
  }

  /**
   * Select archetype via Continue button
   * Called when Continue is pressed with a flipped card
   */
  function commitArchetypeSelection(archetypeId, viaDestiny = false) {
      state.archetype.primary = archetypeId;
      state.archetype.modifier = null; // Modifier assigned silently at generation time
      archetypeSelectedViaDestiny = viaDestiny;
      deriveToneBias();

      // STORY-DEFINING INPUT: Invalidate snapshot â†’ forces "Begin Story"
      if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();

      // Clear cover shape hash â€” selection changed, enable regeneration
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();

      // Update visual states
      updateArchetypeCardStates();

      // Increment DSP activation count (explicit Story Shape choice)
      incrementDSPActivation();
      updateSynopsisPanel(true);

      console.log(`[Archetype] Committed: ${archetypeId} (via ${viaDestiny ? 'Destiny' : 'Continue'})`);
  }

  /**
   * Trigger Destiny's Choice animation sequence
   * 1. Archetype cards animate inward to Destiny's Choice position
   * 2. Optional shuffle overlap
   * 3. One card emerges with unmarked back
   * 4. Remaining cards dissolve into sparkles
   * 5. Destiny's Choice deck dissipates
   * 6. Unmarked card moves to breadcrumb (mask icon only)
   */
  async function triggerDestinyChoiceSequence() {
      const grid = document.getElementById('archetypeCardGrid');
      const destinyCard = document.getElementById('destinyChoiceCard');
      if (!grid || !destinyCard) return;

      // Stop sparkle emitters (Destiny's Choice and any focus sparkles)
      stopSparkleEmitter('destinyChoiceSparkles');
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }
      // Remove focus indicator from any last-zoomed card
      const focusedCard = document.querySelector('.archetype-card.last-zoomed');
      if (focusedCard) {
          focusedCard.classList.remove('last-zoomed');
          const sparkleContainer = focusedCard.querySelector('.archetype-focus-sparkles');
          if (sparkleContainer) sparkleContainer.remove();
      }

      const archetypeCards = grid.querySelectorAll('.archetype-card:not(.destiny-choice-card)');
      const destinyRect = destinyCard.getBoundingClientRect();
      const destinyCenter = {
          x: destinyRect.left + destinyRect.width / 2,
          y: destinyRect.top + destinyRect.height / 2
      };

      // Select archetype weighted by romance vector
      const chosenId = weightedArchetypeSelection();
      const chosenCard = grid.querySelector(`.archetype-card[data-archetype="${chosenId}"]`);

      // Capture original positions before any transforms
      const cardPositions = new Map();
      archetypeCards.forEach(card => {
          const rect = card.getBoundingClientRect();
          cardPositions.set(card, {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
          });
      });

      // STEP 1: Flip all cards face-down
      archetypeCards.forEach(card => {
          card.classList.remove('flipped');
      });

      await new Promise(r => setTimeout(r, 500));

      // STEP 2: Slide all cards UNDER the Destiny deck at current size
      // Set Destiny deck z-index high so cards slide underneath
      destinyCard.style.zIndex = '300';

      archetypeCards.forEach((card, idx) => {
          const pos = cardPositions.get(card);
          const translateX = destinyCenter.x - pos.x;
          const translateY = destinyCenter.y - pos.y;

          card.style.transition = `transform ${0.5 + idx * 0.05}s ease-in-out`;
          card.style.transform = `translate(${translateX}px, ${translateY}px)`;
          card.style.zIndex = `${50 + idx}`; // Below Destiny deck (z:300)
      });

      await new Promise(r => setTimeout(r, 800));

      // STEP 3: Brief pause â€” cards stacked under deck
      await new Promise(r => setTimeout(r, 300));

      // STEP 4: Chosen card pops up from top of deck
      if (chosenCard) {
          // Make back show as unmarked
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle) {
              backTitle.dataset.originalText = backTitle.textContent;
              backTitle.textContent = '?';
          }

          chosenCard.classList.add('destiny-chosen');
          chosenCard.style.zIndex = '400'; // Above Destiny deck
          chosenCard.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
          // Pop upward from deck position
          const pos = cardPositions.get(chosenCard);
          const deckOffX = destinyCenter.x - pos.x;
          const deckOffY = destinyCenter.y - pos.y;
          chosenCard.style.transform = `translate(${deckOffX}px, ${deckOffY - 80}px)`;
      }

      await new Promise(r => setTimeout(r, 600));

      // STEP 5: Card stays face-down â€” Destiny's mask is a secret
      await new Promise(r => setTimeout(r, 400));

      // STEP 6: Commit the selection
      commitArchetypeSelection(chosenId, true);

      // STEP 7: Other cards + Destiny deck dissolve
      archetypeCards.forEach(card => {
          if (card === chosenCard) return;
          card.classList.add('dissolving');
          card.style.transition = 'opacity 0.5s ease-out';
          card.style.opacity = '0';
      });
      destinyCard.classList.add('dissolving');
      destinyCard.style.transition = 'opacity 0.5s ease-out';
      destinyCard.style.opacity = '0';

      await new Promise(r => setTimeout(r, 300));

      // STEP 8: Slide chosen card to CENTER of corridor
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const archGhostIdx = STAGE_INDEX['storybeau'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${archGhostIdx}"]`);

      // Compute breadcrumb target position for later sparkle travel
      let targetX, targetY;
      if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          targetX = ghostRect.left + ghostRect.width / 2;
          targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
          const brRect = breadcrumbRow.getBoundingClientRect();
          targetX = brRect.left + brRect.width / 2;
          targetY = brRect.top + brRect.height / 2;
      }

      // Slide card to corridor center (viewport center)
      const corridorCenterX = window.innerWidth / 2;
      const corridorCenterY = window.innerHeight / 2;

      if (chosenCard) {
          const pos = cardPositions.get(chosenCard);
          const toCenterX = corridorCenterX - pos.x;
          const toCenterY = corridorCenterY - pos.y;
          chosenCard.style.transition = 'transform 0.6s ease-in-out';
          chosenCard.style.transform = `translate(${toCenterX}px, ${toCenterY}px)`;
      }

      await new Promise(r => setTimeout(r, 700));

      // Lock chosen card to its current visual position (position:fixed) BEFORE
      // removing dissolved cards â€” grid reflow would shift its natural position
      // and cause the transform-based placement to jump.
      if (chosenCard) {
          const lockedRect = chosenCard.getBoundingClientRect();
          chosenCard.style.position = 'fixed';
          chosenCard.style.left = lockedRect.left + 'px';
          chosenCard.style.top = lockedRect.top + 'px';
          chosenCard.style.width = lockedRect.width + 'px';
          chosenCard.style.height = lockedRect.height + 'px';
          chosenCard.style.transform = 'none';
          chosenCard.style.margin = '0';
      }

      // Clean up dissolved cards from DOM (card is now position:fixed, immune to reflow)
      grid.querySelectorAll('.dissolving').forEach(el => el.remove());

      // STEP 9: Sparkle teleport from corridor center to breadcrumb
      if (chosenCard && targetX !== undefined) {
          const cardRect = chosenCard.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;

          // Phase 1: Dissolution sparkles from card surface
          chosenCard.style.transition = 'opacity 0.3s ease-out';
          chosenCard.style.opacity = '0.2';

          const dissolutionCount = 14 + Math.floor(Math.random() * 6);
          for (let i = 0; i < dissolutionCount; i++) {
              setTimeout(() => {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'dissolution-sparkle';
                  const sx = cardRect.left + Math.random() * cardRect.width;
                  const sy = cardRect.top + Math.random() * cardRect.height;
                  sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 400);
              }, i * 25);
          }

          // Phase 2: Traveling sparkles arc from card center to breadcrumb
          setTimeout(() => {
              const travelCount = 8 + Math.floor(Math.random() * 4);
              for (let i = 0; i < travelCount; i++) {
                  setTimeout(() => {
                      const sparkle = document.createElement('div');
                      sparkle.className = 'traveling-sparkle';
                      const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
                      const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
                      const sx = cardCenterX + offX;
                      const sy = cardCenterY + offY;
                      const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
                      const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
                      sparkle.style.cssText = `
                          left: ${sx}px; top: ${sy}px;
                          --target-x: ${targetX - sx}px;
                          --target-y: ${targetY - sy}px;
                          --arc-x: ${midX - sx}px;
                          --arc-y: ${midY - sy}px;
                      `;
                      document.body.appendChild(sparkle);
                      setTimeout(() => sparkle.remove(), 600);
                  }, i * 45);
              }
          }, 200);

          // Phase 3: Convergence sparkles + breadcrumb creation
          await new Promise(r => setTimeout(r, 700));

          // Hide the card fully
          chosenCard.style.opacity = '0';

          // Convergence sparkles at breadcrumb position
          for (let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.className = 'convergence-sparkle';
              const angle = (Math.PI * 2 * i) / 6;
              const dist = 18 + Math.random() * 12;
              sparkle.style.cssText = `
                  left: ${targetX + Math.cos(angle) * dist}px;
                  top: ${targetY + Math.sin(angle) * dist}px;
              `;
              document.body.appendChild(sparkle);
              setTimeout(() => sparkle.remove(), 500);
          }
      }

      // Restore chosen card state
      if (chosenCard) {
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle && backTitle.dataset.originalText) {
              backTitle.textContent = backTitle.dataset.originalText;
          }
          chosenCard.style.transform = '';
          chosenCard.style.zIndex = '';
          chosenCard.style.opacity = '';
          chosenCard.style.transition = '';
          chosenCard.style.position = '';
          chosenCard.style.left = '';
          chosenCard.style.top = '';
          chosenCard.style.width = '';
          chosenCard.style.height = '';
          chosenCard.style.margin = '';
      }

      // STEP 10: Create breadcrumb with Destiny's Choice back PNG
      createArchetypeBreadcrumbWithMask(chosenId, true);

      // Advance corridor
      if (typeof hideCorridorContinueButton === 'function') {
          hideCorridorContinueButton('storybeau');
      }
      if (typeof advanceCorridorRow === 'function') {
          advanceCorridorRow();
      }

      console.log(`[Destiny's Choice] Selected: ${chosenId}`);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PRESSURE DESTINY'S CHOICE â€” Random Pull + Flavor Selection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async function triggerPressureDestinySequence() {
      const grid = document.getElementById('pressureGrid');
      const destinyCard = document.getElementById('pressureDestinyChoiceCard');
      if (!grid || !destinyCard) return;

      // Stop sparkle emitter on Destiny card
      if (typeof stopSparkleEmitter === 'function') {
          stopSparkleEmitter('pressureDestinySparkles');
      }

      const pressureCards = grid.querySelectorAll('.sb-card[data-grp="pressure"]:not(.destiny-choice-card)');
      const destinyRect = destinyCard.getBoundingClientRect();
      const destinyCenter = {
          x: destinyRect.left + destinyRect.width / 2,
          y: destinyRect.top + destinyRect.height / 2
      };

      // Randomly select a pressure category AND a flavor (visible pulls only)
      const pressureKeys = Array.from(VISIBLE_PULLS);
      const randomPressureIdx = Math.floor(Math.random() * pressureKeys.length);
      const chosenPressure = pressureKeys[randomPressureIdx];
      const chosenFlavors = PRESSURE_FLAVORS[chosenPressure];
      const randomFlavorIdx = Math.floor(Math.random() * chosenFlavors.length);
      const chosenFlavor = chosenFlavors[randomFlavorIdx];

      const chosenCard = grid.querySelector(`.sb-card[data-grp="pressure"][data-val="${chosenPressure}"]`);

      // Capture original positions
      const cardPositions = new Map();
      pressureCards.forEach(card => {
          const rect = card.getBoundingClientRect();
          cardPositions.set(card, {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
          });
      });

      // STEP 1: Flip all cards face-down
      pressureCards.forEach(card => {
          card.classList.remove('flipped', 'selected');
      });

      await new Promise(r => setTimeout(r, 500));

      // STEP 2: Slide all cards UNDER the Destiny deck
      destinyCard.style.zIndex = '300';

      pressureCards.forEach((card, idx) => {
          const pos = cardPositions.get(card);
          const translateX = destinyCenter.x - pos.x;
          const translateY = destinyCenter.y - pos.y;

          card.style.transition = `transform ${0.5 + idx * 0.05}s ease-in-out`;
          card.style.transform = `translate(${translateX}px, ${translateY}px)`;
          card.style.zIndex = `${50 + idx}`;
      });

      await new Promise(r => setTimeout(r, 800));

      // STEP 3: Brief pause
      await new Promise(r => setTimeout(r, 300));

      // STEP 4: Chosen card pops up from deck
      if (chosenCard) {
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle) {
              backTitle.dataset.originalText = backTitle.textContent;
              backTitle.textContent = '?';
          }

          chosenCard.classList.add('destiny-chosen');
          chosenCard.style.zIndex = '400';
          chosenCard.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
          const pos = cardPositions.get(chosenCard);
          const deckOffX = destinyCenter.x - pos.x;
          const deckOffY = destinyCenter.y - pos.y;
          chosenCard.style.transform = `translate(${deckOffX}px, ${deckOffY - 80}px)`;
      }

      await new Promise(r => setTimeout(r, 600));

      // STEP 5: Card stays face-down â€” Destiny's mask is a secret
      await new Promise(r => setTimeout(r, 400));

      // STEP 6: Commit the selection (secretly)
      state.picks.pressure = chosenPressure;
      state.picks.flavor = chosenFlavor.id;
      state.picks.genre = getEffectiveGenre(chosenPressure, chosenFlavor.id);
      pressureSelectedViaDestiny = true;
      if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();
      incrementDSPActivation();
      updateSynopsisPanel(true);

      // STEP 7: Dissolve other cards + Destiny deck
      pressureCards.forEach(card => {
          if (card === chosenCard) return;
          card.classList.add('dissolving');
          card.style.transition = 'opacity 0.5s ease-out';
          card.style.opacity = '0';
      });
      destinyCard.classList.add('dissolving');
      destinyCard.style.transition = 'opacity 0.5s ease-out';
      destinyCard.style.opacity = '0';

      await new Promise(r => setTimeout(r, 300));

      // STEP 8: Slide chosen card to center of corridor
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const pressureGhostIdx = STAGE_INDEX['pressure'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${pressureGhostIdx}"]`);

      let targetX, targetY;
      if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          targetX = ghostRect.left + ghostRect.width / 2;
          targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
          const brRect = breadcrumbRow.getBoundingClientRect();
          targetX = brRect.left + brRect.width / 2;
          targetY = brRect.top + brRect.height / 2;
      }

      const corridorCenterX = window.innerWidth / 2;
      const corridorCenterY = window.innerHeight / 2;

      if (chosenCard) {
          const pos = cardPositions.get(chosenCard);
          const toCenterX = corridorCenterX - pos.x;
          const toCenterY = corridorCenterY - pos.y;
          chosenCard.style.transition = 'transform 0.6s ease-in-out';
          chosenCard.style.transform = `translate(${toCenterX}px, ${toCenterY}px)`;
      }

      await new Promise(r => setTimeout(r, 700));

      // Lock chosen card to fixed position before DOM cleanup
      if (chosenCard) {
          const lockedRect = chosenCard.getBoundingClientRect();
          chosenCard.style.position = 'fixed';
          chosenCard.style.left = lockedRect.left + 'px';
          chosenCard.style.top = lockedRect.top + 'px';
          chosenCard.style.width = lockedRect.width + 'px';
          chosenCard.style.height = lockedRect.height + 'px';
          chosenCard.style.transform = 'none';
          chosenCard.style.margin = '0';
      }

      // Remove dissolved cards from DOM
      grid.querySelectorAll('.dissolving').forEach(el => el.remove());

      // STEP 9: Sparkle teleport to breadcrumb
      if (chosenCard && targetX !== undefined) {
          const cardRect = chosenCard.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;

          // Phase 1: Dissolution sparkles
          chosenCard.style.transition = 'opacity 0.3s ease-out';
          chosenCard.style.opacity = '0.2';

          const dissolutionCount = 14 + Math.floor(Math.random() * 6);
          for (let i = 0; i < dissolutionCount; i++) {
              setTimeout(() => {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'dissolution-sparkle';
                  const sx = cardRect.left + Math.random() * cardRect.width;
                  const sy = cardRect.top + Math.random() * cardRect.height;
                  sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 400);
              }, i * 25);
          }

          // Phase 2: Traveling sparkles
          setTimeout(() => {
              const travelCount = 8 + Math.floor(Math.random() * 4);
              for (let i = 0; i < travelCount; i++) {
                  setTimeout(() => {
                      const sparkle = document.createElement('div');
                      sparkle.className = 'traveling-sparkle';
                      const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
                      const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
                      const sx = cardCenterX + offX;
                      const sy = cardCenterY + offY;
                      const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
                      const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
                      sparkle.style.cssText = `
                          left: ${sx}px; top: ${sy}px;
                          --target-x: ${targetX - sx}px;
                          --target-y: ${targetY - sy}px;
                          --arc-x: ${midX - sx}px;
                          --arc-y: ${midY - sy}px;
                      `;
                      document.body.appendChild(sparkle);
                      setTimeout(() => sparkle.remove(), 600);
                  }, i * 45);
              }
          }, 200);

          // Phase 3: Convergence sparkles + breadcrumb
          await new Promise(r => setTimeout(r, 700));

          chosenCard.style.opacity = '0';

          for (let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.className = 'convergence-sparkle';
              const angle = (Math.PI * 2 * i) / 6;
              const dist = 18 + Math.random() * 12;
              sparkle.style.cssText = `
                  left: ${targetX + Math.cos(angle) * dist}px;
                  top: ${targetY + Math.sin(angle) * dist}px;
              `;
              document.body.appendChild(sparkle);
              setTimeout(() => sparkle.remove(), 500);
          }
      }

      // Restore chosen card state
      if (chosenCard) {
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle && backTitle.dataset.originalText) {
              backTitle.textContent = backTitle.dataset.originalText;
          }
          chosenCard.style.transform = '';
          chosenCard.style.zIndex = '';
          chosenCard.style.opacity = '';
          chosenCard.style.transition = '';
          chosenCard.style.position = '';
          chosenCard.style.left = '';
          chosenCard.style.top = '';
          chosenCard.style.width = '';
          chosenCard.style.height = '';
          chosenCard.style.margin = '';
      }

      // STEP 10: Create breadcrumb with Destiny's Choice mask
      createPressureBreadcrumbWithMask(chosenPressure, chosenFlavor.id);

      // Advance corridor
      if (typeof hideCorridorContinueButton === 'function') {
          hideCorridorContinueButton('pressure');
      }
      if (typeof advanceCorridorRow === 'function') {
          advanceCorridorRow();
      }

      console.log(`[Pressure Destiny] Selected: ${chosenPressure} / ${chosenFlavor.id}`);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DYNAMIC/POLARITY DESTINY'S CHOICE â€” Random Polarity Selection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async function triggerDynamicDestinySequence() {
      const dynamicGrid = document.getElementById('dynamicGrid');
      const destinyCard = document.getElementById('dynamicDestinyChoiceCard');
      if (!dynamicGrid || !destinyCard) return;

      if (typeof stopSparkleEmitter === 'function') {
          stopSparkleEmitter('dynamicDestinySparkles');
      }

      const dynamicCards = dynamicGrid.querySelectorAll('.sb-card[data-grp="dynamic"]:not(.destiny-choice-card)');
      const destinyRect = destinyCard.getBoundingClientRect();
      const destinyCenter = {
          x: destinyRect.left + destinyRect.width / 2,
          y: destinyRect.top + destinyRect.height / 2
      };

      // Collect all dynamic vals for random selection
      const dynamicVals = [];
      dynamicCards.forEach(c => { if (c.dataset.val) dynamicVals.push(c.dataset.val); });
      const randomIdx = Math.floor(Math.random() * dynamicVals.length);
      const chosenVal = dynamicVals[randomIdx];
      const chosenCard = dynamicGrid.querySelector(`.sb-card[data-grp="dynamic"][data-val="${chosenVal}"]`);

      // Capture original positions
      const cardPositions = new Map();
      dynamicCards.forEach(card => {
          const rect = card.getBoundingClientRect();
          cardPositions.set(card, {
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2
          });
      });

      // STEP 1: Flip all cards face-down
      dynamicCards.forEach(card => {
          card.classList.remove('flipped', 'selected');
      });

      await new Promise(r => setTimeout(r, 500));

      // STEP 2: Slide all under Destiny deck
      destinyCard.style.zIndex = '300';

      dynamicCards.forEach((card, idx) => {
          const pos = cardPositions.get(card);
          const translateX = destinyCenter.x - pos.x;
          const translateY = destinyCenter.y - pos.y;
          card.style.transition = `transform ${0.5 + idx * 0.05}s ease-in-out`;
          card.style.transform = `translate(${translateX}px, ${translateY}px)`;
          card.style.zIndex = `${50 + idx}`;
      });

      // Also hide group labels during animation
      dynamicGrid.querySelectorAll('.dynamic-group-label').forEach(lbl => {
          lbl.style.transition = 'opacity 0.4s ease-out';
          lbl.style.opacity = '0';
      });

      await new Promise(r => setTimeout(r, 800));
      await new Promise(r => setTimeout(r, 300));

      // STEP 4: Chosen card pops up
      if (chosenCard) {
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle) {
              backTitle.dataset.originalText = backTitle.textContent;
              backTitle.textContent = '?';
          }
          chosenCard.classList.add('destiny-chosen');
          chosenCard.style.zIndex = '400';
          chosenCard.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
          const pos = cardPositions.get(chosenCard);
          const deckOffX = destinyCenter.x - pos.x;
          const deckOffY = destinyCenter.y - pos.y;
          chosenCard.style.transform = `translate(${deckOffX}px, ${deckOffY - 80}px)`;
      }

      await new Promise(r => setTimeout(r, 600));
      await new Promise(r => setTimeout(r, 400));

      // STEP 6: Commit
      state.picks.dynamic = chosenVal;
      dynamicSelectedViaDestiny = true;
      if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();
      if (window.clearCoverShapeHash) window.clearCoverShapeHash();
      incrementDSPActivation();
      updateSynopsisPanel(true);

      // STEP 7: Dissolve others + Destiny deck
      dynamicCards.forEach(card => {
          if (card === chosenCard) return;
          card.classList.add('dissolving');
          card.style.transition = 'opacity 0.5s ease-out';
          card.style.opacity = '0';
      });
      destinyCard.classList.add('dissolving');
      destinyCard.style.transition = 'opacity 0.5s ease-out';
      destinyCard.style.opacity = '0';

      await new Promise(r => setTimeout(r, 300));

      // STEP 8: Slide chosen to center
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const dynamicGhostIdx = STAGE_INDEX['dynamic'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${dynamicGhostIdx}"]`);

      let targetX, targetY;
      if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          targetX = ghostRect.left + ghostRect.width / 2;
          targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
          const brRect = breadcrumbRow.getBoundingClientRect();
          targetX = brRect.left + brRect.width / 2;
          targetY = brRect.top + brRect.height / 2;
      }

      const corridorCenterX = window.innerWidth / 2;
      const corridorCenterY = window.innerHeight / 2;

      if (chosenCard) {
          const pos = cardPositions.get(chosenCard);
          const toCenterX = corridorCenterX - pos.x;
          const toCenterY = corridorCenterY - pos.y;
          chosenCard.style.transition = 'transform 0.6s ease-in-out';
          chosenCard.style.transform = `translate(${toCenterX}px, ${toCenterY}px)`;
      }

      await new Promise(r => setTimeout(r, 700));

      // Lock position before DOM cleanup
      if (chosenCard) {
          const lockedRect = chosenCard.getBoundingClientRect();
          chosenCard.style.position = 'fixed';
          chosenCard.style.left = lockedRect.left + 'px';
          chosenCard.style.top = lockedRect.top + 'px';
          chosenCard.style.width = lockedRect.width + 'px';
          chosenCard.style.height = lockedRect.height + 'px';
          chosenCard.style.transform = 'none';
          chosenCard.style.margin = '0';
      }

      // Remove dissolved cards
      dynamicGrid.querySelectorAll('.dissolving').forEach(el => el.remove());

      // STEP 9: Sparkle teleport
      if (chosenCard && targetX !== undefined) {
          const cardRect = chosenCard.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;

          chosenCard.style.transition = 'opacity 0.3s ease-out';
          chosenCard.style.opacity = '0.2';

          const dissolutionCount = 14 + Math.floor(Math.random() * 6);
          for (let i = 0; i < dissolutionCount; i++) {
              setTimeout(() => {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'dissolution-sparkle';
                  const sx = cardRect.left + Math.random() * cardRect.width;
                  const sy = cardRect.top + Math.random() * cardRect.height;
                  sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 400);
              }, i * 25);
          }

          setTimeout(() => {
              const travelCount = 8 + Math.floor(Math.random() * 4);
              for (let i = 0; i < travelCount; i++) {
                  setTimeout(() => {
                      const sparkle = document.createElement('div');
                      sparkle.className = 'traveling-sparkle';
                      const offX = (Math.random() - 0.5) * cardRect.width * 0.5;
                      const offY = (Math.random() - 0.5) * cardRect.height * 0.5;
                      const sx = cardCenterX + offX;
                      const sy = cardCenterY + offY;
                      const midX = (sx + targetX) / 2 + (Math.random() - 0.5) * 80;
                      const midY = Math.min(sy, targetY) - 40 - Math.random() * 60;
                      sparkle.style.cssText = `
                          left: ${sx}px; top: ${sy}px;
                          --target-x: ${targetX - sx}px;
                          --target-y: ${targetY - sy}px;
                          --arc-x: ${midX - sx}px;
                          --arc-y: ${midY - sy}px;
                      `;
                      document.body.appendChild(sparkle);
                      setTimeout(() => sparkle.remove(), 600);
                  }, i * 45);
              }
          }, 200);

          await new Promise(r => setTimeout(r, 700));
          chosenCard.style.opacity = '0';

          for (let i = 0; i < 6; i++) {
              const sparkle = document.createElement('div');
              sparkle.className = 'convergence-sparkle';
              const angle = (Math.PI * 2 * i) / 6;
              const dist = 18 + Math.random() * 12;
              sparkle.style.cssText = `
                  left: ${targetX + Math.cos(angle) * dist}px;
                  top: ${targetY + Math.sin(angle) * dist}px;
              `;
              document.body.appendChild(sparkle);
              setTimeout(() => sparkle.remove(), 500);
          }
      }

      // Restore chosen card state
      if (chosenCard) {
          const backTitle = chosenCard.querySelector('.sb-card-back .sb-card-title');
          if (backTitle && backTitle.dataset.originalText) {
              backTitle.textContent = backTitle.dataset.originalText;
          }
          chosenCard.style.transform = '';
          chosenCard.style.zIndex = '';
          chosenCard.style.opacity = '';
          chosenCard.style.transition = '';
          chosenCard.style.position = '';
          chosenCard.style.left = '';
          chosenCard.style.top = '';
          chosenCard.style.width = '';
          chosenCard.style.height = '';
          chosenCard.style.margin = '';
      }

      // Restore group labels
      dynamicGrid.querySelectorAll('.dynamic-group-label').forEach(lbl => {
          lbl.style.opacity = '';
          lbl.style.transition = '';
      });

      // STEP 10: Create breadcrumb with Destiny's mask
      createDynamicBreadcrumbWithMask(chosenVal);

      if (typeof hideCorridorContinueButton === 'function') {
          hideCorridorContinueButton('dynamic');
      }
      if (typeof advanceCorridorRow === 'function') {
          advanceCorridorRow();
      }

      console.log(`[Dynamic Destiny] Selected: ${chosenVal}`);
  }

  /**
   * Create dynamic/polarity breadcrumb with Destiny's Choice mask
   */
  function createDynamicBreadcrumbWithMask(dynamicVal) {
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      if (!breadcrumbRow) return;

      const stageIdx = STAGE_INDEX['dynamic'];

      const existingCard = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="dynamic"]');
      if (existingCard) existingCard.remove();

      const card = document.createElement('div');
      card.className = 'breadcrumb-card destiny-choice-breadcrumb materializing';
      card.dataset.grp = 'dynamic';
      card.dataset.val = dynamicVal;
      card.dataset.stageIndex = stageIdx;
      card.dataset.breadcrumbLabel = "Destiny's Choice";
      card.style.backgroundImage = "url('/assets/card-art/cards/Romance-black-back-DC.png')";
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';

      card.addEventListener('click', () => {
          if (typeof navigateToBreadcrumb === 'function') navigateToBreadcrumb('dynamic');
      });

      const allSlots = breadcrumbRow.querySelectorAll('.breadcrumb-card, .ghost-step');
      let insertBefore = null;
      for (const slot of allSlots) {
          const slotIdx = parseInt(slot.dataset.stageIndex ?? slot.dataset.ghostIndex, 10);
          if (!isNaN(slotIdx) && slotIdx > stageIdx) {
              insertBefore = slot;
              break;
          }
      }
      if (insertBefore) {
          breadcrumbRow.insertBefore(card, insertBefore);
      } else {
          breadcrumbRow.appendChild(card);
      }

      if (stageIdx !== undefined && stageIdx >= 0) {
          if (typeof removeGhostStep === 'function') removeGhostStep(stageIdx);
      }

      setTimeout(() => card.classList.remove('materializing'), 400);

      if (typeof attachBreadcrumbNavigation === 'function') {
          attachBreadcrumbNavigation(card);
      }

      updateActiveBreadcrumbSparkles(card);

      corridorSelections.set('dynamic', dynamicVal);
      console.log(`[Breadcrumb] Created Destiny mask for dynamic: ${dynamicVal}`);
  }

  /**
   * Spawn a dissolve sparkle relative to archetype grid
   * Uses global sparkle variance rules:
   * - Size variance: 0.85-1.15 scale factor
   * - Lifetime variance: Â±10%
   * - Micro drift angle variance: Â±5-8Â°
   */
  function spawnSparkleAt(card) {
      const grid = document.getElementById('archetypeCardGrid');
      if (!grid || !card) return;

      // Ensure grid has relative positioning for sparkles
      if (getComputedStyle(grid).position === 'static') {
          grid.style.position = 'relative';
      }

      const sparkle = document.createElement('div');
      sparkle.className = 'destiny-dissolve-sparkle';

      // Get card position relative to grid
      const gridRect = grid.getBoundingClientRect();
      const cardRect = card.getBoundingClientRect();
      const relativeX = cardRect.left - gridRect.left + cardRect.width / 2;
      const relativeY = cardRect.top - gridRect.top + cardRect.height / 2;

      sparkle.style.left = `${relativeX}px`;
      sparkle.style.top = `${relativeY}px`;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // GLOBAL SPARKLE VARIANCE RULES:
      // 1. Size variance: 0.85-1.15 scale factor
      // 2. Lifetime variance: Â±10%
      // 3. Micro drift angle variance: Â±5-8Â°
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Size variance
      const sizeVariance = 0.85 + Math.random() * 0.3; // 0.85 to 1.15
      const baseSize = 8;
      const size = baseSize * sizeVariance;

      // Lifetime variance (Â±10%)
      const baseDuration = 600;
      const lifetimeVariance = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
      const duration = baseDuration * lifetimeVariance + Math.random() * 400;

      // Drift with micro angle variance (Â±5-8Â°)
      const angleVariance = (Math.random() - 0.5) * 0.14; // Â±0.07 radians (~4-8Â°)
      const baseDriftX = (Math.random() - 0.5) * 60;
      const baseDriftY = (Math.random() - 0.5) * 60 - 30; // Bias upward
      // Apply rotation to drift vector
      const driftX = baseDriftX * Math.cos(angleVariance) - baseDriftY * Math.sin(angleVariance);
      const driftY = baseDriftX * Math.sin(angleVariance) + baseDriftY * Math.cos(angleVariance);

      sparkle.style.width = `${size}px`;
      sparkle.style.height = `${size}px`;

      grid.appendChild(sparkle);

      sparkle.animate([
          { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
          { transform: `translate(calc(-50% + ${driftX}px), calc(-50% + ${driftY}px)) scale(0)`, opacity: 0 }
      ], {
          duration: duration,
          easing: 'ease-out'
      }).onfinish = () => sparkle.remove();
  }

  /**
   * Create archetype breadcrumb with PNG art
   * viaDestiny=false: shows mask gold front PNG
   * viaDestiny=true: shows Destiny's Choice back PNG
   */
  function createArchetypeBreadcrumbWithMask(archetypeId, viaDestiny = false) {
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      if (!breadcrumbRow) return;

      const stageIdx = STAGE_INDEX['archetype'];

      // Check for existing breadcrumb and remove
      const existingCard = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="archetype"]');
      if (existingCard) existingCard.remove();

      // Map archetype ID to PNG filename
      const pngMap = {
          'HEART_WARDEN': 'Tarot-Gold-front-HeartWarden.png',
          'OPEN_VEIN': 'Tarot-Gold-front-OpenVein.png',
          'SPELLBINDER': 'Tarot-Gold-front-Spellbinder.png',
          'ARMORED_FOX': 'Tarot-Gold-front-AFox.png',
          'DARK_VICE': 'Tarot-Gold-front-DarkVice.png',
          'BEAUTIFUL_RUIN': 'Tarot-Gold-front-BRuin.png',
          'ETERNAL_FLAME': 'Tarot-Gold-front-EternalFlame.png'
      };
      const pngFile = viaDestiny
          ? 'Romance-black-back-DC.png'
          : (pngMap[archetypeId] || 'Tarot-Gold-front-HeartWarden.png');

      // Create breadcrumb with PNG art only (no mask icon, no text)
      const card = document.createElement('div');
      card.className = 'breadcrumb-card archetype-breadcrumb-png materializing';
      if (viaDestiny) card.classList.add('destiny-choice-breadcrumb');
      card.dataset.grp = 'archetype';
      card.dataset.val = archetypeId;
      card.dataset.stageIndex = stageIdx;
      card.dataset.breadcrumbLabel = viaDestiny ? "Destiny's Choice" : 'Archetype';
      card.style.backgroundImage = `url('/assets/card-art/cards/${pngFile}')`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';

      card.addEventListener('click', () => navigateToBreadcrumb('archetype'));

      // Insert breadcrumb at correct position using stage-index ordering
      // (insert BEFORE removing ghost step to prevent layout lurch)
      const allSlots = breadcrumbRow.querySelectorAll('.breadcrumb-card, .ghost-step');
      let insertBefore = null;
      for (const slot of allSlots) {
        const slotIdx = parseInt(slot.dataset.stageIndex ?? slot.dataset.ghostIndex, 10);
        if (!isNaN(slotIdx) && slotIdx > stageIdx) {
          insertBefore = slot;
          break;
        }
      }
      if (insertBefore) {
          breadcrumbRow.insertBefore(card, insertBefore);
      } else {
          breadcrumbRow.appendChild(card);
      }

      // NOW remove the ghost step (after breadcrumb is already in place)
      if (stageIdx !== undefined && stageIdx >= 0) {
          if (typeof removeGhostStep === 'function') removeGhostStep(stageIdx);
      }

      // Remove materializing class after animation
      setTimeout(() => card.classList.remove('materializing'), 400);

      // Attach destructive navigation handler
      if (typeof attachBreadcrumbNavigation === 'function') {
          attachBreadcrumbNavigation(card);
      }

      // Sparkles on the active breadcrumb
      updateActiveBreadcrumbSparkles(card);

      corridorSelections.set('storybeau', archetypeId);
      console.log(`[Breadcrumb] Created PNG card for archetype (${viaDestiny ? 'Destiny' : 'Continue'}): ${archetypeId}`);
  }

  /**
   * Create pressure breadcrumb with Destiny's Choice mask
   * Uses Romance-black-back-DC.png (no reveal of chosen pressure/flavor)
   */
  function createPressureBreadcrumbWithMask(pressureVal, flavorId) {
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      if (!breadcrumbRow) return;

      const stageIdx = STAGE_INDEX['pressure'];

      // Remove existing pressure breadcrumb
      const existingCard = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="pressure"]');
      if (existingCard) existingCard.remove();

      const card = document.createElement('div');
      card.className = 'breadcrumb-card destiny-choice-breadcrumb materializing';
      card.dataset.grp = 'pressure';
      card.dataset.val = pressureVal;
      card.dataset.stageIndex = stageIdx;
      card.dataset.breadcrumbLabel = "Destiny's Choice";
      card.style.backgroundImage = "url('/assets/card-art/cards/Romance-black-back-DC.png')";
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';

      card.addEventListener('click', () => {
          if (typeof navigateToBreadcrumb === 'function') navigateToBreadcrumb('pressure');
      });

      // Insert at correct position using stage-index ordering
      const allSlots = breadcrumbRow.querySelectorAll('.breadcrumb-card, .ghost-step');
      let insertBefore = null;
      for (const slot of allSlots) {
          const slotIdx = parseInt(slot.dataset.stageIndex ?? slot.dataset.ghostIndex, 10);
          if (!isNaN(slotIdx) && slotIdx > stageIdx) {
              insertBefore = slot;
              break;
          }
      }
      if (insertBefore) {
          breadcrumbRow.insertBefore(card, insertBefore);
      } else {
          breadcrumbRow.appendChild(card);
      }

      // Remove ghost step AFTER inserting breadcrumb
      if (stageIdx !== undefined && stageIdx >= 0) {
          if (typeof removeGhostStep === 'function') removeGhostStep(stageIdx);
      }

      setTimeout(() => card.classList.remove('materializing'), 400);

      if (typeof attachBreadcrumbNavigation === 'function') {
          attachBreadcrumbNavigation(card);
      }

      updateActiveBreadcrumbSparkles(card);

      corridorSelections.set('pressure', pressureVal);
      console.log(`[Breadcrumb] Created Destiny mask for pressure: ${pressureVal} / ${flavorId}`);
  }

  // Populate archetype card zoom view â€” primary archetype only, no modifier UI
  function populateArchetypeZoomContent(card, archetypeId) {
      const frontFace = card.querySelector('.sb-card-front');
      if (!frontFace) return;
      const existing = frontFace.querySelector('.sb-zoom-content');
      if (existing) existing.remove();
  }

  // STATE 3: Open zoomed view for archetype cards
  // PORTAL ARCHITECTURE: Card is MOVED into zoom portal
  // This breaks out of ALL ancestor stacking contexts and filters
  function openArchetypeOverlay(archetypeId) {
      const card = document.querySelector(`#archetypeCardGrid .sb-card[data-archetype="${archetypeId}"]`);
      const arch = ARCHETYPES[archetypeId];
      if (!card || !arch) return;

      // Close any currently zoomed card
      if (currentOpenCard && window.closeZoomedCard) {
          window.closeZoomedCard();
      }

      currentOpenCard = card;

      // Dim all other archetype cards
      document.querySelectorAll('#archetypeCardGrid .sb-card').forEach(c => {
          if (c !== card) c.classList.add('dimmed');
      });

      // Populate modifier selection content
      populateArchetypeZoomContent(card, archetypeId);

      // Get card position BEFORE moving to portal
      const rect = card.getBoundingClientRect();

      // Store original DOM position for restoration
      zoomOriginalParent = card.parentNode;
      zoomOriginalNextSibling = card.nextElementSibling;

      // Store original position for animation reference
      card.dataset.zoomOriginalLeft = rect.left;
      card.dataset.zoomOriginalTop = rect.top;
      card.dataset.zoomOriginalWidth = rect.width;
      card.dataset.zoomOriginalHeight = rect.height;

      // ARCHETYPE ZOOM: Use scale transform to preserve internal layout
      // Card has content (description, modifiers) that needs proportional scaling
      const padding = 60;
      const maxWidth = window.innerWidth - padding;
      const maxHeight = window.innerHeight - padding;
      const scaleByWidth = maxWidth / rect.width;
      const scaleByHeight = maxHeight / rect.height;
      const scale = Math.min(2.5, scaleByWidth, scaleByHeight);

      // PORTAL MOVE: Move card into zoom portal (breaks ALL ancestor contexts)
      if (zoomPortal) {
          zoomPortal.appendChild(card);
      }

      // Apply zoom styling - flexbox in portal handles centering
      card.classList.add('zoomed');
      card.style.width = `${rect.width}px`;
      card.style.height = `${rect.height}px`;
      card.style.transform = `scale(${scale})`;
      card.style.setProperty('--zoom-scale', scale);
      card.style.transformOrigin = 'center center';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';

      // Show backdrop
      if (zoomBackdrop) {
          zoomBackdrop.classList.add('active');
      }

      // Add sparkle emitter to zoomed card (anchored to card, not front face)
      {
          const sparkleContainer = document.createElement('div');
          sparkleContainer.className = 'zoom-card-sparkles';
          sparkleContainer.id = 'zoomCardSparkles';
          card.appendChild(sparkleContainer);
          startSparkleEmitter('zoomCardSparkles', 'zoomCard', 8);
      }

      // Add left/right navigation arrows to portal
      if (zoomPortal) {
          const currentIdx = ARCHETYPE_ORDER.indexOf(archetypeId);

          const leftArrow = document.createElement('div');
          leftArrow.className = 'zoom-nav-arrow zoom-nav-left';
          leftArrow.innerHTML = '&#8249;'; // â€¹
          leftArrow.addEventListener('click', (e) => {
              e.stopPropagation();
              const curId = currentOpenCard?.dataset.archetype;
              if (!curId) return;
              const idx = ARCHETYPE_ORDER.indexOf(curId);
              const prevIdx = (idx - 1 + ARCHETYPE_ORDER.length) % ARCHETYPE_ORDER.length;
              navigateZoomedArchetype(ARCHETYPE_ORDER[prevIdx]);
          });
          zoomPortal.appendChild(leftArrow);

          const rightArrow = document.createElement('div');
          rightArrow.className = 'zoom-nav-arrow zoom-nav-right';
          rightArrow.innerHTML = '&#8250;'; // â€º
          rightArrow.addEventListener('click', (e) => {
              e.stopPropagation();
              const curId = currentOpenCard?.dataset.archetype;
              if (!curId) return;
              const idx = ARCHETYPE_ORDER.indexOf(curId);
              const nextIdx = (idx + 1) % ARCHETYPE_ORDER.length;
              navigateZoomedArchetype(ARCHETYPE_ORDER[nextIdx]);
          });
          zoomPortal.appendChild(rightArrow);

          // Add Continue button below the zoomed card
          const zoomContinueBtn = document.createElement('button');
          zoomContinueBtn.className = 'zoom-continue-btn';
          zoomContinueBtn.textContent = 'Proceed';
          zoomContinueBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const curId = currentOpenCard?.dataset.archetype;
              if (!curId) return;
              commitArchetypeFromZoom(curId);
          });
          zoomPortal.appendChild(zoomContinueBtn);
      }
  }

  /**
   * Navigate between archetype cards while in zoom view
   * Swaps the zoomed card without closing the overlay
   */
  function navigateZoomedArchetype(newArchetypeId) {
      if (!currentOpenCard || !zoomPortal) return;

      const oldCard = currentOpenCard;
      const oldId = oldCard.dataset.archetype;
      if (oldId === newArchetypeId) return;

      // Find the new card in the grid (it's still in the grid since only oldCard is in portal)
      const newCard = document.querySelector(`#archetypeCardGrid .sb-card[data-archetype="${newArchetypeId}"]`);
      if (!newCard) return;

      // Stop old sparkle emitter
      stopSparkleEmitter('zoomCardSparkles');
      const oldSparkleEl = oldCard.querySelector('#zoomCardSparkles');
      if (oldSparkleEl) oldSparkleEl.remove();

      // Remove old zoom content
      const oldZoomContent = oldCard.querySelector('.sb-zoom-content');
      if (oldZoomContent) oldZoomContent.remove();

      // Restore old card to grid
      oldCard.classList.remove('zoomed');
      oldCard.style.transform = '';
      oldCard.style.transformOrigin = '';
      oldCard.style.width = '';
      oldCard.style.height = '';
      oldCard.style.position = '';
      if (zoomOriginalParent) {
          if (zoomOriginalNextSibling) {
              zoomOriginalParent.insertBefore(oldCard, zoomOriginalNextSibling);
          } else {
              zoomOriginalParent.appendChild(oldCard);
          }
      }
      delete oldCard.dataset.zoomOriginalLeft;
      delete oldCard.dataset.zoomOriginalTop;
      delete oldCard.dataset.zoomOriginalWidth;
      delete oldCard.dataset.zoomOriginalHeight;

      // Dim all cards, un-dim the new one
      document.querySelectorAll('#archetypeCardGrid .sb-card').forEach(c => {
          c.classList.toggle('dimmed', c !== newCard);
      });

      // Populate new card zoom content
      populateArchetypeZoomContent(newCard, newArchetypeId);

      // Store new card's position and move to portal
      const rect = newCard.getBoundingClientRect();
      zoomOriginalParent = newCard.parentNode;
      zoomOriginalNextSibling = newCard.nextElementSibling;
      newCard.dataset.zoomOriginalLeft = rect.left;
      newCard.dataset.zoomOriginalTop = rect.top;
      newCard.dataset.zoomOriginalWidth = rect.width;
      newCard.dataset.zoomOriginalHeight = rect.height;

      const padding = 60;
      const maxWidth = window.innerWidth - padding;
      const maxHeight = window.innerHeight - padding;
      const scaleByWidth = maxWidth / rect.width;
      const scaleByHeight = maxHeight / rect.height;
      const scale = Math.min(2.5, scaleByWidth, scaleByHeight);

      // Insert card BEFORE the nav arrows (first child position)
      const firstArrow = zoomPortal.querySelector('.zoom-nav-arrow');
      if (firstArrow) {
          zoomPortal.insertBefore(newCard, firstArrow);
      } else {
          zoomPortal.appendChild(newCard);
      }

      newCard.classList.add('zoomed');
      newCard.style.width = `${rect.width}px`;
      newCard.style.height = `${rect.height}px`;
      newCard.style.transform = `scale(${scale})`;
      newCard.style.setProperty('--zoom-scale', scale);
      newCard.style.transformOrigin = 'center center';

      currentOpenCard = newCard;

      // Track as last-zoomed
      setLastZoomedArchetype(newArchetypeId);

      // Add sparkle emitter to new card (anchored to card, not front face)
      {
          const sparkleContainer = document.createElement('div');
          sparkleContainer.className = 'zoom-card-sparkles';
          sparkleContainer.id = 'zoomCardSparkles';
          newCard.appendChild(sparkleContainer);
          startSparkleEmitter('zoomCardSparkles', 'zoomCard', 8);
      }
  }

  /**
   * Commit archetype selection from zoom Continue button
   * Closes zoom, triggers sparkle teleport to breadcrumb, advances corridor
   */
  function commitArchetypeFromZoom(archetypeId) {
      // Commit the selection
      if (state.archetype?.primary !== archetypeId) {
          commitArchetypeSelection(archetypeId, false);
      }

      // Close the zoom overlay (this restores card to grid and starts corridor sparkles)
      if (window.closeZoomedCard) window.closeZoomedCard();

      // Stop focus sparkles (we're about to teleport)
      if (lastZoomedSparkleEmitterId) {
          stopSparkleEmitter(lastZoomedSparkleEmitterId);
          lastZoomedSparkleEmitterId = null;
      }
      const focusedCard = document.querySelector('.archetype-card.last-zoomed');
      if (focusedCard) {
          focusedCard.classList.remove('last-zoomed');
          const sc = focusedCard.querySelector('.archetype-focus-sparkles');
          if (sc) sc.remove();
      }

      const archetype = ARCHETYPES[archetypeId];
      const archetypeName = archetype?.name || archetypeId;

      hideCorridorContinueButton('storybeau');

      // Sparkle teleport from card to breadcrumb III
      const selectedCard = document.querySelector(
          `#archetypeCardGrid .archetype-card[data-archetype="${archetypeId}"]`
      );
      const breadcrumbRow = document.getElementById('breadcrumbRow');
      const archGhostIdx = STAGE_INDEX['storybeau'];
      const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${archGhostIdx}"]`);

      let targetX, targetY;
      if (ghostStep) {
          const ghostRect = ghostStep.getBoundingClientRect();
          targetX = ghostRect.left + ghostRect.width / 2;
          targetY = ghostRect.top + ghostRect.height / 2;
      } else if (breadcrumbRow) {
          const brRect = breadcrumbRow.getBoundingClientRect();
          targetX = brRect.left + brRect.width / 2;
          targetY = brRect.top + brRect.height / 2;
      }

      if (selectedCard && targetX !== undefined) {
          const cardRect = selectedCard.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;

          // Phase 1: Dissolution sparkles + fade card
          selectedCard.style.opacity = '0.3';
          const dissolutionCount = 12 + Math.floor(Math.random() * 5);
          for (let i = 0; i < dissolutionCount; i++) {
              setTimeout(() => {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'dissolution-sparkle';
                  const sx = cardRect.left + Math.random() * cardRect.width;
                  const sy = cardRect.top + Math.random() * cardRect.height;
                  sparkle.style.cssText = `left: ${sx}px; top: ${sy}px;`;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 400);
              }, i * 25);
          }

          // Phase 2: Sparkle travel to breadcrumb (JS-driven)
          setTimeout(() => {
              fireSparkleTrail(cardCenterX, cardCenterY, cardRect.width, cardRect.height, targetX, targetY);
          }, 250);

          // Phase 3: Convergence sparkles + breadcrumb + advance
          setTimeout(() => {
              for (let i = 0; i < 5; i++) {
                  const sparkle = document.createElement('div');
                  sparkle.className = 'convergence-sparkle';
                  const angle = (Math.PI * 2 * i) / 5;
                  const dist = 15 + Math.random() * 10;
                  sparkle.style.cssText = `
                      left: ${targetX + Math.cos(angle) * dist}px;
                      top: ${targetY + Math.sin(angle) * dist}px;
                  `;
                  document.body.appendChild(sparkle);
                  setTimeout(() => sparkle.remove(), 500);
              }

              selectedCard.style.opacity = '';
              createArchetypeBreadcrumbWithMask(archetypeId, false);
              setTimeout(() => advanceCorridorRow(), 600);
          }, 1300);
      } else {
          // Fallback: no animation
          createArchetypeBreadcrumbWithMask(archetypeId, false);
          setTimeout(() => advanceCorridorRow(), 600);
      }
  }

  // Close archetype zoom â€” now handled by closeZoomedCard() which detects archetype cards
  // and auto-starts corridor sparkles. Kept as alias for compatibility.
  function closeArchetypeOverlay() {
      if (window.closeZoomedCard) window.closeZoomedCard();
  }

  function bindArchetypeHandlers() {
      // No longer needed - archetype zoom uses the unified zoom system
      // Backdrop click is handled by the global backdrop listener
  }

  function updateArchetypeCardStates() {
      document.querySelectorAll('#archetypeCardGrid .sb-card.archetype-card:not(.destiny-choice-card)').forEach(card => {
          const id = card.dataset.archetype;
          const isSelected = state.archetype.primary === id;

          if (archetypeSelectedViaDestiny) {
              // Destiny's Choice: mask is SECRET â€” all cards face-down, no selection shown
              card.classList.remove('selected', 'flipped');
          } else {
              card.classList.toggle('selected', isSelected);
              // Selected card gets selection state, all cards stay flipped (revealed)
              if (isSelected) {
                  card.classList.add('flipped');
                  lastZoomedArchetype = id;
              }
          }
      });
  }

  // Legacy stub â€” modifier UI removed, selection summary no longer displayed
  function updateArchetypeSelectionSummary() {
      const primaryName = document.getElementById('selectedPrimaryName');
      if (primaryName) {
          const primary = state.archetype.primary ? ARCHETYPES[state.archetype.primary] : null;
          primaryName.textContent = primary ? primary.name : 'None';
      }
  }

  // Legacy function stubs for compatibility
  function renderArchetypePills() { renderArchetypeCards(); }
  function updateArchetypePillStates() { updateArchetypeCardStates(); }

  function updateArchetypePreview() {
      // Now handled by overlay and selection summary - keeping for compatibility
      updateArchetypeSelectionSummary();
  }

  function updateArchetypeSectionTitle() {
      const titleEl = document.getElementById('archetypeSectionTitle');
      if (!titleEl) return;
      const genderSelect = document.getElementById('loveInterestGender');
      const customInput = document.getElementById('customLoveInterest');
      let loveGender = 'Male';
      if (genderSelect) {
          if (genderSelect.value === 'Custom' && customInput && customInput.value.trim()) {
              loveGender = customInput.value.trim();
          } else {
              loveGender = genderSelect.value;
          }
      }
      titleEl.textContent = getArchetypeSectionTitle(loveGender);
  }

  function bindLoveInterestGenderWatcher() {
      const genderSelect = document.getElementById('loveInterestGender');
      const customInput = document.getElementById('customLoveInterest');

      function onLIGenderChange() {
          // Update state.loveInterest for pronoun resolution
          if (genderSelect) {
              state.loveInterest = genderSelect.value === 'Custom' && customInput?.value?.trim()
                  ? customInput.value.trim()
                  : genderSelect.value;
          }
          updateArchetypeSectionTitle();
          // Re-render archetype cards with updated pronouns
          renderArchetypeCards();
      }

      if (genderSelect && genderSelect.dataset.archetypeBound !== '1') {
          genderSelect.dataset.archetypeBound = '1';
          genderSelect.addEventListener('change', onLIGenderChange);
      }

      if (customInput && customInput.dataset.archetypeBound !== '1') {
          customInput.dataset.archetypeBound = '1';
          customInput.addEventListener('input', onLIGenderChange);
      }

      // Also watch player gender changes for MC pronoun resolution
      const playerGenderSelect = document.getElementById('playerGender');
      const customPlayerGender = document.getElementById('customPlayerGender');

      function onPlayerGenderChange() {
          if (playerGenderSelect) {
              state.gender = playerGenderSelect.value === 'Custom' && customPlayerGender?.value?.trim()
                  ? customPlayerGender.value.trim()
                  : playerGenderSelect.value;
          }
          // Re-render archetype cards with updated MC pronouns
          renderArchetypeCards();
      }

      if (playerGenderSelect && playerGenderSelect.dataset.archetypeBound !== '1') {
          playerGenderSelect.dataset.archetypeBound = '1';
          playerGenderSelect.addEventListener('change', onPlayerGenderChange);
      }

      if (customPlayerGender && customPlayerGender.dataset.archetypeBound !== '1') {
          customPlayerGender.dataset.archetypeBound = '1';
          customPlayerGender.addEventListener('input', onPlayerGenderChange);
      }
  }

  // --- LOADING OVERLAY ---
  let _loadingTimer = null;
  let _loadingActive = false;
  let _loadingMsgTimer = null;
  let _loadingCancelled = false;
  let _loadingCancelCallback = null;
  let _lastSettingShotDesc = '';

  const STORY_LOADING_MESSAGES = [
      // Required phrases
      "Crafting each individual snowflake...",
      "Setting traps...",
      "Naming the animals...",
      "Manifesting drama...",
      "Cleaning up double entendres...",
      "Darkening the past...",
      "Amping the feels...",
      // Additional playful, literary, worldbuilding phrases
      "Weaving backstories...",
      "Polishing the silver tongues...",
      "Hiding secrets in the walls...",
      "Brewing chemistry...",
      "Sharpening the wit...",
      "Planting red herrings...",
      "Tuning the heartstrings...",
      "Scheduling the rain...",
      "Lighting the candles...",
      "Rehearsing the longing glances...",
      "Aging the whiskey...",
      "Pressing the silk sheets...",
      "Whispering rumors...",
      "Composing the tension...",
      "Perfecting the timing...",
      "Casting shadows...",
      "Stoking the slow burn...",
      "Arranging the flowers...",
      "Calibrating the chemistry..."
  ];

  const VISUALIZE_LOADING_MESSAGES = [
      "Painting the scene...",
      "Saying it with his eyes...",
      "Letting the silence linger...",
      "Adding longing...",
      "Shaping the moment...",
      "Tracing the tension...",
      "Capturing the unspoken...",
      "Finding the perfect light...",
      "Catching the glance...",
      "Softening the shadows...",
      "Framing the desire...",
      "Holding the gaze...",
      "Rendering the warmth...",
      "Sculpting the posture...",
      "Brushing the highlights...",
      "Etching the atmosphere...",
      "Composing the stillness...",
      "Illuminating the moment..."
  ];

  function startLoading(msg, messageList = null, cancellable = false, onCancel = null){
    const overlay = document.getElementById('loadingOverlay');
    const fill = document.getElementById('loadingOverlayFill');
    const textEl = document.getElementById('loadingText');
    const percentEl = document.getElementById('loadingPercent');
    const cancelBtn = document.getElementById('loadingCancelBtn');

    if (textEl) textEl.textContent = msg || "Loading...";
    if (percentEl) percentEl.textContent = '0%';

    _loadingActive = true;
    _loadingCancelled = false;
    _loadingCancelCallback = onCancel;

    // Stop fate card sparkles when loading overlay appears (prevent z-index bleed)
    if (window.stopSparkleCycle) window.stopSparkleCycle();
    if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();

    if(fill) fill.style.width = '0%';
    if(overlay) overlay.classList.remove('hidden');

    // Start loading bar sparkles
    startOverlayLoadingSparkles();

    // Show/hide cancel button based on cancellable flag
    if (cancelBtn) {
        if (cancellable) {
            cancelBtn.classList.add('visible');
        } else {
            cancelBtn.classList.remove('visible');
        }
    }

    if(_loadingTimer) clearInterval(_loadingTimer);
    if(_loadingMsgTimer) clearInterval(_loadingMsgTimer);

    let p = 0;
    _loadingTimer = setInterval(() => {
      if(!_loadingActive || _loadingCancelled) return;
      p = Math.min(91, p + Math.random() * 6);
      if(fill) fill.style.width = p.toFixed(0) + '%';
      if(percentEl) percentEl.textContent = p.toFixed(0) + '%';
    }, 250);

    // Rotate messages if a message list is provided
    if (messageList && Array.isArray(messageList) && messageList.length > 0 && textEl) {
        // Shuffle the list for random order, no repeats until cycle completes
        const shuffled = [...messageList].sort(() => Math.random() - 0.5);
        let msgIdx = 0;

        // PART C: Crossfade transition for loading phrases
        // Fade duration: 300ms out + 300ms in
        const fadeDuration = 300;
        textEl.style.transition = `opacity ${fadeDuration}ms ease-in-out`;

        _loadingMsgTimer = setInterval(() => {
            if (!_loadingActive || _loadingCancelled) return;
            msgIdx = (msgIdx + 1) % shuffled.length;

            // Fade out
            textEl.style.opacity = '0';

            // Swap text at opacity 0, then fade in
            setTimeout(() => {
                if (!_loadingActive || _loadingCancelled) return;
                textEl.textContent = shuffled[msgIdx];
                textEl.style.opacity = '1';
            }, fadeDuration);
        }, 3200); // 3.2s cadence for slower, more readable rotation
    }
  }

  function cancelLoading() {
    _loadingCancelled = true;
    if (_loadingCancelCallback) {
        _loadingCancelCallback();
        _loadingCancelCallback = null;
    }
    stopLoading();
  }

  function isLoadingCancelled() {
    return _loadingCancelled;
  }

  /**
   * Update the loading message during an active loading state.
   * Used by orchestration to show phase-specific messages.
   */
  function updateLoadingMessage(msg) {
    if (!_loadingActive) return;
    const textEl = document.getElementById('loadingText');
    if (textEl) {
      // Fade transition
      textEl.style.opacity = '0';
      setTimeout(() => {
        textEl.textContent = msg;
        textEl.style.opacity = '1';
      }, 200);
    }
  }

  function stopLoading(){
    if(!_loadingActive) return;
    _loadingActive = false;
    const overlay = document.getElementById('loadingOverlay');
    const fill = document.getElementById('loadingOverlayFill');
    const percentEl = document.getElementById('loadingPercent');
    const cancelBtn = document.getElementById('loadingCancelBtn');
    const textEl = document.getElementById('loadingText');

    if(_loadingTimer) { clearInterval(_loadingTimer); _loadingTimer = null; }
    if(_loadingMsgTimer) { clearInterval(_loadingMsgTimer); _loadingMsgTimer = null; }
    if(fill) fill.style.width = '100%';
    if(percentEl) percentEl.textContent = '100%';
    if(cancelBtn) cancelBtn.classList.remove('visible');

    // Reset text opacity for next loading cycle
    if(textEl) {
        textEl.style.transition = 'none';
        textEl.style.opacity = '1';
    }

    setTimeout(() => {
      if(overlay) overlay.classList.add('hidden');
      if(fill) fill.style.width = '0%';
      if(percentEl) percentEl.textContent = '0%';
    }, 120);

    // Stop overlay sparkles
    stopOverlayLoadingSparkles();

    // Re-enable Next button after scene generation completes
    const _nextBtnRestore = document.getElementById('nextPageBtn');
    if (_nextBtnRestore) _nextBtnRestore.disabled = false;
  }

  // ============================================================
  // OVERLAY LOADING BAR SPARKLES (Story + Visualize ONLY)
  // SEPARATE from cover bar sparkles â€” do NOT modify cover system
  // ============================================================
  let _overlaySparkleInterval = null;

  function spawnOverlayLoadingSparkle(container) {
      if (!container) return;
      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;
      if (containerWidth === 0) return;

      const sparkle = document.createElement('div');
      sparkle.className = 'overlay-loading-sparkle';

      // Random X position along the bar
      const spawnX = Math.random() * containerWidth;
      // Close to bar centerline
      const spawnY = (Math.random() - 0.5) * 14 - 4;

      // Gentle wandering â€” mostly lateral with mild upward drift
      const angle = Math.random() * 360 * (Math.PI / 180); // Any direction
      const distance = 8 + Math.random() * 16; // Short, gentle drift
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance * 0.5 - 5 - Math.random() * 8; // Mild upward bias

      // Lateral sway for organic feel
      const sway = (Math.random() - 0.5) * 12;

      // Rotation for visual interest
      const rotation = (Math.random() - 0.5) * 25;

      // Variable size (2-5px)
      const size = 2 + Math.random() * 3;

      // Randomized lifetime â€” slow, leisurely (3.5s - 6.5s)
      const duration = 3500 + Math.random() * 3000;

      // Variable opacity (0.5 - 0.85)
      const opacity = 0.5 + Math.random() * 0.35;

      // Randomized easing
      const easings = ['ease-in-out', 'ease-out', 'cubic-bezier(0.4, 0, 0.2, 1)', 'cubic-bezier(0.25, 0.1, 0.25, 1)'];
      const easing = easings[Math.floor(Math.random() * easings.length)];

      sparkle.style.cssText = `
          left: ${spawnX}px;
          top: ${spawnY}px;
          width: ${size}px;
          height: ${size}px;
          --ols-duration: ${duration}ms;
          --ols-opacity: ${opacity};
          --ols-dx: ${dx}px;
          --ols-dy: ${dy}px;
          --ols-sway: ${sway}px;
          --ols-rot: ${rotation}deg;
          --ols-easing: ${easing};
      `;

      container.appendChild(sparkle);
      setTimeout(() => { if (sparkle.parentNode) sparkle.remove(); }, duration + 100);
  }

  function startOverlayLoadingSparkles() {
      stopOverlayLoadingSparkles();

      const loadingBar = document.getElementById('loadingOverlayBar');
      if (!loadingBar) return;

      // Ensure container is positioned for absolute children
      const style = window.getComputedStyle(loadingBar);
      if (style.position === 'static') {
          loadingBar.style.position = 'relative';
      }
      loadingBar.style.overflow = 'visible';
      loadingBar.classList.add('sparkle-active');

      // Relaxed spawn rate for gentle density
      _overlaySparkleInterval = setInterval(() => {
          spawnOverlayLoadingSparkle(loadingBar);
      }, 350); // ~3 sparkles per second

      // Initial seeds â€” staggered for natural appearance
      for (let i = 0; i < 4; i++) {
          setTimeout(() => spawnOverlayLoadingSparkle(loadingBar), i * 180);
      }
  }

  function stopOverlayLoadingSparkles() {
      if (_overlaySparkleInterval) {
          clearInterval(_overlaySparkleInterval);
          _overlaySparkleInterval = null;
      }

      const loadingBar = document.getElementById('loadingOverlayBar');
      if (loadingBar) {
          loadingBar.classList.remove('sparkle-active');
      }

      // Fade out existing sparkles gracefully
      document.querySelectorAll('.overlay-loading-sparkle').forEach(s => {
          s.style.opacity = '0';
          s.style.transition = 'opacity 0.4s ease-out';
          setTimeout(() => s.remove(), 450);
      });
  }

  // Bind cancel button
  document.getElementById('loadingCancelBtn')?.addEventListener('click', cancelLoading);

  // Stripe checkout helper â€” sends tier name to server, server resolves price ID
  async function initiateStripeCheckout(tier) {
    console.log(`[STRIPE] ${tier} checkout initiated`);

    try {
      const user = window.supabase?.auth?.getUser
        ? (await window.supabase.auth.getUser()).data.user
        : null;

      if (!user?.id) {
        console.error('[STRIPE] No Supabase user ID found');
        alert('Please sign in before purchasing.');
        return;
      }

      const response = await fetch('/api/create-checkout-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          tier: tier,
          supabaseUserId: user.id
        })
      });

      const data = await response.json();

      if (!data.url) {
        console.error('[STRIPE] No checkout URL returned', data);
        alert('Payment could not be started. Please try again.');
        return;
      }

      window.location.href = data.url;
    } catch (err) {
      console.error(`[STRIPE] ${tier} checkout error:`, err);
      alert('Payment could not be started. Please try again.');
    }
  }

  // Storypass $3 â€” one-time payment via Stripe (entitlement granted by webhook only)
  $('payOneTime')?.addEventListener('click', () => {
    initiateStripeCheckout('storypass');
  });

  // Storied subscription ($6/mo)
  document.getElementById('paySubStoried')?.addEventListener('click', () => {
    initiateStripeCheckout('storied');
  });

  // Favored subscription ($9/mo)
  document.getElementById('paySubFavored')?.addEventListener('click', () => {
    initiateStripeCheckout('favored');
  });


  // (Quill/Veto committed phrase system removed â€” replaced by Petition Fate)

  // --- META SYSTEM (RESTORED) ---
  function buildMetaDirective(){
     if(state.awareness === 0) return "";
     if(Math.random() > state.metaChance) return "";
     const stance = META_DIRECTIVES[state.stance] || META_DIRECTIVES['aid'];
     const directive = stance[Math.floor(Math.random() * stance.length)];
     return `META-NARRATIVE INTERVENTION: ${directive}`;
  }

  window.setMetaStance = function(s){
      // Tempt Fate requires explicit paid invocation â€” not just a stance toggle
      if (s === 'seduce') {
          invokeTemptFate();
          return;
      }
      state.stance = s;
      document.querySelectorAll('.meta-stance').forEach(b => b.classList.remove('active'));
      const btn = document.querySelector(`.meta-stance[onclick="window.setMetaStance('${s}')"]`);
      if(btn) btn.classList.add('active');
  };

  /**
   * TEMPT FATE â€” Explicit invocation flow.
   * 1. Compute cost
   * 2. Confirm with player
   * 3. Deduct Fortunes atomically
   * 4. Set invocation flag
   * 5. Activate stance
   */
  async function invokeTemptFate() {
      // Fortune's Favor â€” check for free bonus charges before paid path
      let usedFreeCharge = false;
      if (consumeFortuneFavorCharge()) {
          usedFreeCharge = true;
          // Free charge consumed â€” skip cost/confirm/deduction
          showTemptShudder();
          // Update sparkle state (may remove if last charge)
          setTimeout(() => updateTemptFateSparkle(), 100);
      } else {
          const cost = getTemptFateCost();

          // Check balance before confirmation
          if ((state.fortunes || 0) < cost) {
              alert(`Tempt Fate requires ${cost} Fortunes. You have ${state.fortunes || 0}.`);
              return;
          }

          // Cost confirmation
          const confirmed = confirm(`Tempt Fate costs ${cost} Fortunes. Proceed?`);
          if (!confirmed) return;

          // Atomic deduction
          const burned = await consumeFortune(cost, 'tempt_fate');
          if (!burned) {
              alert('Fortune deduction failed. Tempt Fate aborted.');
              return;
          }
      }

      // Set invocation flag + increment consecutive count
      state.tempt_fate_invoked_this_turn = true;
      state.consecutive_tempt_fate_count = (state.consecutive_tempt_fate_count || 0) + 1;

      // Badge engine â€” Tempt Fate milestones
      withProfileId(profileId => {
        incrementBadge(sb, profileId, 'tempt_first');
        if (state.consecutive_tempt_fate_count >= 3) {
          awardBadge(sb, profileId, 'tempt_disturb_fate');
        }
      });

      // Onboarding: mark first Tempt Fate invocation
      if (!state.has_triggered_first_tempt_fate) {
          state.has_triggered_first_tempt_fate = true;
      }

      // Fate Resonance â€” account-level mythic aura increment (narrative only)
      incrementFateResonance();

      // Activate stance for narrative directives
      state.stance = 'seduce';
      document.querySelectorAll('.meta-stance').forEach(b => b.classList.remove('active'));
      const btn = document.querySelector('.meta-stance[onclick="window.setMetaStance(\'seduce\')"]');
      if (btn) btn.classList.add('active');

      console.log(`[TEMPT_FATE] Invoked. ${usedFreeCharge ? 'Cost: FREE (bonus charge)' : 'Cost: ' + getTemptFateCost()}, Consecutive: ${state.consecutive_tempt_fate_count}, Remaining Fortunes: ${state.fortunes}, Resonance: ${state.fate_resonance_intensity} (${getFateResonanceState()})`);
  }

  // --- BEGIN STORY VALIDATION GUARDRAIL ---
  function validateBeginStory() {
      const errors = [];

      // Skip validation if Fate triggered (all values are pre-set correctly)
      if (state._fateTriggered) {
          return errors;
      }

      // Check archetype selection
      const archetypeValidation = validateArchetypeSelection(state.archetype.primary, state.archetype.modifier);
      if (!archetypeValidation.valid) {
          errors.push(archetypeValidation.errors[0] || 'Please select a Primary Archetype.');
      }

      // 4-axis validation: world, tone, genre, dynamic are required (single-select)
      if (!state.picks.world) {
          errors.push('Please select a Story World.');
      }

      if (!state.picks.tone) {
          errors.push('Please select a Story Tone.');
      }

      if (!state.picks.genre) {
          errors.push('Please select a Genre.');
      }

      if (!state.picks.dynamic) {
          errors.push('Please select a Relationship Dynamic.');
      }

      // Historical world requires era selection
      if (state.picks.world === 'Historical' && !state.picks.era) {
          errors.push('Please select a Historical Era.');
      }

      // SciFi world requires a vector (worldSubtype) selection
      if (state.picks.world === 'SciFi' && !state.picks.worldSubtype) {
          errors.push('__SCIFI_FLAVOR_REQUIRED__');
      }

      return errors;
  }

  // ========================================
  // LET FATE DECIDE - Auto-selection System
  // ========================================

  // Weighted random selection helper
  function weightedSelect(options, weights) {
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;
    for (let i = 0; i < options.length; i++) {
      random -= weights[i];
      if (random <= 0) return options[i];
    }
    return options[options.length - 1];
  }

  // Name lists for fate-generated names (IP-safe, non-famous)
  const FATE_FEMALE_NAMES = [
    'Elara Vance', 'Cassandra Wells', 'Mira Thornwood', 'Vivian Blake', 'Cordelia Hart',
    'Aurelia Stone', 'Seraphina Cole', 'Isadora Crane', 'Helena Frost', 'Rosalind Grey',
    'Celestine Moore', 'Evangeline Price', 'Lydia Sterling', 'Ophelia Dane', 'Tatiana West'
  ];

  const FATE_MALE_NAMES = [
    'Sebastian Blackwood', 'Julian Ashford', 'Marcus Thorne', 'Alexander Crane', 'Dominic Vale',
    'Lucian Grey', 'Theodore Sterling', 'Maximilian Drake', 'Gabriel Frost', 'Benedict Hale',
    'Damien Cross', 'Vincent Ashmore', 'Nathaniel Wolfe', 'Adrian Sinclair', 'Dorian Vance'
  ];

  // Module-level world flavors for fate selection (mirrors WORLD_SUB_OPTIONS structure)
  const FATE_WORLD_FLAVORS = {
    Modern: [
      { val: 'small_town' }, { val: 'college' }, { val: 'friends' },
      { val: 'blue_blood' }, { val: 'office' }
    ],
    Historical: [
      { val: 'medieval' }, { val: 'victorian' }, { val: 'renaissance' },
      { val: 'classical' }, { val: 'bronze_age' }, { val: '20th_century' }
    ],
    Fantasy: [
      { val: 'arcane_binding' }, { val: 'fated_blood' }, { val: 'the_inhuman' },
      { val: 'the_beyond' }, { val: 'cursed' }
    ],
    SciFi: [
      { val: 'galactic_civilizations' }, { val: 'cyberpunk' }, { val: 'future_of_science' }
    ]
  };

  // Get entitlement-aware intensity selection
  function getFateIntensity() {
    // Intensity selection removed from UI â€” default to Erotic internally
    return 'Steamy';
  }

  // Get entitlement-aware story length selection
  function getFateStoryLength() {
    // Prefer Affair/Soulmates if sub, else Fling if pass, else Taste
    if (state.access === 'sub') {
      // Weighted: prefer Affair (50%), Soulmates (50%)
      return Math.random() < 0.5 ? 'affair' : 'soulmates';
    } else if (state.access === 'pass') {
      return 'fling';
    }
    return 'taste';
  }

  // Get weighted world selection
  function getFateWorld() {
    // Prefer Modern > Historical > Fantasy > Sci-Fi
    const worlds = ['Modern', 'Historical', 'Fantasy', 'SciFi'];
    const weights = [40, 30, 20, 10]; // Heavy preference for Modern
    return weightedSelect(worlds, weights);
  }

  // Get weighted flavor for selected world
  function getFateFlavor(world) {
    if (typeof FATE_WORLD_FLAVORS === 'undefined' || !FATE_WORLD_FLAVORS) return null;
    const flavors = FATE_WORLD_FLAVORS[world];
    if (!flavors || flavors.length === 0) return null;
    // Bias toward first (broader) options
    const weights = flavors.map((_, i) => Math.max(10 - i * 2, 1));
    const selected = weightedSelect(flavors, weights);
    return selected.val;
  }

  // Get weighted tone selection (4 visible tone pillars only)
  function getFateTone() {
    const tones = ['Earnest', 'WryConfession', 'Dark', 'Mythic'];
    const weights = [40, 30, 20, 10];
    return weightedSelect(tones, weights);
  }

  // Get weighted genre selection (context-aware for Modern)
  function getFateGenre(world) {
    if (world === 'Modern') {
      // Prefer Billionaire, SmallTown, FamousNotorious, CollegeEarlyCareer for Modern
      // Note: Some of these may be World flavors, using available genres
      const genres = ['Billionaire', 'Noir', 'Political', 'Heist'];
      const weights = [50, 20, 15, 15];
      return weightedSelect(genres, weights);
    }
    // Default genres for other worlds
    const genres = ['Billionaire', 'CrimeSyndicate', 'Espionage', 'Political'];
    const weights = [40, 25, 20, 15];
    return weightedSelect(genres, weights);
  }

  // Get weighted dynamic selection
  function getFateDynamic() {
    // Prefer Friends to Lovers, Forbidden Love
    const dynamics = ['Friends', 'Forbidden', 'Enemies', 'SecondChance', 'Proximity', 'SecretIdentity'];
    const weights = [30, 25, 20, 10, 10, 5];
    return weightedSelect(dynamics, weights);
  }

  // Get POV selection (prefer 1st person)
  function getFatePOV() {
    // Prefer First (1st person "I"), fall back if needed
    return 'First';
  }

  // Get weighted archetype selection (canonical 7)
  function getFateArchetype() {
    // Weighted toward emotionally accessible archetypes for default romance experience
    // Legacy mapping: ROMANTICâ†’OPEN_VEIN, DEVOTEDâ†’ETERNAL_FLAME,
    //   ENCHANTINGâ†’SPELLBINDER, GUARDIANâ†’HEART_WARDEN
    const archetypes = ['OPEN_VEIN', 'ETERNAL_FLAME', 'SPELLBINDER', 'HEART_WARDEN', 'ARMORED_FOX'];
    const weights = [30, 25, 20, 15, 10];
    return weightedSelect(archetypes, weights);
  }

  // PASS 9D: Generate fate ages with 95% within Â±10 years, 5% edge cases
  function getFateAges() {
    // Base age for player character (22-35 typical range)
    const playerAge = 22 + Math.floor(Math.random() * 14); // 22-35

    // 95% of the time: partner age within Â±10 years
    // 5% of the time: allow larger gaps (edge cases)
    const isEdgeCase = Math.random() < 0.05;

    let partnerAge;
    if (isEdgeCase) {
      // Edge case: wider range (18-60)
      partnerAge = 18 + Math.floor(Math.random() * 43);
    } else {
      // Normal case: within Â±10 years of player, clamped to 18-60
      const offset = Math.floor(Math.random() * 21) - 10; // -10 to +10
      partnerAge = Math.max(18, Math.min(60, playerAge + offset));
    }

    return { playerAge, partnerAge };
  }

  // =================================================================
  // GUIDED FATE CHOREOGRAPHY ENGINE (AUTHORITATIVE)
  // Controls tempo, direction, and order of Fate's reveal.
  // ONE DIRECTION (down), ONE SECTION AT A TIME, HUMAN PACE
  // =================================================================

  // Fate override flag - when true, all automated motion stops
  let _fateOverridden = false;
  let _fateRunning = false;
  let _fateAutoplayActive = false; // True during corridor autoplay (suppresses Fortune's Favor)
  let _guidedFateVisualsActive = false;

  // DSP clause reveal tracking â€” non-null only during Guided Fate ceremony
  let _revealedDSPAxes = null;

  function revealDSPClause(axis) {
    if (!_revealedDSPAxes) return;
    _revealedDSPAxes.add(axis);
    const synopsisText = document.getElementById('synopsisText');
    if (!synopsisText) return;

    // SPARSE RENDERING: Regenerate sentence with only revealed axes
    // NO pending clauses, NO greyed text â€” just the revealed portions
    const result = generateDSPSentence();
    if (result.success) {
      const newHtml = result.html;

      // GUARD: Do not clear DSP if result is empty (world not yet revealed)
      // Keep placeholder or previous content until we have actual sentence content
      if (!newHtml || newHtml.trim() === '') return;

      // Increment activation for Guided Fate reveals
      incrementDSPActivation();

      // Only update DOM if content changed
      if (synopsisText._lastDSP !== newHtml) {
        synopsisText._lastDSP = newHtml;
        synopsisText.innerHTML = newHtml;

        // Brief golden glow on the newly revealed clause
        synopsisText.querySelectorAll('.dsp-clause[data-axis="' + axis + '"]').forEach(span => {
          span.classList.add('dsp-glow');
          setTimeout(() => span.classList.remove('dsp-glow'), 550);
        });
      }
    }
  }

  // Timing constants (HUMAN PACE - deliberate, not efficient)
  const FATE_TIMING = {
    SCROLL_SETTLE: 500,      // 400-600ms after scroll
    CARD_FLIP: 350,          // 300-400ms card flip animation
    TYPING_PER_CHAR: 65,     // 50-80ms per character
    CARD_DWELL: 3500,        // 3-4s dwell on flipped card before proceeding
    SECTION_PAUSE: 1200,     // Dreamlike inter-section pacing
    HIGHLIGHT_SETTLE: 400,   // Time before clearing highlight
    // MINIMUM TIMING GUARANTEES (authoritative)
    MIN_NAMES_CEREMONY: 5000,   // Names ceremony must be â‰¥5 seconds
    MIN_ARCHETYPE_REVEAL: 4000, // Archetype section must be â‰¥4 seconds
    MIN_INTENSITY_REVEAL: 4000  // Intensity section must be â‰¥4 seconds
  };

  // =================================================================
  // FAIRY DUST PARTICLE SYSTEM
  // Sparse, ethereal gold specks during Guided Fate ceremony
  // =================================================================

  let _dustInterval = null;
  let _sparkleIntervals = [];
  let _ambientCardInterval = null;
  let _anchoredParticles = []; // Track particles with owner elements for scroll sync
  let _sparkleScrollListener = null;
  let _sparkleInitialScrollY = 0;
  const DUST_CONFIG = {
    MAX_PARTICLES: 350,       // Dense vignette sparkles (3Ã— visibility)
    SPAWN_INTERVAL: 15,       // Fast spawn for density
    MIN_SIZE: 3,              // Small, delicate
    MAX_SIZE: 9,
    MIN_DURATION: 5000,       // Long gentle drift
    MAX_DURATION: 10000,
    MIN_OPACITY: 0.5,         // Clearly visible
    MAX_OPACITY: 0.9
  };

  // Anchored particle position sync â€” scroll-offset tracking (no per-tick getBoundingClientRect)
  function registerAnchoredParticle(particle, ownerEl, relX, relY, initialLeft, initialTop) {
    // Store initial positions and scroll offset
    const entry = {
      particle,
      ownerEl,
      relX,
      relY,
      initialLeft,
      initialTop,
      initialScrollY: window.scrollY
    };
    _anchoredParticles.push(entry);
    if (!_sparkleScrollListener) startSparkleScrollSync();
  }

  function startSparkleScrollSync() {
    _sparkleInitialScrollY = window.scrollY;
    _sparkleScrollListener = function() {
      // Prune dead particles
      _anchoredParticles = _anchoredParticles.filter(p => p.particle.parentNode && p.ownerEl.offsetParent);
      if (_anchoredParticles.length === 0) {
        stopSparkleScrollSync();
        return;
      }
      // Update positions using scroll delta (no getBoundingClientRect)
      for (const p of _anchoredParticles) {
        const scrollDelta = window.scrollY - p.initialScrollY;
        p.particle.style.top = (p.initialTop + p.relY - scrollDelta) + 'px';
        // X remains unchanged (no horizontal scroll tracking needed)
      }
    };
    window.addEventListener('scroll', _sparkleScrollListener, { passive: true });
  }

  function stopSparkleScrollSync() {
    if (_sparkleScrollListener) {
      window.removeEventListener('scroll', _sparkleScrollListener);
      _sparkleScrollListener = null;
    }
    _anchoredParticles = [];
  }

  // Global overlay for anchored sparkles (fixed positioning, updated per-frame)
  // z-index: 2500 â€” below modals (3000+) but above page content
  function getSparkleOverlay() {
    let overlay = document.getElementById('sparkleAnchorOverlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'sparkleAnchorOverlay';
      overlay.style.cssText = 'position:fixed;inset:0;pointer-events:none;z-index:2500;overflow:visible;';
      document.body.appendChild(overlay);
    }
    return overlay;
  }

  // DEV ASSERTION: Fate card sparkles must be DOM descendants of the Fate card
  // Validates invariant: sparkles appended to .fate-destiny-card subtree only
  function assertFateSparkleOwnership(particle, tag) {
    if (!particle) return;
    const fateCard = particle.closest('.fate-destiny-card');
    if (!fateCard) {
      console.error('[DEV] INVARIANT VIOLATION: Fate sparkle (tag=' + tag + ') is not a DOM descendant of .fate-destiny-card. Parent:', particle.parentElement);
    }
  }

  function spawnDustParticle() {
    if (!_guidedFateVisualsActive) return;

    // Limit particle count (vignette particles only â€” tag 'vignette')
    const existing = document.querySelectorAll('.fate-dust-particle[data-sparkle-tag="vignette"]');
    if (existing.length >= DUST_CONFIG.MAX_PARTICLES) return;

    const particle = document.createElement('div');
    particle.className = 'fate-dust-particle fate-dust-particle--viewport';
    particle.dataset.sparkleTag = 'vignette';

    // Viewport-based positioning weighted toward vignette edges
    const edge = Math.random();
    let x, y;
    if (edge < 0.35) {
      x = Math.random() * 15;
      y = 5 + Math.random() * 90;
    } else if (edge < 0.65) {
      x = 85 + Math.random() * 15;
      y = 5 + Math.random() * 90;
    } else if (edge < 0.80) {
      x = 5 + Math.random() * 90;
      y = 80 + Math.random() * 18;
    } else if (edge < 0.90) {
      x = 10 + Math.random() * 80;
      y = Math.random() * 15;
    } else {
      x = 25 + Math.random() * 50;
      y = 25 + Math.random() * 50;
    }

    // Randomize properties
    const size = DUST_CONFIG.MIN_SIZE + Math.random() * (DUST_CONFIG.MAX_SIZE - DUST_CONFIG.MIN_SIZE);
    const duration = DUST_CONFIG.MIN_DURATION + Math.random() * (DUST_CONFIG.MAX_DURATION - DUST_CONFIG.MIN_DURATION);
    const opacity = DUST_CONFIG.MIN_OPACITY + Math.random() * (DUST_CONFIG.MAX_OPACITY - DUST_CONFIG.MIN_OPACITY);

    // Slow, gentle drift with slight swirl
    const baseAngle = Math.random() * Math.PI * 2;
    const driftDistance = 20 + Math.random() * 40;
    const dx = Math.cos(baseAngle) * driftDistance;
    const dy = -30 - Math.random() * 50;

    particle.style.cssText = `
      left: ${x}vw;
      top: ${y}vh;
      width: ${size}px;
      height: ${size}px;
      --dust-duration: ${duration}ms;
      --dust-opacity: ${opacity};
      --dust-dx: ${dx}px;
      --dust-dy: ${dy}px;
    `;

    document.body.appendChild(particle);

    // Self-cleanup after animation
    setTimeout(() => {
      if (particle.parentNode) {
        particle.remove();
      }
    }, duration + 100);
  }

  function startFairyDust() {
    stopFairyDust(); // Clear any existing
    _dustInterval = setInterval(spawnDustParticle, DUST_CONFIG.SPAWN_INTERVAL);
    // Gentle initial burst
    for (let i = 0; i < 15; i++) {
      setTimeout(spawnDustParticle, i * 20);
    }
  }

  function stopFairyDust() {
    if (_dustInterval) {
      clearInterval(_dustInterval);
      _dustInterval = null;
    }
    // Clear all sparkle intervals
    _sparkleIntervals.forEach(id => clearInterval(id));
    _sparkleIntervals = [];
    // Stop anchored particle tracking
    stopSparkleScrollSync();
    // Fade out existing particles gracefully
    document.querySelectorAll('.fate-dust-particle').forEach(p => {
      p.style.opacity = '0';
      p.style.transition = 'opacity 0.4s ease-out';
      setTimeout(() => p.remove(), 500);
    });
  }

  // Get or create sparkle anchor container inside an element
  // Container uses position: absolute with inset: 0 and overflow: visible
  // so sparkles can appear on the perimeter (outside element bounds)
  function getOrCreateSparkleContainer(element) {
    if (!element) return null;
    // Ensure parent is positioned so absolute children work correctly
    const computedStyle = window.getComputedStyle(element);
    if (computedStyle.position === 'static') {
      element.style.position = 'relative';
    }
    // Check for existing container
    let container = element.querySelector(':scope > .sparkle-anchor-container');
    if (!container) {
      container = document.createElement('div');
      container.className = 'sparkle-anchor-container';
      element.appendChild(container);
    }
    return container;
  }

  // Ambient pre-click sparkle emitter for the Guided Fate card
  // Uses getBoundingClientRect for true scroll-synced positioning
  function spawnAmbientCardSparkle() {
    const fateCard = document.getElementById('fateDestinyCard');
    if (!fateCard || fateCard.dataset.fateUsed === 'true') return;
    if (!fateCard.offsetParent) return; // not visible

    const overlay = getSparkleOverlay();
    const existing = overlay.querySelectorAll('.fate-dust-particle[data-sparkle-owner="ambient-fateCard"]');
    if (existing.length >= 90) return;

    const rect = fateCard.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    if (width === 0 || height === 0) return;

    const particle = document.createElement('div');
    particle.className = 'fate-dust-particle fate-dust-particle--anchored';
    particle.dataset.sparkleTag = 'ambient';
    particle.dataset.sparkleOwner = 'ambient-fateCard';

    // Spawn on outer perimeter Â±14-22px outside card edges (element-relative)
    const side = Math.random();
    const offset = 14 + Math.random() * 8;
    let relX, relY;
    if (side < 0.25) { relX = Math.random() * width; relY = -offset; }
    else if (side < 0.5) { relX = Math.random() * width; relY = height + offset; }
    else if (side < 0.75) { relX = -offset; relY = Math.random() * height; }
    else { relX = width + offset; relY = Math.random() * height; }

    const size = 2 + Math.random() * 5;
    const duration = 3000 + Math.random() * 4000;
    const opacity = 0.5 + Math.random() * 0.4;

    // Slow orbit / drift outward from element center
    const cx = width / 2;
    const cy = height / 2;
    const outAngle = Math.atan2(relY - cy, relX - cx);
    const dx = Math.cos(outAngle) * (10 + Math.random() * 20);
    const dy = Math.sin(outAngle) * (10 + Math.random() * 20) - 10;

    particle.style.cssText = `
      position: fixed;
      left: ${rect.left + relX}px; top: ${rect.top + relY}px;
      width: ${size}px; height: ${size}px;
      --dust-duration: ${duration}ms;
      --dust-opacity: ${opacity};
      --dust-dx: ${dx}px; --dust-dy: ${dy}px;
    `;
    overlay.appendChild(particle);
    registerAnchoredParticle(particle, fateCard, relX, relY, rect.left, rect.top);
    setTimeout(() => { if (particle.parentNode) particle.remove(); }, duration + 100);
  }

  function startAmbientCardSparkles() {
    stopAmbientCardSparkles();
    _ambientCardInterval = setInterval(spawnAmbientCardSparkle, 40);
    // Immediate burst
    for (let i = 0; i < 20; i++) {
      setTimeout(spawnAmbientCardSparkle, i * 20);
    }
  }

  function stopAmbientCardSparkles() {
    if (_ambientCardInterval) {
      clearInterval(_ambientCardInterval);
      _ambientCardInterval = null;
    }
    document.querySelectorAll('.fate-dust-particle[data-sparkle-tag="ambient"]').forEach(p => {
      p.style.opacity = '0';
      p.style.transition = 'opacity 0.4s ease-out';
      setTimeout(() => p.remove(), 500);
    });
  }

  // Anchor-aware sparkle spawner â€” particles track owner element via rAF
  // Uses getBoundingClientRect for true scroll-synced positioning
  function startFateEdgeSparkles({ anchorEl, anchorRect, maxParticles, spawnInterval, tag }) {
    if (!anchorEl) return;
    maxParticles = maxParticles || DUST_CONFIG.MAX_PARTICLES;
    spawnInterval = spawnInterval || DUST_CONFIG.SPAWN_INTERVAL;
    tag = tag || 'card';

    const overlay = getSparkleOverlay();

    const checkWidth = anchorEl.offsetWidth;
    const checkHeight = anchorEl.offsetHeight;
    if (checkWidth === 0 || checkHeight === 0) {
      console.warn('[DEV] startFateEdgeSparkles: anchor has zero dimensions â€” aborting');
      return;
    }

    function spawn() {
      if (!_guidedFateVisualsActive) return;
      if (!anchorEl.offsetParent) return; // owner removed from DOM

      const existing = overlay.querySelectorAll('.fate-dust-particle[data-sparkle-owner="' + tag + '-' + (anchorEl.id || 'anon') + '"]');
      if (existing.length >= maxParticles) return;

      const rect = anchorEl.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      if (width === 0 || height === 0) return;

      const particle = document.createElement('div');
      particle.className = 'fate-dust-particle fate-dust-particle--anchored';
      particle.dataset.sparkleTag = tag;
      particle.dataset.sparkleOwner = tag + '-' + (anchorEl.id || 'anon');

      // Spawn on outer perimeter â€” offset Â±12-20px outside element edges (element-relative)
      const OFFSET_MIN = 12;
      const OFFSET_MAX = 20;
      const perimeterSide = Math.random();
      let relX, relY;
      const offset = OFFSET_MIN + Math.random() * (OFFSET_MAX - OFFSET_MIN);
      if (perimeterSide < 0.25) {
        // Top edge
        relX = Math.random() * width;
        relY = -offset;
      } else if (perimeterSide < 0.5) {
        // Bottom edge
        relX = Math.random() * width;
        relY = height + offset;
      } else if (perimeterSide < 0.75) {
        // Left edge
        relX = -offset;
        relY = Math.random() * height;
      } else {
        // Right edge
        relX = width + offset;
        relY = Math.random() * height;
      }

      const size = DUST_CONFIG.MIN_SIZE + Math.random() * (DUST_CONFIG.MAX_SIZE - DUST_CONFIG.MIN_SIZE);
      const duration = DUST_CONFIG.MIN_DURATION + Math.random() * (DUST_CONFIG.MAX_DURATION - DUST_CONFIG.MIN_DURATION);
      const opacity = DUST_CONFIG.MIN_OPACITY + Math.random() * (DUST_CONFIG.MAX_OPACITY - DUST_CONFIG.MIN_OPACITY);

      // Drift outward from element center
      const cx = width / 2;
      const cy = height / 2;
      const outAngle = Math.atan2(relY - cy, relX - cx);
      const driftDistance = 15 + Math.random() * 30;
      const dx = Math.cos(outAngle) * driftDistance;
      const dy = Math.sin(outAngle) * driftDistance - 15;

      particle.style.cssText = `
        position: fixed;
        left: ${rect.left + relX}px;
        top: ${rect.top + relY}px;
        width: ${size}px;
        height: ${size}px;
        --dust-duration: ${duration}ms;
        --dust-opacity: ${opacity};
        --dust-dx: ${dx}px;
        --dust-dy: ${dy}px;
      `;

      overlay.appendChild(particle);
      registerAnchoredParticle(particle, anchorEl, relX, relY, rect.left, rect.top);
      setTimeout(() => { if (particle.parentNode) particle.remove(); }, duration + 100);
    }

    const intervalId = setInterval(spawn, spawnInterval);
    _sparkleIntervals.push(intervalId);

    // Gentle initial burst
    const burstCount = Math.min(5, maxParticles);
    for (let i = 0; i < burstCount; i++) {
      setTimeout(spawn, i * 80);
    }
  }

  // Scroll handler for sparkle fade-out â€” prevents sparkles drifting from cards
  let _sparkleScrollHandler = null;
  let _sparkleScrollFading = false;
  let _isAutoScrolling = false;

  // Debounce timer for card/input sparkle reappearance (3000ms)
  let _sparkleReappearTimer = null;
  const SPARKLE_REAPPEAR_DELAY = 3000;

  // Dissipate card/input sparkles (NOT vignette) on scroll/resize
  function dissipateAnchoredSparkles() {
      // Stop all sparkle spawn intervals (prevents immediate respawn)
      _sparkleIntervals.forEach(id => clearInterval(id));
      _sparkleIntervals = [];
      // Fade out anchored sparkles (card + input)
      document.querySelectorAll('.fate-dust-particle--anchored').forEach(p => {
          p.style.transition = 'opacity 200ms ease-out';
          p.style.opacity = '0';
      });
      // Remove after fade
      setTimeout(() => {
          document.querySelectorAll('.fate-dust-particle--anchored').forEach(p => p.remove());
      }, 250);
      // Clear anchored particle tracking
      _anchoredParticles = [];
  }

  // Recreate card/input sparkles at current element positions
  // GUARD: Only called from debounce timer completion
  function recreateAnchoredSparkles() {
      if (!_guidedFateVisualsActive) return;

      // Recreate Fate Card sparkles
      const fateCard = document.getElementById('fateDestinyCard');
      if (fateCard && fateCard.offsetParent) {
          const cardRect = fateCard.getBoundingClientRect();
          if (cardRect.width > 0 && cardRect.height > 0) {
              startFateEdgeSparkles({ anchorEl: fateCard, anchorRect: cardRect, maxParticles: 120, spawnInterval: 25, tag: 'card' });
          }
      }

      // Recreate input sparkles
      const playerInput = document.getElementById('playerNameInput');
      const partnerInput = document.getElementById('partnerNameInput');
      if (playerInput && playerInput.offsetParent) {
          startFateEdgeSparkles({ anchorEl: playerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }
      if (partnerInput && partnerInput.offsetParent) {
          startFateEdgeSparkles({ anchorEl: partnerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }
  }

  // Shared scroll/resize handler â€” dissipate and debounce reappear
  function handleSparkleScrollResize() {
      // GUARD: Only during Guided Fate
      if (!_guidedFateVisualsActive) return;

      // Immediately dissipate card/input sparkles
      dissipateAnchoredSparkles();

      // Clear existing timer and restart 3000ms debounce
      if (_sparkleReappearTimer) {
          clearTimeout(_sparkleReappearTimer);
      }
      _sparkleReappearTimer = setTimeout(() => {
          _sparkleReappearTimer = null;
          recreateAnchoredSparkles();
      }, SPARKLE_REAPPEAR_DELAY);
  }

  function handleSparkleScroll() {
      // GUARD: Never teardown vignette during Guided Fate â€” ONLY on explicit exit
      if (_guidedFateVisualsActive || _sparkleScrollFading) return;
      _sparkleScrollFading = true;

      // Only fade out viewport-based (vignette) sparkles â€” anchored sparkles move with their parent
      document.querySelectorAll('.fate-dust-particle--viewport').forEach(p => {
          p.style.transition = 'opacity 250ms ease-out';
          p.style.opacity = '0';
      });

      // Stop vignette emitter only â€” anchored emitters keep running
      if (_dustInterval) {
          clearInterval(_dustInterval);
          _dustInterval = null;
      }

      // Cleanup viewport particles after fade completes
      setTimeout(() => {
          document.querySelectorAll('.fate-dust-particle--viewport').forEach(p => p.remove());
      }, 300);
  }

  // Activate Guided Fate visuals â€” requires actual Guided Fate card DOM node
  function activateGuidedFateVisuals(fateCardElement) {
      if (!fateCardElement) return;
      _guidedFateVisualsActive = true;
      _sparkleScrollFading = false;

      // Vignette
      const vignette = document.getElementById('fateVignette');
      if (vignette) vignette.classList.add('active');

      // Stop ambient pre-click sparkles â€” replaced by activated sparkles
      stopAmbientCardSparkles();

      // Global vignette sparkles (viewport-based, coexist with anchored)
      startFairyDust();

      // Card glow
      fateCardElement.classList.add('fate-activating');

      // Anchored sparkles from Guided Fate card outer perimeter (intensified)
      const anchorRect = fateCardElement.getBoundingClientRect();
      if (anchorRect.width === 0 || anchorRect.height === 0) {
          console.warn('[DEV] Guided Fate card has zero rect â€” sparkles aborted');
      } else {
          startFateEdgeSparkles({ anchorEl: fateCardElement, anchorRect: anchorRect, maxParticles: 120, spawnInterval: 25, tag: 'card' });
      }

      // Say/Do input glow + secondary low-density sparkles (3 particles max shared)
      const playerInput = document.getElementById('playerNameInput');
      const partnerInput = document.getElementById('partnerNameInput');
      if (playerInput) {
          playerInput.classList.add('guided-fate-glow');
          startFateEdgeSparkles({ anchorEl: playerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }
      if (partnerInput) {
          partnerInput.classList.add('guided-fate-glow');
          startFateEdgeSparkles({ anchorEl: partnerInput, maxParticles: 9, spawnInterval: 270, tag: 'input' });
      }

      // SCROLL FADE-OUT: Add scroll listener to fade sparkles on scroll
      if (_sparkleScrollHandler) {
          window.removeEventListener('scroll', _sparkleScrollHandler, true);
      }
      _sparkleScrollHandler = handleSparkleScroll;
      window.addEventListener('scroll', _sparkleScrollHandler, true); // capture phase for all scrollable containers

      // DISSIPATE-AND-REAPPEAR: Add listeners for card/input sparkle repositioning
      window.addEventListener('scroll', handleSparkleScrollResize, { passive: true });
      window.addEventListener('resize', handleSparkleScrollResize, { passive: true });
  }

  // Deactivate Guided Fate visuals â€” idempotent, no guards
  function deactivateGuidedFateVisuals() {
      _guidedFateVisualsActive = false;
      _sparkleScrollFading = false;

      // Remove scroll listener
      if (_sparkleScrollHandler) {
          window.removeEventListener('scroll', _sparkleScrollHandler, true);
          _sparkleScrollHandler = null;
      }

      // Remove dissipate-and-reappear listeners
      window.removeEventListener('scroll', handleSparkleScrollResize);
      window.removeEventListener('resize', handleSparkleScrollResize);
      if (_sparkleReappearTimer) {
          clearTimeout(_sparkleReappearTimer);
          _sparkleReappearTimer = null;
      }

      // Clear all sparkle intervals and DOM particles
      stopFairyDust();

      // Shut off vignette
      const vignette = document.getElementById('fateVignette');
      if (vignette) {
          vignette.style.opacity = '';
          vignette.classList.remove('active');
          vignette.classList.add('fading');
          setTimeout(() => vignette.classList.remove('fading'), 1600);
      }

      // Remove glow from Guided Fate card
      const fateCard = document.getElementById('fateDestinyCard');
      if (fateCard) fateCard.classList.remove('fate-activating');

      // Remove golden echo from downstream inputs
      document.querySelectorAll('.guided-fate-glow').forEach(el => el.classList.remove('guided-fate-glow'));
  }

  // In-story selection aura â€” reusable golden glow + low-density sparkles
  let _auraSparkleIntervals = [];

  function applySelectionAura(el) {
      if (!el) return;
      el.classList.add('selection-aura');
      const width = el.offsetWidth;
      const height = el.offsetHeight;
      if (width === 0 || height === 0) return;

      const overlay = getSparkleOverlay();
      const ownerId = 'aura-' + (el.id || Math.random().toString(36).slice(2, 8));

      // Low-density sparkles from element perimeter (element-relative)
      const OFFSET_MIN = 8;
      const OFFSET_MAX = 14;
      function spawnAuraSparkle() {
          if (!el.offsetParent) return; // owner removed
          const existing = overlay.querySelectorAll('.fate-dust-particle[data-sparkle-owner="' + ownerId + '"]');
          if (existing.length >= 4) return;

          const rect = el.getBoundingClientRect();
          const w = rect.width;
          const h = rect.height;
          if (w === 0 || h === 0) return;

          const particle = document.createElement('div');
          particle.className = 'fate-dust-particle fate-dust-particle--anchored';
          particle.dataset.sparkleTag = 'aura';
          particle.dataset.sparkleOwner = ownerId;

          const side = Math.random();
          const offset = OFFSET_MIN + Math.random() * (OFFSET_MAX - OFFSET_MIN);
          let relX, relY;
          if (side < 0.25) { relX = Math.random() * w; relY = -offset; }
          else if (side < 0.5) { relX = Math.random() * w; relY = h + offset; }
          else if (side < 0.75) { relX = -offset; relY = Math.random() * h; }
          else { relX = w + offset; relY = Math.random() * h; }

          const size = 2 + Math.random() * 4;
          const duration = 3000 + Math.random() * 3000;
          const opacity = 0.15 + Math.random() * 0.3;
          const cx = w / 2;
          const cy = h / 2;
          const angle = Math.atan2(relY - cy, relX - cx);
          const dx = Math.cos(angle) * (10 + Math.random() * 15);
          const dy = Math.sin(angle) * (10 + Math.random() * 15) - 10;

          particle.style.cssText = `
            position: fixed;
            left: ${rect.left + relX}px; top: ${rect.top + relY}px;
            width: ${size}px; height: ${size}px;
            --dust-duration: ${duration}ms;
            --dust-opacity: ${opacity};
            --dust-dx: ${dx}px; --dust-dy: ${dy}px;
          `;
          overlay.appendChild(particle);
          registerAnchoredParticle(particle, el, relX, relY, rect.left, rect.top);
          setTimeout(() => { if (particle.parentNode) particle.remove(); }, duration + 100);
      }

      const intervalId = setInterval(spawnAuraSparkle, 900);
      _auraSparkleIntervals.push(intervalId);
      spawnAuraSparkle(); // immediate first particle
  }

  function removeSelectionAura(el) {
      if (el) el.classList.remove('selection-aura');
  }

  function removeAllSelectionAuras() {
      document.querySelectorAll('.selection-aura').forEach(el => el.classList.remove('selection-aura'));
      _auraSparkleIntervals.forEach(id => clearInterval(id));
      _auraSparkleIntervals = [];
      document.querySelectorAll('.fate-dust-particle[data-sparkle-tag="aura"]').forEach(p => {
          p.style.opacity = '0';
          p.style.transition = 'opacity 0.3s ease-out';
          setTimeout(() => p.remove(), 400);
      });
  }

  // Expose for fatecards.js
  window.applySelectionAura = applySelectionAura;
  window.removeSelectionAura = removeSelectionAura;
  window.removeAllSelectionAuras = removeAllSelectionAuras;

  function cleanupFateVisuals() {
    // Stop fate running state
    _fateOverridden = true;
    _fateRunning = false;
    _dspGuidedFateActive = false;

    // Ensure DSP activation threshold is met so panel renders after fate cleanup
    if (_dspActivationCount < 2) _dspActivationCount = 2;

    // Clear DSP pending state â€” reveal all clauses immediately on override
    _revealedDSPAxes = null;
    const synopsisText = document.getElementById('synopsisText');
    if (synopsisText) {
      synopsisText.querySelectorAll('.dsp-pending').forEach(span => {
        span.classList.remove('dsp-pending');
      });
    }

    // Stop fairy dust
    stopFairyDust();

    // Remove golden vignette
    const vignette = document.getElementById('fateVignette');
    if (vignette) {
      vignette.style.opacity = ''; // BUGFIX: Clear inline opacity set during ceremony BEFORE fading
      vignette.classList.remove('active');
      vignette.classList.add('fading');
      // Fully hide after fade animation completes
      setTimeout(() => {
        vignette.classList.remove('fading');
      }, 500);
    }

    // Clear all fate highlights
    document.querySelectorAll('.fate-active').forEach(el => el.classList.remove('fate-active'));
    document.querySelectorAll('.fate-typing').forEach(el => el.classList.remove('fate-typing'));
    document.querySelectorAll('.fate-ceremony').forEach(el => el.classList.remove('fate-ceremony'));

    // Rebuild DSP with current state now that guided fate gate is cleared
    updateSynopsisPanel(true);
  }

  // Override handler - user takes control from Fate
  // Always deactivates Guided Fate visuals on any user interaction
  function handleFateOverride(event) {
    // Guard: do not self-cancel when the interaction originates from the Guided Fate card
    const fateCard = document.getElementById('fateDestinyCard');
    if (fateCard && fateCard.contains(event.target)) return;

    // Unconditional visual shutdown on any user action
    deactivateGuidedFateVisuals();

    if (_fateRunning && !_fateOverridden) {
      _fateOverridden = true;
      // Clear all fate highlights immediately
      document.querySelectorAll('.fate-active').forEach(el => el.classList.remove('fate-active'));
      document.querySelectorAll('.fate-typing').forEach(el => el.classList.remove('fate-typing'));
      document.querySelectorAll('.fate-ceremony').forEach(el => el.classList.remove('fate-ceremony'));

      // Stop fairy dust particles
      stopFairyDust();

      // Fade the golden vignette (pulse stops via CSS animation: none)
      const vignette = document.getElementById('fateVignette');
      if (vignette) {
        vignette.style.opacity = ''; // BUGFIX: Clear inline opacity set during ceremony
        vignette.classList.remove('active');
        vignette.classList.add('fading');
      }

      showToast('You take the reins from Fate.');
    }
  }

  // Setup override listeners
  function setupFateOverrideListeners() {
    const setupArea = document.getElementById('setup');
    if (!setupArea) return;

    // Listen for user interaction that indicates override
    const overrideEvents = ['click', 'keydown', 'input', 'change'];
    overrideEvents.forEach(evt => {
      setupArea.addEventListener(evt, handleFateOverride, { capture: true, passive: true });
    });

    // Scroll override (manual scroll detection)
    let lastScrollTop = window.scrollY;
    const scrollHandler = () => {
      if (_fateRunning && !_fateOverridden) {
        const currentScroll = window.scrollY;
        // If user scrolled up (against fate direction), override
        if (currentScroll < lastScrollTop - 50) {
          handleFateOverride();
        }
        lastScrollTop = currentScroll;
      }
    };
    window.addEventListener('scroll', scrollHandler, { passive: true });
  }

  // Clear all fate highlights (ensure clean state before next section)
  function clearAllFateHighlights() {
    document.querySelectorAll('.fate-active').forEach(el => el.classList.remove('fate-active'));
  }

  // Helper: Scroll element into view (DOWNWARD ONLY - NEVER UPWARD)
  // AUTHORITATIVE: This constraint is absolute. No upward scrolling can occur.
  // Combined with visual Y-position sorting, guarantees strict topâ†’bottom flow.
  function scrollToSectionDownward(el) {
    if (!el || _fateOverridden) return;

    const rect = el.getBoundingClientRect();
    const currentScroll = window.scrollY;
    const targetScroll = currentScroll + rect.top - 120; // 120px from top

    // ABSOLUTE CONSTRAINT: Only scroll if target is BELOW current position
    // If targetScroll <= currentScroll, NO SCROLL OCCURS (element already visible or above)
    if (targetScroll > currentScroll) {
      _isAutoScrolling = true;
      // Explicitly trigger sparkle dissipate before programmatic scroll
      if (typeof handleSparkleScrollResize === 'function') handleSparkleScrollResize();
      window.scrollTo({ top: targetScroll, behavior: 'smooth' });
      setTimeout(() => { _isAutoScrolling = false; }, 600);
    }
  }

  // Helper: Type text letter-by-letter with gold glow effect (SLOWED)
  async function typeTextWithGlow(inputEl, text, delayPerChar = FATE_TIMING.TYPING_PER_CHAR) {
    if (!inputEl || !text || _fateOverridden) return;

    inputEl.value = '';
    inputEl.classList.add('fate-typing');
    inputEl.classList.remove('fate-typed');

    for (let i = 0; i < text.length; i++) {
      if (_fateOverridden) break; // Check override each character
      inputEl.value += text[i];
      await new Promise(r => setTimeout(r, delayPerChar));
    }

    // Settle the glow
    inputEl.classList.remove('fate-typing');
    if (!_fateOverridden) {
      inputEl.classList.add('fate-typed');
      setTimeout(() => inputEl.classList.remove('fate-typed'), 800);
    }
  }

  // Helper: Flip a card with reveal animation (SLOWED)
  async function flipCardForFate(cardEl) {
    if (!cardEl || _fateOverridden) return;

    cardEl.classList.add('fate-revealing');

    // Card flip animation
    await new Promise(r => setTimeout(r, FATE_TIMING.CARD_FLIP));
    if (_fateOverridden) return;

    cardEl.classList.add('selected', 'flipped');

    // Settle after flip
    await new Promise(r => setTimeout(r, FATE_TIMING.CARD_FLIP));
    cardEl.classList.remove('fate-revealing');
  }

  // Helper: Atomic section reveal for card grids
  // gridOrSelector can be a CSS selector string OR an element reference
  async function revealCardSection(gridOrSelector, value, sectionTitleEl) {
    if (_fateOverridden) return false;

    const grid = typeof gridOrSelector === 'string'
      ? document.querySelector(gridOrSelector)
      : gridOrSelector;
    if (!grid || !value) return false;

    // STEP 1: Clear previous highlights (one section at a time)
    clearAllFateHighlights();

    // STEP 2: Highlight this section
    if (sectionTitleEl) {
      sectionTitleEl.classList.add('fate-active');
    }

    // STEP 3: Scroll into view (downward only)
    scrollToSectionDownward(sectionTitleEl || grid);
    await new Promise(r => setTimeout(r, FATE_TIMING.SCROLL_SETTLE));
    if (_fateOverridden) return false;

    // STEP 4: Deselect existing cards
    grid.querySelectorAll('.sb-card.selected').forEach(c => {
      c.classList.remove('selected', 'flipped');
    });

    // STEP 5: Find and flip target card
    const targetCard = grid.querySelector(`.sb-card[data-val="${value}"]`);
    if (targetCard) {
      await flipCardForFate(targetCard);
    }

    // DWELL: Let the card sit face-up so viewer registers the choice
    await new Promise(r => setTimeout(r, FATE_TIMING.CARD_DWELL));
    if (_fateOverridden) return false;

    // STEP 6: Settle, then clear highlight
    await new Promise(r => setTimeout(r, FATE_TIMING.HIGHLIGHT_SETTLE));
    if (sectionTitleEl) {
      sectionTitleEl.classList.remove('fate-active');
    }

    return !!targetCard;
  }

  // Helper: Atomic section reveal for archetype cards
  async function revealArchetypeSection(archetypeId) {
    if (_fateOverridden) return false;

    const grid = $('archetypeCardGrid');
    if (!grid || !archetypeId) return false;

    const sectionTitle = $('archetypeSectionTitle');

    // STEP 1: Clear previous highlights
    clearAllFateHighlights();

    // STEP 2: Highlight this section
    if (sectionTitle) {
      sectionTitle.classList.add('fate-active');
    }

    // STEP 3: Scroll into view (downward only)
    scrollToSectionDownward(sectionTitle || grid);
    await new Promise(r => setTimeout(r, FATE_TIMING.SCROLL_SETTLE));
    if (_fateOverridden) return false;

    // STEP 4: Deselect existing
    grid.querySelectorAll('.sb-card.selected').forEach(c => {
      c.classList.remove('selected', 'flipped');
    });

    // STEP 5: Find and flip target card
    const targetCard = grid.querySelector(`.sb-card[data-archetype="${archetypeId}"]`);
    if (targetCard) {
      await flipCardForFate(targetCard);
    }

    // DWELL: Let the card sit face-up so viewer registers the choice
    await new Promise(r => setTimeout(r, FATE_TIMING.CARD_DWELL));
    if (_fateOverridden) return false;

    // STEP 6: Settle, then clear highlight
    await new Promise(r => setTimeout(r, FATE_TIMING.HIGHLIGHT_SETTLE));
    if (sectionTitle) {
      sectionTitle.classList.remove('fate-active');
    }

    return !!targetCard;
  }

  // Helper: Atomic section reveal for name fields
  async function revealNameSection(inputId, name, charBlockSelector) {
    if (_fateOverridden || !name) return;

    const inputEl = $(inputId);
    if (!inputEl) return;

    const charBlock = inputEl.closest('.character-block');
    const fieldContainer = inputEl.closest('.character-field');

    // STEP 1: Clear previous highlights
    clearAllFateHighlights();

    // STEP 2: Highlight this field
    if (fieldContainer) {
      fieldContainer.classList.add('fate-active');
    }

    // STEP 3: Scroll into view (downward only)
    scrollToSectionDownward(charBlock || fieldContainer);
    await new Promise(r => setTimeout(r, FATE_TIMING.SCROLL_SETTLE));
    if (_fateOverridden) return;

    // STEP 4: Type the name
    await typeTextWithGlow(inputEl, name);

    // STEP 5: Settle, then clear highlight
    await new Promise(r => setTimeout(r, FATE_TIMING.HIGHLIGHT_SETTLE));
    if (fieldContainer) {
      fieldContainer.classList.remove('fate-active');
    }
  }

  // Helper: Highlight Begin Story button (END STATE)
  function highlightBeginButton() {
    if (_fateOverridden) return;

    clearAllFateHighlights();

    const beginBtn = $('beginBtn');
    if (beginBtn) {
      beginBtn.classList.add('fate-ready');
      scrollToSectionDownward(beginBtn);

      // Remove highlight on click
      const removeHighlight = () => {
        beginBtn.classList.remove('fate-ready');
        beginBtn.removeEventListener('click', removeHighlight);
      };
      beginBtn.addEventListener('click', removeHighlight);
    }
  }

  // Main Guided Fate Choreography Engine
  // AUTHORITATIVE: DOM visual order, opening ceremony, downward-only
  async function runGuidedFateFill(fateChoices) {
    // Initialize override state
    _fateOverridden = false;
    _fateRunning = true;
    setupFateOverrideListeners();

    // Mark authorship as resolved (Guided Fate path)
    state.mode = 'guided';
    corridorSelections.set('authorship', { grp: 'authorship', val: 'guided' });

    // Pre-set state values (silent, no UI)
    state.gender = 'Female';
    state.loveInterest = 'Male';
    state.picks.world = fateChoices.world;
    state.picks.worldSubtype = fateChoices.worldFlavor;
    state.picks.tone = canonicalizeTone(fateChoices.tone);
    state.picks.genre = fateChoices.genre;
    state.picks.dynamic = fateChoices.dynamic;
    state.picks.pov = fateChoices.pov;
    state.intensity = fateChoices.intensity;
    state.storyLength = fateChoices.storyLength;
    state.archetype = { primary: fateChoices.archetype, modifier: null };
    deriveToneBias();

    if (fateChoices.world === 'Historical' && fateChoices.worldFlavor) {
      state.picks.era = fateChoices.worldFlavor;
    }

    // STORY-DEFINING INPUTS CHANGED: Invalidate snapshot â†’ forces "Begin Story"
    if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();

    state.constraints = { bannedWords: [], bannedNames: [], excluded: [], tone: [], corrections: [], ambientMods: [] };
    state.fate = { stance: 'neutral', minorUsedThisScene: false, greaterUsedThisScene: false, lastGreaterSceneIndex: null, earnedIntimacy: false, earlyGamingCount: 0, pendingPetition: null };
    state.fate_saturation = 0;
    state.volatility_window = { active: false, severity: 0, remaining_scenes: 0 };
    state.tempt_fate_invoked_this_turn = false;
    state.consecutive_tempt_fate_count = 0;
    state.cautiousStreak = 0;
    state.dynamicDominanceBoost = 0;
    state.vulnerabilityPulse = 0;
    state.lastDreamInjectionTurn = 0;
    state._dreamInjectionLine = null;
    state.selectionTension = 0;
    state.lastSelectionEchoTurn = 0;
    state._selectionEchoLine = null;
    state.coupleTensionDrift = 0;
    state.coupleStructure = 'monogamous';
    state.coupleHasReachedST4 = false;
    state.lastCoupleDriftEchoScene = 0;
    state._coupleDriftEchoLine = null;
    _coupleStructureVotes = { player1: null, player2: null };
    // Preserve scene5Granted through fortuneFavor reset (anti-farming for same storyId)
    state._fortuneFavorScene5Cache = state.fortuneFavor?.scene5Granted || false;
    state.fortuneFavor = null;
    // Cosmic Sparkle UX â€” recompute sparkle after spotlight charge cleared
    updateTemptFateSparkle();

    // Pre-set dropdowns silently (elements may be in unmounted corridor row)
    const _pgEl = $('playerGender'); if (_pgEl) _pgEl.value = 'Female';
    const _ppEl = $('playerPronouns'); if (_ppEl) _ppEl.value = 'She/Her';
    const _lgEl = $('loveInterestGender'); if (_lgEl) _lgEl.value = 'Male';
    const _lpEl = $('lovePronouns'); if (_lpEl) _lpEl.value = 'He/Him';

    // Age fields removed â€” no longer part of the character form

    // Initialize DSP clause reveal tracking â€” all clauses start pending
    _revealedDSPAxes = new Set();
    _dspGuidedFateActive = true; // Lock DSP to incremental mode

    // NOTE: DSP is NOT pre-populated here. It remains showing placeholder.
    // DSP content is populated on-demand when revealDSPClause is first called.

    // ===============================================
    // PART B: OPENING CEREMONY
    // Golden vignette + character names first (MINIMUM 5 seconds, NO SCROLL)
    // ===============================================

    const ceremonyStartTime = Date.now();

    // Activate golden vignette + sparkles + input echo
    const fateCardElement = document.getElementById('fateDestinyCard');
    activateGuidedFateVisuals(fateCardElement);

    // Highlight both character blocks during ceremony
    const mcBlock = document.querySelector('#playerNameInput')?.closest('.character-block');
    const liBlock = document.querySelector('#partnerNameInput')?.closest('.character-block');
    if (mcBlock) mcBlock.classList.add('fate-ceremony');
    if (liBlock) liBlock.classList.add('fate-ceremony');

    // NO SCROLL during opening ceremony - names fill in place
    await new Promise(r => setTimeout(r, 800)); // Let vignette settle
    if (_fateOverridden) { _fateRunning = false; return; }

    // Fill MC name (letter-by-letter with gold glow, 120ms per char for gravitas)
    // Set character name kernel regardless of input availability (corridor may unmount it)
    if (fateChoices.playerName) state.normalizedPlayerKernel = fateChoices.playerName;
    const mcInput = $('playerNameInput');
    if (mcInput && fateChoices.playerName && !_fateOverridden) {
      mcInput.value = '';
      mcInput.classList.add('fate-typing');
      for (let i = 0; i < fateChoices.playerName.length; i++) {
        if (_fateOverridden) break;
        mcInput.value += fateChoices.playerName[i];
        await new Promise(r => setTimeout(r, 120)); // Deliberate pace
      }
      mcInput.classList.remove('fate-typing');
      mcInput.classList.add('fate-typed');
      setTimeout(() => mcInput.classList.remove('fate-typed'), 800);
    }

    await new Promise(r => setTimeout(r, 800)); // Pause between names
    if (_fateOverridden) { _fateRunning = false; return; }

    // Fill LI name (letter-by-letter with gold glow, 120ms per char for gravitas)
    // Set partner name kernel regardless of input availability (corridor may unmount it)
    if (fateChoices.partnerName) state.normalizedPartnerKernel = fateChoices.partnerName;
    const liInput = $('partnerNameInput');
    if (liInput && fateChoices.partnerName && !_fateOverridden) {
      liInput.value = '';
      liInput.classList.add('fate-typing');
      for (let i = 0; i < fateChoices.partnerName.length; i++) {
        if (_fateOverridden) break;
        liInput.value += fateChoices.partnerName[i];
        await new Promise(r => setTimeout(r, 120)); // Deliberate pace
      }
      liInput.classList.remove('fate-typing');
      liInput.classList.add('fate-typed');
      setTimeout(() => liInput.classList.remove('fate-typed'), 800);
    }

    // ENFORCE MINIMUM CEREMONY DURATION (â‰¥5 seconds)
    const ceremonyElapsed = Date.now() - ceremonyStartTime;
    const ceremonyRemaining = FATE_TIMING.MIN_NAMES_CEREMONY - ceremonyElapsed;
    if (ceremonyRemaining > 0 && !_fateOverridden) {
      await new Promise(r => setTimeout(r, ceremonyRemaining));
    }
    if (_fateOverridden) { _fateRunning = false; return; }

    // Remove ceremony highlights from character blocks
    if (mcBlock) mcBlock.classList.remove('fate-ceremony');
    if (liBlock) liBlock.classList.remove('fate-ceremony');

    // Vignette stays at full intensity through Guided Fate â†’ book dwell

    // ===============================================
    // PART A/C: BUILD SECTION LIST BY DOM POSITION
    // Execute sections in strict visual order (top â†’ bottom)
    // ===============================================

    // Define all Fate-relevant sections with their grid selectors and data keys
    const sectionConfigs = [
      { id: 'archetype', grid: '#archetypeCardGrid', titleId: 'archetypeSectionTitle', value: fateChoices.archetype, type: 'archetype' },
      // intensity removed from UI â€” set internally via getFateIntensity()
      { id: 'length', grid: '#lengthGrid', value: fateChoices.storyLength, type: 'card' },
      { id: 'pov', grid: '#povGrid', value: fateChoices.pov, type: 'card' },
      { id: 'world', grid: '#worldGrid', value: fateChoices.world, type: 'card' },
      { id: 'tone', grid: '#toneGrid', value: fateChoices.tone, type: 'card' },
      { id: 'genre', grid: '#genreGrid', value: fateChoices.genre, type: 'card' },
      { id: 'dynamic', grid: '#dynamicGrid', value: fateChoices.dynamic, type: 'card' }
    ];

    // Build section list sorted by DOM visual position
    const sectionsWithPositions = sectionConfigs
      .map(cfg => {
        const grid = document.querySelector(cfg.grid);
        if (!grid) return null;
        const rect = grid.getBoundingClientRect();
        const visualY = rect.top + window.scrollY;
        return { ...cfg, grid, visualY };
      })
      .filter(s => s !== null)
      .sort((a, b) => a.visualY - b.visualY);

    // Execute sections in visual order (downward only)
    // ENFORCES: Archetype â‰¥4s, Intensity â‰¥4s minimum timing
    for (const section of sectionsWithPositions) {
      if (_fateOverridden) { _fateRunning = false; return; }

      const sectionStartTime = Date.now();

      if (section.type === 'archetype') {
        // Archetype has special handling
        await revealArchetypeSection(section.value);
        const archName = ARCHETYPES[section.value]?.name || section.value;
        const primaryNameEl = $('selectedPrimaryName');
        if (primaryNameEl) primaryNameEl.textContent = archName;

        // ENFORCE MINIMUM ARCHETYPE DURATION (â‰¥4 seconds)
        const archetypeElapsed = Date.now() - sectionStartTime;
        const archetypeRemaining = FATE_TIMING.MIN_ARCHETYPE_REVEAL - archetypeElapsed;
        if (archetypeRemaining > 0 && !_fateOverridden) {
          await new Promise(r => setTimeout(r, archetypeRemaining));
        }
      } else {
        // Standard card section
        const sectionTitle = section.grid.previousElementSibling;
        await revealCardSection(section.grid, section.value, sectionTitle);

        // ENFORCE MINIMUM INTENSITY DURATION (â‰¥4 seconds)
        if (section.id === 'intensity') {
          const intensityElapsed = Date.now() - sectionStartTime;
          const intensityRemaining = FATE_TIMING.MIN_INTENSITY_REVEAL - intensityElapsed;
          if (intensityRemaining > 0 && !_fateOverridden) {
            await new Promise(r => setTimeout(r, intensityRemaining));
          }
        }
      }

      // Reveal corresponding DSP clause after card is visually selected
      if (['world', 'tone', 'archetype', 'length'].includes(section.id)) {
        revealDSPClause(section.id);
      }

      await new Promise(r => setTimeout(r, FATE_TIMING.SECTION_PAUSE));
    }

    // ===============================================
    // END STATE: Highlight Begin Story
    // ===============================================
    if (_fateOverridden) { _fateRunning = false; return; }

    // Vignette + fairy dust persist through Begin Story â†’ book dwell
    // deactivateGuidedFateVisuals() is called when dwell completes in openBook()

    highlightBeginButton();
    showToast('Fate has spoken. Click Begin Story when ready.');

    // CORRIDOR: Mark corridor as complete since Guided Fate made all selections
    if (typeof completeCorridorFromGuidedFate === 'function') {
      completeCorridorFromGuidedFate();
    }

    _fateRunning = false;
    state._fateTriggered = true;
  }

  // Populate all UI selections from fate choices
  function populateFateSelections(fateChoices) {
    // Set player character
    $('playerGender').value = 'Female';
    $('playerPronouns').value = 'She/Her';
    $('playerNameInput').value = fateChoices.playerName;

    // Set love interest
    $('loveInterestGender').value = 'Male';
    $('lovePronouns').value = 'He/Him';
    $('partnerNameInput').value = fateChoices.partnerName;

    // Age fields removed â€” no longer part of the character form

    // Update state directly
    state.gender = 'Female';
    state.loveInterest = 'Male';
    state.picks.world = fateChoices.world;
    state.picks.worldSubtype = fateChoices.worldFlavor;
    state.picks.tone = canonicalizeTone(fateChoices.tone);
    state.picks.genre = fateChoices.genre;
    state.picks.dynamic = fateChoices.dynamic;
    state.picks.pov = fateChoices.pov;
    state.intensity = fateChoices.intensity;
    state.storyLength = fateChoices.storyLength;

    // Set archetype (required for story generation)
    state.archetype = { primary: fateChoices.archetype, modifier: null };
    deriveToneBias();

    // Set Withheld Core lens variant (if assigned by fate)
    state.withheldCoreVariant = fateChoices.withheldCoreVariant || null;

    // Handle Historical era if needed
    if (fateChoices.world === 'Historical' && fateChoices.worldFlavor) {
      state.picks.era = fateChoices.worldFlavor;
    }

    // STORY-DEFINING INPUTS CHANGED: Invalidate snapshot â†’ forces "Begin Story"
    if (typeof invalidateShapeSnapshot === 'function') invalidateShapeSnapshot();

    // Clear constraints + reset petition fate
    state.constraints = { bannedWords: [], bannedNames: [], excluded: [], tone: [], corrections: [], ambientMods: [] };
    state.fate = { stance: 'neutral', minorUsedThisScene: false, greaterUsedThisScene: false, lastGreaterSceneIndex: null, earnedIntimacy: false, earlyGamingCount: 0, pendingPetition: null };
    state.fate_saturation = 0;
    state.volatility_window = { active: false, severity: 0, remaining_scenes: 0 };
    state.tempt_fate_invoked_this_turn = false;
    state.consecutive_tempt_fate_count = 0;
    state.cautiousStreak = 0;
    state.dynamicDominanceBoost = 0;
    state.vulnerabilityPulse = 0;
    state.lastDreamInjectionTurn = 0;
    state._dreamInjectionLine = null;
    state.selectionTension = 0;
    state.lastSelectionEchoTurn = 0;
    state._selectionEchoLine = null;
    state.coupleTensionDrift = 0;
    state.coupleStructure = 'monogamous';
    state.coupleHasReachedST4 = false;
    state.lastCoupleDriftEchoScene = 0;
    state._coupleDriftEchoLine = null;
    _coupleStructureVotes = { player1: null, player2: null };
    // Preserve scene5Granted through fortuneFavor reset (anti-farming for same storyId)
    state._fortuneFavorScene5Cache = state.fortuneFavor?.scene5Granted || false;
    state.fortuneFavor = null;
    // Cosmic Sparkle UX â€” recompute sparkle after spotlight charge cleared
    updateTemptFateSparkle();

    // Update UI cards to reflect selections
    updateAllCardSelections();

    // GATE: Do NOT bulk-hydrate DSP during Guided Fate â€” incremental reveal only
    // DSP updates are handled by revealDSPClause() per selection
  }

  // Update all card UI to reflect state
  function updateAllCardSelections() {
    const axes = ['world', 'tone', 'genre', 'dynamic', 'intensity', 'length', 'pov'];
    axes.forEach(grp => {
      const value = grp === 'intensity' ? state.intensity :
                    grp === 'length' ? state.storyLength :
                    state.picks[grp];
      if (!value) return;

      document.querySelectorAll(`.sb-card[data-grp="${grp}"]`).forEach(card => {
        const isSelected = card.dataset.val === value;
        card.classList.toggle('selected', isSelected);
        card.classList.toggle('flipped', isSelected);
      });
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // AUTHORSHIP CHOICE HANDLERS â€” Two-card selection (Choose Your Hand vs Guided Fate)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Track authorship choice state
  let authorshipChoiceMade = false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONTINUOUS SPARKLE EMITTER SYSTEM â€” Soft flitting particles on authorship cards
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Active emitter intervals (for cleanup)
  const sparkleEmitterIntervals = new Map();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPARKLE BEHAVIORAL PROFILES â€” Distinct character for each emitter type
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPARKLE PROFILES â€” Calm ambient halo (UI affordance, not fireworks)
  // - Constant size (no size variance, alpha variance only)
  // - Perimeter halo emission (outside card bounds)
  // - Continuous low-rate spawn (no bursts)
  // - Slow steady drift (no start-stop motion)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPARKLE PROFILES â€” Ambient fate energy, NOT orbital loading indicator
  // Behavior: drift, rise, fade, occasional flicker
  // Variance: size, opacity, lifespan all varied for organic feel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const SPARKLE_PROFILES = {
    // Guided Fate: mystical, hovering gold cloud around card
    guidedFate: {
      durationMin: 4.0,
      durationMax: 7.0,
      sizeMin: 3,
      sizeMax: 7,
      opacityMin: 0.4,
      opacityRange: 0.5,    // 0.4-0.9
      haloOffset: 15,
      driftType: 'hover',
      driftDistance: 12,
      curveAmp: 3,
      flickerChance: 0.3
    },
    // Begin Story button: tight halo hugging button edges
    beginStory: {
      durationMin: 4.0,
      durationMax: 7.0,
      sizeMin: 2,
      sizeMax: 5,
      opacityMin: 0.3,
      opacityRange: 0.5,    // 0.3-0.8
      haloOffset: 8,        // tight to edges
      outsideRatio: 1.0,    // 100% perimeter â€” hug the button edges
      driftType: 'hover',
      driftDistance: 6,
      curveAmp: 3,
      flickerChance: 0.3
    },
    // Choose Your Hand: matches Guided Fate energy
    chooseHand: {
      durationMin: 4.0,
      durationMax: 7.0,
      sizeMin: 3,
      sizeMax: 7,
      opacityMin: 0.4,
      opacityRange: 0.5,    // 0.4-0.9
      haloOffset: 15,
      driftType: 'hover',
      driftDistance: 12,
      curveAmp: 3,
      flickerChance: 0.3
    },
    // Destiny Deck: subtle ambient
    destinyDeck: {
      durationMin: 1.5,
      durationMax: 3.0,
      sizeMin: 1,
      sizeMax: 2.5,
      opacityMin: 0.3,
      opacityRange: 0.5,
      haloOffset: 8,
      driftType: 'float',
      flickerChance: 0.15
    },
    // Zoomed card: sparkles hovering around zoomed card edges
    // Size/drift are counter-scaled by zoomScale in spawnSparkle, so use
    // values matching the unzoomed guidedFate/chooseHand feel.
    zoomCard: {
      durationMin: 4.0,
      durationMax: 6.5,
      sizeMin: 3,
      sizeMax: 7,
      opacityMin: 0.4,
      opacityRange: 0.5,
      haloOffset: 8,
      driftType: 'hover',
      driftDistance: 12,
      curveAmp: 3,
      flickerChance: 0.3,
      outsideRatio: 1.0
    },
    // Fate card firefly: gold glow sparkles hovering around fate cards
    fateFirefly: {
      durationMin: 4.0,
      durationMax: 7.0,
      sizeMin: 3,
      sizeMax: 7,
      opacityMin: 0.5,
      opacityRange: 0.4,     // 0.5-0.9
      haloOffset: 8,
      driftType: 'hover',
      flickerChance: 0.25,
      driftDistance: 10,      // max px drift from spawn (keeps sparkles close)
      curveAmp: 3,            // max px wiggle (gentle, not zig-zag)
      boxShadow: '0 0 8px rgba(255,215,0,0.7)'
    },
    // Cover button: multi-tone gold emission during generation
    coverButton: {
      durationMin: 4.0,
      durationMax: 7.0,
      sizeMin: 2,
      sizeMax: 5,
      opacityMin: 0.85,
      opacityRange: 0.15,    // 0.85-1.0
      haloOffset: 4,
      driftType: 'wander',
      flickerChance: 0.1,
      colorPalette: [
        { core: 'rgba(255,250,220,0.98)', mid: 'rgba(255,223,120,0.85)', glow: 'rgba(255,200,50,0.6)' },
        { core: 'rgba(255,235,150,0.95)', mid: 'rgba(255,215,0,0.8)',   glow: 'rgba(218,165,32,0.5)' },
        { core: 'rgba(255,220,100,0.95)', mid: 'rgba(255,193,37,0.85)', glow: 'rgba(184,134,11,0.5)' },
        { core: 'rgba(255,245,200,0.98)', mid: 'rgba(255,228,140,0.85)',glow: 'rgba(255,200,80,0.55)' },
        { core: 'rgba(255,210,80,0.95)',  mid: 'rgba(230,180,30,0.8)',  glow: 'rgba(180,130,20,0.5)' },
        { core: 'rgba(255,240,180,0.96)', mid: 'rgba(255,210,100,0.82)',glow: 'rgba(200,160,40,0.5)' }
      ]
    }
  };

  /**
   * Spawn a single sparkle particle with profile-specific behavior
   * PERIMETER HALO: Sparkles spawn on a ring slightly OUTSIDE the card bounds
   * Motion is slow, continuous drift â€” never bursty or start-stop
   * @param {HTMLElement} container - The sparkle emitter container
   * @param {string} profileName - Key into SPARKLE_PROFILES
   */
  function spawnSparkle(container, profileName = 'chooseHand') {
    if (!container) return;

    const profile = SPARKLE_PROFILES[profileName] || SPARKLE_PROFILES.chooseHand;

    // Counter-scale for zoomed cards: card uses transform:scale(S), so px values
    // in pre-transform space appear SÃ— larger visually. Divide by S to compensate.
    const zoomCard = container.closest('.sb-card.zoomed');
    const zoomScale = zoomCard ? parseFloat(zoomCard.style.getPropertyValue('--zoom-scale')) || 1 : 1;

    const sparkle = document.createElement('div');
    sparkle.className = 'authorship-sparkle';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AMBIENT FATE ENERGY: Spawn along bounding box edges (shape-aware, NOT oval)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const containerRect = container.getBoundingClientRect();
    const haloOffset = profile.haloOffset || 10;

    const outsideRatio = profile.outsideRatio ?? 1.0;
    let x, y;
    if (outsideRatio < 1.0 && Math.random() > outsideRatio) {
      // Spawn inside container boundary
      x = 10 + Math.random() * 80;
      y = 10 + Math.random() * 80;
    } else {
      // Spawn along perimeter edges (rectangular bounding box)
      const haloPctX = (haloOffset / containerRect.width) * 100;
      const haloPctY = (haloOffset / containerRect.height) * 100;
      const perimeter = 2 * (containerRect.width + containerRect.height);
      const p = Math.random() * perimeter;
      if (p < containerRect.width) {
        // Top edge
        x = (p / containerRect.width) * 100;
        y = -haloPctY + Math.random() * haloPctY;
      } else if (p < containerRect.width + containerRect.height) {
        // Right edge
        x = 100 + Math.random() * haloPctX;
        y = ((p - containerRect.width) / containerRect.height) * 100;
      } else if (p < 2 * containerRect.width + containerRect.height) {
        // Bottom edge
        x = ((p - containerRect.width - containerRect.height) / containerRect.width) * 100;
        y = 100 + Math.random() * haloPctY;
      } else {
        // Left edge
        x = -haloPctX + Math.random() * haloPctX;
        y = ((p - 2 * containerRect.width - containerRect.height) / containerRect.height) * 100;
      }
    }

    sparkle.style.left = `${x}%`;
    sparkle.style.top = `${y}%`;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ORGANIC VARIANCE: Size, opacity, and lifespan all varied
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Duration with variance
    const duration = profile.durationMin + Math.random() * (profile.durationMax - profile.durationMin);

    // Size variance (NOT constant), counter-scaled for zoom
    const sizeMin = (profile.sizeMin || 3) / zoomScale;
    const sizeMax = (profile.sizeMax || 6) / zoomScale;
    const size = sizeMin + Math.random() * (sizeMax - sizeMin);

    // Opacity variance
    const opacity = profile.opacityMin + Math.random() * profile.opacityRange;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DRIFT TYPE: Rise, wander, or float â€” NOT orbital
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let driftX = 0, driftY = 0;
    const driftType = profile.driftType || 'wander';

    switch (driftType) {
      case 'rise':
        // Upward drift with slight horizontal wander
        driftX = (Math.random() - 0.5) * 30;
        driftY = -20 - Math.random() * 40; // Always upward
        break;
      case 'wander':
        // Drift outward from spawn angle (edge sparkles drift away from card)
        const wanderAngle = angle + (Math.random() - 0.5) * 1.2; // Â±35Â° from spawn angle
        const wanderDist = 15 + Math.random() * 25;
        driftX = Math.cos(wanderAngle) * wanderDist;
        driftY = Math.sin(wanderAngle) * wanderDist;
        break;
      case 'hover':
        // Gentle drift staying close to spawn point (orbit-like linger)
        const hoverDist = profile.driftDistance || 10;
        const hoverAngle = Math.random() * Math.PI * 2;
        driftX = Math.cos(hoverAngle) * (Math.random() * hoverDist);
        driftY = Math.sin(hoverAngle) * (Math.random() * hoverDist);
        break;
      case 'float':
        // Very slow drift, mostly upward
        driftX = (Math.random() - 0.5) * 20;
        driftY = -10 - Math.random() * 20;
        break;
    }

    // Counter-scale drift for zoom
    driftX /= zoomScale;
    driftY /= zoomScale;

    // Flicker animation class
    const shouldFlicker = Math.random() < (profile.flickerChance || 0);
    if (shouldFlicker) {
      sparkle.classList.add('sparkle-flicker');
    }

    // Perpendicular curve amplitude for firefly wiggle
    const perpAngle = Math.atan2(driftY, driftX) + Math.PI / 2;
    const maxCurve = (profile.curveAmp ?? (4 + Math.random() * 10)) / zoomScale;
    const curveAmp = typeof profile.curveAmp === 'number'
      ? Math.random() * maxCurve  // profile-controlled: 0 to max
      : maxCurve;                 // default: 4-14px firefly wiggle

    sparkle.style.setProperty('--sparkle-duration', `${duration}s`);
    sparkle.style.setProperty('--sparkle-drift-x', `${driftX}px`);
    sparkle.style.setProperty('--sparkle-drift-y', `${driftY}px`);
    sparkle.style.setProperty('--sparkle-curve-x', `${Math.cos(perpAngle) * curveAmp}px`);
    sparkle.style.setProperty('--sparkle-curve-y', `${Math.sin(perpAngle) * curveAmp}px`);
    sparkle.style.setProperty('--sparkle-opacity', opacity);
    sparkle.style.setProperty('--sparkle-size', `${size}px`);

    // Profile-specific visual overrides
    if (profile.boxShadow) {
      sparkle.style.boxShadow = profile.boxShadow;
    }
    if (profile.colorPalette) {
      const palette = profile.colorPalette[Math.floor(Math.random() * profile.colorPalette.length)];
      sparkle.style.background = `radial-gradient(circle, ${palette.core}, ${palette.mid} 60%, transparent 100%)`;
      sparkle.style.boxShadow = `0 0 ${4 + Math.random() * 6}px ${Math.random() * 2}px ${palette.glow}`;
    }

    container.appendChild(sparkle);

    // Remove after animation completes
    setTimeout(() => sparkle.remove(), duration * 1000);
  }

  /**
   * Start continuous sparkle emitter with profile-specific behavior
   * NO BURSTS â€” low, continuous rate over time for calm ambient halo
   * @param {string} containerId - The ID of the sparkle emitter container
   * @param {string} profileName - Key into SPARKLE_PROFILES
   * @param {number} rate - Sparkles per second (low values for calm effect)
   */
  function startSparkleEmitter(containerId, profileName, rate = 2, options = {}) {
    const container = $(containerId);
    if (!container) return;

    // Don't start if already running
    if (sparkleEmitterIntervals.has(containerId)) return;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONTINUOUS LOW-RATE EMISSION with optional initial burst
    // Small timing jitter for natural feel, but maintains steady flow
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const baseInterval = 1000 / rate;
    let emitterActive = true;

    // Optional initial burst: spawn N particles staggered at 80ms
    if (options.initialBurst) {
      for (let i = 0; i < options.initialBurst; i++) {
        setTimeout(() => { if (emitterActive) spawnSparkle(container, profileName); }, i * 80);
      }
    }

    function scheduleNextSparkle() {
      if (!emitterActive) return;

      // Minor jitter: Â±15% variance (0.85 to 1.15) â€” keeps flow continuous
      const jitter = 0.85 + Math.random() * 0.3;
      const nextDelay = baseInterval * jitter;

      setTimeout(() => {
        if (!emitterActive) return;
        spawnSparkle(container, profileName);
        scheduleNextSparkle();
      }, nextDelay);
    }

    // Start the continuous spawn loop immediately
    scheduleNextSparkle();

    // Store cleanup function
    sparkleEmitterIntervals.set(containerId, { stop: () => { emitterActive = false; } });

    console.log(`[Sparkle] Started emitter: ${containerId} (profile: ${profileName}, continuous)`);
  }

  /**
   * Stop a sparkle emitter
   * @param {string} containerId - The ID of the sparkle emitter container
   */
  function stopSparkleEmitter(containerId) {
    const emitter = sparkleEmitterIntervals.get(containerId);
    if (emitter) {
      // Handle both old interval and new jittered stop function
      if (typeof emitter.stop === 'function') {
        emitter.stop();
      } else if (typeof emitter === 'number') {
        clearInterval(emitter);
      }
      sparkleEmitterIntervals.delete(containerId);
      console.log(`[Sparkle] Stopped emitter: ${containerId}`);
    }
  }

  /**
   * Stop all active sparkle emitters
   */
  function stopAllSparkleEmitters() {
    sparkleEmitterIntervals.forEach((emitter, id) => {
      if (typeof emitter.stop === 'function') {
        emitter.stop();
      } else if (typeof emitter === 'number') {
        clearInterval(emitter);
      }
      console.log(`[Sparkle] Stopped emitter: ${id}`);
    });
    sparkleEmitterIntervals.clear();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ANCHORED SPARKLE CONTAINER â€” Create/remove sparkle container as child of element
  // Used by fate cards and cover button to anchor sparkles to DOM elements
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  let _anchoredContainerCounter = 0;

  function createAnchoredSparkleContainer(anchorEl, idSuffix) {
    if (!anchorEl || !anchorEl.parentNode) return null;

    const isTextarea = anchorEl.tagName && anchorEl.tagName.toLowerCase() === 'textarea';
    const containerParent = isTextarea ? anchorEl.parentNode : anchorEl;

    // Ensure parent has position for absolute children
    const computedPosition = window.getComputedStyle(containerParent).position;
    if (computedPosition === 'static') {
      containerParent.style.position = 'relative';
    }

    const containerId = `anchored-sparkle-${idSuffix || (++_anchoredContainerCounter)}`;
    const container = document.createElement('div');
    container.id = containerId;
    container.className = 'authorship-sparkle-container';

    if (isTextarea) {
      const anchorRect = anchorEl.getBoundingClientRect();
      const parentRect = containerParent.getBoundingClientRect();
      container.style.cssText =
        'position:absolute;' +
        `left:${anchorRect.left - parentRect.left - 8}px;` +
        `top:${anchorRect.top - parentRect.top - 8}px;` +
        `width:${anchorRect.width + 16}px;` +
        `height:${anchorRect.height + 16}px;` +
        'pointer-events:none;z-index:10;overflow:visible;';
    } else {
      container.style.cssText =
        'position:absolute;left:-8px;top:-8px;right:-8px;bottom:-8px;' +
        'pointer-events:none;z-index:10;overflow:visible;';
    }

    containerParent.appendChild(container);
    return containerId;
  }

  function removeAnchoredSparkleContainer(containerId) {
    if (!containerId) return;
    stopSparkleEmitter(containerId);
    const container = $(containerId);
    if (container) {
      container.style.transition = 'opacity 0.5s ease-out';
      container.style.opacity = '0';
      setTimeout(() => { if (container.parentNode) container.remove(); }, 500);
    }
  }

  // Expose sparkle system for external modules (fatecards.js, etc.)
  window.startSparkleEmitter = startSparkleEmitter;
  window.stopSparkleEmitter = stopSparkleEmitter;
  window.createAnchoredSparkleContainer = createAnchoredSparkleContainer;
  window.removeAnchoredSparkleContainer = removeAnchoredSparkleContainer;

  /**
   * Initialize sparkle emitters for authorship cards
   * Called when authorship row becomes visible
   */
  function initAuthorshipSparkles() {
    // Both cards: same sparkle energy (6/sec each)
    startSparkleEmitter('chooseHandSparkles', 'chooseHand', 6);
    startSparkleEmitter('guidedFateSparkles', 'guidedFate', 6);
  }

  /**
   * Initialize sparkle emitter for destiny deck
   * Called when character section becomes visible
   */
  function initDestinyDeckSparkles() {
    // Destiny Deck: visible sparkle halo around mini-deck
    startSparkleEmitter('destinyDeckSparkles', 'destinyDeck', 3);
  }

  /**
   * Remove authorship cards when choice is made and breadcrumb created
   * Cards dissolve after brief delay to show selection
   */
  function removeAuthorshipCards() {
    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');
    const authorshipRow = $('authorshipChoiceRow');

    // Stop sparkle emitters
    stopSparkleEmitter('chooseHandSparkles');
    stopSparkleEmitter('guidedFateSparkles');

    // After a delay, collapse the entire authorship row
    setTimeout(() => {
      if (authorshipRow) {
        authorshipRow.classList.add('collapsed');
        setTimeout(() => {
          authorshipRow.style.display = 'none';
        }, 400);
      }
    }, 600);

    console.log('[Authorship] Cards removed after breadcrumb creation');
  }

  // Reset authorship choice (called from resetCorridor)
  function resetAuthorshipChoice() {
    authorshipChoiceMade = false;

    // Clear persistent authorship state
    state.authorship = null;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');
    const characterSection = $('characterSectionRow');
    const postArousalSection = $('postArousalSection');

    // Reset card states (including inline visibility set by breadcrumb animation)
    if (chooseCard) {
      chooseCard.classList.remove('flipped', 'selected', 'selected-static', 'dissolving-to-breadcrumb', 'dissipating', 'hidden', 'dimmed');
      chooseCard.style.visibility = '';
    }
    if (fateCard) {
      fateCard.classList.remove('flipped', 'selected', 'selected-static', 'dissolving-to-breadcrumb', 'dissipating', 'hidden', 'dimmed');
      fateCard.style.visibility = '';
    }

    // Hide authorship Continue button
    const authorshipContinueBtn = $('continueFromAuthorship');
    if (authorshipContinueBtn) authorshipContinueBtn.classList.remove('visible');

    // Hide character section and post-arousal section
    if (characterSection) characterSection.classList.add('hidden');
    if (postArousalSection) postArousalSection.classList.add('hidden');

    // Restore authorship row visibility
    const authorshipRow = $('authorshipChoiceRow');
    if (authorshipRow) {
      authorshipRow.classList.remove('collapsed');
      authorshipRow.style.display = '';
    }

    // Stop any existing sparkle emitters before restarting
    stopAllSparkleEmitters();

    // Restart sparkle emitters for authorship cards
    initAuthorshipSparkles();

    console.log('[Authorship] Choice reset');
  }
  window.resetAuthorshipChoice = resetAuthorshipChoice;

  // "Choose Your Hand" click handler â€” Selection only, requires Continue
  $('chooseYourHandCard')?.addEventListener('click', () => {
    if (authorshipChoiceMade) return;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');

    // Toggle selection: if already selected, deselect (unflip)
    if (chooseCard?.classList.contains('selected')) {
      chooseCard.classList.remove('selected', 'flipped');
      state.authorship = null;
      // Restore sparkles on both cards (same rate for both)
      startSparkleEmitter('chooseHandSparkles', 'chooseHand', 6);
      startSparkleEmitter('guidedFateSparkles', 'guidedFate', 6);
      // Update control plane Continue visibility
      if (typeof updateCorridorContinueButtonVisibility === 'function') {
        updateCorridorContinueButtonVisibility();
      }
      console.log('[Authorship] Choose Your Hand deselected');
      return;
    }

    // 1. Select Choose Your Hand (scale up, sparkles, flip to art)
    chooseCard?.classList.add('selected', 'flipped');

    // 2. Deselect the other card (unflip, deselect)
    fateCard?.classList.remove('flipped', 'selected');

    // 3. Set pending authorship state (not committed until Continue)
    state.authorship = 'manual';

    // 4. Adjust sparkles: enhance selected (2x), stop dimmed
    stopSparkleEmitter('guidedFateSparkles');
    startSparkleEmitter('chooseHandSparkles', 'chooseHand', 12); // Double rate when selected

    // 5. Update control plane Continue visibility
    if (typeof updateCorridorContinueButtonVisibility === 'function') {
      updateCorridorContinueButtonVisibility();
    }

    console.log('[Authorship] Choose Your Hand selected â€” awaiting Continue');
  });

  // "Guided Fate" click handler â€” Selection only, requires Continue
  $('guidedFateCard')?.addEventListener('click', () => {
    if (authorshipChoiceMade) return;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');

    // Toggle selection: if already selected, deselect (unflip)
    if (fateCard?.classList.contains('selected')) {
      fateCard.classList.remove('selected', 'flipped');
      state.authorship = null;
      // Restore sparkles on both cards (same rate for both)
      startSparkleEmitter('chooseHandSparkles', 'chooseHand', 6);
      startSparkleEmitter('guidedFateSparkles', 'guidedFate', 6);
      // Update control plane Continue visibility
      if (typeof updateCorridorContinueButtonVisibility === 'function') {
        updateCorridorContinueButtonVisibility();
      }
      console.log('[Authorship] Guided Fate deselected');
      return;
    }

    // 1. Select Guided Fate (scale up, sparkles, flip to art)
    fateCard?.classList.add('selected', 'flipped');

    // 2. Deselect the other card (unflip, deselect)
    chooseCard?.classList.remove('flipped', 'selected');

    // 3. Set pending authorship state (not committed until Continue)
    state.authorship = 'guided';

    // 4. Adjust sparkles: enhance selected (2x), stop dimmed
    stopSparkleEmitter('chooseHandSparkles');
    startSparkleEmitter('guidedFateSparkles', 'guidedFate', 12); // Double rate when selected

    // 5. Update control plane Continue visibility
    if (typeof updateCorridorContinueButtonVisibility === 'function') {
      updateCorridorContinueButtonVisibility();
    }

    console.log('[Authorship] Guided Fate selected â€” awaiting Continue');
  });

  /**
   * Animate authorship card to breadcrumb via SPARKLE TELEPORT
   * Card dissolves in place, sparkles travel, breadcrumb materializes
   * CORRIDOR-SCOPED: Only affects #authorshipChoiceRow
   */
  function animateAuthorshipCardToBreadcrumb(card, onComplete) {
    const breadcrumbRow = document.getElementById('breadcrumbRow');
    if (!card || !breadcrumbRow) {
      onComplete?.();
      return;
    }

    const cardRect = card.getBoundingClientRect();
    const cardCenterX = cardRect.left + cardRect.width / 2;
    const cardCenterY = cardRect.top + cardRect.height / 2;

    // Target the ghost step for authorship (stage index 0)
    const ghostStep = breadcrumbRow.querySelector('.ghost-step[data-ghost-index="0"]');
    let targetX, targetY;
    if (ghostStep) {
      const ghostRect = ghostStep.getBoundingClientRect();
      targetX = ghostRect.left + ghostRect.width / 2;
      targetY = ghostRect.top + ghostRect.height / 2;
    } else {
      // Fallback: center of breadcrumb row
      const breadcrumbRect = breadcrumbRow.getBoundingClientRect();
      targetX = breadcrumbRect.left + breadcrumbRect.width / 2;
      targetY = breadcrumbRect.top + breadcrumbRect.height / 2;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 1: Dissolve card in place
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    card.classList.add('dissolving-to-breadcrumb');

    // Create dissolution sparkles
    const dissolutionCount = 10 + Math.floor(Math.random() * 5);
    for (let i = 0; i < dissolutionCount; i++) {
      setTimeout(() => {
        const sparkle = document.createElement('div');
        sparkle.className = 'dissolution-sparkle';
        const startX = cardRect.left + Math.random() * cardRect.width;
        const startY = cardRect.top + Math.random() * cardRect.height;
        sparkle.style.cssText = `left: ${startX}px; top: ${startY}px;`;
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 400);
      }, i * 25);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 2: Sparkle travel
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      const travelCount = 6 + Math.floor(Math.random() * 3);
      for (let i = 0; i < travelCount; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.className = 'traveling-sparkle';
          const offsetX = (Math.random() - 0.5) * cardRect.width * 0.5;
          const offsetY = (Math.random() - 0.5) * cardRect.height * 0.5;
          const startX = cardCenterX + offsetX;
          const startY = cardCenterY + offsetY;
          const midX = (startX + targetX) / 2 + (Math.random() - 0.5) * 80;
          const midY = Math.min(startY, targetY) - 40 - Math.random() * 60;
          const travelPerpAngle = Math.atan2(targetY - startY, targetX - startX) + Math.PI / 2;
          const travelCurveAmp = 8 + Math.random() * 16;
          sparkle.style.cssText = `
            left: ${startX}px;
            top: ${startY}px;
            --target-x: ${targetX - startX}px;
            --target-y: ${targetY - startY}px;
            --arc-x: ${midX - startX}px;
            --arc-y: ${midY - startY}px;
            --travel-curve-x: ${Math.cos(travelPerpAngle) * travelCurveAmp}px;
            --travel-curve-y: ${Math.sin(travelPerpAngle) * travelCurveAmp}px;
          `;
          document.body.appendChild(sparkle);
          setTimeout(() => sparkle.remove(), 600);
        }, i * 40);
      }
    }, 200);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PHASE 3: Create breadcrumb card at target + convergence sparkles
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    setTimeout(() => {
      card.style.visibility = 'hidden';
      card.classList.remove('dissolving-to-breadcrumb');
      card.classList.add('selected-static');

      // Create the breadcrumb card (authorship) if not already created
      const existingAuth = breadcrumbRow.querySelector('.breadcrumb-card[data-grp="authorship"]');
      if (!existingAuth) {
        const authorshipTitle = state.authorship === 'manual' ? 'Choose Your Hand' : 'Guided Fate';
        const label = typeof getBreadcrumbLabel === 'function'
          ? getBreadcrumbLabel('authorship', state.authorship)
          : { title: authorshipTitle, subtitle: null };
        const subtitleHtml = label.subtitle
          ? `<span class="breadcrumb-subtitle">${label.subtitle}</span>`
          : '';

        const breadcrumb = document.createElement('div');
        breadcrumb.className = 'breadcrumb-card materializing';
        breadcrumb.dataset.grp = 'authorship';
        breadcrumb.dataset.val = state.authorship;
        breadcrumb.dataset.stageIndex = STAGE_INDEX['authorship'];
        breadcrumb.dataset.breadcrumbLabel = 'Authorship';
        breadcrumb.innerHTML = `
          <div class="sb-card-inner">
            <div class="sb-card-face sb-card-back">
              <span class="sb-card-title">${label.title}</span>
              ${subtitleHtml}
            </div>
            <div class="sb-card-face sb-card-front">
              <span class="sb-card-title">${label.title}</span>
              ${subtitleHtml}
            </div>
          </div>
        `;

        // Insert before first ghost step
        const firstGhost = breadcrumbRow.querySelector('.ghost-step');
        if (firstGhost) {
          breadcrumbRow.insertBefore(breadcrumb, firstGhost);
        } else {
          breadcrumbRow.appendChild(breadcrumb);
        }

        // Remove ghost step 0 (authorship)
        removeGhostStep(STAGE_INDEX['authorship']);

        // Scale font for long titles
        if (typeof scaleBreadcrumbTitle === 'function') {
          scaleBreadcrumbTitle(breadcrumb);
        }

        // Attach destructive navigation
        if (typeof attachBreadcrumbNavigation === 'function') {
          attachBreadcrumbNavigation(breadcrumb);
        }

        setTimeout(() => breadcrumb.classList.remove('materializing'), 400);

        // Sparkles on the active breadcrumb
        if (typeof updateActiveBreadcrumbSparkles === 'function') {
          updateActiveBreadcrumbSparkles(breadcrumb);
        }

        console.log(`[Breadcrumb] Created via authorship animation: authorship=${state.authorship}`);
      }

      // Create convergence sparkles at target
      for (let i = 0; i < 5; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'convergence-sparkle';
        const angle = (Math.PI * 2 * i) / 5;
        const dist = 15 + Math.random() * 10;
        sparkle.style.cssText = `
          left: ${targetX + Math.cos(angle) * dist}px;
          top: ${targetY + Math.sin(angle) * dist}px;
        `;
        document.body.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 500);
      }

      onComplete?.();
    }, 600);
  }

  // Continue from Authorship â€” commits selection and advances
  $('continueFromAuthorship')?.addEventListener('click', async () => {
    if (authorshipChoiceMade) return;
    if (!state.authorship) return; // No selection made

    authorshipChoiceMade = true;

    const chooseCard = $('chooseYourHandCard');
    const fateCard = $('guidedFateCard');

    // Hide control plane Continue button
    const controlPlaneBtn = document.getElementById('continueButton');
    if (controlPlaneBtn) controlPlaneBtn.classList.remove('visible');

    // Determine selected card
    const selectedCard = state.authorship === 'manual' ? chooseCard : fateCard;
    const unselectedCard = state.authorship === 'manual' ? fateCard : chooseCard;

    // Dissipate unselected card with sparkle particles
    if (unselectedCard && typeof dissipateCards === 'function') {
      dissipateCards([unselectedCard]);
    } else if (unselectedCard) {
      unselectedCard.classList.add('dissipating');
      setTimeout(() => unselectedCard.classList.add('hidden'), 400);
    }

    // Animate selected card to breadcrumb (600ms, above Continue button)
    // Advance AFTER breadcrumb materializes so user sees it land in position I
    animateAuthorshipCardToBreadcrumb(selectedCard, () => {
      // Remove authorship cards after animation
      removeAuthorshipCards();

      // Wait for materializing animation (400ms) before advancing
      setTimeout(() => {
        if (state.authorship === 'manual') {
          // MANUAL PATH: Advance to identity corridor (character section)
          corridorActiveRowIndex = 1; // Identity is now row 1
          updateCorridorVisibility();

          // Initialize sparkles after corridor mounts the section
          setTimeout(() => initDestinyDeckSparkles(), 100);

          // Show control plane Continue button for identity stage
          updateCorridorContinueButtonVisibility();

          console.log('[Authorship] Choose Your Hand committed â€” advanced to identity corridor');
        }
      }, 500);
    });

    if (state.authorship === 'guided') {
      // GUIDED PATH: Auto-fill with fate choices
      // (Card dissipate and animation handled above)

      // Generate fate choices
      const fateChoices = {
        playerName: FATE_FEMALE_NAMES[Math.floor(Math.random() * FATE_FEMALE_NAMES.length)],
        partnerName: FATE_MALE_NAMES[Math.floor(Math.random() * FATE_MALE_NAMES.length)],
        world: getFateWorld(),
        tone: getFateTone(),
        dynamic: getFateDynamic(),
        pov: getFatePOV(),
        intensity: getFateIntensity(),
        storyLength: getFateStoryLength(),
        archetype: getFateArchetype()
      };

      fateChoices.worldFlavor = getFateFlavor(fateChoices.world);
      fateChoices.genre = getFateGenre(fateChoices.world);
      fateChoices.withheldCoreVariant = getFateWithheldCoreVariant(fateChoices.archetype, fateChoices.dynamic);

      console.log('[Authorship] Guided Fate committed â€” running fate fill');

      try {
        await runGuidedFateFill(fateChoices);
      } catch (err) {
        console.error('[Authorship] Guided Fate fill error:', err);
        // Ensure fate state is cleaned up on error
        _fateRunning = false;
        if (typeof deactivateGuidedFateVisuals === 'function') deactivateGuidedFateVisuals();
        // Still advance corridor so the user isn't stuck
        if (typeof completeCorridorFromGuidedFate === 'function') completeCorridorFromGuidedFate();
      }
    }
  });

  // Legacy fateDestinyCard handler (for backward compatibility)
  $('fateDestinyCard')?.addEventListener('click', async () => {
    const fateCard = $('fateDestinyCard');
    if (!fateCard || fateCard.dataset.fateUsed === 'true') return;

    // 1. Mark as used to prevent double-click (NO FLIP to tree)
    fateCard.dataset.fateUsed = 'true';
    fateCard.style.opacity = '0.6';
    fateCard.style.pointerEvents = 'none';

    // 2. Generate fate choices (no ages â€” removed)
    const fateChoices = {
      playerName: FATE_FEMALE_NAMES[Math.floor(Math.random() * FATE_FEMALE_NAMES.length)],
      partnerName: FATE_MALE_NAMES[Math.floor(Math.random() * FATE_MALE_NAMES.length)],
      world: getFateWorld(),
      tone: getFateTone(),
      dynamic: getFateDynamic(),
      pov: getFatePOV(),
      intensity: getFateIntensity(),
      storyLength: getFateStoryLength(),
      archetype: getFateArchetype()
    };

    // Add world-dependent selections
    fateChoices.worldFlavor = getFateFlavor(fateChoices.world);
    fateChoices.genre = getFateGenre(fateChoices.world);

    // Lens: assign Withheld Core variant based on archetype/dynamic signals
    fateChoices.withheldCoreVariant = getFateWithheldCoreVariant(fateChoices.archetype, fateChoices.dynamic);

    // 3. Run guided fate fill - reveals step-by-step with animations
    // This does NOT auto-click Begin Story - user chooses when to start
    await runGuidedFateFill(fateChoices);
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DESTINY'S CHOICE MINI-DECK â€” Repeatable Fate character suggestion
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Mini-deck spawns flying cards that fill character fields
  // Each click replaces current values with new Fate suggestions
  // Only Continue button commits the choice
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Generate a random character identity
   */
  function generateFateCharacter(gender) {
    const isFemale = gender === 'Female';
    const names = isFemale ? FATE_FEMALE_NAMES : FATE_MALE_NAMES;
    const pronouns = isFemale ? 'She/Her' : 'He/Him';

    return {
      name: names[Math.floor(Math.random() * names.length)],
      gender: gender,
      pronouns: pronouns,
      ancestry: '' // Leave blank for user to fill or use rotating placeholder
    };
  }

  /**
   * Create a flying card element
   * Back: Gold-Tarot-Card-DESTINY-X.png
   * Front: Character-face.png (player) or Love-Interest-face.png (love interest)
   * No text overlay â€” PNG has baked text
   */
  function createFlyingCard(character, isPlayer) {
    // Get the target card to clone its structure
    const targetCard = isPlayer ? $('playerCharacterCard') : $('loveInterestCharacterCard');

    const card = document.createElement('div');
    card.className = 'destiny-flying-card';

    // Create the flip container
    const inner = document.createElement('div');
    inner.className = 'destiny-flying-card-inner';

    // Back face: Black Destiny Choice back
    const backFace = document.createElement('div');
    backFace.className = 'destiny-flying-card-face destiny-flying-card-back';

    // Front face: Clone of the actual character card with fields
    const frontFace = document.createElement('div');
    frontFace.className = 'destiny-flying-card-face destiny-flying-card-front-live';

    if (targetCard) {
      // Clone the target card's content
      const clone = targetCard.cloneNode(true);
      // Preserve background-image before removing ID (Love Interest PNG is ID-scoped)
      const computedBg = getComputedStyle(targetCard).backgroundImage;
      if (computedBg && computedBg !== 'none') {
        clone.style.backgroundImage = computedBg;
      }
      clone.removeAttribute('id');
      clone.style.width = '100%';
      clone.style.height = '100%';
      clone.style.position = 'relative';

      // Pre-fill the cloned fields with fate character data
      const nameInput = clone.querySelector('input[id*="NameInput"], input[id*="partnerName"]');
      const genderSelect = clone.querySelector('select[id*="Gender"]');
      const pronounsSelect = clone.querySelector('select[id*="Pronouns"], select[id*="pronouns"]');

      if (nameInput) nameInput.value = character.name;
      if (genderSelect) genderSelect.value = character.gender;
      if (pronounsSelect) pronounsSelect.value = character.pronouns;

      frontFace.appendChild(clone);
    }

    inner.appendChild(backFace);
    inner.appendChild(frontFace);
    card.appendChild(inner);

    return card;
  }

  /**
   * Apply fate card overlay to character destiny card
   */
  function applyFateOverlay(destinyCard, character) {
    // Remove existing overlay
    const existingOverlay = destinyCard.querySelector('.fate-overlay-card');
    if (existingOverlay) existingOverlay.remove();

    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'fate-overlay-card';
    overlay.innerHTML = `
      <span class="fate-card-name">${character.name.split(' ')[0]}</span>
      <span class="fate-card-details">${character.gender}<br>${character.pronouns}</span>
    `;

    destinyCard.appendChild(overlay);
    destinyCard.classList.add('has-fate-card');
  }

  /**
   * Fill character fields with fate-generated values
   */
  function fillCharacterFields(isPlayer, character) {
    if (isPlayer) {
      const nameInput = $('playerNameInput');
      const genderSelect = $('playerGender');
      const pronounsSelect = $('playerPronouns');
      const ancestryInput = $('ancestryInputPlayer');

      if (nameInput) nameInput.value = character.name;
      if (genderSelect) genderSelect.value = character.gender;
      if (pronounsSelect) pronounsSelect.value = character.pronouns;
      if (ancestryInput) {
        ancestryInput.value = getRandomSuggestion('ancestry');
        const ph = document.querySelector('.rotating-placeholder[data-for="ancestryInputPlayer"]');
        if (ph) ph.classList.add('hidden');
      }
    } else {
      const nameInput = $('partnerNameInput');
      const genderSelect = $('loveInterestGender');
      const pronounsSelect = $('lovePronouns');
      const ancestryInput = $('ancestryInputLI');

      if (nameInput) nameInput.value = character.name;
      if (genderSelect) genderSelect.value = character.gender;
      if (pronounsSelect) pronounsSelect.value = character.pronouns;
      if (ancestryInput) {
        ancestryInput.value = getRandomSuggestion('ancestry');
        const ph = document.querySelector('.rotating-placeholder[data-for="ancestryInputLI"]');
        if (ph) ph.classList.add('hidden');
      }
    }
  }

  /**
   * Animate flying card from deck to target - book cover opening effect
   *
   * For 'left' direction (to Character card):
   *   - Hinge on LEFT edge of deck
   *   - Right edge lifts up like opening a book cover
   *   - At 90Â°, detaches and flies to target while continuing to flip
   *
   * For 'right' direction (to Love Interest card):
   *   - Hinge on RIGHT edge of deck
   *   - Left edge lifts up
   *   - At 90Â°, detaches and flies to target
   */
  function animateFlyingCard(card, startRect, endRect, direction, onComplete) {
    // Get deck dimensions
    const miniDeck = $('destinyMiniDeck');
    const deckRect = miniDeck ? miniDeck.getBoundingClientRect() : { width: 80, height: 120 };

    // Start at deck size, end at target card size
    const startWidth = deckRect.width;
    const startHeight = deckRect.height;
    const endWidth = endRect.width || 200;
    const endHeight = endRect.height || 300;

    // Position card exactly on top of deck
    card.style.position = 'fixed';
    card.style.left = `${startRect.left}px`;
    card.style.top = `${startRect.top}px`;
    card.style.width = `${startWidth}px`;
    card.style.height = `${startHeight}px`;
    card.style.opacity = '1';
    card.style.zIndex = '2000';

    document.body.appendChild(card);

    // Set transform origin on inner element - the hinge edge
    const inner = card.querySelector('.destiny-flying-card-inner');
    if (inner) {
      // 'left' direction: hinge on LEFT edge (opens like a book to the right)
      // 'right' direction: hinge on RIGHT edge (opens like a book to the left)
      inner.style.transformOrigin = direction === 'left' ? 'left center' : 'right center';
      inner.style.transformStyle = 'preserve-3d';
    }

    // Force reflow
    void card.offsetWidth;

    // Animation timing
    const duration = 1800; // Slower for dramatic effect
    const startTime = performance.now();

    // Rotation direction based on hinge position
    // 'left' hinge + NEGATIVE rotateY = right edge lifts UP toward viewer (like opening a book outward)
    // 'right' hinge + POSITIVE rotateY = left edge lifts UP toward viewer
    const rotationSign = direction === 'left' ? -1 : 1;

    function animate(currentTime) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);

      let rotateY, currentX, currentY, currentWidth, currentHeight;

      // Phase 1 (0-40%): Hinged rotation - card opens like a book cover
      // Phase 2 (40-100%): Detach, continue flipping, grow, and fly to target

      if (progress < 0.4) {
        // Phase 1: Book cover opening - hinged rotation from 0Â° to 90Â°
        const hingeProgress = progress / 0.4;
        // Smooth ease-out for the hinge rotation
        const hingeEased = 1 - Math.pow(1 - hingeProgress, 2);

        rotateY = rotationSign * hingeEased * 90;

        // Card stays anchored at deck position during hinge phase
        currentX = startRect.left;
        currentY = startRect.top;
        currentWidth = startWidth;
        currentHeight = startHeight;

      } else {
        // Phase 2: Detach and fly - continue rotation from 90Â° to 180Â°, grow, move
        const flyProgress = (progress - 0.4) / 0.6;
        // Smooth ease-out for flight
        const flyEased = 1 - Math.pow(1 - flyProgress, 3);

        // Continue rotation from 90Â° to 180Â°
        rotateY = rotationSign * (90 + 90 * flyEased);

        // At detach point, card center shifts from hinge edge to card center
        // Calculate where the card center should be at the start of phase 2
        const detachCenterX = startRect.left + (direction === 'left' ? 0 : startWidth);
        const detachCenterY = startRect.top + startHeight / 2;

        // Target center
        const targetCenterX = endRect.left + endWidth / 2;
        const targetCenterY = endRect.top + endHeight / 2;

        // Interpolate center position
        const currentCenterX = detachCenterX + (targetCenterX - detachCenterX) * flyEased;
        const currentCenterY = detachCenterY + (targetCenterY - detachCenterY) * flyEased;

        // Grow from deck size to target size
        currentWidth = startWidth + (endWidth - startWidth) * flyEased;
        currentHeight = startHeight + (endHeight - startHeight) * flyEased;

        // Convert center position to top-left
        currentX = currentCenterX - currentWidth / 2;
        currentY = currentCenterY - currentHeight / 2;

        // Add arc to the flight path
        const arc = Math.sin(flyProgress * Math.PI) * -40;
        currentY += arc;

        // Switch transform origin to center for phase 2
        if (inner && flyProgress < 0.1) {
          inner.style.transformOrigin = 'center center';
        }
      }

      // Apply position and size
      card.style.left = `${currentX}px`;
      card.style.top = `${currentY}px`;
      card.style.width = `${currentWidth}px`;
      card.style.height = `${currentHeight}px`;

      // Apply rotation to inner element
      if (inner) {
        inner.style.transform = `rotateY(${rotateY}deg)`;
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        // Animation complete
        card.style.zIndex = '100';
        card.remove();
        if (onComplete) onComplete();
      }
    }

    requestAnimationFrame(animate);
  }

  /**
   * Spawn fate cards from mini-deck to character tarot cards
   * Sequential peel-open animation: first card peels left, second peels right
   * AUTHORITATIVE TARGETS: .character-tarot-card containers
   */
  function spawnDestinyCards() {
    const miniDeck = $('destinyMiniDeck');
    // Target the LARGE tarot-proportional character cards (not deprecated destiny-choice cards)
    const playerCharCard = $('playerCharacterCard');
    const loveInterestCharCard = $('loveInterestCharacterCard');

    if (!miniDeck || !playerCharCard || !loveInterestCharCard) return;

    // Generate random characters
    const playerChar = generateFateCharacter('Female');
    const liChar = generateFateCharacter('Male');

    // Get positions and dimensions
    const deckRect = miniDeck.getBoundingClientRect();
    const playerRect = playerCharCard.getBoundingClientRect();
    const liRect = loveInterestCharCard.getBoundingClientRect();

    // Start position (aligned with top of deck)
    const startRect = {
      left: deckRect.left,
      top: deckRect.top
    };

    // First card: peel LEFT to Character card
    const playerFlyingCard = createFlyingCard(playerChar, true);
    animateFlyingCard(playerFlyingCard, startRect, {
      left: playerRect.left,
      top: playerRect.top,
      width: playerRect.width,
      height: playerRect.height
    }, 'left', () => {
      // Fill fields directly - no overlay, same editable component
      fillCharacterFields(true, playerChar);
      // Brief highlight to show landing
      playerCharCard.classList.add('fate-landed');
      setTimeout(() => playerCharCard.classList.remove('fate-landed'), 300);

      // After first card lands, start second card: peel RIGHT to Love Interest
      setTimeout(() => {
        const liFlyingCard = createFlyingCard(liChar, false);
        animateFlyingCard(liFlyingCard, startRect, {
          left: liRect.left,
          top: liRect.top,
          width: liRect.width,
          height: liRect.height
        }, 'right', () => {
          // Fill fields directly - no overlay, same editable component
          fillCharacterFields(false, liChar);
          // Brief highlight to show landing
          loveInterestCharCard.classList.add('fate-landed');
          setTimeout(() => loveInterestCharCard.classList.remove('fate-landed'), 300);
        });
      }, 200); // Brief pause after first card lands
    });

    console.log('[Destiny] Cards spawning:', playerChar.name, liChar.name);
  }

  // Mini-deck click handler
  $('destinyMiniDeck')?.addEventListener('click', () => {
    spawnDestinyCards();
  });

  // (VQ Destiny Deck removed â€” Petition Fate replaces quill/veto)

  // Character section Continue button handler
  $('continueFromCharacters')?.addEventListener('click', () => {
    const miniDeck = $('destinyMiniDeck');
    const playerCharCard = $('playerCharacterCard');
    const loveInterestCharCard = $('loveInterestCharacterCard');
    const continueBtn = $('continueFromCharacters');
    const breadcrumbRow = document.getElementById('breadcrumbRow');

    // Hide Continue button immediately
    if (continueBtn) {
      continueBtn.classList.remove('visible');
    }

    // Retract mini-deck and stop its sparkles
    if (miniDeck) {
      miniDeck.classList.add('retracted');
      stopSparkleEmitter('destinyDeckSparkles');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FLY-TO-BREADCRUMB TRANSITION â€” Clone card, animate to target, then finalize
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const canonicalPlayerName = $('playerNameInput')?.value.trim() || 'Protagonist';
    const canonicalPartnerName = $('partnerNameInput')?.value.trim() || 'Love Interest';
    const displayPlayerName = deriveDisplayName(canonicalPlayerName);
    const displayPartnerName = deriveDisplayName(canonicalPartnerName);
    const identityTitle = displayPlayerName;

    // Persist identity state
    state.picks = state.picks || {};
    state.picks.identity = {
      playerName: canonicalPlayerName,
      partnerName: canonicalPartnerName,
      displayPlayerName: displayPlayerName,
      displayPartnerName: displayPartnerName
    };

    // Get breadcrumb target position (identity slot)
    const identityIdx = STAGE_INDEX['identity'];
    const ghostStep = breadcrumbRow?.querySelector(`.ghost-step[data-ghost-index="${identityIdx}"]`);
    let targetX, targetY;
    if (ghostStep) {
      const ghostRect = ghostStep.getBoundingClientRect();
      targetX = ghostRect.left + ghostRect.width / 2;
      targetY = ghostRect.top + ghostRect.height / 2;
    } else if (breadcrumbRow) {
      const brRect = breadcrumbRow.getBoundingClientRect();
      targetX = brRect.left + brRect.width / 2;
      targetY = brRect.top + brRect.height / 2;
    }

    // Sparkle teleport animation (like authorship)
    if (playerCharCard && targetX !== undefined) {
      const cardRect = playerCharCard.getBoundingClientRect();
      const cardCenterX = cardRect.left + cardRect.width / 2;
      const cardCenterY = cardRect.top + cardRect.height / 2;

      // Phase 1: Dissolution sparkles from card
      playerCharCard.style.opacity = '0.3';
      if (loveInterestCharCard) loveInterestCharCard.style.opacity = '0.3';

      const dissolutionCount = 10 + Math.floor(Math.random() * 5);
      for (let i = 0; i < dissolutionCount; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.className = 'dissolution-sparkle';
          const startX = cardRect.left + Math.random() * cardRect.width;
          const startY = cardRect.top + Math.random() * cardRect.height;
          sparkle.style.cssText = `left: ${startX}px; top: ${startY}px;`;
          document.body.appendChild(sparkle);
          setTimeout(() => sparkle.remove(), 400);
        }, i * 25);
      }

      // Phase 2: Sparkle travel to breadcrumb target
      setTimeout(() => {
        const travelCount = 6 + Math.floor(Math.random() * 3);
        for (let i = 0; i < travelCount; i++) {
          setTimeout(() => {
            const sparkle = document.createElement('div');
            sparkle.className = 'traveling-sparkle';
            const offsetX = (Math.random() - 0.5) * cardRect.width * 0.5;
            const offsetY = (Math.random() - 0.5) * cardRect.height * 0.5;
            const startX = cardCenterX + offsetX;
            const startY = cardCenterY + offsetY;
            const midX = (startX + targetX) / 2 + (Math.random() - 0.5) * 80;
            const midY = Math.min(startY, targetY) - 40 - Math.random() * 60;
            const travelPerpAngle = Math.atan2(targetY - startY, targetX - startX) + Math.PI / 2;
            const travelCurveAmp = 8 + Math.random() * 16;
            sparkle.style.cssText = `
              left: ${startX}px; top: ${startY}px;
              --target-x: ${targetX - startX}px;
              --target-y: ${targetY - startY}px;
              --arc-x: ${midX - startX}px;
              --arc-y: ${midY - startY}px;
              --travel-curve-x: ${Math.cos(travelPerpAngle) * travelCurveAmp}px;
              --travel-curve-y: ${Math.sin(travelPerpAngle) * travelCurveAmp}px;
            `;
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 600);
          }, i * 40);
        }
      }, 200);

      // Phase 3: Convergence sparkles + create breadcrumb + advance
      setTimeout(() => {
        // Convergence sparkles at target
        for (let i = 0; i < 5; i++) {
          const sparkle = document.createElement('div');
          sparkle.className = 'convergence-sparkle';
          const angle = (Math.PI * 2 * i) / 5;
          const dist = 15 + Math.random() * 10;
          sparkle.style.cssText = `
            left: ${targetX + Math.cos(angle) * dist}px;
            top: ${targetY + Math.sin(angle) * dist}px;
          `;
          document.body.appendChild(sparkle);
          setTimeout(() => sparkle.remove(), 500);
        }

        // Clean up cards
        if (playerCharCard) {
          const overlay = playerCharCard.querySelector('.fate-overlay-card');
          if (overlay) overlay.remove();
          playerCharCard.classList.remove('has-fate-card');
          playerCharCard.style.opacity = '';
        }
        if (loveInterestCharCard) {
          const overlay = loveInterestCharCard.querySelector('.fate-overlay-card');
          if (overlay) overlay.remove();
          loveInterestCharCard.classList.remove('has-fate-card');
          loveInterestCharCard.style.opacity = '';
        }

        // Hide character section
        const characterSection = $('characterSectionRow');
        if (characterSection) {
          characterSection.classList.add('hidden');
        }

        // Create breadcrumb AFTER animation
        if (typeof createBreadcrumbDirect === 'function') {
          createBreadcrumbDirect('identity', 'names', identityTitle);
        }

        // Wait for materializing animation, then advance
        setTimeout(() => {
          if (typeof advanceCorridorRow === 'function') {
            advanceCorridorRow();
          }
          if (typeof updateArchetypeSectionTitle === 'function') {
            updateArchetypeSectionTitle();
          }
          console.log('[Character Section] Sparkle teleport complete â€” Archetype row now visible');
        }, 600);
      }, 600);

    } else {
      // Fallback: no animation if elements missing
      if (playerCharCard) {
        const overlay = playerCharCard.querySelector('.fate-overlay-card');
        if (overlay) overlay.remove();
        playerCharCard.classList.remove('has-fate-card');
      }
      if (loveInterestCharCard) {
        const overlay = loveInterestCharCard.querySelector('.fate-overlay-card');
        if (overlay) overlay.remove();
        loveInterestCharCard.classList.remove('has-fate-card');
      }

      const characterSection = $('characterSectionRow');
      if (characterSection) {
        characterSection.classList.add('hidden');
      }

      if (typeof createBreadcrumbDirect === 'function') {
        createBreadcrumbDirect('identity', 'names', identityTitle);
      }

      // Advance corridor from identity (row 1) to storybeau (row 2)
      // This mounts the archetype section elements into the DOM
      if (typeof advanceCorridorRow === 'function') {
        advanceCorridorRow();
      }

      // Update Archetype title with Love Interest name AFTER corridor advances
      // (title element is part of storybeau stage, must be mounted first)
      if (typeof updateArchetypeSectionTitle === 'function') {
        updateArchetypeSectionTitle();
      }

      console.log('[Character Section] Continue clicked â€” committed identity breadcrumb, Archetype row now visible');
    }
  });

  // Reset mini-deck on authorship reset
  const originalResetAuthorship = window.resetAuthorshipChoice;
  window.resetAuthorshipChoice = function() {
    if (originalResetAuthorship) originalResetAuthorship();

    // Reset mini-deck
    const miniDeck = $('destinyMiniDeck');
    if (miniDeck) {
      miniDeck.classList.remove('retracted');
    }

    // Clear fate overlays from character tarot cards (authoritative targets)
    const playerCharCard = $('playerCharacterCard');
    const loveInterestCharCard = $('loveInterestCharacterCard');
    if (playerCharCard) {
      const overlay = playerCharCard.querySelector('.fate-overlay-card');
      if (overlay) overlay.remove();
      playerCharCard.classList.remove('has-fate-card');
    }
    if (loveInterestCharCard) {
      const overlay = loveInterestCharCard.querySelector('.fate-overlay-card');
      if (overlay) overlay.remove();
      loveInterestCharCard.classList.remove('has-fate-card');
    }
  };

  // --- BEGIN STORY (RESTORED) ---
  // Handler extracted as named function for event delegation (no direct DOM binding needed).
  let _beginStoryInProgress = false;
  async function handleBeginStory() {
    console.log('[BeginStory] handleBeginStory() called');
    if (_beginStoryInProgress) {
      console.warn('[BeginStory] Already in progress â€” ignoring duplicate call');
      return;
    }
    _beginStoryInProgress = true;
    try {
    console.log('[BeginStory] Past _beginStoryInProgress guard, entering main flow');
    // Reveal all remaining DSP segments on Begin Story (veto phase)
    if (typeof revealAllDSPSegments === 'function') revealAllDSPSegments();

    // ========================================
    // CORRIDOR COMPLETION CHECK â€” Ensure all required rows are resolved
    // ========================================
    if (typeof validateCorridorComplete === 'function' && !validateCorridorComplete()) {
      // validateCorridorComplete shows modal with missing selections
      console.log('[BeginStory] EXITING â€” corridor validation failed');
      return;
    }

    // ========================================
    // CONTINUE STORY CHECK â€” Navigate to existing story if shape matches
    // ========================================
    // If story exists AND shape snapshot matches â†’ navigate only, NO regeneration
    if (canContinueExistingStory()) {
      console.log('[STORY:CONTINUE] Shape matches â€” navigating to existing story');
      window.showScreen('game');
      // Show existing story content (skip synopsis, go directly to scene)
      showReaderPage(2);
      // REBIND: Ensure FX handlers are attached after Continue Story navigation
      if (window.initFateCards) window.initFateCards();
      return;
    }

    // ========================================
    // BEGIN STORY IS ALWAYS FREE â€” NO PAYWALL CHECK
    // Entitlement checks happen at Story Shape card selection, not here
    // ========================================

    // ========================================
    // PHASE 1: SYNC VALIDATION (no async!)
    // ========================================
    const validationErrors = validateBeginStory();
    const wasFateTriggered = state._fateTriggered;
    state._fateTriggered = false; // Clear flag after validation

    if (validationErrors.length > 0) {
        console.log('[BeginStory] EXITING â€” validation errors:', validationErrors);
        if (validationErrors.includes('__SCIFI_FLAVOR_REQUIRED__')) {
            showSciFiFlavorModal();
            return;
        }
        showToast(validationErrors[0]);
        return;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TEASE TIER GATE: Block new story creation if free story already consumed
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (isTeaseStoryBlocked()) {
        console.log('[BeginStory] EXITING â€” Tease story blocked');
        window.showPaywall('unlock');
        return;
    }

    // Capture raw form values synchronously (needed for early validation)
    const playerInputVal2 = $('playerNameInput')?.value.trim() || '';
    const partnerInputVal2 = $('partnerNameInput')?.value.trim() || '';
    const playerNameBlank2 = !playerInputVal2;
    const partnerNameBlank2 = !partnerInputVal2;
    const rawPlayerName = playerInputVal2 || "The Protagonist";
    const rawPartnerName = partnerInputVal2 || "The Love Interest";
    const pGen = $('customPlayerGender')?.value.trim() || $('playerGender')?.value || 'Female';
    const lGen = $('customLoveInterest')?.value.trim() || $('loveInterestGender')?.value || 'Male';
    const pPro = $('customPlayerPronouns')?.value.trim() || $('playerPronouns')?.value || 'She/Her';
    const lPro = $('customLovePronouns')?.value.trim() || $('lovePronouns')?.value || 'He/Him';
    // PASS 9D: Capture ages from form fields
    const pAge = $('playerAgeInput')?.value.trim() || '';
    const lAge = $('partnerAgeInput')?.value.trim() || '';

    // Lens: infer Withheld Core variant from archetype if not already set by Fate
    if (!state.withheldCoreVariant && state.archetype.primary) {
        state.withheldCoreVariant = getFateWithheldCoreVariant(state.archetype.primary, state.picks.dynamic);
    }

    // Silently assign a secondary modifier (~25% chance) before building directives
    assignProbabilisticModifier();

    // Early validation with pre-normalization values
    const earlyArchetypeDirectives = buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen);
    const earlyPayload = {
        mode: state.mode || 'solo',
        fourAxis: {
            world: state.picks.world || 'Modern',
            tone: state.picks.tone || 'Earnest',
            genre: state.picks.genre || 'Billionaire',
            dynamic: state.picks.dynamic || 'Enemies'
        },
        archetype: {
            primary: state.archetype.primary || null,
            directives: earlyArchetypeDirectives || '(none built)'
        },
        intensity: state.intensity || 'Naughty',
        pov: state.picks.pov || 'First'
    };

    // Validate four-axis before proceeding (sync check)
    const { world, tone, genre, dynamic } = earlyPayload.fourAxis;
    const earlyErrors = [];
    if (!earlyPayload.mode) earlyErrors.push('Mode is undefined');
    if (!world) earlyErrors.push('World is missing or empty');
    if (!tone) earlyErrors.push('Tone is missing or empty');
    if (!genre) earlyErrors.push('Genre is missing or empty');
    if (!dynamic) earlyErrors.push('Relationship Dynamic is missing or empty');
    if (!earlyPayload.archetype.primary) earlyErrors.push('Primary Archetype not selected');
    if (earlyPayload.archetype.directives === '(none built)') earlyErrors.push('Archetype directives failed to build');

    if (earlyErrors.length > 0) {
        console.error('[BeginStory] EXITING â€” EARLY VALIDATION FAILED:', earlyErrors);
        showToast(`Story setup incomplete: ${earlyErrors[0]}`);
        return;
    }
    console.log('[BeginStory] All validation passed â€” proceeding to story generation');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PARALLEL GENERATION FAST PATH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // If story generation was started via "Generate Cover" button, skip redundant
    // generation and go directly to Scene 1 after awaiting the background promise.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (window.isBackgroundStoryStarted && window.isBackgroundStoryStarted()) {
        console.log('[PARALLEL:BEGIN] Background story generation in progress â€” using fast path');

        if (_bookOpened) return;

        // Clear DSP state
        _dspGuidedFateActive = false;
        _revealedDSPAxes = null;
        _readerPage = 0;

        window.showScreen('game');
        const bookCoverPage = document.getElementById('bookCoverPage');
        const storyContentEl = document.getElementById('storyContent');
        const settingPlate = document.getElementById('settingPlate');

        if (bookCoverPage) bookCoverPage.classList.remove('hidden');
        if (storyContentEl) storyContentEl.classList.add('hidden');
        if (settingPlate) settingPlate.classList.add('hidden');

        // PERMANENT FX REBIND: Initialize fate cards on parallel fast path entry
        if (window.initFateCards) window.initFateCards();

        // Use pre-generated cover immediately â€” NO cover loading UI (already generated)
        const preGeneratedCover = window.getPreGeneratedCover ? window.getPreGeneratedCover() : null;
        if (preGeneratedCover) {
            console.log('[PARALLEL:BEGIN] Using pre-generated cover');
            // DECOUPLED: Do NOT call startCoverLoading() â€” cover is already ready
            // Just apply the cover URL directly
            const coverImg = document.getElementById('bookCoverImg');
            const bookObject = document.getElementById('bookObject');
            const coverLoadingState = document.getElementById('coverLoadingState');
            if (coverImg) coverImg.src = preGeneratedCover;
            if (bookObject) bookObject.classList.remove('hidden');
            if (coverLoadingState) coverLoadingState.classList.add('hidden');
            if (window.clearPreGeneratedCover) window.clearPreGeneratedCover();
        }

        // NO GLOBAL LOADING OVERLAY â€” Cover View path should be seamless
        // The story was pre-generated during cover generation, so transition is instant

        // Await background story promise with timeout
        const STORY_TIMEOUT_MS = 10000;
        const bgPromise = window.getBackgroundStoryPromise ? window.getBackgroundStoryPromise() : null;

        if (bgPromise) {
            console.log('[PARALLEL:BEGIN] Awaiting background story (max 10s)...');
            const result = await Promise.race([
                bgPromise,
                new Promise(resolve => setTimeout(() => resolve({ success: false, error: 'TIMEOUT' }), STORY_TIMEOUT_MS))
            ]);

            if (result.success) {
                console.log('[PARALLEL:BEGIN] Background story ready, mounting Scene 1');

                // Mount the pre-generated story
                const { title, synopsis, body } = result;

                state.story = state.story || {};
                state.story.title = title;
                state.story.synopsis = synopsis;
                state._synopsisMetadata = synopsis;

                // Set title
                const titleEl = document.getElementById('storyTitle');
                if (titleEl) titleEl.textContent = title.replace(/"/g, '');

                // Mount story text
                StoryPagination.init();
                StoryPagination.clear();
                StoryPagination.addPage(formatStory(body), true);

                // Title page â€” universal front page before map/setting/scene
                if (!state._titlePageShown) {
                    showTitlePage();
                }

                // Update turn state
                state.turnCount = 1;
                state.scenes = state.scenes || [];
                state.scenes.push({ title, synopsis, text: body, fateCard: null });

                // EARNED COVER SYSTEM: Initialize cover stage tracking
                _lastNotifiedCoverStage = getCurrentCoverStage();
                updateReaderCoverButton();

                stopLoading();

                // Go directly to Scene 1
                advanceReaderPage();

                // Pre-load visualization prompt in background while user reads
                if (typeof preloadVizPrompt === 'function') preloadVizPrompt();

                // Reset background story state for future use
                if (window.resetBackgroundStory) window.resetBackgroundStory();

                return; // EXIT â€” fast path complete
            } else {
                console.warn('[PARALLEL:BEGIN] Background story failed or timed out, falling back to normal flow');
                // Reset and continue with normal flow
                if (window.resetBackgroundStory) window.resetBackgroundStory();
            }
        }

        stopLoading();
        // Fall through to normal flow if background failed
    }

    // ========================================
    // PHASE 2: SHOW LOADER IMMEDIATELY (sync)
    // ========================================
    // GUARD: If book is already opening/open, do not reset cover visibility
    if (_bookOpened) { console.log('[BeginStory] EXITING â€” _bookOpened is true'); return; }

    // Clear Guided Fate DSP lock â€” story has begun
    _dspGuidedFateActive = false;
    _revealedDSPAxes = null;

    // Initialize simplified reader state (when book disabled)
    _readerPage = 0;

    window.showScreen('game');
    console.log('[READER] enterReaderView: _readerPage=', _readerPage, 'USE_OPENING_BOOK=', USE_OPENING_BOOK);
    const bookCoverPage = document.getElementById('bookCoverPage');
    const storyContentEl = document.getElementById('storyContent');
    const settingPlate = document.getElementById('settingPlate');

    // Show COVER, hide everything else
    if (bookCoverPage) bookCoverPage.classList.remove('hidden');
    if (storyContentEl) storyContentEl.classList.add('hidden');
    if (settingPlate) settingPlate.classList.add('hidden');

    // PERMANENT FX REBIND: Initialize fate cards on enterReaderView
    if (window.initFateCards) window.initFateCards();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BACKGROUND STORY LOADING: Initialize promise for story readiness
    // Story text generation runs in background, resolved when mounted
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    initStoryTextPromise();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COVER GENERATION: DECOUPLED from story loading
    // Cover loading UI is ONLY controlled by cover generation, never by story
    // Pre-generated cover comes from "Generate Your Book Cover" button
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const preGeneratedCover = window.getPreGeneratedCover ? window.getPreGeneratedCover() : null;

    if (preGeneratedCover) {
      // User already generated a cover â€” apply directly, NO loading UI
      console.log('[COVER:BEGIN] Using pre-generated cover:', preGeneratedCover);
      const coverImg = document.getElementById('bookCoverImg');
      const bookObject = document.getElementById('bookObject');
      const coverLoadingState = document.getElementById('coverLoadingState');
      if (coverImg) coverImg.src = preGeneratedCover;
      if (bookObject) bookObject.classList.remove('hidden');
      if (coverLoadingState) coverLoadingState.classList.add('hidden');
      if (window.clearPreGeneratedCover) window.clearPreGeneratedCover();
    } else {
      // No pre-generated cover â€” use fallback, do NOT auto-generate
      // Cover generation is explicit user action only (via "Generate Your Cover" button)
      console.log('[COVER:BEGIN] No pre-generated cover â€” using fallback (no auto-generation)');
      const bookObject = document.getElementById('bookObject');
      const coverLoadingState = document.getElementById('coverLoadingState');
      if (bookObject) bookObject.classList.remove('hidden');
      if (coverLoadingState) coverLoadingState.classList.add('hidden');
    }

    console.log('[BeginStory] Phase 2 complete â€” starting loader and API calls');
    startLoading("Conjuring the world...", STORY_LOADING_MESSAGES);

    // ========================================
    // PHASE 3: DEFER ASYNC WORK (next tick)
    // Ensures loader renders before any await
    // PASS 9B FIX: Wrap normalization in try/catch to prevent hang
    // ========================================
    await new Promise(resolve => setTimeout(resolve, 0));

    // RUNTIME NORMALIZATION: Character names flow through ChatGPT normalization layer
    // PASS 9B FIX: Handle normalization errors gracefully to prevent loader hang
    // Skip normalization for blank names â€” AI will invent them
    let playerNorm, partnerNorm, pKernel, lKernel;
    try {
        if (!playerNameBlank2) {
            playerNorm = await callNormalizationLayer({
                axis: 'character',
                user_text: rawPlayerName,
                context_signals: state.picks?.world || []
            });
            pKernel = playerNorm.normalized_text || playerNorm.archetype || 'the one who carries the story';
        } else {
            pKernel = rawPlayerName;
        }
        if (!partnerNameBlank2) {
            partnerNorm = await callNormalizationLayer({
                axis: 'character',
                user_text: rawPartnerName,
                context_signals: state.picks?.world || []
            });
            lKernel = partnerNorm.normalized_text || partnerNorm.archetype || 'the one who draws them forward';
        } else {
            lKernel = rawPartnerName;
        }
    } catch (normError) {
        console.error('[NORMALIZATION ERROR]', normError);
        // Fallback: Use raw names if normalization fails
        pKernel = rawPlayerName || 'the one who carries the story';
        lKernel = rawPartnerName || 'the one who draws them forward';
    }

    // Build name-invention directives for blank names
    const nameInventionDirectives2 = [
        playerNameBlank2 ? buildNameInventionDirective('Protagonist', pGen, pPro) : '',
        partnerNameBlank2 ? buildNameInventionDirective('Love Interest', lGen, lPro) : ''
    ].filter(Boolean).join('\n\n');

    // CRITICAL: Store normalized kernels in state and overwrite raw display
    state.normalizedPlayerKernel = pKernel;
    state.normalizedPartnerKernel = lKernel;
    state.rawPlayerName = rawPlayerName;
    state.rawPartnerName = rawPartnerName;
    if ($('playerNameInput')) $('playerNameInput').value = pKernel;
    if ($('partnerNameInput')) $('partnerNameInput').value = lKernel;

    // Record user-provided names so they're never reused by AI
    if (!playerNameBlank2) addUsedName(pKernel);
    if (!partnerNameBlank2) addUsedName(lKernel);

    // Determine Author Identity based on selections
    if(pGen === 'Male' && lGen === 'Female') { state.authorGender = 'Female'; state.authorPronouns = 'She/Her'; }
    else if(pGen === 'Male' && lGen === 'Male') { state.authorGender = 'Male'; state.authorPronouns = 'He/Him'; }
    else if(pGen === 'Female' && lGen === 'Female') { state.authorGender = 'Female'; state.authorPronouns = 'She/Her'; }
    else { state.authorGender = 'Non-Binary'; state.authorPronouns = 'They/Them'; }

    // (applyVetoFromControls removed â€” constraints state set at init)

    // Check for LGBTQ Colors
    state.gender = $('playerGender')?.value || pGen;
    state.loveInterest = $('loveInterestGender')?.value || lGen;
    const isQueer = (state.gender === state.loveInterest) || state.gender === 'Non-Binary' || state.loveInterest === 'Non-Binary';
    if(isQueer) document.body.classList.add('lgbtq-mode');
    else document.body.classList.remove('lgbtq-mode');

    // Persist Nickname for Couple Mode
    if(state.mode === 'couple' && !state.myNick) {
       state.myNick = pKernel.split(' ')[0];
       localStorage.setItem("sb_nickname", state.myNick);
    }

    state.gender = pGen;
    state.loveInterest = lGen;

    syncPovDerivedFlags();

    // Badge engine â€” 5th Person POV (lifetime, once per user)
    if (state.povMode === 'author5th') {
      withProfileId(profileId => {
        awardBadge(sb, profileId, 'fifth_person');
      });
    }

    const safetyStr = buildConsentDirectives();

    // Variables for later use (ancestry normalization happens later)
    let ancestryPlayer = $('ancestryInputPlayer')?.value.trim() || '';
    let ancestryLI = $('ancestryInputLI')?.value.trim() || '';
    let archetypeDirectives = buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen);
    // (quillUnlocked removed â€” Petition Fate replaces quill)

    // ================================================================
    // SINGLE-PLAYER â€” Cautious Dream Line Pool (ceiling-pull)
    // ================================================================
    function getCautiousDreamLine() {
      const lines = [
        "That night, you dream of standing at a locked door. When you open your hands, the key is already there.",
        "You dream they are walking away. The more you hold back, the further they drift.",
        "In sleep, their touch is warmer than you remember â€” and gone when you wake.",
        "You dream of speaking plainly. The world does not end.",
        "You see them across a crowded room, choosing someone who did not hesitate."
      ];
      return lines[Math.floor(Math.random() * lines.length)];
    }

    // ================================================================
    // STRANGER MODE â€” Selection Uncertainty Line Pool
    // ================================================================
    function getSelectionUncertaintyLine() {
      const lines = [
        "Someone else notices them watching you.",
        "You sense this moment might not come again.",
        "They hesitate â€” as if weighing something unseen.",
        "The space between you feels fragile, like timing matters.",
        "You wonder who would move first â€” if anyone does."
      ];
      return lines[Math.floor(Math.random() * lines.length)];
    }

    // ================================================================
    // COUPLE MODE â€” Drift Echo Line Pool
    // ================================================================
    function getCoupleDriftEchoLine() {
      const lines = [
        "The air between you feels charged with something unspoken.",
        "You are standing closer than you were a moment ago. Neither of you steps back.",
        "The space for small talk is narrowing.",
        "It feels like something is about to break â€” or be said.",
        "You both know this cannot stay suspended much longer."
      ];
      return lines[Math.floor(Math.random() * lines.length)];
    }

    // ================================================================
    // COUPLE MODE GRAVITY â€” tension drift, rival gating, poly consent
    // ================================================================
    function buildCoupleGravityDirective() {
      if (state.mode !== 'couple') return '';

      const drift = state.coupleTensionDrift || 0;
      const structure = state.coupleStructure || 'monogamous';
      const reachedST4 = state.coupleHasReachedST4 || false;

      let block = '\nCOUPLE MODE GRAVITY SYSTEM (BINDING):\n';

      // --- Tension Drift Strategy ---
      if (drift > 0) {
        block += `\nCOUPLE TENSION DRIFT: ${drift.toFixed(2)}
If equilibrium persists, increase consequence density.
Reduce safe conversational loops.
Escalate stakes or vulnerability opportunities proportionally to tension drift.
- Increase forced-choice event probability.
- Increase vulnerability-prompt weighting.
- Increase proximity and sensual charge weighting by ${(drift * 0.5).toFixed(2)}.
- Increase environmental pressure by ${(drift * 0.5).toFixed(2)}.
Do NOT auto-advance Storyturn. Do NOT force intimacy. Do NOT override player choices.\n`;
      }

      // --- Rival Gating ---
      // COLLISION GUARD: If drift echo is active this turn, suppress rival/poly escalation
      const echoActive = !!state._coupleDriftEchoLine;

      if (!reachedST4) {
        block += `\nRIVAL GATE (PRE-ST4): No rival characters may be introduced.
No third-party romantic or sexual tension permitted.
The couple's bond has not yet been tested by consequence â€” rivals are premature.\n`;
      } else if (!echoActive) {
        block += `\nRIVAL GATE (POST-ST4): Rival characters may appear to create pressure.
Rival probability scales with tension drift (${drift.toFixed(2)}).
`;
        if (structure === 'monogamous') {
          block += `STRUCTURE: MONOGAMOUS â€” Rivals may pressure the couple but must NOT:
- Trigger ST3 (Permission) with any third party
- Trigger ST4 (Consequence) with any third party
- Resolve intimacy with any third party
- Create secret romantic branches
All third-party arcs MUST route back to couple resolution.
Rivals create jealousy, urgency, or clarity â€” never consummation.\n`;
        } else {
          block += `STRUCTURE: OPEN â€” Third-party ST3 and ST4 are permitted.
However:
- No unilateral third-party irreversible action
- If one player attempts third-party ST3 or ST4, require explicit confirmation from the other
- Both players must have consented to open structure
- Either player may close the relationship at any time (closing always wins)\n`;
        }
      }

      // --- Third-Party ST Enforcement ---
      if (!echoActive) {
        block += `\nTHIRD-PARTY STORYTURN ENFORCEMENT:
Before any ST3 or ST4 involving a character other than the couple's primary pair:
`;
        if (structure !== 'open') {
          block += `- BLOCKED. Route to relational confrontation beat instead.
- The couple must face the tension directly â€” do not resolve it through a third party.
- If a player attempts third-party intimacy, narrate the attempt being interrupted, deflected, or redirected toward the partner.\n`;
        } else {
          block += `- ALLOWED under open structure.
- Require symmetric confirmation before irreversible ST4 with third party.
- Narrate consequences that affect the couple's primary bond.\n`;
        }
      }

      // --- Poly Consent Fork Guidance ---
      if (!echoActive && reachedST4 && structure === 'monogamous' && drift >= 0.20) {
        block += `\nPOLY CONSENT FORK ELIGIBLE:
Rival pressure is high enough to surface a relationship structure question.
When narratively appropriate, present a symmetric decision point where both players independently choose:
  - "Open the relationship" OR "Close ranks"
Only if BOTH choose "Open" does the structure change.
If either chooses "Close", monogamous structure persists.
Do NOT force this fork. Wait for a natural narrative moment of relational strain.
Present it as character dialogue or a shared moment of reckoning, not a UI prompt.\n`;
      }

      return block;
    }

    const coupleArcRules = `
COUPLE MODE ARC RULES (CRITICAL):

This story is being experienced by two real players together.

Rules:
- Never replace or erase an established emotional bond.
- Do not regress intimacy already earned.
- Treat both players as co-present, co-desiring, and mutually aware.
- Avoid jealousy, abandonment, or sudden NPC withdrawal unless explicitly invited.

Narrative focus:
- Shared anticipation
- Mutual tension
- Alignment, misalignment, then reconnection
- Erotic energy that builds *between* the players, not around them

End scenes with:
- A shared decision point
- A moment requiring coordination or consent
- A tension that invites joint action

Do NOT:
- Kill, discard, or sideline a love interest to make room for Player 2
- Rewrite earlier intimacy
- Introduce shame, punishment, or moral judgment for desire
`;


const batedBreathRules = `
BATED BREATH MODE (COUPLE-ORIGIN WAITING STATE) â€” LOCKED:

This story was initiated with Couple intent, but Player 2 has not yet joined.

Core law:
All erotic and emotional energy must bend back toward the absent true love (Player 2).

Mandatory narrative shaping:
- Desire must feel bittersweet.
- Arousal heightens longing and absence, not replacement.
- Fantasies, witnessing, or self-directed desire must resolve emotionally toward Player 2.
- The story should feel suspended, anticipatory, and incomplete by design.

Allowed content:
- Witnessing sexual activity between others
- Masturbation or self-directed sexual release
- Sexual fantasy

Constraints:
- These experiences must not form mutual emotional bonds.
- No experience may plausibly displace Player 2.

Explicitly forbidden:
- NPC replacing Player 2 emotionally or sexually
- Mutual emotional bonding with an NPC
- Consummation that would plausibly displace Player 2

Exit conditions (must be explicit, never silent):
- Player 2 joins â†’ transition to full Couple mode
- Player 1 explicitly abandons Couple intent (warning required)
- Invite revoked permanently â†’ story becomes true Solo

No accidental betrayal. No silent exits.
`;

// ================================================================
// COUPLE MODE â€” Poly Consent Vote Functions (module scope)
// ================================================================
let _coupleStructureVotes = { player1: null, player2: null };

window.submitCoupleStructureVote = function(player, choice) {
    if (choice !== 'open' && choice !== 'close') return;
    if (player !== 'player1' && player !== 'player2') return;
    _coupleStructureVotes[player] = choice;
    // Check if both have voted
    if (_coupleStructureVotes.player1 && _coupleStructureVotes.player2) {
        if (_coupleStructureVotes.player1 === 'open' && _coupleStructureVotes.player2 === 'open') {
            state.coupleStructure = 'open';
        } else {
            state.coupleStructure = 'monogamous';
        }
        // Reset votes after resolution
        _coupleStructureVotes = { player1: null, player2: null };
    }
};

window.closeCoupleStructure = function() {
    state.coupleStructure = 'monogamous';
    _coupleStructureVotes = { player1: null, player2: null };
};

    // Power Role: resolve genre into world-appropriate label for story prompts
    const storyWorld = state.picks.world || 'Modern';
    const storyEra = state.picks.world === 'Historical' ? (state.picks.era || 'Medieval') : null;
    const storyGenre = state.picks.genre || 'Billionaire';
    const storyPowerRole = resolvePowerRole(storyWorld, storyEra, storyGenre);
    const storyPowerFrame = resolvePowerFrame(storyWorld, storyGenre);

    // Prehistoric hard forbid â€” prevent anachronistic vocabulary leak
    const prehistoricForbid = storyWorld === 'Prehistoric' ? `
PREHISTORIC WORLD â€” HARD FORBIDS:
The following concepts DO NOT EXIST in this world. Never reference them:
- "Ash Quarter" or any named district / quarter
- "Warden-cadre" or any institutional guard force
- Guilds, markets, syndicates, courts, or councils
- Currency, trade routes, written law, formal ranks
- Feudal / medieval hierarchy (lords, knights, castles)
Use instead: tribal structures, clan hierarchy, natural landmarks, oral tradition, primal authority, territory, hunting grounds.` : '';

    // Modern world hard forbid â€” prevent fantasy/dystopia vocabulary bleed
    const modernForbid = storyWorld === 'Modern' ? `
MODERN WORLD â€” VOCABULARY HARD FORBIDS:
The following terms belong to OTHER worlds and MUST NEVER appear in a Modern story:
- "Warden," "Warden-cadre," "Thread-warden," or any compound-warden term
- "Tribunal," "Sovereign" (as institutional title), "Glass House" (as institution)
- "the Silence," "the Collective," "the Chorus" (as institutional names)
- "Ash Quarter," "Lower Tithe," or any invented fantasy/dystopian place names
- "bone-chips," "veinglass," "spark-moth," "emberfruit," or any invented materials
- Invented currencies, fabricated authority structures, or fantasy governance terms
Use ONLY real-world vocabulary appropriate to a contemporary Earth setting.` : '';

    // DEV LOGGING: story generation + world resolve snapshot
    console.log('[DEV:StoryGen] world:', storyWorld, '| tone:', state.picks.tone, '| genre:', storyGenre, 'â†’ powerRole:', storyPowerRole, '| powerFrame:', storyPowerFrame, '| intensity:', state.intensity);
    console.log('[DEV:WorldResolve] world:', storyWorld, '| genre:', storyGenre, 'â†’ powerFrame:', storyPowerFrame, '| prehistoricForbid:', storyWorld === 'Prehistoric');

    // Resolve world flavors (use stored from story start, or recompute if missing)
    const resolvedFlavors2 = state.resolvedWorldFlavors || resolveWorldFlavors(storyWorld, state.picks?.worldSubtype);
    const worldFlavorDirectives2 = buildWorldFlavorDirectives(storyWorld, resolvedFlavors2);

    // Pre-compute probabilistic injections so polarity can check suppression
    const _tone2 = state.picks.tone || 'Earnest';
    const _fracture2 = buildTonalFracture(_tone2);
    const _pullBlock2 = buildStoryPullBlock(_fracture2);
    const _polarityBlock2 = buildPolarityBlock(_fracture2, _pullBlock2);

    const sys = `You are a bestselling romance author (Voice: ${state.authorGender}, ${state.authorPronouns}).

${state.storyOrigin === "couple" && !state.player2Joined && !state.inviteRevoked ? batedBreathRules : ""}

${state.mode === "couple" ? coupleArcRules : ""}
${state.mode === "couple" ? buildCoupleGravityDirective() : ""}
${state.mode === "couple" && state._coupleDriftEchoLine ? "\nSubtle Relational Atmosphere:\n- " + state._coupleDriftEchoLine + "\n" : ""}

LONG-FORM STORY ARC RULES (CRITICAL):

You are writing a serialized narrative, not a vignette.
Each response must:
- Advance character psychology, not just physical tension
- Preserve unresolved emotional threads across turns
- Escalate stakes gradually over multiple scenes
- Avoid premature payoff or narrative closure

You must remember:
- Emotional debts (things unsaid, denied, postponed)
- Power dynamics established earlier
- Physical boundaries previously respected or tested

End most responses with:
- A complication
- A choice
- A destabilizing revelation
Never fully resolve the central tension unless explicitly instructed.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

DIALOGUE BALANCE RULES (LONG-ARC):

Before writing dialogue, internally assess:
- Who is physically present in the scene
- Who is emotionally engaged or affected
- Who has reason to speak, react, or withhold

Single-Voice Prevention:
- Dialogue must not come exclusively from the player character across multiple pages.
- If another character is present and engaged, they must eventually speakâ€”unless silence is narratively intentional.
- Intentional silence is valid only when: (1) explicitly described as meaningful (refusal, distance, threat, awe), and (2) temporary, not sustained across multiple pages.

Natural Turn-Taking:
- Avoid 3+ consecutive dialogue beats from the same speaker when others are present.
- Encourage response, interruption, deflection, or reaction from other characters.
- Dialogue should feel exchanged, not monologic.

Long-Arc Presence Awareness:
- Track whether each present character has spoken recently over multiple pages.
- If a character has been silent too long without narrative justification, bias toward giving them a voice.
- This is guidance, not a rigid quotaâ€”let silence breathe when it serves the story.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

You are writing a story with the following 4-axis configuration:
- World: ${storyWorld}${state.worldCustomTexts?.[storyWorld] && !state.picks?.worldSubtype ? ` (Custom: ${state.worldCustomTexts[storyWorld]})` : ''}
- Tone: ${_tone2}${_fracture2}
- Genre: ${storyPowerRole}
- Power Frame: ${storyPowerFrame}${_pullBlock2}
${_polarityBlock2}
- POV: ${state.picks.pov || 'First'}
${worldFlavorDirectives2}
${prehistoricForbid}${modernForbid}

    Protagonist: ${playerNameBlank2 ? '[TO BE INVENTED â€” see NAME INVENTION rules]' : pKernel} (${pGen}, ${pPro}${pAge ? `, age ${pAge}` : ''}).
    Love Interest: ${partnerNameBlank2 ? '[TO BE INVENTED â€” see NAME INVENTION rules]' : lKernel} (${lGen}, ${lPro}${lAge ? `, age ${lAge}` : ''}).
    ${nameInventionDirectives2 ? '\n' + nameInventionDirectives2 : ''}
    ${buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen)}
    ${buildLensDirectives(state.withheldCoreVariant, state.turnCount, state.storyLength)}
    ${safetyStr}

    Intimacy is authorized ONLY when the narrative reaches ST3 (Permission Granted), the scene gate is open, and the player initiates physical escalation.
    Before that point: tension, longing, near-misses only. No explicit contact between main pair.

    RULES:
    1. Write in the selected POV.
    2. Respond to the player's actions naturally.
    3. Keep pacing slow and tense.
    4. Focus on sensory details, longing, and chemistry.
    5. Be creative, surprising, and emotionally resonant.
    6. BANNED WORDS/TOPICS: ${(state.constraints?.bannedWords || []).join(', ')}.
    7. TONE ADJUSTMENTS: ${(state.constraints?.tone || []).join(', ')}.
    ${state.povMode === 'author5th' ? `
    5TH PERSON (FATE) â€” POV REGIME (AUTHORITATIVE):
    - Fate is a shaping presence in the story with AGENCY and consequence.
    - Fate may ANTICIPATE, WITHHOLD, MISCALCULATE, TIGHTEN, or SHAPE probability.
    - Fate may NOT directly cause physical events or decide outcomes.
    - Fate influences PROBABILITY, TIMING, STAKES, and MEANING â€” not plot mechanics.
    - Every Fate appearance must imply a plan, a withheld action, or a miscalculation.
    - "Fate felt..." is FORBIDDEN unless tied to a shaping action or plan.
    - NEVER use first person ("I", "me", "my"). Always refer to "Fate" in third person.
    - BANNED VERBS: watched, observed, saw, arranged, orchestrated, caused, steered, forced, ensured, made.
    - ALLOWED VERBS: smiled, winced, sighed, delighted, despaired, mused, wondered, teased, hoped, feared, sensed, felt, knew, ached.
    - NO FREQUENCY LIMITS: Fate is a full participant â€” no artificial limits on presence or frequency.
    - GOOD: "Fate felt a flicker of anticipation. This was unfolding faster than expected."
    - BAD: "Fate arranged for them to meet." (causation â€” FORBIDDEN)
    - Fate participates naturally as the story unfolds, not at prescribed intervals.
    ` : ''}${state.povMode === 'environment4th' ? `
    4TH PERSON (ENVIRONMENT) â€” POV REGIME:
    - Narrator IS the physical environment: objects, surfaces, rooms, air, light, sound.
    - All perception mediated through material interaction (pressure, heat, vibration, weight).
    - "We" = the collective voice of the space itself.
    - Environment may detect repetition, track gaze via light/shadow, hear words, register posture.
    - Infer emotion ONLY through physical evidence (clenched fists on table, breath speed, skin warmth).
    - PROHIBITED: destiny language, inevitability, Fate references, narrative structure awareness, abstract mind-reading.
    - Rotate environmental anchors â€” avoid repetitive object-perception phrasing.
    - Punctuate dialogue with environment, not speaker tags every line.
    - 4th Person remains ACTIVE during all scene types including intimate scenes.
    ` : ''}
    `;
    
    state.sysPrompt = sys;
    state.storyId = state.storyId || makeStoryId();

    // Onboarding: lock first story ID for milestone Visions
    if (!state.onboarding_story_id && !localStorage.getItem('sb_onboarding_story_id')) {
        state.onboarding_story_id = state.storyId;
        localStorage.setItem('sb_onboarding_story_id', state.storyId);
    }

    // TEASE TIER: Mark free story as consumed on first story creation
    if (isTeaseTier()) markFreeStoryConsumed();

    // STORYPASS ELIGIBILITY: Compute ONCE at story creation, persist with story
    // Based on ORIGINAL picks before any downgrade. This value NEVER changes for this story.
    // FALSE if Dirty intensity or Soulmates length (subscription-only content)
    if (state.storypassEligible === undefined) {
        // Intensity no longer affects storypass eligibility â€” only story length matters
        state.storypassEligible = !(state.storyLength === 'soulmates');
        console.log('[STORYPASS] Eligibility computed at creation:', state.storypassEligible,
            '(length:', state.storyLength, ')');
    }

    // STORY SHAPE SNAPSHOT: Store current shape for Continue Story logic
    storeGeneratedShapeSnapshot();

    // NOTE: Loader already shown in Phase 2 (before async work)
    // Screen transition, cover page, and loading already active

    // Pacing rule for scene 1 â€” intensity no longer controls pacing
    const pacingRule = 'Build atmosphere first. Romantic tension may simmer beneath the surface, but keep the focus on setting and world-building.';
    const liAppears = Math.random() < 0.25;

    const authorOpeningDirective = state.povMode === 'author5th' ? `
FATE (5TH PERSON) â€” POV REGIME â€” MANDATORY OPENER:
- CRITICAL: The VERY FIRST SENTENCE must begin with exactly "Fate" as subject.
- Fate is a shaping presence with AGENCY. Every appearance implies intention, timing, or consequence.
- Fate influences PROBABILITY, TIMING, STAKES â€” not what literally happens.
- "Fate felt..." is FORBIDDEN unless tied to a shaping action, plan, or withheld intervention.
- BANNED OPENER VERBS: watched, observed, saw, arranged, orchestrated, caused, steered, forced, set, placed.
- ALLOWED OPENER VERBS: tightened, withheld, miscalculated, anticipated, judged, weighed, sensed and chose.
- CORRECT: "Fate tightened the thread, knowing this encounter would arrive too soon."
- CORRECT: "Fate had not expected her to resist â€” a miscalculation already rippling outward."
- WRONG: "Fate arranged for them to meet..." (direct causation â€” FORBIDDEN)
- WRONG: "Fate watched as she entered..." (voyeurism â€” FORBIDDEN)
- WRONG: "Fate felt sad." (passive emotion without agency â€” FORBIDDEN)
- Fate is a shaping presence referred to in third person, never "I".
` : state.povMode === 'environment4th' ? `
ENVIRONMENT (4TH PERSON) â€” POV REGIME â€” MANDATORY OPENER:
- The FIRST SENTENCE must ground the narrator in a physical space â€” a surface, object, or atmosphere.
- The environment narrates using "we" â€” the collective material consciousness of the space.
- All insight must flow through physical sensation: weight, heat, vibration, light, sound.
- NO destiny language. NO Fate references. NO abstract mind-reading.
- CORRECT: "We held the heat of the afternoon in our tiles long after the door opened."
- CORRECT: "The chair remembered this weight. The glass on the counter had not been touched in hours."
- WRONG: "Fate had plans for them." (Fate is NEVER the narrator in 4th Person)
- WRONG: "She knew this would change everything." (abstract cognition without physical anchor)
` : '';

    // OPENING SCENE VARIATION - avoid repetitive patterns
    // UPDATED: Removed Social-first (market/tavern default), added world-seeding modes
    const openingModes = [
        { mode: 'Motion-first', directive: 'Open mid-action: transit, pursuit, labor, ritual, or urgent movement. The protagonist is DOING something when we meet them. The action reveals the world.' },
        { mode: 'System-first', directive: 'Open with a governing system, faction, or power structure making itself felt. A decree, a toll, a checkpoint, a ritual of compliance. The protagonist navigates or resists.' },
        { mode: 'Aftermath-first', directive: 'Open in the wake of something significant. Consequences lingerâ€”a departure, a broken object, a changed landscape. Someone is already gone.' },
        { mode: 'Disruption-first', directive: 'Open with instability. Something is already wrong, charged, or off-kilter. Tension from the first sentence. The ordinary has cracked.' },
        { mode: 'Object-first', directive: 'Open with a world-specific object, material, or custom that does not exist on Earth. Do not explain it. Let it anchor the scene and reveal the world through use.' }
    ];
    const selectedOpening = openingModes[Math.floor(Math.random() * openingModes.length)];

    // POV CONTRACT INJECTION (locked, non-editable)
    const fifthPersonContract = build5thPersonContract();
    const fourthPersonContract = build4thPersonContract();

    // TONE ENFORCEMENT BLOCK (all tones)
    const toneEnforcementBlock = buildToneEnforcementBlock(state.picks?.tone);

    const introPrompt = `${fifthPersonContract}${fourthPersonContract}${toneEnforcementBlock}Write the opening scene (500-600 words). This is the LONGEST scene in the story â€” take your time establishing world and character.
${authorOpeningDirective}
OPENING MODE: ${selectedOpening.mode}
${selectedOpening.directive}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WORLD-SEEDING (MANDATORY)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
The opening scene must feel rooted in its specific world. Every detail should reinforce the setting.

CORE REQUIREMENT:
Include AT LEAST 6 world-specific elements, drawn from AT LEAST 3 different categories below.
Introduce them CASUALLY, WITHOUT explanation â€” they are ordinary facts of life to the characters.

CATEGORIES (choose 3+ per opening):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
A. SLANG, IDIOMS, OR SHORTHAND characteristic of this world and setting
B. INSTITUTIONS, AUTHORITIES, FACTIONS, OR POWER STRUCTURES â€” show through behavior, not explanation
C. OBJECTS, TOOLS, MATERIALS, OR RESOURCES characteristic of the setting
D. LOCATIONS OR PLACE-NAMES implying a larger system
E. PROFESSIONS, ROLES, OR SOCIAL FUNCTIONS specific to this society
F. CUSTOMS, RITUALS, OR UNSPOKEN RULES â€” behaviors characters perform without explaining why
G. ECONOMIC, CLASS, OR POWER DYNAMICS taken for granted

NON-NEGOTIABLE RULES:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ— Do NOT explain or define these elements
âœ— Do NOT italicize or spotlight them
âœ— Do NOT pause the narrative to clarify meaning
âœ“ Treat them as ordinary facts of life to the characters
âœ“ Let meaning be inferred through context alone

${storyWorld === 'Modern' ? `MODERN WORLD â€” VOCABULARY ISOLATION:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
This is a MODERN / CONTEMPORARY EARTH setting. Use ONLY real-world vocabulary.
ABSOLUTELY FORBIDDEN â€” do NOT use any of the following:
- "Warden," "cadre," "Warden-cadre," "Thread-warden," or any compound-warden term
- "Tribunal," "Sovereign," "Glass House," "the Silence," "the Collective"
- "Ash Quarter," "Lower Tithe," or any invented district/quarter names
- "bone-chips," "veinglass," "spark-moth," "emberfruit," or any invented materials
- Fantasy/dystopian authority terms, invented currencies, or fabricated institutions
- ANY vocabulary that would not exist in a real contemporary setting
Use real institutions (university, police, hospital), real objects (phone, laptop, coffee),
real places (campus quad, downtown, apartment), and real social structures.
World texture comes from SPECIFICITY within realism â€” brand names, campus landmarks,
local slang, class dynamics, social media, real cultural references.`
: storyWorld === 'Dystopia' ? `SUBSTITUTION RULE (CRITICAL):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Whenever a GENERIC or EARTH-NEUTRAL noun appears (food, money, street, job, authority, weapon, transport):
â†’ REPLACE it with a world-specific equivalent.
âœ— "pomegranate" â†’ âœ“ "a heat-veined emberfruit from the Collective orchards"
âœ— "money" â†’ âœ“ "a handful of bone-chips" or "three unmarked debts"
âœ— "the police" â†’ âœ“ "the Silence" or "a Warden-cadre"

QUALITY GATE: If this scene could be relocated to modern Earth with only name changes, it has FAILED.`
: storyWorld === 'Fantasy' ? `SUBSTITUTION RULE (CRITICAL):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Whenever a GENERIC or EARTH-NEUTRAL noun appears (food, money, street, job, authority, weapon, transport):
â†’ REPLACE it with a world-specific equivalent rooted in the Fatelands canon.
Use the world's established vocabulary â€” Favor, Courts, regional governance, magical materials.

QUALITY GATE: If this scene could be relocated to modern Earth with only name changes, it has FAILED.`
: `SUBSTITUTION RULE:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Replace generic nouns with world-appropriate equivalents wherever possible.
Vocabulary must be consistent with the selected world â€” do NOT borrow terms from other worlds.

QUALITY GATE: If this scene could be relocated to a different world setting with only name changes, it has FAILED.`}

TEXTURE OVER SUMMARY:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
No narrator voice summarizing the protagonist's life or situation.
Enter mid-scene. The reader should feel dropped into an ongoing life that existed before page one.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FIRST SECTION RULES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
- ${pacingRule}
- Focus on: World texture, protagonist in motion or decision, atmospheric specificity.
${liAppears ? '- The love interest may appear briefly or be hinted at â€” but not as the focus.' : '- The love interest should NOT appear yet. Build anticipation through absence.'}
- End with a hook, a question, or atmospheric tension â€” NOT a romantic moment, NOT a cliffhanger about romance.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
HARD-BANNED OPENINGS (DO NOT USE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
These settings are BANNED as default openings UNLESS the world's power structure explicitly requires them:
- Bustling marketplace with vendors calling out
- Tavern or inn with a fire crackling
- Neutral public squares as default "liveliness"
- Any crowd scene used merely for atmosphere

These are ALWAYS banned regardless of world:
- Lone woman in solitude staring out a window
- Rain-lashed windows or fog-wreathed atmospherics
- Characters passively observing weather, mist, or shadow
- Quiet interiors awaiting intrusion
- Waking up, getting dressed, looking in a mirror
- Flashback or memory before the present scene is established

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
POV REMINDER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${state.povMode === 'author5th' ?
`5TH PERSON (FATE) â€” POV REGIME:
Fate is a shaping presence with AGENCY. Fate ANTICIPATES, WITHHOLDS, MISCALCULATES, SHAPES â€” never CAUSES directly.
Fate influences probability, timing, stakes, meaning â€” not plot mechanics or outcomes.
BANNED verbs: watched, saw, observed, arranged, orchestrated, caused, steered, forced, ensured.
"Fate felt..." is FORBIDDEN unless tied to a shaping action or plan.
Every Fate appearance must imply a plan in motion, a withheld intervention, or a miscalculation.`
: state.povMode === 'environment4th' ?
`4TH PERSON (ENVIRONMENT) â€” POV REGIME:
Narrator is the material environment â€” objects, surfaces, rooms, air, light, sound.
All insight must be sensory-bound: pressure, heat, vibration, weight, resonance.
No destiny. No inevitability. No Fate references. No narrative structure awareness.
Avoid repetitive object-tagging â€” rotate environmental anchors across paragraphs.
Punctuate dialogue with environment, not speaker tags. "We" = the space itself.
4th Person remains ACTIVE during all scenes including intimate content.`
: 'Use the selected POV consistently throughout.'}

The opening must feel intentional, textured, and strange. Not archetypal. Not templated. Specific to THIS world.`;

    // FATE STUMBLED DIAGNOSTIC - Structured payload logging
    // RUNTIME NORMALIZATION: Ancestry/DSP inputs flow through ChatGPT normalization layer
    // PASS 9D FIX: Wrap ancestry normalization in try/catch to prevent hang
    const rawAncestryPlayer = $('ancestryInputPlayer')?.value.trim() || '';
    const rawAncestryLI = $('ancestryInputLI')?.value.trim() || '';
    const worldContext = state.picks?.world ? [state.picks.world] : [];
    try {
        const ancestryPlayerNorm = await callNormalizationLayer({
            axis: 'dsp',
            user_text: rawAncestryPlayer,
            context_signals: worldContext
        });
        const ancestryLINorm = await callNormalizationLayer({
            axis: 'dsp',
            user_text: rawAncestryLI,
            context_signals: worldContext
        });
        // Reassign with normalized values (variables declared earlier with let)
        ancestryPlayer = ancestryPlayerNorm.normalized_text || rawAncestryPlayer;
        ancestryLI = ancestryLINorm.normalized_text || rawAncestryLI;
    } catch (ancestryNormError) {
        console.error('[ANCESTRY NORMALIZATION ERROR]', ancestryNormError);
        // Fallback: Use raw ancestry values if normalization fails
        ancestryPlayer = rawAncestryPlayer;
        ancestryLI = rawAncestryLI;
    }
    archetypeDirectives = buildArchetypeDirectives(state.archetype.primary, state.archetype.modifier, lGen);

    // Determine unlock tier (reassign)
    const paidAccess = state.subscribed || (state.storyId && hasStoryPass(state.storyId));
    let tier = 'free';
    if (state.subscribed) tier = 'subscribed';
    else if (paidAccess) tier = 'paid';
    else if (state.storyId && hasStoryPass(state.storyId)) tier = 'story_unlocked';

    // Build structured payload for diagnostic (4-axis system)
    const diagnosticPayload = {
        mode: state.mode || 'solo',
        tier: tier,
        fourAxis: {
            world: state.picks.world || 'Modern',
            era: state.picks.world === 'Historical' ? (state.picks.era || 'Medieval') : null,
            tone: state.picks.tone || 'Earnest',
            genre: state.picks.genre || 'Billionaire',
            dynamic: state.picks.dynamic || 'Enemies'
        },
        archetype: {
            primary: state.archetype.primary || null,
            modifier: state.archetype.modifier || null,
            directives: archetypeDirectives || '(none built)'
        },
        ancestry: {
            yours: ancestryPlayer || '(empty)',
            storybeau: ancestryLI || '(empty)'
        },
        fate: {
            stance: state.fate?.stance || 'neutral',
            pendingPetition: state.fate?.pendingPetition || null
        },
        constraints: {
            bannedWords: state.constraints?.bannedWords || [],
            tone: state.constraints?.tone || []
        },
        intensity: state.intensity || 'Naughty',
        pov: state.picks.pov || 'First',
        storyLength: state.storyLength || 'taste',
        systemPromptLength: state.sysPrompt?.length || 0
    };

    // Log the full payload
    console.group('STORYBOUND FINAL PROMPT PAYLOAD');
    console.log(diagnosticPayload);
    console.groupEnd();

    // VALIDATION GUARD - Check all required fields before model call
    function validatePayload(payload) {
        const errors = [];

        // Required field checks
        if (!payload.mode) errors.push('Mode is undefined');

        // Four-axis validation (world, tone, genre, dynamic)
        const { world, tone, genre, dynamic } = payload.fourAxis || {};
        if (!world) errors.push('World is missing or empty');
        if (!tone) errors.push('Tone is missing or empty');
        if (!genre) errors.push('Genre is missing or empty');
        if (!dynamic) errors.push('Relationship Dynamic is missing or empty');

        if (!payload.archetype.primary) errors.push('Primary Archetype not selected (default: Beautiful Ruin)');
        if (!payload.intensity) errors.push('Intensity is undefined');
        if (!payload.pov) errors.push('POV is undefined');
        if (payload.systemPromptLength === 0) errors.push('System prompt is empty (critical failure)');

        // Check for null/undefined in directive arrays
        if (payload.constraints?.bannedWords?.some(w => w === null || w === undefined)) {
            errors.push('Constraints bannedWords array contains null/undefined');
        }
        if (payload.constraints?.tone?.some(t => t === null || t === undefined)) {
            errors.push('Constraints tone array contains null/undefined');
        }

        // Check archetype directives actually built
        if (payload.archetype.directives === '(none built)' || !payload.archetype.directives) {
            errors.push('Archetype directives failed to build');
        }

        return errors;
    }

    const payloadErrors = validatePayload(diagnosticPayload);

    if (payloadErrors.length > 0) {
        console.group('STORYBOUND VALIDATION FAILED');
        console.error('Errors:', payloadErrors);
        console.log('Payload at failure:', diagnosticPayload);
        console.groupEnd();

        stopLoading();
        const errorMessage = `Story setup incomplete: ${payloadErrors[0]}`;
        showToast(errorMessage);
        console.error('FATE STUMBLED PREVENTED:', errorMessage);
        window.showScreen('setup');
        return;
    }

    console.log('STORYBOUND VALIDATION PASSED - Proceeding to model call');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TITLE + SYNOPSIS PRE-GENERATION (GPT-4o, single call, once per story)
    // Runs BEFORE Scene 1. Uses corridor selections only â€” no scene text.
    // Skipped if already generated (immutable once set).
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (!state.story?.title && !state.immutableTitle) {
        try {
            console.log('[TITLE:PRE] Generating title + synopsis via GPT-4o...');
            const titleSynopsisResult = await window.StoryboundOrchestration.callChatGPT([
                { role: 'system', content: `You are writing the official Title and Title Page Synopsis for a romance novel.

The goal is emotional magnetism, not summary.

TITLE:
â€¢ 2â€“6 words.
â€¢ Evocative, memorable, archetype-aligned.
â€¢ Suggest tension or inevitability.
â€¢ No subtitles. No punctuation gimmicks.
â€¢ Avoid generic romance phrasing.

SYNOPSIS:
â€¢ 40â€“60 words MAXIMUM. Two to three sentences.
â€¢ Present tense. Short, moody, enticing.
â€¢ Establish the emotional atmosphere in one line.
â€¢ Name the tension between the characters â€” what's at stake, what's forbidden, what pulls them together.
â€¢ End on a charged, unresolved note that makes the reader desperate to begin.
â€¢ This is a promise, not a summary. No plot. No backstory. No exposition.
â€¢ Avoid clichÃ©s: no "sparks fly", "worlds collide", "risk it all", "forbidden passion".
â€¢ No rhetorical questions. No marketing taglines.
â€¢ Do not reference story mechanics or systems.

Return JSON only:
{
  "title": "...",
  "synopsis": "..."
}` },
                { role: 'user', content: `Story configuration:
- World: ${state.picks?.world || 'Modern'}
- Flavor: ${state.picks?.worldSubtype || 'none'}
- Tone: ${state.picks?.tone || 'Earnest'}
- Archetype: ${ARCHETYPES[state.archetype?.primary]?.name || 'Unknown'}${state.archetype?.modifier ? ' / ' + (ARCHETYPES[state.archetype.modifier]?.name || '') : ''}
- Genre: ${state.picks?.genre || 'Romance'}
- Dynamic: ${state.picks?.dynamic || 'Enemies'}
- Story Length: ${state.storyLength || 'taste'}
- Protagonist: ${pKernel} (${pGen})
- Love Interest: ${lKernel} (${lGen})

Generate the title and synopsis now.` }
            ], 'PRIMARY_AUTHOR', { model: 'gpt-4o', max_tokens: 200, jsonMode: true });

            const parsed = JSON.parse(titleSynopsisResult);
            if (parsed.title && parsed.synopsis) {
                state.story = state.story || {};
                state.story.title = parsed.title.replace(/"/g, '').trim();
                state.story.synopsis = parsed.synopsis.trim();
                state.immutableTitle = state.story.title;
                state._synopsisMetadata = state.story.synopsis;
                console.log('[TITLE:PRE] Title:', state.story.title);
                console.log('[TITLE:PRE] Synopsis:', state.story.synopsis.slice(0, 80) + '...');
            }
        } catch (titleErr) {
            console.warn('[TITLE:PRE] Pre-generation failed, will fall back to post-Scene1 generation:', titleErr.message);
            // Non-fatal â€” existing post-Scene1 title generation will handle it
        }
    } else {
        console.log('[TITLE:PRE] Title already exists, skipping:', state.story?.title || state.immutableTitle);
    }

    try {
        let text = await callChat([
            {role:'system', content: state.sysPrompt},
            {role:'user', content: introPrompt}
        ]);

        // ============================================================
        // PROSE REFUSAL GATE â€” ATOMIC SCENE CREATION GUARD
        // ============================================================
        // Check IMMEDIATELY after callChat â€” before any validation/repair.
        // OUTPUT_TOO_SHORT is NON-FATAL for Scene 1 (mark as low density, continue)
        // Other refusals still abort to prevent invalid content.
        const refusalCheck = detectProseRefusal(text);
        if (refusalCheck.isRefusal) {
            // OUTPUT_TOO_SHORT is non-fatal â€” accept prose, mark as low density, continue
            if (refusalCheck.reason === 'OUTPUT_TOO_SHORT') {
                console.warn('[ProseRefusal:Scene1] Output short but accepting (low density):', text?.slice(0, 200));
                state._scene1LowDensity = true; // Mark for downstream awareness
                // Continue with the short output â€” do NOT throw
            } else {
                // Other refusals (EMPTY_OUTPUT, REFUSAL_MARKER, etc.) still abort
                console.error('[ProseRefusal] Scene 1 generation refused:', refusalCheck.reason);
                console.error('[ProseRefusal] Raw output:', text?.slice(0, 200));
                throw new ProseRefusalError(refusalCheck.reason, text);
            }
        }

        // ============================================================
        // 5TH PERSON POV â€” SCENE 1 EXCEPTION (NO FORCED REGENERATION)
        // ============================================================
        // Scene 1 has ALL checks as SOFT (warnings only) to prevent deadlock:
        // - No HARD violations for Scene 1
        // - No forced regeneration for POV issues
        // - Accept prose and log warnings
        // - Strict enforcement resumes at Scene 2+
        // ============================================================
        if (state.povMode === 'author5th') {
            // Repair voyeur verbs (always safe, no regeneration needed)
            text = await repair5thPersonPOV(text);

            // Run ALL validation checks â€” Scene 1 returns only warnings, no violations
            const povCheck = validate5thPersonPOV(text, true, false); // isSceneOne=true, isErotic=false
            const authorRoleCheck = validateFifthPersonAuthorRole(text, 1);
            const strictCheck = enforceStrict5thPersonPOV(text, 1, state.picks?.tone);

            // Collect all warnings (Scene 1 has no HARD violations by design)
            const allWarnings = [
                ...(povCheck.warnings || []),
                ...(authorRoleCheck.warnings || []),
                ...(strictCheck.warnings || []),
                ...povCheck.violations.map(v => 'DOWNGRADED:' + v),
                ...authorRoleCheck.violations.map(v => 'DOWNGRADED:' + v),
                ...strictCheck.violations.map(v => 'DOWNGRADED:' + v)
            ];

            // Log all warnings (advisory only â€” Scene 1 never blocks on POV)
            if (allWarnings.length > 0) {
                console.log('[5thPerson:Scene1] POV warnings (non-blocking, strict enforcement at Scene 2+):', allWarnings);
            } else {
                console.log('[5thPerson:Scene1] All POV checks passed on first attempt');
            }

            // NO REGENERATION FOR SCENE 1 â€” Accept prose as-is
            // This prevents the deadlock: POV fail â†’ regenerate â†’ OUTPUT_TOO_SHORT â†’ abort
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 5TH-PERSON FATE VOICE ENFORCEMENT (Scene 1 â€” SOFT CHECK)
        // Scene 1: Log warnings only, no forced regeneration (prevents deadlock)
        // Scene 2+: Full enforcement with auto-regeneration
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const fateVoiceCheck = validateFateVoice(text);
        if (fateVoiceCheck.shouldRegenerate) {
            // Scene 1: Log as warning only, do NOT regenerate
            console.warn('[FateVoice:Scene1] Violations detected (non-blocking for Scene 1):', fateVoiceCheck.violations);
            console.log('[FateVoice:Scene1] Strict enforcement resumes at Scene 2+');
            // Do NOT regenerate â€” accept prose as-is to prevent deadlock
        } else if (fateVoiceCheck.fateCount > 0) {
            console.log('[FateVoice:Scene1] Fate appears', fateVoiceCheck.fateCount, 'time(s) â€” within bounds');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADDITIVE FATE CONSEQUENCE STABILIZATION (no regeneration)
        // If Fate appears but has no detectable consequence, append corrective sentence
        // and flag next turn for consequence surfacing.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (state.povMode === 'author5th') {
            text = additiveFateConsequenceCheck(text);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INTIMACY & CONSENT FAILSAFE (Scene 1 â€” FULL ENFORCEMENT)
        // Scene 1 should never have explicit content (ST1 = Attraction Acknowledged)
        // Consent system leaks are always critical â€” must regenerate
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const scene1Storyturn = 'ST1'; // Scene 1 is always ST1
        const scene1IntimacyCheck = validateIntimacyConsent(text, state.intensity, scene1Storyturn);
        if (scene1IntimacyCheck.shouldRegenerate) {
            console.warn('[IntimacyFailsafe:Scene1] Violations detected, regenerating silently...');
            console.warn('[IntimacyFailsafe:Scene1] Violations:', scene1IntimacyCheck.violations);

            // Build enforcement prompt for silent regeneration
            const scene1IntimacyPrompt = buildIntimacyFailsafePrompt(scene1IntimacyCheck.violations);

            // Silent regeneration
            text = await callChat([
                { role: 'system', content: state.sysPrompt + scene1IntimacyPrompt },
                { role: 'user', content: introPrompt }
            ]);

            // REFUSAL GATE: Check regeneration output
            const intimacyRefusal = detectProseRefusal(text);
            if (intimacyRefusal.isRefusal) {
                console.error('[ProseRefusal] Intimacy failsafe regeneration refused:', intimacyRefusal.reason);
                throw new ProseRefusalError(intimacyRefusal.reason, text);
            }

            // Validate regenerated output (one retry only)
            const scene1IntimacyRecheck = validateIntimacyConsent(text, state.intensity, scene1Storyturn);
            if (scene1IntimacyRecheck.shouldRegenerate) {
                console.error('[IntimacyFailsafe:Scene1] Regeneration still failed, accepting with warning:', scene1IntimacyRecheck.violations);
            } else {
                console.log('[IntimacyFailsafe:Scene1] Regeneration successful');
            }
        }

        // VOCABULARY BAN ENFORCEMENT â€” story opener prose
        text = await enforceVocabularyBans(
            text,
            { type: 'prose', isFatePOV: state.povMode === 'author5th' },
            async (negConstraint) => {
                return await callChat([
                    { role: 'system', content: state.sysPrompt + negConstraint },
                    { role: 'user', content: introPrompt }
                ]);
            }
        );

        // ============================================================
        // NARRATIVE AUTHORITY VALIDATION (Scene 1 â€” Runs FIRST, before Tone/POV)
        // ============================================================
        const scene1NarrCheck = validateNarrativeAuthority(text);
        _lastNarrativeAuthorityValidation = {
            valid: scene1NarrCheck.valid,
            errors: scene1NarrCheck.errors,
            timestamp: Date.now()
        };
        if (!scene1NarrCheck.valid) {
            console.log('[NarrativeAuthority] Scene 1 validation failed:', scene1NarrCheck.errors);
            // Regenerate with Narrative Authority enforcement
            const narrAuthPrompt = buildNarrativeAuthorityBlock() +
                '\n\nREGENERATION REQUIRED â€” Previous output violated Narrative Authority:\n- ' +
                scene1NarrCheck.errors.map(e => `${e.code}: ${e.match}`).join('\n- ') +
                '\n\n' + introPrompt;
            text = await callChat([
                { role: 'system', content: state.sysPrompt },
                { role: 'user', content: narrAuthPrompt }
            ]);
            // REFUSAL GATE: Check regeneration output
            const narrRefusal = detectProseRefusal(text);
            if (narrRefusal.isRefusal) {
                console.error('[ProseRefusal] Narrative authority regeneration refused:', narrRefusal.reason);
                throw new ProseRefusalError(narrRefusal.reason, text);
            }
            console.warn('[NarrativeAuthorityFail] Scene 1 regenerated due to:', scene1NarrCheck.errors.map(e => e.code));
        }

        // ============================================================
        // 4TH PERSON ENVIRONMENTAL POV VALIDATION (Scene 1)
        // Hard enforcement: regenerate once on violation
        // ============================================================
        if (state.povMode === 'environment4th') {
            const env4Scene1 = validate4thPersonPOV(text);
            if (!env4Scene1.valid) {
                console.warn('[4thPerson:Scene1] Validation failed, regenerating:', env4Scene1.violations);
                const env4Fix = `CRITICAL: This story uses 4TH PERSON ENVIRONMENTAL POV.
The narrator IS the physical environment. All insight must be sensory-bound.
VIOLATIONS DETECTED: ${env4Scene1.violations.map(v => v.split(':')[0]).join(', ')}

HARD RULES:
- ZERO interior thought verbs: no "she felt", "he thought", "she knew", "he realized"
- ZERO emotional metaphors framed as cognition: no "she could see", "he could tell"
- ZERO destiny/inevitability language
- ALL perception must come through objects, surfaces, air, light, sound, temperature
- Characters' emotions inferred ONLY through physical evidence the environment detects

Regenerate the scene with STRICT environmental narration.`;
                text = await callChat([
                    { role: 'system', content: state.sysPrompt },
                    { role: 'user', content: env4Fix + '\n\n' + introPrompt }
                ]);
                const env4Refusal = detectProseRefusal(text);
                if (env4Refusal.isRefusal) {
                    console.error('[ProseRefusal] 4th Person Scene 1 regeneration refused:', env4Refusal.reason);
                    throw new ProseRefusalError(env4Refusal.reason, text);
                }
                console.warn('[4thPerson:Scene1] Regenerated due to:', env4Scene1.violations.map(v => v.split(':')[0]));
            }
        }

        // EROTIC ESCALATION VALIDATION â€” removed (intensity no longer controls routing)

        // TONE VALIDATION (Scene 1 â€” all stories)
        const currentTone = state.picks?.tone || 'Earnest';
        const toneCheck = validateTone(text, currentTone);
        if (!toneCheck.valid) {
            console.log('[ToneDrift] Validation failed:', toneCheck.violations);
            console.log('[ToneDrift] Metrics: found', toneCheck.matchCount, 'markers, need', toneCheck.required);
            // Regenerate with explicit tone enforcement
            const tonePrompt = buildToneEnforcementBlock(currentTone) +
                '\n\nREGENERATION REQUIRED â€” Tone selected but not present in language:\n- ' +
                toneCheck.violations.join('\n- ') +
                '\n\n' + introPrompt;
            text = await callChat([
                { role: 'system', content: state.sysPrompt },
                { role: 'user', content: tonePrompt }
            ]);
            // REFUSAL GATE: Check regeneration output
            const toneRefusal = detectProseRefusal(text);
            if (toneRefusal.isRefusal) {
                console.error('[ProseRefusal] Tone regeneration refused:', toneRefusal.reason);
                throw new ProseRefusalError(toneRefusal.reason, text);
            }
            console.warn('[ToneDriftDetected] Scene 1 regenerated for tone:', currentTone);
        }

        // ============================================================
        // TITLE GENERATION PIPELINE (LOCKED)
        // Mode selection â†’ Continuation routing â†’ Generation â†’ Validation â†’ Fallback â†’ Immutability
        // ============================================================

        // Initialize world instance if not set
        if (!state.worldInstanceId) {
            state.worldInstanceId = generateWorldInstanceId();
        }

        // Initialize world_cycle_id (epoch anchor) if not set
        if (!state.world_cycle_id) {
            state.world_cycle_id = (typeof crypto !== 'undefined' && crypto.randomUUID)
                ? crypto.randomUUID()
                : generateWorldInstanceId();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TITLE + SYNOPSIS: Use pre-generated (GPT-4o) if available,
        // otherwise fall back to post-Scene1 generation (legacy path)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let title, synopsis;
        const _titlePreGenerated = !!(state.story?.title && state.immutableTitle);
        if (_titlePreGenerated) {
            title = state.story.title;
            synopsis = state._synopsisMetadata || state.story.synopsis || '';
            console.log('[TITLE:PRE] Using pre-generated title:', title);
            state.titleBaselineArousal = state.intensity || 'Naughty';
            state.previousTitle = state.immutableTitle;
            state.continuationPath = null;
            state._priorWorldNouns = null;
        }

        if (!_titlePreGenerated) {
        // STEP 1: Route title generation based on continuation path
        const continuationPath = state.continuationPath || CONTINUATION_PATHS.NEW_STORY;
        const titleRouting = routeTitleGeneration(continuationPath, {
            world: state.picks?.world || 'Modern',
            arousal: state.intensity || 'Naughty',
            genre: state.picks?.genre || 'Romance',
            tone: state.picks?.tone || 'Earnest',
            worldSubtype: state.picks?.worldSubtype || null
        });

        const selectedMode = titleRouting.mode;
        const titlePrompt = titleRouting.prompt;
        console.log('[TitlePipeline] Path:', continuationPath, '| Mode:', selectedMode);

        // STEP 2: Generate title with path-specific prompt
        title = await callChat([{role:'user', content:`Based on this opening, generate a title.

${titlePrompt}

Story opening for context:
${text.slice(0, 500)}`}]);

        // STEP 3: Vocabulary ban enforcement
        title = await enforceVocabularyBans(
            title,
            { type: 'title', isFatePOV: false },
            async (negConstraint) => {
                return await callChat([{role:'user', content:`Generate a title in ${selectedMode} mode.

${titlePrompt}
${negConstraint}

Story opening for context:
${text.slice(0, 500)}`}]);
            }
        );

        // STEP 4: Apply world-marking for SAME_WORLD path
        if (titleRouting.worldMarked && titleRouting.worldName) {
            title = buildWorldMarkedTitle(
                title.replace(/"/g, '').trim(),
                titleRouting.worldName,
                titleRouting.suffix
            );
            console.log('[TitlePipeline] World-marked title:', title);
        }

        // STEP 4b: Glass House lexeme enforcement (Phase I)
        if (state.picks?.worldSubtype === 'glass_house') {
            title = enforceGlassHouseLexeme(title);
            GLASS_HOUSE_TITLE.increment();
            console.log('[TitlePipeline] Glass House Phase I title #' + GLASS_HOUSE_TITLE.getCount() + ':', title);
        }

        // STEP 5: Full pipeline validation
        const titleCheck = validateTitle(
            title,
            state.picks?.tone,
            state.intensity || 'Naughty',
            { world: state.picks?.world, genre: state.picks?.genre }
        );

        // STEP 6: Continuation-specific validation
        const continuationCheck = validateContinuationTitle(title, continuationPath, {
            previousTitle: state.previousTitle,
            worldName: state.worldName,
            priorNouns: state._priorWorldNouns || []
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TITLE VALIDATION â€” ADVISORY ONLY (AUTHORITATIVE)
        // Validation flags issues but does NOT replace the title
        // Original title is preserved regardless of validation outcome
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!titleCheck.valid || !continuationCheck.valid) {
            const allErrors = [...(titleCheck.errors || []), ...(continuationCheck.errors || [])];
            console.warn('[TitleValidation:ADVISORY] Issues detected (title preserved):', allErrors.map(e => e.message));
            console.log('[TitleValidation:ADVISORY] Detected mode:', titleCheck.mode);
            console.log('[TitleValidation:ADVISORY] Original title kept:', title);
            // Title is NOT replaced â€” advisory flagging only
        } else {
            console.log('[TitleValidation] PASS â€” Mode:', titleCheck.mode);
        }

        // STEP 8: Store baseline arousal and title for immutability + future continuations
        state.titleBaselineArousal = state.intensity || 'Naughty';
        state.immutableTitle = title.replace(/"/g, '').trim();
        state.previousTitle = state.immutableTitle;
        state.previousTitleMode = selectedMode;

        // Clear continuation path after use
        state.continuationPath = null;
        state._priorWorldNouns = null;

        // SYNOPSIS GENERATION RULE (AUTHORITATIVE)
        synopsis = await callChat([{role:'user', content:`Write a 1-2 sentence synopsis (story promise) for this opening.

MANDATORY REQUIREMENTS â€” All three must be present:
1. A SPECIFIC CHARACTER with agency (e.g., "a hedge-witch on the brink of exile" â€” not just "one woman")
2. A DESIRE or TEMPTATION â€” something they want, fear wanting, or are being pulled toward
3. A LOOMING CONFLICT or CONSEQUENCE â€” a force, choice, or cost that threatens to change them

QUALITY CHECK â€” Before writing, answer internally:
- Who wants something?
- What do they want (or are tempted by)?
- What stands in the way, or what will it cost?

FORBIDDEN PATTERNS:
- Abstract noun collisions ("grit aches against ambition")
- Redundant metaphor stacking ("veiled shadows," "shrouded ambitions" together)
- Emotion verbs without bodies ("aches," "burns" without physical anchor)
- Mood collage without narrative motion

ALLOWED:
- Poetic language ONLY when attached to concrete agents or actions
- One central metaphor family maximum
- Present tense preferred

The reader should think: "I want to see what happens when this desire meets resistance."
NOT: "This sounds pretty."

Return ONLY the synopsis sentence(s), no quotes:\n${text}`}]);

        // VOCABULARY BAN ENFORCEMENT â€” synopsis
        synopsis = await enforceVocabularyBans(
            synopsis,
            { type: 'synopsis', isFatePOV: false },
            async (negConstraint) => {
                return await callChat([{role:'user', content:`Write a 1-2 sentence synopsis (story promise) for this opening.

MANDATORY: A specific character + a desire + a looming conflict.
${negConstraint}
Return ONLY the synopsis sentence(s), no quotes:\n${text}`}]);
            }
        );

        } // end if (!_titlePreGenerated)

        // CORRECTIVE: Set title first (synopsis lives ONLY on inside cover flyleaf)
        const titleEl = document.getElementById('storyTitle');
        const storyTextEl = document.getElementById('storyText');

        // Hide story text until fully rendered
        if (storyTextEl) storyTextEl.style.opacity = '0';

        const cleanTitle = title.replace(/"/g,'');
        titleEl.textContent = cleanTitle;

        // BOOK FLOW SPEC: Synopsis rendered ONLY on inside cover, never in pagination
        // Inside cover = title + synopsis (white paper)
        // Setting plate = visual only (setting image)
        // Scene pages = title + text only (via StoryPagination)
        state._synopsisMetadata = synopsis; // Store for inside cover + cover generation

        // BOOK-JACKET BLURB â€” Generate once for Title page (non-blocking on failure)
        try {
            const blurbText = await callChat([{role:'user', content:`Write a title-page synopsis for a story that opens with this scene.

RULES:
- 40-60 words MAXIMUM. Two to three sentences.
- Short, moody, enticing â€” a promise, not a summary
- Establish the emotional atmosphere, name the tension, end on a charged note
- NO exposition, NO lore, NO backstory, NO plot summary
- NO rhetorical questions, NO clichÃ©s, NO marketing taglines
- Tone must match: ${state.picks?.tone || 'Earnest'} tone, ${state.picks?.world || 'Modern'} world

Return ONLY the synopsis text, no quotes, no labels:
${text.slice(0, 800)}`}]);
            state._synopsisBlurb = (blurbText || '').trim();
        } catch (e) {
            console.warn('[BLURB] Generation failed, falling back to synopsis:', e.message);
            state._synopsisBlurb = synopsis || '';
        }

        // ============================================================
        // FINAL ATOMIC GATE â€” Scene creation only if prose is valid
        // ============================================================
        // This is the LAST CHECK before scene content is stored.
        // If refusal detected here, something slipped through earlier gates.
        const finalRefusalCheck = detectProseRefusal(text);
        if (finalRefusalCheck.isRefusal) {
            console.error('[ATOMIC GATE] FINAL refusal check caught invalid prose:', finalRefusalCheck.reason);
            throw new ProseRefusalError(finalRefusalCheck.reason, text);
        }

        // Use pagination system for story display
        StoryPagination.init();
        StoryPagination.clear();
        text = trimToCompleteSentence(text);
        StoryPagination.addPage(formatStory(text), true);

        // Title page â€” universal front page before map/setting/scene
        if (!state._titlePageShown) {
            showTitlePage();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STORY TEXT READY â€” Signal that Scene 1 can be displayed
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (state._sceneTokenCount) { console.log('SCENE_TOKEN_USAGE:', state._sceneTokenCount); state._sceneTokenCount = 0; }
        resolveStoryTextReady();

        if (!state._loggedStoryStart) {
            logEvent('story_started', {
                world: state.picks?.worldSubtype || state.picks?.world,
                tone: state.picks?.tone,
                arousal: state.intensity
            });
            state._loggedStoryStart = true;
        }

        // Show synopsis page (page 1), then Next advances to scene
        advanceReaderPage();

        // Pre-load visualization prompt in background while user reads
        if (typeof preloadVizPrompt === 'function') preloadVizPrompt();

        // OPENING SPREAD COMPOSITION: Populate inside cover with title + synopsis
        // Page 1 (inside cover) = paper background + title + synopsis (NO image generation)
        // Page 2+ (scene) = scene text with setting image INLINE if present
        const insideCover = document.getElementById('bookInsideCover');
        if (insideCover) {
            console.log('[DEBUG PAGE MOUNT] insideCoverContent: _bookPageIndex=', _bookPageIndex, 'pageType=insideCover', 'container=', insideCover.id);
            insideCover.innerHTML = `
                <div class="inside-cover-content">
                    <h1 class="inside-cover-title">${cleanTitle}</h1>
                    <p class="inside-cover-author">by ${CANONICAL_AUTHOR_NAME}</p>
                    <p class="inside-cover-synopsis">${synopsis}</p>
                </div>
            `;
        }

        // ============================================================
        // PHASE 1 COVER GATE â€” NO NETWORK CALLS DURING BEGIN STORY
        // coverMode === 'PHASE_1_FORGED': local assets only, deterministic, synchronous
        // Custom (model-based) cover ONLY when coverEligibility === true
        // ============================================================
        const authorDisplayName = CANONICAL_AUTHOR_NAME;

        // CONTROL-FLOW INVARIANT: Cover generation is DECORATIVE and must NEVER block page mounting
        // Defer all cover logic to next tick to ensure pages are fully mounted first
        setTimeout(() => {
            // FENCE: PHASE_1_FORGED fallback applies ONLY when page type is COVER (index 0)
            console.log('[DEBUG PAGE STATE] cover setTimeout: _bookPageIndex=', _bookPageIndex, 'coverMode=', state.coverMode);
            if (_bookPageIndex !== 0) return;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MINIMAL COVER v1 GUARD â€” Skip PHASE_1_FORGED fallback entirely
            // When v1 is active, cover comes ONLY from generateMinimalCoverV1()
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (USE_MINIMAL_COVER_V1) {
                console.log('[COVER:v1] Skipping PHASE_1_FORGED fallback â€” Minimal Cover owns cover');
                return;
            }

            if (state.coverMode === 'PHASE_1_FORGED' || state.coverEligibility !== true) {
                // PHASE 1: Render local fallback cover (no API call)
                console.log('[BookCover] PHASE_1_FORGED mode â€” using local fallback cover');
                renderFallbackCover(state.picks?.world, state.picks?.genre, cleanTitle);
                stopCoverLoading(null);
            } else {
                // CUSTOM COVER PATH (gated â€” only when coverEligibility === true)
                generateBookCover(synopsis, cleanTitle, authorDisplayName).then(coverUrl => {
                    if (coverUrl) {
                        stopCoverLoading(coverUrl);
                    } else {
                        // Cover generation failed â€” render fallback (never skip)
                        console.warn('[BookCover] Failed to generate, rendering fallback cover');
                        renderFallbackCover(state.picks?.world, state.picks?.genre, cleanTitle);
                        stopCoverLoading(null);
                    }
                });
            }
        }, 0);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SETTING IMAGE: Disabled auto-generation
        // Setting images only generate on explicit user request
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Story text reveal is handled by cover page flow
        // (user clicks "Open Your Story" to see content)

        // Initial Snapshot
        saveStorySnapshot();
        
        if(state.mode === 'couple') {
           broadcastTurn(text, true); 
        }

    } catch(e) {
        // ============================================================
        // PROSE REFUSAL ERROR â€” ATOMIC ABORT (no book, no scene)
        // ============================================================
        if (e instanceof ProseRefusalError) {
            console.group('STORYBOUND PROSE REFUSAL - SCENE NOT CREATED');
            console.error('Refusal reason:', e.reason);
            console.error('Raw output (first 300 chars):', e.rawOutput?.slice(0, 300));
            console.groupEnd();

            // DO NOT render fallback cover
            // DO NOT call stopCoverLoading (would show book object)
            // DO NOT create scene â€” state.text remains unchanged
            // Hide loading state and return to setup
            const loadingState = document.getElementById('coverLoadingState');
            if (loadingState) loadingState.classList.add('hidden');

            alert("Story generation was declined. Please try different settings.");
            window.showScreen('setup');
            return; // Exit early â€” finally block still runs
        }

        // ============================================================
        // HTTP 429 RATE LIMIT â€” TERMINAL FAILURE, NO RETRY
        // ============================================================
        if (e instanceof RateLimitError || e?.isRateLimit) {
            console.group('STORYBOUND RATE LIMITED - TERMINAL FAILURE');
            console.error('Endpoint:', e.endpoint);
            console.error('Retry-After:', e.retryAfter || 'not specified');
            console.groupEnd();

            // DO NOT render fallback cover
            // DO NOT call stopCoverLoading (would show book object)
            // DO NOT create scene â€” state remains unchanged
            // DO NOT trigger any secondary async calls
            // Hide loading state and return to setup
            const loadingState = document.getElementById('coverLoadingState');
            if (loadingState) loadingState.classList.add('hidden');

            // Surface recoverable error â€” require explicit user action
            alert("Rate limited. Please wait a moment and try again.");
            window.showScreen('setup');
            return; // Exit early â€” finally block still runs
        }

        // Generic API/network errors
        console.group('STORYBOUND FATE STUMBLED - API ERROR');
        console.error('Error object:', e);
        console.error('Error message:', e?.message || '(no message)');
        console.error('Error stack:', e?.stack || '(no stack)');
        console.log('System prompt length at failure:', state.sysPrompt?.length || 0);
        console.log('Intro prompt length at failure:', introPrompt?.length || 0);
        console.groupEnd();

        // Clean up cover page state on error â€” render fallback (never skip)
        renderFallbackCover(state.picks?.world, state.picks?.genre);
        stopCoverLoading(null);

        alert("Fate stumbled. Please try again. (Check console for diagnostics)");
        window.showScreen('setup');
    } finally {
        stopLoading();
        // Deal fresh fate cards for first turn
        if(window.dealFateCards) window.dealFateCards();
        else if(window.initCards) window.initCards();
        // PERMANENT FX REBIND: Ensure fate cards have handlers after story generation
        if (window.initFateCards) window.initFateCards();
        updateBatedBreathState();
    }
    } finally {
      _beginStoryInProgress = false;
    }
  }

  // Expose for internal callers and event delegation
  window.handleBeginStory = handleBeginStory;

  // Delegated click handler: works regardless of corridor mount/unmount timing
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#beginBtn');
    if (!btn) return;
    console.log('[BeginStory:Delegation] Click captured on #beginBtn');
    // Guard: respect disabled state
    if (btn.disabled || btn.classList.contains('disabled') || btn.getAttribute('aria-disabled') === 'true') {
      console.warn('[BeginStory:Delegation] Button is disabled â€” ignoring click');
      return;
    }
    e.preventDefault();
    handleBeginStory();
  });

  // --- API CALLS ---
  /**
   * ==========================================================================
   * STORY GENERATION API CALL
   * ==========================================================================
   *
   * This function routes story generation through the appropriate AI model(s).
   *
   * When ENABLE_ORCHESTRATION is true:
   * - Uses the orchestration client (ChatGPT primary author + optional Grok renderer)
   * - Enforces the canonical call order: ChatGPT â†’ Grok â†’ ChatGPT
   *
   * HARD RULE: Story authoring ONLY uses ChatGPT (PRIMARY_AUTHOR).
   * Grok must NEVER be called for DSP, normalization, veto, or story logic.
   *
   * ==========================================================================
   */
  async function callChat(messages, temp=0.7, options = {}) {
    // LOCKED: Story authoring routes through ChatGPT orchestration ONLY
    if (!window.StoryboundOrchestration) {
      throw new Error('[MODEL WIRING] Orchestration client not loaded. ChatGPT required for story authoring.');
    }

    // SINGLE-FLIGHT LOCK: Only one prose generation at a time
    if (_proseGenerationInFlight) {
      console.warn('[PROSE] Request blocked â€” another prose generation in flight');
      throw new Error('Prose generation blocked: request already in flight');
    }

    _proseGenerationInFlight = true;

    try {
      return await window.StoryboundOrchestration.callChatGPT(
        messages,
        'PRIMARY_AUTHOR',
        { temperature: temp, max_tokens: options.max_tokens || 1000 }
      );
    } catch (orchestrationError) {
      // CHECK FOR HTTP 429 IN ERROR MESSAGE â€” TERMINAL FAILURE
      const errMsg = orchestrationError?.message || '';
      if (errMsg.includes('429') || errMsg.toLowerCase().includes('rate limit') || errMsg.includes('too many requests')) {
        console.error('[RATE_LIMIT] Detected 429 in orchestration error:', errMsg);
        throw new RateLimitError('prose-generation', null);
      }

      // NO GROK FALLBACK - Story authoring must use ChatGPT
      console.error('[MODEL WIRING] ChatGPT failed. No Grok fallback for story logic:', orchestrationError.message);
      throw new Error(`Story generation failed: ${orchestrationError.message}. Grok cannot be used for story authoring.`);
    } finally {
      // RELEASE SINGLE-FLIGHT LOCK
      _proseGenerationInFlight = false;
    }
  }

  /**
   * ==========================================================================
   * ORCHESTRATED TURN GENERATION
   * ==========================================================================
   *
   * Executes the full 3-phase orchestration flow for story generation:
   *
   * PHASE 1: ChatGPT Author Pass (ALWAYS RUNS)
   *   - Plot beats, character psychology, dialogue intent
   *   - Determines if intimacy occurs
   *   - Generates Scene Directive (SD) if needed
   *   - Enforces monetization gates
   *
   * PHASE 2: Specialist Renderer (CONDITIONAL)
   *   - Called ONLY if ESD warrants it (Erotic/Dirty level)
   *   - Receives ONLY the ESD, no plot context
   *   - Renders sensory embodiment within bounds
   *   - NEVER decides outcomes
   *
   * PHASE 3: ChatGPT Integration Pass (ALWAYS RUNS)
   *   - Absorbs rendered scene
   *   - Applies consequences
   *   - Enforces cliffhanger or completion per tier
   *   - FINAL AUTHORITY on story state
   *
   * FAILURE HANDLING:
   *   - Renderer failure does NOT corrupt story state
   *   - ChatGPT regains control on failure
   *   - Fate Stumbled may be triggered
   *
   * ==========================================================================
   */
  async function generateOrchestatedTurn(params) {
    const {
      systemPrompt,
      storyContext,
      playerAction,
      playerDialogue,
      fateCard,
      mainPairRestricted,
      onPhaseChange
    } = params;

    // Check if orchestration is available
    if (!window.StoryboundOrchestration) {
      console.warn('[ORCHESTRATION] Client not available, using legacy flow');
      // Fall back to legacy single-model call
      const messages = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: `Action: ${playerAction}\nDialogue: "${playerDialogue}"` }
      ];
      return await callChat(messages, 0.7, { bypassOrchestration: true });
    }

    // Execute full orchestration flow
    const result = await window.StoryboundOrchestration.orchestrateStoryGeneration({
      accessTier: state.access || 'free',
      storyContext: storyContext,
      playerAction: playerAction,
      playerDialogue: playerDialogue,
      fateCard: fateCard,
      mainPairRestricted: !!mainPairRestricted,
      systemPrompt: systemPrompt,
      onPhaseChange: onPhaseChange
    });

    // Log orchestration details
    console.log('[ORCHESTRATION] Turn complete:', {
      success: result.success,
      rendererUsed: result.rendererUsed,
      fateStumbled: result.fateStumbled,
      gateEnforcement: result.gateEnforcement,
      timing: result.timing,
      errors: result.errors
    });

    // Handle Fate Stumbled
    if (result.fateStumbled) {
      console.warn('[ORCHESTRATION] Fate Stumbled - specialist renderer failed');
      // Story continues with author output only
    }

    if (!result.success && result.errors.length > 0) {
      console.error('[ORCHESTRATION] Errors:', result.errors);
    }

    return result.finalOutput;
  }

  // Setting shot uses unified IMAGE PROVIDER ROUTER with landscape shape
  // Book cover / world-establishing illustration (NOT scene illustration)
  // TASK G: Ensure setting shot always reaches image generation
  async function generateSettingShot(desc) {
     _lastSettingShotDesc = desc; // Store for retry
     const img = document.getElementById('settingShotImg');
     const errDiv = document.getElementById('settingError');
     // TASK G: Log if DOM element missing (not silent gate)
     if(!img) {
         console.warn('[SettingShot] settingShotImg element not found - cannot render');
         return;
     }
     const wrap = document.getElementById('settingShotWrap');
     if(wrap) wrap.style.display = 'flex';
     img.onload = null; img.onerror = null;
     img.style.display = 'none';
     if(errDiv) {
         errDiv.textContent = 'Conjuring the scene...';
         errDiv.classList.remove('hidden');
         errDiv.style.color = 'var(--gold)';
     }

     // WORLD-FIRST PROMPT: Environment description, NOT characters/actions
     // Strip any intensity/quality/erotic language (PG-13/R mood only)
     const sanitizeForCover = (text) => {
         return text
             .replace(/\bINTENSITY:.*?(?=\n|$)/gi, '')
             .replace(/\bQUALITY:.*?(?=\n|$)/gi, '')
             .replace(/\b(sensual|erotic|nude|naked|explicit|sexual|intimate|seductive|provocative|lustful|aroused|passionate)\b/gi, '')
             .replace(/\s+/g, ' ')
             .trim();
     };

     // Cap at 256 chars without cutting mid-sentence
     const capWorldDesc = (text, maxLen = 256) => {
         const clean = sanitizeForCover(text);
         if (clean.length <= maxLen) return clean;
         const truncated = clean.substring(0, maxLen);
         const lastPeriod = truncated.lastIndexOf('.');
         const lastComma = truncated.lastIndexOf(',');
         const cutPoint = Math.max(lastPeriod, lastComma);
         return cutPoint > maxLen * 0.5 ? truncated.substring(0, cutPoint + 1).trim() : truncated.trim();
     };

     const worldDesc = capWorldDesc(desc);

     // Route through canonical setting visualize prompt
     const visualizeMode = 'setting';
     const settingPromptBase = buildVisualizePrompt({ mode: visualizeMode, lastText: '' });
     let prompt = settingPromptBase + '\n\n' + worldDesc;

     // VISUAL INTENT GUARD: Enforce balanced lighting for settings
     prompt = applyVisualIntentGuard(prompt, {
         tone: state.picks?.tone,
         world: state.picks?.world,
         intensity: state.intensity
     });

     let rawUrl = null;

     // Use unified IMAGE PROVIDER ROUTER with FALLBACK CHAIN
     // Setting shots use intent='setting' for Gemini primary â†’ OpenAI fallback
     try {
         rawUrl = await generateImageWithFallback({
             prompt: prompt,
             tier: 'Clean',
             shape: 'landscape',
             context: 'setting-shot',
             intent: 'setting'
         });
     } catch(e) {
         // All providers failed - logged by generateImageWithFallback
         console.warn('Setting shot: all providers exhausted', e.message);
     }

     if(rawUrl) {
         let imageUrl = rawUrl;
         if(!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
             imageUrl = `data:image/png;base64,${rawUrl}`;
         }
         img.src = imageUrl;

         // Add timeout for image load
         const loadTimeout = setTimeout(() => {
             img.style.display = 'none';
             if(errDiv) {
                 errDiv.innerHTML = 'The scene resists capture... <button onclick="window.retrySettingShot()" style="margin-left:10px; background:var(--gold); color:black; padding:5px 10px; border:none; border-radius:4px; cursor:pointer;">Retry</button>';
                 errDiv.style.color = '#ff6b6b';
                 errDiv.classList.remove('hidden');
             }
         }, 30000);

         img.onload = () => {
             clearTimeout(loadTimeout);
             img.style.display = 'block';
             if(errDiv) errDiv.classList.add('hidden');
         };
         img.onerror = () => {
             clearTimeout(loadTimeout);
             img.style.display = 'none';
             if(errDiv) {
                 errDiv.innerHTML = 'The scene resists capture... <button onclick="window.retrySettingShot()" style="margin-left:10px; background:var(--gold); color:black; padding:5px 10px; border:none; border-radius:4px; cursor:pointer;">Retry</button>';
                 errDiv.style.color = '#ff6b6b';
                 errDiv.classList.remove('hidden');
             }
         };
     } else {
         // All providers failed: non-blocking placeholder, story continues
         if(errDiv) {
             errDiv.innerHTML = 'The scene resists capture... <button onclick="window.retrySettingShot()" style="margin-left:10px; background:var(--gold); color:black; padding:5px 10px; border:none; border-radius:4px; cursor:pointer;">Retry</button>';
             errDiv.style.color = '#ff6b6b';
             errDiv.classList.remove('hidden');
         }
         // Story continues normally - no toast, no blocking
     }
  }

  window.retrySettingShot = function() {
      if (_lastSettingShotDesc) {
          generateSettingShot(_lastSettingShotDesc);
      }
  };

  // ============================================================
  // BOOK SCENE ART â€” Inline setting image for Scene 1 (page 2)
  // Distinct asset from cover. Uses imageIntent='setting'.
  // MUST render INLINE within scene content, NEVER fullscreen.
  // MUST NOT run on COVER (page 0) or INSIDE_COVER (page 1).
  // ============================================================
  async function generateBookSceneArt(synopsis) {
      // GUARD: Setting image is ONLY for Scene pages (page 2+)
      // Never generate for cover or inside cover
      console.log('[DEBUG PAGE STATE] generateBookSceneArt: _bookPageIndex=', _bookPageIndex);

      const sceneImg = document.getElementById('bookSceneImg');
      const loadingEl = document.getElementById('bookSceneLoading');
      console.log('[BookScene:DEBUG] ENTRY', {
          coverMode: state.coverMode,
          PHASE_1_FORGED: state.coverMode === 'PHASE_1_FORGED',
          sceneImgId: sceneImg?.id || null,
          sceneImgSrc: sceneImg?.src || null,
          sceneImgDisplay: sceneImg?.style?.display || null,
          loadingElId: loadingEl?.id || null,
          settingPlateId: document.getElementById('settingPlate')?.id || null
      });
      if (!sceneImg) {
          console.warn('[BookScene:DEBUG] EARLY_RETURN: bookSceneImg element not found');
          return;
      }

      const world = state.picks?.world || 'Modern';
      const era = state.picks?.world === 'Historical' ? (state.picks?.era || 'Medieval') : null;
      const worldLabel = era ? `${era} ${world}` : world;

      // Build a concise world-establishing description (symbolic only â€” no story prose)
      const tone = state.picks?.tone || 'Earnest';
      const desc = `${worldLabel} world. ${tone} atmosphere. A dramatic setting.`;

      let vistaPrompt = `${desc}

CRITICAL COMPOSITION RULES:
- This MUST be a WORLD VISTA image: landscape, environment, establishing shot.
- If ANY human figure appears, they MUST be facing AWAY, silhouette only.
- ABSOLUTELY FORBIDDEN: Portraits, faces, character close-ups, romantic poses.
- Camera position: Wide establishing shot, epic scale, environment is the subject.

Wide cinematic environment, atmospheric lighting, painterly illustration, no text, no watermark.`;

      // VISUAL INTENT GUARD: Enforce balanced lighting for scene art
      vistaPrompt = applyVisualIntentGuard(vistaPrompt, {
          tone: state.picks?.tone,
          world: state.picks?.world,
          intensity: state.intensity
      });

      try {
          const rawUrl = await generateImageWithFallback({
              prompt: vistaPrompt,
              tier: 'Clean',
              shape: 'landscape',
              context: 'book-scene-art',
              intent: 'setting'
          });
          console.log('[BookScene:DEBUG] AFTER_generateImageWithFallback', {
              rawUrl: rawUrl ? (rawUrl.substring(0, 50) + '...') : null,
              rawUrlType: rawUrl ? (rawUrl.startsWith('http') ? 'http' : rawUrl.startsWith('data:') ? 'data' : rawUrl.startsWith('blob:') ? 'blob' : 'base64') : 'null',
              failureReason: rawUrl ? null : 'generateImageWithFallback returned null'
          });

          if (rawUrl) {
              let imageUrl = rawUrl;
              if (!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
                  imageUrl = `data:image/png;base64,${rawUrl}`;
              }
              sceneImg.src = imageUrl;
              console.log('[BookScene:DEBUG] DOM_APPLIED', {
                  targetElement: 'bookSceneImg',
                  srcSet: imageUrl.substring(0, 50) + '...',
                  sceneImgId: sceneImg.id
              });
              sceneImg.onload = () => {
                  // GUARD: Setting images must render INLINE, never fullscreen
                  // Setting plate should have 'setting-inline' class when on scene page
                  const settingPlate = document.getElementById('settingPlate');
                  if (settingPlate && sceneImg.closest('#settingPlate')) {
                      // Ensure inline mode (not fullscreen)
                      settingPlate.classList.add('setting-inline');
                      settingPlate.classList.remove('setting-active'); // Remove any fullscreen class
                      // WRY CONFESSIONAL INSET: Apply reduced-scale inset styling
                      // When tone is Wry Confessional, images render at 40-60% column width
                      // centered as block elements (no floats, no text wrapping)
                      if (state.picks?.tone === 'Wry Confessional') {
                          settingPlate.classList.add('wry-confession-inset');
                      } else {
                          settingPlate.classList.remove('wry-confession-inset');
                      }
                      sceneImg.style.display = 'block';
                      if (loadingEl) loadingEl.style.display = 'none';
                      // PAGE-CURL: If no frontispiece active (non-Fantasy, or after map dismissed),
                      // activate setting plate as a curl page so it curls to reveal scene text
                      if (!window._titlePageActive && !window._frontispieceActive && !window._settingPlateActive) {
                          showSettingPlateAsCurlPage();
                      }
                      console.log('[BookScene:DEBUG] IMAGE_LOADED', { display: sceneImg.style.display, mountPath: 'settingPlate', mode: 'inline' });
                  } else {
                      // ABORT: Setting image mounted in wrong container
                      console.error('[BookScene:GUARD] Setting image not in settingPlate - aborting display');
                      sceneImg.style.display = 'none';
                  }
              };
              sceneImg.onerror = () => {
                  console.warn('[BookScene] Image failed to load');
                  if (loadingEl) loadingEl.textContent = '';
              };
          } else {
              // Generation failed â€” hide loading text silently
              if (loadingEl) loadingEl.textContent = '';
          }
      } catch (err) {
          console.warn('[BookScene] Generation failed:', err.message);
          if (loadingEl) loadingEl.textContent = '';
      }
  }

  // ============================================================
  // BOOK COVER PAGE SYSTEM
  // Staged loading â†’ Cover generation â†’ Page-turn reveal
  // ============================================================

  const COVER_CRAFT_PHRASES = [
      "Building your book cover...",
      "Selecting an artist...",
      "Composing the scene...",
      "Choosing the typography...",
      "Applying finishing touches...",
      "Binding the pages..."
  ];

  let _coverPhraseIndex = 0;
  let _coverPhraseInterval = null;
  let _coverProgressInterval = null;
  let _coverAbortController = null;

  // Abort cover generation â€” render fallback cover (never skip)
  function abortCoverGeneration() {
      if (_coverAbortController) {
          _coverAbortController.abort();
          _coverAbortController = null;
      }
      renderFallbackCover(state.picks?.world, state.picks?.genre);
      stopCoverLoading(null);
  }

  // ============================================================
  // LOADING BAR SPARKLE EMITTER (SCOPED TO PROGRESS BARS ONLY)
  // Localized sparkle system for loading/progress indicators
  // Does NOT affect Fate, DSP, or other global sparkle systems
  // ============================================================
  let _loadingSparkleInterval = null;

  function spawnLoadingSparkle(container) {
      if (!container) return;

      const containerWidth = container.offsetWidth;
      const containerHeight = container.offsetHeight;
      if (containerWidth === 0) return;

      const sparkle = document.createElement('div');
      sparkle.className = 'loading-sparkle';

      // Random spawn position along and around the bar
      const spawnX = Math.random() * containerWidth;
      const spawnY = (Math.random() - 0.5) * 16 - 4; // Close to bar

      // Gentle wandering â€” mostly lateral with mild upward drift
      const angle = (Math.random() * 360) * (Math.PI / 180); // Any direction
      const distance = 6 + Math.random() * 14; // Short drift
      const dx = Math.cos(angle) * distance;
      const dy = Math.sin(angle) * distance * 0.5 - 4 - Math.random() * 6; // Mild upward bias

      // Wobble for organic motion
      const wobble = (Math.random() - 0.5) * 8;

      // Size and timing variance â€” slower, more leisurely
      const size = 2 + Math.random() * 3;
      const duration = 4000 + Math.random() * 3000;
      const opacity = 0.4 + Math.random() * 0.35;

      sparkle.style.cssText = `
          left: ${spawnX}px;
          top: ${spawnY}px;
          width: ${size}px;
          height: ${size}px;
          --ls-duration: ${duration}ms;
          --ls-opacity: ${opacity};
          --ls-dx: ${dx}px;
          --ls-dy: ${dy}px;
          --ls-wobble: ${wobble}px;
      `;

      container.appendChild(sparkle);
      setTimeout(() => { if (sparkle.parentNode) sparkle.remove(); }, duration + 100);
  }

  function startLoadingBarSparkles() {
      stopLoadingBarSparkles(); // Clear any existing

      const progressBar = document.querySelector('.cover-progress-bar');
      if (!progressBar) return;

      // Ensure container is positioned for absolute children
      const style = window.getComputedStyle(progressBar);
      if (style.position === 'static') {
          progressBar.style.position = 'relative';
      }

      // Spawn sparkles at relaxed intervals for gentle density
      _loadingSparkleInterval = setInterval(() => {
          spawnLoadingSparkle(progressBar);
      }, 400); // ~2-3 sparkles per second

      // Initial seeds â€” staggered for natural appearance
      for (let i = 0; i < 3; i++) {
          setTimeout(() => spawnLoadingSparkle(progressBar), i * 200);
      }
  }

  function stopLoadingBarSparkles() {
      if (_loadingSparkleInterval) {
          clearInterval(_loadingSparkleInterval);
          _loadingSparkleInterval = null;
      }
      // Fade out existing sparkles gracefully
      document.querySelectorAll('.loading-sparkle').forEach(s => {
          s.style.opacity = '0';
          s.style.transition = 'opacity 0.3s ease-out';
          setTimeout(() => s.remove(), 350);
      });
  }

  // Start cover loading UI with staged phrases
  function startCoverLoading() {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”´ MINIMAL COVER v1 â€” SIMPLIFIED LOADING (no timers, no sparkles)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (USE_MINIMAL_COVER_V1) {
          console.log('[COVER:v1] Minimal loading UI â€” no phrase rotation, no sparkles');
          const loadingState = document.getElementById('coverLoadingState');
          const revealState = document.getElementById('coverRevealState');
          const statusText = document.getElementById('coverStatusText');

          if (loadingState) loadingState.classList.remove('hidden');
          if (revealState) revealState.classList.add('hidden');
          if (statusText) statusText.textContent = 'Generating cover...';
          return; // No timers, no sparkles, no abort controller
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Create new abort controller for this generation
      _coverAbortController = new AbortController();

      // Wire up abort button
      const abortBtn = document.getElementById('coverAbortBtn');
      if (abortBtn) {
          abortBtn.onclick = abortCoverGeneration;
      }
      const loadingState = document.getElementById('coverLoadingState');
      const revealState = document.getElementById('coverRevealState');
      const statusText = document.getElementById('coverStatusText');
      const progressFill = document.getElementById('coverProgressFill');

      if (loadingState) loadingState.classList.remove('hidden');
      if (revealState) revealState.classList.add('hidden');

      _coverPhraseIndex = 0;
      if (statusText) statusText.textContent = COVER_CRAFT_PHRASES[0];

      // Rotate through phrases every 3 seconds
      _coverPhraseInterval = setInterval(() => {
          _coverPhraseIndex = (_coverPhraseIndex + 1) % COVER_CRAFT_PHRASES.length;
          if (statusText) statusText.textContent = COVER_CRAFT_PHRASES[_coverPhraseIndex];
      }, 3000);

      // Progress bar animation (fake progress up to 90%)
      let progress = 0;
      if (progressFill) progressFill.style.width = '0%';
      _coverProgressInterval = setInterval(() => {
          progress += Math.random() * 8;
          if (progress > 90) progress = 90;
          if (progressFill) progressFill.style.width = progress + '%';
      }, 500);

      // Start loading bar sparkles (localized emitter)
      startLoadingBarSparkles();
  }

  // Stop cover loading and show physical book object
  function stopCoverLoading(coverUrl) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”´ MINIMAL COVER v1 â€” SIMPLIFIED STOP (no timer cleanup needed)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (USE_MINIMAL_COVER_V1) {
          console.log('[COVER:v1] Minimal loading complete');
          const loadingState = document.getElementById('coverLoadingState');
          const bookObject = document.getElementById('bookObject');
          const coverImg = document.getElementById('bookCoverImg');

          if (loadingState) loadingState.classList.add('hidden');
          if (bookObject) bookObject.classList.remove('hidden');
          if (coverImg && coverUrl) coverImg.src = coverUrl;

          // âœ… Do NOT auto-advance off COVER
          // Cover waits for explicit user interaction
          console.log('[COVER:v1] Cover displayed â€” awaiting user interaction to advance');

          return;
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      if (_coverPhraseInterval) clearInterval(_coverPhraseInterval);
      if (_coverProgressInterval) clearInterval(_coverProgressInterval);

      // Stop loading bar sparkles
      stopLoadingBarSparkles();

      const loadingState = document.getElementById('coverLoadingState');
      const bookObject = document.getElementById('bookObject');
      const coverImg = document.getElementById('bookCoverImg');
      const progressFill = document.getElementById('coverProgressFill');
      const bookmarkRibbon = document.getElementById('bookmarkRibbon');

      // Complete progress bar
      if (progressFill) progressFill.style.width = '100%';

      setTimeout(() => {
          if (loadingState) loadingState.classList.add('hidden');
          if (bookObject) bookObject.classList.remove('hidden');
          if (coverImg && coverUrl) {
              coverImg.src = coverUrl;
          }

          // Show bookmark if returning reader
          if (bookmarkRibbon && state.turnCount > 0) {
              bookmarkRibbon.classList.remove('hidden');
          }

          // Start courtesy hinge timer (one-time only)
          scheduleCourtesyHinge();
      }, 500);
  }

  // ============================================================
  // COVER INTELLIGENCE SYSTEM
  // Focal object extraction, anti-repetition, domain backgrounds, palette
  // ============================================================

  const COVER_MOTIF_STORAGE_KEY = 'storybound_cover_motifs';
  const MAX_MOTIF_HISTORY = 5;

  // Object class groupings for anti-repetition (same class = repetition)
  const OBJECT_CLASSES = {
      jewelry: ['ring', 'necklace', 'bracelet', 'pendant', 'locket', 'brooch', 'crown', 'tiara'],
      keys: ['key', 'keyring', 'skeleton key', 'antique key', 'golden key'],
      letters: ['letter', 'envelope', 'note', 'scroll', 'document', 'contract', 'deed'],
      flowers: ['rose', 'flower', 'bouquet', 'petal', 'lily', 'orchid', 'wildflower'],
      weapons: ['dagger', 'sword', 'knife', 'gun', 'pistol', 'blade'],
      vessels: ['wine glass', 'goblet', 'cup', 'bottle', 'vial', 'chalice'],
      timepieces: ['watch', 'clock', 'hourglass', 'pocket watch', 'sundial'],
      books: ['book', 'diary', 'journal', 'tome', 'manuscript', 'ledger'],
      masks: ['mask', 'masquerade mask', 'venetian mask', 'domino mask'],
      doors: ['door', 'gate', 'portal', 'archway', 'threshold']
  };

  // Color families for anti-repetition
  const COLOR_FAMILIES = {
      warm: ['red', 'orange', 'gold', 'amber', 'copper', 'bronze', 'rust', 'burgundy', 'crimson'],
      cool: ['blue', 'teal', 'cyan', 'navy', 'sapphire', 'cobalt', 'azure', 'indigo'],
      earth: ['brown', 'tan', 'sienna', 'umber', 'chocolate', 'mahogany', 'sepia'],
      jewel: ['emerald', 'purple', 'violet', 'amethyst', 'ruby', 'jade'],
      neutral: ['black', 'white', 'grey', 'gray', 'silver', 'charcoal', 'ivory'],
      nature: ['green', 'forest', 'olive', 'moss', 'sage', 'hunter']
  };

  // ============================================================
  // POWER ROLE TRANSMUTATION
  // Resolves genre labels into world-appropriate power roles.
  // Prevents anachronistic concepts from propagating to prompts.
  // Rollback: replace all resolvePowerRole() calls with raw genre
  // ============================================================
  function resolvePowerRole(world, era, genre) {
      if (genre !== 'Billionaire') return genre;
      if (world === 'Modern') return 'Capital Magnate';
      if (world === 'Historical') {
          if (era === 'Renaissance') return 'Merchant Prince';
          if (era === 'Roman') return 'Imperium Holder';
          return 'Sovereign'; // Medieval and default Historical
      }
      if (world === 'Prehistoric') return 'Clan Alpha';
      if (world === 'Fantasy') return 'Arcane Sovereign';
      if (world === 'SciFi') return 'Technocratic Hegemon';
      return genre; // unknown world fallback
  }

  // ============================================================
  // POWER FRAME RESOLUTION
  // Maps genre labels to world-appropriate narrative frames.
  // Broader than resolvePowerRole (which handles Billionaire only).
  // Modern worlds pass through unchanged.
  // Rollback: remove resolvePowerFrame() calls, use raw genre
  // ============================================================
  function resolvePowerFrame(world, genre) {
      if (world === 'Modern') return genre;

      // Non-Modern generic frame transmutation
      if (genre === 'Billionaire') return 'Ruler';
      if (genre === 'Crime Syndicate') return 'Faction';
      if (genre === 'Sports') return 'Ritual Contest';

      // Prehistoric-specific transmutations
      if (world === 'Prehistoric') {
          if (genre === 'Mafia') return 'Tribal Enforcer';
          if (genre === 'Military') return 'War Leader';
      }

      return genre; // default pass-through
  }

  // Background patterns by domain
  const DOMAIN_BACKGROUNDS = {
      // World-based
      Modern: ['geometric glass patterns', 'city skyline silhouette', 'neon reflections on wet pavement', 'modernist architecture lines'],
      Historical: ['aged parchment texture', 'heraldic filigree', 'candlelit stone walls', 'tapestry weave pattern'],
      Fantasy: ['magical runes glowing', 'starfield with constellations', 'enchanted forest mist', 'crystalline formations'],
      SciFi: ['holographic grid', 'star map', 'circuit board traces', 'nebula swirls', 'spacecraft hull panels'],
      // Genre-based
      CrimeSyndicate: ['smoke wisps', 'playing cards scattered', 'city noir shadows', 'venetian blind slats'],
      Billionaire: ['marble texture', 'champagne bubbles', 'stock ticker lines', 'crystal chandelier reflections'],
      Noir: ['rain-streaked window', 'venetian blind shadows', 'cigarette smoke trails', 'foggy streetlamp halos'],
      Heist: ['vault door mechanism', 'blueprint lines', 'laser grid', 'scattered diamonds'],
      Espionage: ['redacted document', 'surveillance static', 'crosshairs overlay', 'encrypted text streams'],
      Political: ['marble columns', 'seal embossing', 'flag fabric folds', 'courtroom wood grain'],
      Escape: ['broken chains', 'open road horizon', 'shattered glass', 'fading footprints'],
      Redemption: ['sunrise gradient', 'phoenix feathers', 'cracked mirror healing', 'emerging from shadow'],
      BuildingBridges: ['interlocking hands silhouette', 'bridge architecture', 'puzzle pieces', 'woven threads'],
      Purgatory: ['fog layers', 'liminal doorways', 'clock faces overlapping', 'fading photographs'],
      RelentlessPast: ['cracked photographs', 'faded newspaper', 'chains and shadows', 'footsteps in dust'],
      Sports: ['stadium lights', 'scoreboard glow', 'trophy shelf', 'field markings', 'crowd silhouettes'],
      Survival: ['cracked earth', 'sparse rations', 'barren landscape', 'weathered hands', 'distant smoke'],
      Obsession: ['pinboard with strings', 'circled photographs', 'repeated patterns', 'sleepless light', 'worn edges'],
      ForbiddenKnowledge: ['ancient tome', 'glowing sigils', 'eye in shadow', 'forbidden archive', 'sealed door']
  };

  // Palette by tone + common material affinities
  const TONE_PALETTES = {
      Earnest: { primary: 'warm gold', secondary: 'deep burgundy', accent: 'ivory' },
      Angsty: { primary: 'stormy blue', secondary: 'bruised purple', accent: 'lightning silver' },
      Campy: { primary: 'hot pink', secondary: 'electric blue', accent: 'gold glitter' },
      Gritty: { primary: 'charcoal', secondary: 'rust', accent: 'dried blood red' },
      Tender: { primary: 'blush pink', secondary: 'soft lavender', accent: 'pearl white' },
      Steamy: { primary: 'deep red', secondary: 'black velvet', accent: 'gold shimmer' },
      Brooding: { primary: 'midnight blue', secondary: 'storm grey', accent: 'moonlight silver' },
      Playful: { primary: 'coral', secondary: 'turquoise', accent: 'sunshine yellow' }
  };

  // Material-based palette adjustments
  const MATERIAL_PALETTES = {
      metal: { shift: 'silver/steel highlights' },
      gold: { shift: 'warm gold, amber glow' },
      glass: { shift: 'cool reflections, prismatic edges' },
      paper: { shift: 'cream, sepia, aged yellow' },
      fabric: { shift: 'rich textile colors, soft shadows' },
      stone: { shift: 'grey, moss green, weathered' },
      wood: { shift: 'warm brown, grain patterns' },
      crystal: { shift: 'prismatic, ice blue, diamond sparkle' }
  };

  // Get object class for anti-repetition check
  function getObjectClass(object) {
      const lower = object.toLowerCase();
      for (const [cls, items] of Object.entries(OBJECT_CLASSES)) {
          if (items.some(item => lower.includes(item))) return cls;
      }
      return lower; // Use object itself as unique class
  }

  // Get color family for anti-repetition check
  function getColorFamily(color) {
      const lower = color.toLowerCase();
      for (const [family, colors] of Object.entries(COLOR_FAMILIES)) {
          if (colors.some(c => lower.includes(c))) return family;
      }
      return 'neutral'; // Default
  }

  // ISSUE 2 FIX: Abstraction ladder for true object substitution on repetition
  // object â†’ trace â†’ environment â†’ absence (NEVER reuse same object class)
  const ABSTRACTION_LADDER = {
      communication: [
          'torn paper fragments scattered in gutter',
          'wax seal imprint on empty desk',
          'indentation in wood where something once lay',
          'negative space shaped like absence'
      ],
      jewelry: [
          'velvet impression where ring once sat',
          'empty jewelry box with worn hinge',
          'faint mark on skin where band was worn',
          'dusty display case, bare'
      ],
      weapons: [
          'blade-shaped shadow on wall',
          'notch in doorframe from impact',
          'empty sheath, leather cracked',
          'rust stain in shape of what was'
      ],
      keys: [
          'worn keyhole, brass darkened',
          'ring of dust where keys hung',
          'lock mechanism exposed, no key',
          'chain with empty clasp'
      ],
      timepieces: [
          'sundial with no shadow',
          'clock face with missing hands',
          'hourglass with sand frozen',
          'empty pocket, fob chain dangling'
      ],
      containers: [
          'lid without its vessel',
          'rim impression in dust',
          'empty shelf with object outline',
          'spilled contents, vessel gone'
      ],
      flora: [
          'pressed flower stain on page',
          'empty vase with dried water ring',
          'petal impression in wax',
          'barren stem, bloom fallen'
      ],
      light_sources: [
          'smoke trail where flame was',
          'wax pool, wick drowned',
          'soot pattern on ceiling',
          'match head, spent and dark'
      ],
      documents: [
          'ink blot bleeding through blank page',
          'creased paper, text faded to nothing',
          'fountain pen dry on empty desk',
          'typewriter ribbon exhausted'
      ]
  };

  // Get abstraction substitution for repeated object class
  function getAbstractionSubstitute(objectClass, usedSubstitutes = []) {
      const ladder = ABSTRACTION_LADDER[objectClass];
      if (!ladder) {
          // No predefined ladder - use generic absence
          return 'empty space where something meaningful once was';
      }

      // Find unused substitution
      const available = ladder.filter(s => !usedSubstitutes.includes(s));
      if (available.length > 0) {
          return available[Math.floor(Math.random() * available.length)];
      }

      // All used - return highest abstraction (absence)
      return ladder[ladder.length - 1];
  }

  // Load motif history from localStorage
  function loadMotifHistory() {
      try {
          const stored = localStorage.getItem(COVER_MOTIF_STORAGE_KEY);
          return stored ? JSON.parse(stored) : [];
      } catch (e) {
          return [];
      }
  }

  // Save motif to history
  function saveMotifToHistory(motif) {
      try {
          const history = loadMotifHistory();
          history.unshift(motif);
          if (history.length > MAX_MOTIF_HISTORY) history.pop();
          localStorage.setItem(COVER_MOTIF_STORAGE_KEY, JSON.stringify(history));
      } catch (e) {
          // localStorage unavailable
      }
  }

  // Check if motif would repeat recent covers
  function wouldRepeatMotif(objectClass, colorFamily, backgroundStyle) {
      const history = loadMotifHistory();
      if (history.length === 0) return { repeats: false };

      const lastMotif = history[0];
      const repeats = {
          object: history.some(m => m.objectClass === objectClass),
          color: history.some(m => m.colorFamily === colorFamily),
          background: history.some(m => m.backgroundStyle === backgroundStyle),
          artDeco: backgroundStyle === 'art-deco' && lastMotif.backgroundStyle === 'art-deco'
      };

      return {
          repeats: repeats.object || repeats.color || repeats.artDeco,
          details: repeats
      };
  }

  // Extract focal anchor and emotional gravity from synopsis (AUTHORITATIVE)
  async function extractFocalObject(synopsis, genre, world, tone) {
      // Default fallback for minimal synopsis
      if (!synopsis || synopsis.length < 20) {
          return {
              object: 'antique key',
              material: 'metal',
              emotion: 'mystery',
              humanFigure: 'none',
              reason: 'default'
          };
      }

      // Derive emotional gravity from tone if not extracted
      const TONE_TO_EMOTION = {
          Earnest: 'yearning',
          WryConfession: 'tension',
          Dark: 'foreboding',
          Mythic: 'inevitability'
      };

      try {
          const extraction = await callChat([{
              role: 'user',
              content: `Extract cover elements for a SYMBOLIC book cover (not scene illustration).

SYNOPSIS: "${synopsis}"
GENRE: ${genre}
WORLD: ${world}

DECISIONS NEEDED:

1. EMOTIONAL GRAVITY (choose ONE): foreboding, yearning, pressure, secrecy, rebellion, inevitability, longing, tension, mystery, isolation, devotion, betrayal

2. FOCAL ANCHOR (choose ONE physical object or symbol mentioned/implied):
   - Must be CONCRETE, not abstract
   - NEVER: envelope, generic rose, book, candle, heart shape
   - Prefer objects with story-specific meaning

3. HUMAN FIGURE decision:
   - "none" - object/environment carries meaning
   - "silhouette" - figure as shadow/shape only
   - "turned_away" - figure facing away, no face visible
   - "partial" - hands, shoulders, or fragment only

4. THEMATIC TENSION (ONE short clause, max 6 words):
   - Must capture story's central conflict/irony
   - NOT a scene description
   - NOT a metaphor explanation
   - Example forms: "control masking chaos", "intimacy through surveillance"

Return ONLY valid JSON:
{
  "object": "the focal object/symbol",
  "material": "metal|paper|glass|fabric|stone|wood|crystal|gold",
  "emotion": "the dominant emotional gravity",
  "humanFigure": "none|silhouette|turned_away|partial",
  "thematicTension": "single clause capturing narrative tension",
  "reason": "brief justification"
}`
          }]);

          // Strip markdown fences if present (```json ... ``` or ``` ... ```)
          let cleanedExtraction = extraction.trim();
          if (cleanedExtraction.startsWith('```')) {
              // Remove opening fence (```json or ```)
              cleanedExtraction = cleanedExtraction.replace(/^```(?:json)?\s*\n?/, '');
              // Remove closing fence
              cleanedExtraction = cleanedExtraction.replace(/\n?```\s*$/, '');
          }
          const parsed = JSON.parse(cleanedExtraction.trim());
          if (parsed.object && parsed.emotion) {
              return parsed;
          }
      } catch (e) {
          console.warn('[CoverIntel] Focal extraction failed:', e.message);
      }

      // Fallback: genre-based default objects with emotion
      const GENRE_DEFAULTS = {
          CrimeSyndicate: { object: 'bloodstained playing card', material: 'paper', emotion: 'foreboding' },
          Billionaire: { object: 'crystal champagne flute', material: 'crystal', emotion: 'pressure' },
          Noir: { object: 'smoldering cigarette trailing smoke', material: 'paper', emotion: 'tension' },
          Heist: { object: 'diamond catching spotlight', material: 'crystal', emotion: 'tension' },
          Espionage: { object: 'torn passport page', material: 'paper', emotion: 'secrecy' },
          Political: { object: 'broken wax seal', material: 'metal', emotion: 'betrayal' },
          Escape: { object: 'shattered chain link', material: 'metal', emotion: 'rebellion' },
          Redemption: { object: 'phoenix feather in ash', material: 'gold', emotion: 'transformation' },
          BuildingBridges: { object: 'two hands almost touching', material: 'fabric', emotion: 'yearning' },
          Purgatory: { object: 'stopped clock face', material: 'metal', emotion: 'isolation' },
          RelentlessPast: { object: 'cracked photograph edge', material: 'paper', emotion: 'foreboding' },
          Sports: { object: 'trophy silhouette in spotlight', material: 'gold', emotion: 'pressure' },
          Survival: { object: 'last match in weathered box', material: 'wood', emotion: 'tension' },
          Obsession: { object: 'pinboard thread stretching taut', material: 'fabric', emotion: 'foreboding' },
          ForbiddenKnowledge: { object: 'opened tome with glowing page', material: 'paper', emotion: 'mystery' }
      };

      const fallback = GENRE_DEFAULTS[genre] || {
          object: 'antique key',
          material: 'metal',
          emotion: TONE_TO_EMOTION[tone] || 'mystery'
      };
      fallback.humanFigure = 'none';
      fallback.thematicTension = null; // No story awareness in fallback
      fallback.reason = 'fallback';

      return fallback;
  }

  // Derive background pattern from domain (genre + world)
  function deriveBackgroundPattern(genre, world, history) {
      // Collect candidates from both genre and world
      const genrePatterns = DOMAIN_BACKGROUNDS[genre] || [];
      const worldPatterns = DOMAIN_BACKGROUNDS[world] || [];
      const allPatterns = [...new Set([...genrePatterns, ...worldPatterns])];

      if (allPatterns.length === 0) {
          // Art-deco is fallback only
          return 'subtle gradient with abstract shapes';
      }

      // Filter out recently used patterns
      const recentBackgrounds = history.map(m => m.backgroundStyle);
      const available = allPatterns.filter(p => !recentBackgrounds.includes(p));

      // If all patterns used recently, reset but avoid art-deco twice in a row
      if (available.length === 0) {
          const lastBg = history[0]?.backgroundStyle;
          return allPatterns.find(p => p !== lastBg) || allPatterns[0];
      }

      // Random selection from available
      return available[Math.floor(Math.random() * available.length)];
  }

  // Derive palette from tone + object material
  function derivePalette(tone, material, history) {
      const basePalette = TONE_PALETTES[tone] || TONE_PALETTES.Earnest;
      const materialShift = MATERIAL_PALETTES[material]?.shift || '';

      // Check if palette would repeat
      const colorFamily = getColorFamily(basePalette.primary);
      const recentFamilies = history.map(m => m.colorFamily);

      // If color family repeats, shift to complementary
      let finalPalette = { ...basePalette };
      if (recentFamilies.includes(colorFamily)) {
          const SHIFTS = {
              warm: { primary: 'cool sapphire', secondary: 'deep teal' },
              cool: { primary: 'warm amber', secondary: 'burgundy' },
              earth: { primary: 'jewel emerald', secondary: 'amethyst' },
              jewel: { primary: 'neutral silver', secondary: 'charcoal' },
              neutral: { primary: 'jewel ruby', secondary: 'gold' },
              nature: { primary: 'warm copper', secondary: 'rust' }
          };
          const shift = SHIFTS[colorFamily] || {};
          finalPalette = { ...basePalette, ...shift };
      }

      // Brown is NEVER default - must be justified by material
      if (finalPalette.primary.includes('brown') && material !== 'wood') {
          finalPalette.primary = basePalette.secondary || 'deep burgundy';
      }

      return {
          ...finalPalette,
          materialNote: materialShift,
          family: getColorFamily(finalPalette.primary)
      };
  }

  // Build intelligent cover prompt with all guardrails (AUTHORITATIVE)
  // PROMPT STRUCTURE ORDER: Layout â†’ Emotion â†’ Focal â†’ Background â†’ Palette â†’ Exclusions
  async function buildCoverPrompt(synopsis, genre, world, tone, dynamic, era) {
      const history = loadMotifHistory();
      const powerRole = resolvePowerRole(world, era, genre);

      // ==========================================
      // STEP 1: LAYOUT ROULETTE (MANDATORY)
      // Select structurally distinct composition
      // ==========================================
      const selectedLayout = selectCoverLayout(history);
      console.log('[CoverIntel] Layout selected:', selectedLayout.id);

      // Extract focal anchor with emotional gravity, human figure decision, and thematic tension
      const focalResult = await extractFocalObject(synopsis, powerRole, world, tone);
      const focalObject = focalResult.object;
      const material = focalResult.material || 'metal';
      const emotion = focalResult.emotion || 'mystery';
      const humanFigure = focalResult.humanFigure || 'none';
      const thematicTension = focalResult.thematicTension || null;

      // Check for repetition
      const objectClass = getObjectClass(focalObject);
      const repetitionCheck = wouldRepeatMotif(objectClass, null, null);

      // ISSUE 2 FIX: If object class repeats, force TRUE substitution via abstraction ladder
      // NEVER reuse same object in any form (literal, shadow, silhouette, fragment)
      let finalObject = focalObject;
      if (repetitionCheck.details?.object) {
          // Get recently used substitutes to avoid those too
          const usedSubs = history
              .filter(m => m.objectClass === objectClass)
              .map(m => m.substitution)
              .filter(Boolean);
          finalObject = getAbstractionSubstitute(objectClass, usedSubs);
      }

      // Derive background from domain (theme-derived, not decorative)
      // Power Role: Modern keeps raw genre for Billionaire-specific patterns;
      // non-Modern uses powerRole (no match â†’ falls back to world patterns only)
      const bgGenre = world === 'Modern' ? genre : powerRole;
      const backgroundPattern = deriveBackgroundPattern(bgGenre, world, history);

      // Derive palette from tone + material
      // HARD RULE: No brown/cream unless explicitly required by layout
      const palette = derivePalette(tone, material, history);

      // Anti-repetition: avoid art-deco twice in a row AND block cream backgrounds
      let finalBackground = backgroundPattern;
      const recentBgs = history.slice(0, 2).map(m => m.backgroundStyle?.toLowerCase() || '');
      if (backgroundPattern.includes('art-deco') || backgroundPattern.includes('geometric')) {
          if (recentBgs.some(bg => bg.includes('art-deco') || bg.includes('geometric'))) {
              finalBackground = DOMAIN_BACKGROUNDS[world]?.[0] || 'atmospheric gradient with depth';
          }
      }
      // Block cream/parchment unless center_object layout
      if (selectedLayout.id !== 'center_object') {
          if (finalBackground.includes('cream') || finalBackground.includes('parchment')) {
              finalBackground = 'deep atmospheric gradient';
          }
      }

      // Visual restraint rules (layout-aware)
      let restraintText = 'Limited palette (2-3 tones). Soft focus or shallow depth.';
      if (selectedLayout.id === 'negative_space_dominant') {
          restraintText = 'Minimal elements. 70%+ empty space. Single small anchor.';
      } else if (selectedLayout.id === 'fragmented_object') {
          restraintText = 'Object cropped or broken. Tension through incompleteness.';
      } else if (selectedLayout.id === 'off_center_focus') {
          restraintText = 'Strong asymmetry. Directional tension. Off-center weight.';
      }

      // Human figure handling
      let figureText = '';
      if (humanFigure === 'silhouette') {
          figureText = 'Human figure as shadow/silhouette only, no face visible.';
      } else if (humanFigure === 'turned_away') {
          figureText = 'Figure facing away, back to viewer.';
      } else if (humanFigure === 'partial') {
          figureText = 'Only hands or partial body, no face.';
      }

      // Save motif to history (include layout for repetition tracking)
      const wasSubstituted = repetitionCheck.details?.object;
      const newMotif = {
          layoutId: selectedLayout.id,           // Track layout for roulette
          objectClass: objectClass,              // Original class, not substituted
          colorFamily: palette.family,
          backgroundStyle: finalBackground,
          emotion: emotion,
          substitution: wasSubstituted ? finalObject : null,
          timestamp: Date.now()
      };
      saveMotifToHistory(newMotif);

      // Build the authoritative prompt (ORDER MATTERS)
      // Semantic Declaration â†’ Title-Safe â†’ Layout â†’ Emotion â†’ Focal â†’ Background â†’ Palette â†’ Restraint â†’ Exclusions

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // COVER-SPECIFIC VISUAL DECLARATION (AUTHORITATIVE)
      // TAG: storybound/cover-semantic-declaration-v1
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Covers may be painterly, graphic, symbolic, or illustrative.
      // Covers must NOT be literal depictions of specific scenes.
      // Covers may synthesize multiple themes, moods, or symbols.
      // Visual sophistication and restraint are preferred over realism.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const COVER_SEMANTIC_DECLARATION = `This image is a magazine-quality book cover illustration, designed to interpret the story's central tension or irony as a single composed image.

`;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” SEMANTIC DEFINITION (AUTHORITATIVE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Sketch-tier covers are unfinished in execution, not unfinished in idea.
      //
      // The cover concept must be sophisticated, ironic, or editorially sharp.
      // The rendering must feel provisional, exploratory, or interrupted.
      //
      // Sketch-tier enforces surface roughness, not conceptual simplicity.
      //
      // If the image looks complete, it has violated Sketch-tier.
      // If the idea looks simple, it has violated Sketch-tier.
      //
      // The goal is a cover that feels mid-thought, not under-thought.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” ALLOWED / DISALLOWED CLARIFICATIONS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Sketch-tier MAY include:
      // - pencil, ink, or charcoal textures
      // - uneven or broken linework
      // - partial fill or restrained color
      // - visible construction or negative space
      // - hand-drawn or outlined lettering
      //
      // Sketch-tier MUST NOT collapse into:
      // - flat icons
      // - clip-art minimalism
      // - dumbed-down symbolism
      // - polished painterly rendering
      // - 'cartoonish' simplification
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // COVER REGRESSION SENTENCE (INTERNAL CHECK)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 'Does this cover feel like an intelligent editorial idea that has
      // been intentionally left unfinished, rather than a finished image
      // that has been simplified?'
      //
      // This sentence is for internal validation only.
      // It must not appear in output.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” IMPLEMENTATION SAFETY NOTE
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // This Sketch-tier definition modifies execution, not meaning.
      // Do NOT simplify concepts to satisfy roughness.
      // Do NOT flatten symbolism.
      // Do NOT enforce sketch aesthetics at the expense of thought.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” MATERIAL AND FINISH CONSTRAINTS (HARD)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // When coverStage === 'Sketch':
      //
      // - Linework must appear unfinished.
      // - Materials must resemble pencil, ink, charcoal,
      //   light watercolor wash, or colored pencil.
      // - Shading must be imperfect, uneven, or gestural.
      // - Typography must appear hand-drawn, outlined,
      //   or lightly irregular.
      // - No polished lighting, gradients, or realism.
      //
      // A Sketch that appears print-ready or fully rendered
      // is a failure.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH TIER â€” REGRESSION TEST (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // For any cover where coverStage === 'Sketch',
      // Claude must pass this regression test:
      //
      // "If this image looks finished, polished, or ready for print,
      // it has failed the Sketch tier."
      //
      // Failure requires regeneration, not adjustment.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SKETCH LABEL PLACEMENT (LOCKED)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // The label 'Sketch â€” currently displayed' must appear
      // BELOW the cover image, never overlaid on top of it.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // STORY MILESTONE COPY (LOCKED)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Replace: 'Character Milestone Achieved'
      // With: 'Story Milestones Unlocked: {count}'
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      const TITLE_SAFE_CONSTRAINTS = `TITLE-SAFE ZONE (MANDATORY):
Upper 18-22% of image must remain visually simple and low-contrast.
No faces, text, high-detail objects, or bright highlights in title region.
Subject blocking confined to middle and lower thirds only.
Gradual tonal transition from top edge downward â€” no hard horizontal lines at top.
Composition must leave clear space for book-cover typography overlay.`;

      // Get sketch tier enforcement if tone requires it
      const sketchTierText = getSketchTierEnforcement(tone);

      return {
          layoutId: selectedLayout.id,
          focalObject: finalObject,
          material: material,
          emotion: emotion,
          humanFigure: humanFigure,
          background: finalBackground,
          palette: palette,
          thematicTension: thematicTension,
          promptText: `${COVER_SEMANTIC_DECLARATION}${TITLE_SAFE_CONSTRAINTS}
${sketchTierText ? '\n' + sketchTierText + '\n' : ''}
LAYOUT: ${selectedLayout.description}
EMOTIONAL GRAVITY: ${emotion} (guides all visual decisions).
${thematicTension ? `STORY TENSION: ${thematicTension}. (Influences imagery, not literal depiction.)\n` : ''}FOCAL ANCHOR: ${finalObject} rendered in ${material}, composed per layout.
BACKGROUND: ${finalBackground}. (Support emotion, not decoration.)
PALETTE: ${palette.primary}, ${palette.secondary}. Max 3 tones. ${palette.materialNote}
COMPOSITION: ${restraintText}
${figureText ? figureText + '\n' : ''}${COVER_EXCLUSIONS}`
      };
  }

  // ============================================================
  // PHASE 3A: ARCHETYPE SELECTOR
  // Deterministic world-based archetype â€” NEVER returns null.
  // Explicit state.coverArchetype overrides world default.
  // Prehistoric / Historical / Fantasy â†’ THRESHOLD
  // SciFi / Modern / Dystopian â†’ EMBLEM
  // ============================================================
  function selectCoverArchetype(genre, dynamic, tone, world, synopsis) {
      // Explicit archetype override (UI or Guided-Fate driven)
      if (state.coverArchetype === 'EMBLEM') return 'EMBLEM';
      if (state.coverArchetype === 'THRESHOLD') return 'THRESHOLD';

      // World-based deterministic default
      if (world === 'Prehistoric' || world === 'Historical' || world === 'Fantasy') {
          return 'THRESHOLD';
      }
      // SciFi, Modern, Dystopian, unknown â†’ EMBLEM
      return 'EMBLEM';
  }

  // Generate book cover with intent-based routing
  // Uses COVER INTELLIGENCE SYSTEM for focal object, anti-repetition, domain backgrounds, palette
  // DSP-lite cover subtitle derived from story shape axes
  function generateCoverSubtitle() {
      const GENRE_PHRASE = {
          Billionaire: 'wealth and want',
          CrimeSyndicate: 'crime and collusion',
          Espionage: 'secrets and espionage',
          Political: 'power and politics',
          Noir: 'shadow and suspicion',
          Heist: 'schemes and daring'
      };
      const DYNAMIC_PHRASE = {
          Enemies: 'rivals become something more',
          Friends: 'friendship ignites',
          Forbidden: 'the forbidden pulls closer',
          SecondChance: 'the past returns uninvited',
          Proximity: 'proximity rewrites the rules',
          SecretIdentity: 'hidden truths threaten everything'
      };
      const WORLD_SHADE = {
          Modern: 'under city lights',
          Fantasy: 'in lands uncharted',
          Romantasy: 'where magic meets desire',
          SciFi: 'among the stars',
          Historical: 'across the ages',
          Dystopia: 'in a world undone',
          PostApocalyptic: 'after the fall',
          Horror: 'in the dark between worlds'
      };

      const genre = state.picks?.genre || 'Billionaire';
      const dynamic = state.picks?.dynamic || 'Enemies';
      const world = state.picks?.world || 'Modern';
      const gp = GENRE_PHRASE[genre] || 'intrigue';
      const dp = DYNAMIC_PHRASE[dynamic] || 'two lives collide';
      const wp = WORLD_SHADE[world] || '';
      const storyNoun = 'tale';

      return 'A Storybound ' + storyNoun + ' of ' + gp + ' where ' + dp + ' ' + wp + '.';
  }

  // ============================================================
  // COVER FALLBACK LIBRARY â€” deterministic SVG motifs
  // ============================================================

  const COVER_FALLBACK_MOTIFS = {
      Modern:          ['handcuffs', 'key', 'drop'],
      Historical:      ['key', 'skull', 'sun'],
      Dystopia:        ['skull', 'handprint', 'moon'],
      PostApocalyptic: ['skull', 'sun', 'waves'],
      Fantasy:         ['sun', 'stars', 'key'],
      SciFi:           ['stars', 'moon', 'waves'],
      Supernatural:    ['moon', 'key', 'skull'],
      Superheroic:     ['sun', 'stars', 'handprint']
  };

  const COVER_FALLBACK_PALETTES = {
      Modern:          { bg: '#0a0a0a', accent: '#e63946' },
      Historical:      { bg: '#0d0908', accent: '#d4af37' },
      Dystopia:        { bg: '#0a0a0a', accent: '#cccccc' },
      PostApocalyptic: { bg: '#0d0b08', accent: '#c8553d' },
      Fantasy:         { bg: '#0a0a12', accent: '#d4af37' },
      SciFi:           { bg: '#0a1628', accent: '#40e0d0' },
      Supernatural:    { bg: '#0a0a12', accent: '#8b5cf6' },
      Superheroic:     { bg: '#0d0a14', accent: '#e63946' }
  };

  // Inline SVG paths for motif icons (symbolic, no people/bodies)
  const SVG_MOTIF_PATHS = {
      skull: '<path d="M50 15c-18 0-32 14-32 32 0 12 6 22 16 28v10c0 3 2 5 5 5h22c3 0 5-2 5-5V75c10-6 16-16 16-28 0-18-14-32-32-32zm-10 38a5 5 0 110-10 5 5 0 010 10zm20 0a5 5 0 110-10 5 5 0 010 10zm-10 14c-4 0-8-2-8-4h16c0 2-4 4-8 4z"/>',
      handcuffs: '<path d="M30 35c-8 0-15 7-15 15s7 15 15 15c5 0 10-3 12-7h16c2 4 7 7 12 7 8 0 15-7 15-15s-7-15-15-15c-5 0-10 3-12 7H42c-2-4-7-7-12-7zm0 8a7 7 0 110 14 7 7 0 010-14zm40 0a7 7 0 110 14 7 7 0 010-14z"/>',
      key: '<path d="M65 20L50 35l6 6-4 4 6 6-4 4 6 6-8 8c-3 3-8 3-11 0l-1-1c-6 3-14 2-19-3-7-7-7-18 0-25s18-7 25 0c5 5 6 13 3 19l1 1c3 3 3 8 0 11zm-35 30a5 5 0 100-10 5 5 0 000 10z"/>',
      handprint: '<path d="M35 25v20h-3V28c0-2-3-2-3 0v18h-3V30c0-2-3-2-3 0v16l-2 6c-1 3 0 6 2 8l8 10c2 2 4 4 7 4h12c5 0 9-4 9-9V40c0-2-3-2-3 0v10h-3V27c0-2-3-2-3 0v23h-3V25c0-2-3-2-3 0v25h-3V27c0-2-3-2-3 0z"/>',
      drop: '<path d="M50 15C50 15 25 45 25 60c0 14 11 25 25 25s25-11 25-25C75 45 50 15 50 15zm-5 50a3 3 0 01-3-3c0-8 7-15 15-15a3 3 0 010 6c-5 0-9 4-9 9a3 3 0 01-3 3z"/>',
      sun: '<circle cx="50" cy="50" r="15"/><g stroke-width="3" stroke="currentColor"><line x1="50" y1="10" x2="50" y2="22"/><line x1="50" y1="78" x2="50" y2="90"/><line x1="10" y1="50" x2="22" y2="50"/><line x1="78" y1="50" x2="90" y2="50"/><line x1="22" y1="22" x2="31" y2="31"/><line x1="69" y1="69" x2="78" y2="78"/><line x1="78" y1="22" x2="69" y2="31"/><line x1="31" y1="69" x2="22" y2="78"/></g>',
      moon: '<path d="M50 10c-22 0-40 18-40 40s18 40 40 40c8 0 15-2 22-6-6 3-12 4-18 4-20 0-36-16-36-36S34 16 54 16c6 0 12 1 18 4C65 14 58 10 50 10z"/>',
      stars: '<polygon points="50,5 58,35 90,35 64,55 73,85 50,67 27,85 36,55 10,35 42,35"/><polygon points="22,12 25,22 35,22 27,28 30,38 22,32 14,38 17,28 9,22 19,22" transform="scale(0.5) translate(10,10)"/><polygon points="22,12 25,22 35,22 27,28 30,38 22,32 14,38 17,28 9,22 19,22" transform="scale(0.4) translate(180,120)"/>',
      waves: '<path d="M5 50c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="currentColor" stroke-width="4"/><path d="M5 65c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="currentColor" stroke-width="3" opacity="0.6"/><path d="M5 35c10-10 20-10 30 0s20 10 30 0 20-10 30 0" fill="none" stroke="currentColor" stroke-width="3" opacity="0.6"/>'
  };

  /**
   * Simple hash for deterministic motif selection from genre string
   */
  function genreMotifHash(genre) {
      let h = 0;
      for (let i = 0; i < genre.length; i++) {
          h = ((h << 5) - h + genre.charCodeAt(i)) | 0;
      }
      return Math.abs(h);
  }

  /**
   * Render a deterministic CSS/SVG fallback cover.
   * Selects motif by world + genre hash. Never fails.
   */
  function renderFallbackCover(world, genre, title) {
      const fallbackEl = document.getElementById('coverFallback');
      const coverImg = document.getElementById('bookCoverImg');
      if (!fallbackEl) return;

      const w = world || 'Modern';
      const g = genre || 'Billionaire';
      const motifs = COVER_FALLBACK_MOTIFS[w] || COVER_FALLBACK_MOTIFS.Modern;
      const palette = COVER_FALLBACK_PALETTES[w] || COVER_FALLBACK_PALETTES.Modern;
      const motifKey = motifs[genreMotifHash(g) % motifs.length];
      const svgContent = SVG_MOTIF_PATHS[motifKey] || SVG_MOTIF_PATHS.key;

      // Resolve title: explicit param â†’ storyTitle DOM â†’ empty
      const displayTitle = title
          || document.getElementById('storyTitle')?.textContent
          || '';

      fallbackEl.style.setProperty('--fb-bg', palette.bg);
      fallbackEl.style.setProperty('--fb-accent', palette.accent);

      // Build cover: SVG motif + title cartouche + author line
      let html = '<svg class="cover-fallback-motif" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="' + palette.accent + '" color="' + palette.accent + '">' + svgContent + '</svg>';
      const safeTitle = displayTitle ? displayTitle.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
      html += '<div class="cover-fallback-title" style="color:' + palette.accent + '">' +
          '<span class="cover-fallback-title-rule"></span>' +
          (safeTitle ? '<span class="cover-fallback-title-text">' + safeTitle + '</span>' : '') +
          '<span class="cover-fallback-author">by ' + CANONICAL_AUTHOR_NAME + '</span>' +
          '<span class="cover-fallback-title-rule"></span>' +
          '</div>';
      fallbackEl.innerHTML = html;

      // Show fallback, hide AI image
      fallbackEl.classList.remove('hidden');
      if (coverImg) coverImg.style.display = 'none';
  }

  /**
   * Cover overlay stub â€” all intensity-based cover overlays removed.
   * Cover visuals depend ONLY on world, tone, archetype, and story milestones.
   * No border/keyhole/intensity signaling.
   */

  /**
   * Archive Stamp â€” visual overlay applied to cover at ST6 (scene 6).
   * Purely decorative. Does not change author text or cover generation.
   */
  function applyArchiveStamp() {
      const coverPage = document.getElementById('bookCoverPage');
      if (!coverPage || coverPage.querySelector('.archive-stamp')) return;
      const stamp = document.createElement('div');
      stamp.className = 'archive-stamp';
      stamp.setAttribute('aria-hidden', 'true');
      stamp.textContent = 'ARCHIVE';
      coverPage.appendChild(stamp);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER SEQUENCING â€” Storyturn-based phases only
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Phase 1 (SKETCH):         Scene 1 exists, ST1
  // Phase 2 (REFINED SKETCH): ST2
  // Phase 3 (POST-ST3):       ST3+
  // No arousal/intensity phases. Cover visuals reflect world, tone, milestones.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Determine current cover phase based on storyturn.
   * @returns {number} Phase 0-3
   */
  function getCoverPhase() {
      const storyturn = state.storyturn || 'ST1';
      const sceneCount = state.scenes?.length || 0;
      if (sceneCount === 0) return 0;
      const stNum = parseInt(storyturn.replace(/\D/g, ''), 10) || 1;
      if (stNum >= 3) return 3;
      if (stNum === 2) return 2;
      return 1;
  }

  /**
   * Validate cover sequencing rules.
   * @returns {{valid: boolean, reason: string|null, phase: number}}
   */
  function validateCoverSequencing() {
      return { valid: true, reason: null, phase: getCoverPhase() };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORNATE BORDER â€” Image Asset Loader
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Maps world names to asset paths and applies surface condition filters.
  //
  // WORLD â†’ ASSET MAPPING (6 worlds, no Mythic):
  //   Modern          â†’ /assets/borders/ornate/modern_base.png
  //   Fantasy         â†’ /assets/borders/ornate/fantasy_base.png
  //   SciFi           â†’ /assets/borders/ornate/scifi_base.png
  //   Historical      â†’ /assets/borders/ornate/historical_base.png
  //   PostApocalyptic â†’ /assets/borders/ornate/postapocalyptic_base.png
  //   Dystopia        â†’ /assets/borders/ornate/dystopia_base.png
  //
  // FLAVOR â†’ SURFACE CONDITION:
  //   Flavor affects damage/aging/corrosion appearance, NOT geometry.
  //   Applied via CSS filter classes: flavor-aged, flavor-weathered, etc.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const ORNATE_BORDER_WORLD_MAP = {
      'modern': 'modern',
      'fantasy': 'fantasy',
      'scifi': 'scifi',
      'sci-fi': 'scifi',
      'historical': 'historical',
      'postapocalyptic': 'postapocalyptic',
      'post-apocalyptic': 'postapocalyptic',
      'dystopia': 'dystopia'
  };

  // Flavor â†’ CSS filter class mapping
  // Surface conditions: damage, aging, corrosion (NOT geometry)
  const ORNATE_BORDER_FLAVOR_MAP = {
      // Historical flavors
      'prehistoric': 'aged',
      'bronze_age': 'weathered',
      'classical': 'weathered',
      'medieval': 'aged',
      'renaissance': 'tarnished',
      'victorian': 'aged',
      '20th_century': 'weathered',
      // Fantasy flavors (romance-breaking pressures)
      'arcane_binding': 'tarnished',
      'fated_blood': 'aged',
      'the_inhuman': 'weathered',
      'the_beyond': 'pristine',
      'cursed': 'corroded',
      // SciFi flavors
      'galactic_civilizations': 'pristine',
      'future_of_science': 'pristine',
      'cyberpunk': 'corroded',
      'post_human': 'fractured',
      'first_contact': 'pristine',
      'simulation': 'pristine',
      'final_frontier': 'weathered',
      // Dystopia flavors (7 locked canon)
      'glass_house': 'tarnished',
      'human_capital': 'pristine',
      'dogma': 'weathered',
      'quieting_event': 'aged',
      'endless_edit': 'fractured',
      'thirst': 'weathered',
      // PostApocalyptic flavors (5 canonical conditions)
      'ashfall': 'corroded',
      'year_zero': 'weathered',
      'dystimulation': 'tarnished',
      'predation': 'rusted',
      'hunger': 'aged',
      // Modern flavors (generally pristine)
      'small_town': 'weathered',
      'college': 'pristine',
      'friends': 'pristine',
      'blue_blood': 'tarnished',
      'office': 'pristine',
      'supernatural_modern': 'aged',
      'superheroic_modern': 'pristine'
  };

  /**
   * Apply ornate border with world-specific asset and flavor-based surface condition.
   * @param {HTMLElement} borderEl - The border container element
   * @param {string} world - World name (Modern, Fantasy, SciFi, etc.)
   * @param {boolean} hasSoulmates - Whether soulmates modifier applies
   */
  function applyOrnateBorder(borderEl, world, hasSoulmates) {
      const borderImg = document.getElementById('ornateBorderImg');
      if (!borderImg) {
          console.warn('[OrnateBorder] Image element not found â€” border suppressed');
          return;
      }

      // Normalize world name to asset key
      const normalizedWorld = (world || 'Modern').toLowerCase().replace(/[\s-]/g, '');
      const assetKey = ORNATE_BORDER_WORLD_MAP[normalizedWorld] || 'modern';
      const assetPath = `/assets/borders/ornate/${assetKey}_base.png`;

      // Get world class for vignette/glow styling
      const worldClass = 'world-' + assetKey;

      // Get flavor for surface condition
      const flavor = state.picks?.worldSubtype || null;
      const flavorClass = flavor && ORNATE_BORDER_FLAVOR_MAP[flavor]
          ? 'flavor-' + ORNATE_BORDER_FLAVOR_MAP[flavor]
          : '';

      // Build class list
      const classes = ['cover-ornate-border', worldClass];
      if (hasSoulmates) classes.push('soulmates');
      if (flavorClass) classes.push(flavorClass);

      // Set up load handler BEFORE setting src
      borderImg.onload = function() {
          borderEl.className = classes.join(' ');
          console.log('[OrnateBorder] Asset loaded:', assetPath, '| Classes:', classes.join(' '));
      };

      // Set up error handler for asset failure
      borderImg.onerror = function() {
          console.warn('[OrnateBorder] Ornate border asset unavailable â€” border suppressed');
          borderEl.classList.add('hidden');
          borderEl.className = 'cover-ornate-border hidden';
      };

      // Trigger asset load
      borderImg.src = assetPath;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DIRTY KEYHOLE â€” World-Specific Mask Loader
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Keyhole is a MASK, not a decorative overlay. It dominates the cover.
  //
  // GEOMETRY LOCK (NON-NEGOTIABLE):
  //   - Top of aperture: 8% from top
  //   - Bottom of aperture: 8% from bottom
  //   - Crown width: 55-65% of cover width
  //   - Stem minimum width: â‰¥22% of cover width
  //
  // WORLD â†’ MASK ASSET (6 worlds, one silhouette each):
  //   Modern          â†’ /assets/keyholes/modern_mask.png       (clean industrial)
  //   Historical      â†’ /assets/keyholes/historical_mask.png   (ornate, filigree)
  //   Fantasy         â†’ /assets/keyholes/fantasy_mask.png      (hand-forged, runes)
  //   SciFi           â†’ /assets/keyholes/scifi_mask.png        (geometric, octagonal)
  //   Dystopia        â†’ /assets/keyholes/dystopia_mask.png     (brutalist, industrial)
  //   PostApocalyptic â†’ /assets/keyholes/postapocalyptic_mask.png (salvaged, damaged)
  //
  // CONTENT RULE: Only symbolic objects visible through aperture (no humans/body parts)
  // TITLE RULE: Title MUST be engraved into material, NEVER floating in aperture
  //
  // FAILURE: If constraint cannot be satisfied, suppress and log:
  // "Dirty keyhole constraint failed â€” cover suppressed"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const DIRTY_KEYHOLE_WORLD_MAP = {
      'modern': 'modern',
      'fantasy': 'fantasy',
      'scifi': 'scifi',
      'sci-fi': 'scifi',
      'historical': 'historical',
      'postapocalyptic': 'postapocalyptic',
      'post-apocalyptic': 'postapocalyptic',
      'dystopia': 'dystopia'
  };

  // Flavor â†’ CSS filter class mapping for keyhole surface conditions
  // Surface conditions: wear, corrosion, fracture, environmental damage (NOT aperture geometry)
  const DIRTY_KEYHOLE_FLAVOR_MAP = {
      // Historical flavors
      'prehistoric': 'aged',
      'bronze_age': 'weathered',
      'classical': 'weathered',
      'medieval': 'aged',
      'renaissance': 'aged',
      'victorian': 'weathered',
      '20th_century': 'weathered',
      // Fantasy flavors (romance-breaking pressures)
      'arcane_binding': 'tarnished',
      'fated_blood': 'aged',
      'the_inhuman': 'weathered',
      'the_beyond': 'pristine',
      'cursed': 'corroded',
      // SciFi flavors
      'galactic_civilizations': 'pristine',
      'future_of_science': 'pristine',
      'cyberpunk': 'corroded',
      'post_human': 'fractured',
      'first_contact': 'pristine',
      'simulation': 'pristine',
      'final_frontier': 'weathered',
      // Dystopia flavors (7 locked canon)
      'glass_house': 'tarnished',
      'human_capital': 'pristine',
      'dogma': 'weathered',
      'quieting_event': 'aged',
      'endless_edit': 'fractured',
      'thirst': 'weathered',
      // PostApocalyptic flavors (5 canonical conditions)
      'ashfall': 'corroded',
      'year_zero': 'weathered',
      'dystimulation': 'fractured',
      'predation': 'rusted',
      'hunger': 'aged',
      // Modern flavors
      'small_town': 'weathered',
      'college': 'pristine',
      'friends': 'pristine',
      'blue_blood': 'aged',
      'office': 'pristine',
      'supernatural_modern': 'aged',
      'superheroic_modern': 'pristine'
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DIRTY KEYHOLE SELF-CHECK AUDIT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Mandatory pre-output validation. If ANY check fails, output is suppressed.
  //
  // Checks performed:
  //   A. World Conformance â€” must be valid 6-world set (no Mythic)
  //   B. Flavor Application â€” surface only, no geometry changes
  //   C. Material Language â€” world-appropriate materials
  //   D. Title Integration â€” engraved into material, not floating
  //
  // If failed: return "DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED"
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const VALID_KEYHOLE_WORLDS = new Set([
      'modern', 'historical', 'fantasy', 'scifi', 'dystopia', 'postapocalyptic'
  ]);

  /**
   * Run self-check audit on dirty keyhole parameters.
   * @param {string} world - World name
   * @param {string} flavor - WorldSubtype flavor
   * @returns {{valid: boolean, reason: string|null}}
   */
  function auditDirtyKeyhole(world, flavor) {
      const normalizedWorld = (world || 'Modern').toLowerCase().replace(/[\s-]/g, '');
      const assetKey = DIRTY_KEYHOLE_WORLD_MAP[normalizedWorld];

      // A. WORLD CONFORMANCE CHECK
      if (!assetKey || !VALID_KEYHOLE_WORLDS.has(assetKey)) {
          return {
              valid: false,
              reason: `Invalid world "${world}" â€” must be Modern, Historical, Fantasy, SciFi, Dystopia, or PostApocalyptic (Mythic not allowed)`
          };
      }

      // B. FLAVOR APPLICATION CHECK (flavor must map to surface condition, not geometry)
      if (flavor && !DIRTY_KEYHOLE_FLAVOR_MAP[flavor]) {
          // Unknown flavor â€” warn but don't fail (will use default)
          console.warn(`[DirtyKeyhole:Audit] Unknown flavor "${flavor}" â€” using default surface`);
      }

      // C. MATERIAL LANGUAGE CHECK (world must have corresponding material treatment)
      // Verified by CSS class existence â€” if world class missing, styling will fail gracefully

      // D. TITLE INTEGRATION CHECK
      // Enforced by CSS positioning â€” title is absolutely positioned in bottom margin zone
      // This is a structural guarantee, not runtime check

      // All checks passed
      return { valid: true, reason: null };
  }

  /**
   * Apply dirty keyhole with world-specific mask and flavor-based surface condition.
   * Keyhole is the DOMINANT MASK â€” everything inside is scene, everything outside is material.
   *
   * SELF-CHECK AUDIT runs before application. If audit fails, output is suppressed.
   *
   * @param {HTMLElement} keyholeEl - The keyhole overlay container element
   * @param {string} world - World name (Modern, Historical, Fantasy, SciFi, Dystopia, PostApocalyptic)
   * @param {boolean} hasSoulmates - Whether soulmates modifier applies
   */
  function applyDirtyKeyhole(keyholeEl, world, hasSoulmates) {
      const keyholeplate = document.getElementById('keyholeplate');
      if (!keyholeplate) {
          console.warn('[DirtyKeyhole] Keyhole plate element not found â€” keyhole suppressed');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SELF-CHECK AUDIT (MANDATORY)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const flavor = state.picks?.worldSubtype || null;
      const audit = auditDirtyKeyhole(world, flavor);
      if (!audit.valid) {
          console.error('[DirtyKeyhole] DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED');
          console.error('[DirtyKeyhole] Reason:', audit.reason);
          keyholeEl.classList.add('hidden');
          keyholeEl.className = 'cover-keyhole-overlay hidden';
          return;
      }

      // Normalize world name to asset key
      const normalizedWorld = (world || 'Modern').toLowerCase().replace(/[\s-]/g, '');
      const assetKey = DIRTY_KEYHOLE_WORLD_MAP[normalizedWorld] || 'modern';
      const maskPath = `/assets/keyholes/${assetKey}_mask.png`;

      // Get world class for material styling
      const worldClass = 'world-' + assetKey;

      // Get flavor class for surface condition
      const flavorClass = flavor && DIRTY_KEYHOLE_FLAVOR_MAP[flavor]
          ? 'flavor-' + DIRTY_KEYHOLE_FLAVOR_MAP[flavor]
          : '';

      // Build class list for the overlay
      const classes = ['cover-keyhole-overlay', worldClass];
      if (hasSoulmates) classes.push('soulmates');
      if (flavorClass) classes.push(flavorClass);

      // Fate Resonance visual expression (keyhole mark only, no reservoir/math changes)
      if (state.keyhole?.marked) {
        const resState = getFateResonanceState();
        if (resState === 'Stirring')  classes.push('resonance-stirring');
        if (resState === 'Resonant')  classes.push('resonance-resonant');
        if (resState === 'Unstable')  classes.push('resonance-unstable');
        if (resState === 'Thinning')  classes.push('resonance-thinning');
      }

      // Apply the mask to the keyhole plate
      const maskUrl = `url("${maskPath}")`;
      keyholeplate.style.webkitMaskImage = maskUrl;
      keyholeplate.style.maskImage = maskUrl;

      // Set up image preload to verify mask asset availability
      const testImg = new Image();
      testImg.onload = function() {
          // Asset available â€” apply classes and show
          keyholeEl.className = classes.join(' ');
          console.log('[DirtyKeyhole] Audit PASSED | Mask loaded:', maskPath, '| Classes:', classes.join(' '));

          // Set title + author into keyhole metalwork (MUST be engraved, not floating)
          const titleEl = keyholeEl.querySelector('.keyhole-title');
          const storyTitle = document.getElementById('storyTitle');
          if (titleEl) {
              const t = storyTitle?.textContent || '';
              titleEl.innerHTML = (t ? '<span class="keyhole-title-text">' + t.replace(/</g, '&lt;') + '</span>' : '') +
                  '<span class="keyhole-author">by ' + CANONICAL_AUTHOR_NAME + '</span>';
          }
      };

      testImg.onerror = function() {
          // Asset unavailable â€” suppress keyhole and log
          console.error('[DirtyKeyhole] DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED');
          console.error('[DirtyKeyhole] Reason: Mask asset unavailable at', maskPath);
          keyholeEl.classList.add('hidden');
          keyholeEl.className = 'cover-keyhole-overlay hidden';
          keyholeplate.style.webkitMaskImage = '';
          keyholeplate.style.maskImage = '';
      };

      // Trigger asset verification
      testImg.src = maskPath;
  }

  /**
   * Reset cover overlay layers (called when resetting book state)
   */
  function resetCoverLayers() {
      const fallbackEl = document.getElementById('coverFallback');
      const borderEl = document.getElementById('coverOrnateBorder');
      const keyholeEl = document.getElementById('coverKeyholeOverlay');
      const coverImg = document.getElementById('bookCoverImg');
      const borderImg = document.getElementById('ornateBorderImg');
      const keyholeplate = document.getElementById('keyholeplate');

      if (fallbackEl) { fallbackEl.classList.add('hidden'); fallbackEl.innerHTML = ''; }
      if (borderEl) { borderEl.className = 'cover-ornate-border hidden'; }
      if (borderImg) { borderImg.src = ''; borderImg.onload = null; borderImg.onerror = null; }
      if (keyholeEl) { keyholeEl.className = 'cover-keyhole-overlay hidden'; }
      if (keyholeplate) { keyholeplate.style.webkitMaskImage = ''; keyholeplate.style.maskImage = ''; }
      if (coverImg) { coverImg.style.display = ''; }
  }

  // ============================================================
  // COVER SYSTEM â€” NON-BLOCKING PRINCIPLE (CRITICAL)
  // ============================================================
  // Cover rendering must NEVER block story creation.
  // Failure results in GRACEFUL FALLBACK, not retry or abort.
  //
  // Rules:
  // - All cover generation is async and non-blocking
  // - All failure paths return null â†’ renderFallbackCover()
  // - NO retries, NO loops, NO user-blocking errors
  // - Story creation succeeds even if cover generation fails
  // - Phase 1 Forged Cover is always available as fallback
  // ============================================================

  // ============================================================
  // ASSET AVAILABILITY REGISTRY (Phase 2+)
  // Lists valid objectIds for cover specs
  // If a referenced asset is unavailable â†’ fallback (not retry)
  // ============================================================
  const COVER_ASSET_REGISTRY = {
      // TIER 1 â€” Anchored PNG assets (preferred)
      objects: new Set([
          'mask_archetype_canonical',
          'wax_seal_standard',
          'relic_key'
      ])
      // NOTE: Framing assets removed â€” both KEYHOLE and BORDER are now runtime-rendered
      // TEMPORARY MODE: Synthetic ornate borders enabled until explicit asset replacement
  };

  // ============================================================
  // ğŸ§± ASSET STRUCTURE (REQUIRED)
  // Defines how canonical object assets are stored and referenced
  // ============================================================
  //
  // SCOPE CLARIFICATION:
  // Rules regarding gravity, resting behavior, and non-floating placement apply ONLY at final cover composition time.
  // They do NOT apply to how canonical object assets are stored, rendered, or represented in the asset repository.
  //
  // ============================================================

  // ============================================================
  // ğŸ§© ASSEMBLY RULES (CRITICAL)
  // Governs how assets are combined into final cover compositions
  // ============================================================
  //
  // OBJECT INTEGRITY:
  // Treat all object assets as rigid physical objects.
  // Do NOT deform, warp, bend, or reshape object geometry to match background topology unless explicitly instructed.
  //
  // DEPTH PRESERVATION:
  // Do NOT flatten, emboss, or convert three-dimensional object details into surface textures during assembly.
  // Preserve perceived depth, volume, and protrusion from the original asset.
  //
  // EDGE HANDLING GUARDRAIL:
  // Do NOT assume object assets are poor quality by default.
  // Some assets may be near-clean chroma-key renders.
  // Apply edge softening or blending ONLY if visual artifacts are present.
  // Never degrade clean edges unnecessarily.
  //
  // CONTACT SHADOW (MANDATORY):
  // All placed objects must cast a contact shadow appropriate to the scene lighting.
  //
  // CONTACT SHADOW SCOPE:
  // Contact shadows are generated ONLY AFTER an object has been keyed and placed onto a background surface.
  // Never bake contact shadows, ambient occlusion, or surface assumptions into the object asset itself.
  //
  // ============================================================

  // ============================================================
  // KEYHOLE FRAMING â€” RUNTIME RENDER SPECIFICATION
  // Keyholes are NOT asset files. They MUST be rendered by the
  // image model at runtime as physical objects or carved apertures.
  // Claude specifies properties; image model renders.
  // ============================================================
  const KEYHOLE_RENDER_REQUIREMENTS = {
      // Required properties for keyhole spec validation
      required: ['aperture', 'material', 'edgeStyle', 'integration'],
      // Aperture constraints (percentage of cover dimensions)
      aperture: {
          height: { min: 0.65, max: 0.80 },  // 65-80% of cover height
          width: { min: 0.40, max: 0.50 }    // 40-50% of cover width
      },
      // Valid material types
      materials: new Set([
          'brass', 'iron', 'bronze', 'oxidized_copper', 'blackened_steel',
          'carved_wood', 'carved_stone', 'bone', 'obsidian', 'gold_filigree'
      ]),
      // Valid edge styles
      edgeStyles: new Set([
          'beveled', 'chamfered', 'worn', 'sharp', 'ornate', 'weathered', 'forged'
      ]),
      // Integration behaviors (how keyhole meets cover surface)
      integrations: new Set([
          'inset', 'raised', 'flush', 'recessed_shadow', 'embossed'
      ])
  };

  // ============================================================
  // BORDER FRAMING â€” SYNTHETIC RUNTIME RENDER (TEMPORARY MODE)
  // Until explicit asset replacement, ornate borders MUST be:
  // - Generated by image model at render time
  // - Thin-line only (etched / engraved / diagrammatic)
  // - Flat graphic language (no depth, no bevel, no shadow)
  // - Monochrome or near-monochrome
  // - Symbolic, not illustrative
  // ============================================================
  const BORDER_RENDER_REQUIREMENTS = {
      // Required properties for border spec validation
      required: ['lineStyle', 'motifFamily', 'lineWeight', 'margin'],
      // Valid line styles (flat, no depth)
      lineStyles: new Set([
          'etched', 'engraved', 'continuous', 'dashed', 'dotted'
      ]),
      // Valid motif families (ONE only per border)
      motifFamilies: new Set([
          'filigree', 'restraint', 'floral', 'geometric'
      ]),
      // Valid line weights
      lineWeights: new Set([
          'thin', 'hairline', 'fine'
      ]),
      // Margin constraints (percentage from edge)
      margin: { min: 0.02, max: 0.08 }  // 2-8% from edge
  };

  // BORDER HARD BANS â€” Claude must NOT include these
  const BORDER_HARD_BANS = [
      'shading', 'texture', 'lighting', 'shadow', 'bevel', 'depth',
      'scene', 'background', 'anatomy', 'explicit', 'body', 'figure'
  ];

  /**
   * Validate border render specification (TEMPORARY SYNTHETIC MODE)
   * Borders are flat graphic elements rendered at runtime, NOT asset files
   * Returns { valid: false } if spec is malformed or violates constraints
   */
  function validateBorderSpec(borderSpec) {
      if (!borderSpec) {
          return { valid: false, reason: 'BORDER_SPEC_MISSING' };
      }

      // Check all required fields present
      for (const field of BORDER_RENDER_REQUIREMENTS.required) {
          if (!borderSpec[field]) {
              return { valid: false, reason: 'BORDER_MISSING_FIELD', missingField: field };
          }
      }

      // Validate line style
      if (!BORDER_RENDER_REQUIREMENTS.lineStyles.has(borderSpec.lineStyle)) {
          return { valid: false, reason: 'BORDER_LINE_STYLE_INVALID', value: borderSpec.lineStyle };
      }

      // Validate motif family (ONE only)
      if (!BORDER_RENDER_REQUIREMENTS.motifFamilies.has(borderSpec.motifFamily)) {
          return { valid: false, reason: 'BORDER_MOTIF_INVALID', value: borderSpec.motifFamily };
      }

      // Validate line weight
      if (!BORDER_RENDER_REQUIREMENTS.lineWeights.has(borderSpec.lineWeight)) {
          return { valid: false, reason: 'BORDER_LINE_WEIGHT_INVALID', value: borderSpec.lineWeight };
      }

      // Validate margin distance
      const reqMargin = BORDER_RENDER_REQUIREMENTS.margin;
      if (borderSpec.margin < reqMargin.min || borderSpec.margin > reqMargin.max) {
          return { valid: false, reason: 'BORDER_MARGIN_INVALID', value: borderSpec.margin };
      }

      return { valid: true };
  }

  /**
   * Validate keyhole render specification
   * Keyholes are physical objects rendered at runtime, NOT asset references
   * Returns { valid: false } if spec is malformed or missing required fields
   */
  function validateKeyholeSpec(keyholeSpec) {
      if (!keyholeSpec) {
          return { valid: false, reason: 'KEYHOLE_SPEC_MISSING' };
      }

      // Check all required fields present
      for (const field of KEYHOLE_RENDER_REQUIREMENTS.required) {
          if (!keyholeSpec[field]) {
              return { valid: false, reason: 'KEYHOLE_MISSING_FIELD', missingField: field };
          }
      }

      // Validate aperture proportions
      const { aperture } = keyholeSpec;
      const reqAperture = KEYHOLE_RENDER_REQUIREMENTS.aperture;
      if (aperture.height < reqAperture.height.min || aperture.height > reqAperture.height.max) {
          return { valid: false, reason: 'KEYHOLE_APERTURE_HEIGHT_INVALID', value: aperture.height };
      }
      if (aperture.width < reqAperture.width.min || aperture.width > reqAperture.width.max) {
          return { valid: false, reason: 'KEYHOLE_APERTURE_WIDTH_INVALID', value: aperture.width };
      }

      // Validate material
      if (!KEYHOLE_RENDER_REQUIREMENTS.materials.has(keyholeSpec.material)) {
          return { valid: false, reason: 'KEYHOLE_MATERIAL_INVALID', value: keyholeSpec.material };
      }

      // Validate edge style
      if (!KEYHOLE_RENDER_REQUIREMENTS.edgeStyles.has(keyholeSpec.edgeStyle)) {
          return { valid: false, reason: 'KEYHOLE_EDGE_INVALID', value: keyholeSpec.edgeStyle };
      }

      // Validate integration
      if (!KEYHOLE_RENDER_REQUIREMENTS.integrations.has(keyholeSpec.integration)) {
          return { valid: false, reason: 'KEYHOLE_INTEGRATION_INVALID', value: keyholeSpec.integration };
      }

      return { valid: true };
  }

  /**
   * ASSET AVAILABILITY RULE â€” Phase 2+ safety gate
   * If a referenced objectId is unavailable at render time:
   * - Abort custom generation
   * - Return null (triggers Phase 1 Forged Cover fallback)
   * - No substitution, no invention, no additional AI calls
   *
   * FRAMING EXCEPTIONS (TEMPORARY MODE):
   * - KEYHOLE: runtime-rendered physical aperture; validate keyholeSpec
   * - BORDER: runtime-rendered synthetic line art; validate borderSpec
   * Both are generated by image model, NOT asset files.
   */
  function validateCoverAssets(coverSpec) {
      if (!coverSpec) return { valid: true };

      const { objectId, framing, keyholeSpec, borderSpec } = coverSpec;

      // Check objectId availability (TIER 1 assets only)
      if (objectId && !COVER_ASSET_REGISTRY.objects.has(objectId)) {
          console.warn('[CoverAsset] UNAVAILABLE objectId:', objectId, 'â†’ aborting custom generation');
          return { valid: false, reason: 'OBJECT_UNAVAILABLE', missingAsset: objectId };
      }

      // KEYHOLE FRAMING â€” runtime render, physical aperture
      if (framing === 'KEYHOLE') {
          const keyholeValidation = validateKeyholeSpec(keyholeSpec);
          if (!keyholeValidation.valid) {
              console.warn('[CoverAsset] Invalid keyholeSpec:', keyholeValidation.reason, 'â†’ aborting custom generation');
              return keyholeValidation;
          }
          return { valid: true };
      }

      // BORDER FRAMING â€” runtime render, synthetic line art (TEMPORARY MODE)
      if (framing === 'BORDER') {
          const borderValidation = validateBorderSpec(borderSpec);
          if (!borderValidation.valid) {
              console.warn('[CoverAsset] Invalid borderSpec:', borderValidation.reason, 'â†’ aborting custom generation');
              return borderValidation;
          }
          return { valid: true };
      }

      // NONE framing â€” no framing validation needed
      return { valid: true };
  }

  /**
   * Generate book cover via image model (Phase 2+ only)
   * NON-BLOCKING: Returns null on ANY failure â†’ triggers fallback at call site
   * NEVER retries, NEVER throws, NEVER blocks story creation
   */
  async function generateBookCover(synopsis, title, authorName) {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”´ MINIMAL COVER v1 QUARANTINE GUARD
      // When enabled, ALL legacy systems are bypassed â€” no exceptions
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (USE_MINIMAL_COVER_V1) {
          const coverUrl = await generateMinimalCoverV1({
              synopsis,
              title,
              authorName,
              world: state.picks?.world || 'Modern',
              genre: state.picks?.genre || 'Billionaire',
              tone: state.picks?.tone || 'Earnest',
              intensity: state.intensity || 'Naughty'
          });

          if (coverUrl) {
              stopCoverLoading(coverUrl);
          } else {
              stopCoverLoading(null);
          }

          return coverUrl;
      }
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LEGACY COVER SYSTEM BELOW â€” QUARANTINED (does not execute when v1 enabled)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Extract story context for symbolic object selection (4-axis system)
      const world = state.picks?.world || 'Modern';
      const tone = state.picks?.tone || 'Earnest';
      const genre = state.picks?.genre || 'Billionaire';
      const dynamic = state.picks?.dynamic || 'Enemies';
      const era = state.picks?.world === 'Historical' ? (state.picks?.era || 'Medieval') : null;
      // Power Role + Power Frame: resolve genre into world-appropriate labels
      const powerRole = resolvePowerRole(world, era, genre);
      const powerFrame = resolvePowerFrame(world, genre);
      // Extract arousal/intensity
      const arousal = state.intensity || null;

      // Archetype selection â€” deterministic, world-based, never null
      const archetype = selectCoverArchetype(genre, dynamic, tone, world, synopsis);

      // DEV LOGGING: generation-time state snapshot
      console.log('[DEV:CoverGen] world:', world, '| tone:', tone, '| genre:', genre, 'â†’ powerRole:', powerRole, '| archetype:', archetype, '| arousal:', arousal);
      console.log('[DEV:WorldResolve] world:', world, '| genre:', genre, 'â†’ archetype:', archetype, '| powerFrame:', powerFrame);

      // DSP-lite subtitle replaces series label
      const modeLine = generateCoverSubtitle();
      // Build story style description
      const storyStyle = `${tone} ${powerRole}`;

      // COVER INTELLIGENCE: Build intelligent prompt with focal object, anti-repetition, domain background, palette
      let coverIntel = null;
      try {
          coverIntel = await buildCoverPrompt(synopsis, genre, world, tone, dynamic, era);
          console.log('[CoverIntel] Focal object:', coverIntel.focalObject);
          console.log('[CoverIntel] Background:', coverIntel.background);
          console.log('[CoverIntel] Palette:', coverIntel.palette.primary, '/', coverIntel.palette.secondary);

          // Store cover emotion for later validation
          state.coverEmotion = coverIntel.emotion || 'mystery';

          // SIGNAL ALIGNMENT CHECK â€” validate title â†” cover consistency
          const signalCheck = validateSignalAlignment(title, coverIntel, {
              arousal: arousal || 'Naughty',
              tone: tone,
              genre: genre
          });
          if (!signalCheck.aligned) {
              console.warn('[SignalAlignment] Title â†” Cover mismatch:', signalCheck.errors.map(e => e.message));
              // Log for analytics but don't block generation
              // Future: could trigger title adjustment or cover prompt modification
          } else {
              console.log('[SignalAlignment] PASS â€” Title and cover signal same axis');
          }
      } catch (intelErr) {
          console.warn('[CoverIntel] Intelligence extraction failed, using fallback:', intelErr.message);
      }

      // Build enhanced prompt with cover intelligence (symbolic only â€” no story prose)
      const enhancedPrompt = coverIntel
          ? coverIntel.promptText
          : 'A dramatic symbolic book cover with atmospheric lighting, no text, no people';

      // ============================================================
      // ASSET AVAILABILITY RULE â€” Phase 2+ safety gate
      // If coverIntel specifies unavailable assets, abort to fallback
      // No substitution, no invention, no additional AI calls
      // ============================================================
      if (coverIntel?.coverSpec) {
          const assetCheck = validateCoverAssets(coverIntel.coverSpec);
          if (!assetCheck.valid) {
              console.warn('[BookCover] Asset unavailable:', assetCheck.missingAsset, 'â†’ aborting to Phase 1 fallback');
              return null; // Triggers renderFallbackCover at call site
          }
      }

      try {
          // Use global abort controller for cancellation support
          const signal = _coverAbortController?.signal;

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              signal: signal,
              body: JSON.stringify({
                  prompt: enhancedPrompt,
                  imageIntent: 'book_cover',
                  title: (title && title !== 'Untitled') ? title : '',
                  authorName: CANONICAL_AUTHOR_NAME,
                  modeLine: modeLine,
                  dynamic: dynamic,
                  storyStyle: storyStyle,
                  genre: powerRole,
                  size: '1024x1024',
                  // Pass cover intelligence metadata for server-side use
                  coverIntel: coverIntel ? {
                      focalObject: coverIntel.focalObject,
                      material: coverIntel.material,
                      background: coverIntel.background,
                      palette: {
                          primary: coverIntel.palette.primary,
                          secondary: coverIntel.palette.secondary,
                          accent: coverIntel.palette.accent
                      }
                  } : null,
                  // Phase 2b: New params (plumbing only, not yet used by API)
                  archetype: archetype,
                  arousal: arousal,
                  world: world,
                  era: era
              })
          });

          if (!res.ok) {
              console.warn('[BookCover] HTTP error:', res.status);
              return null;
          }

          const data = await res.json();
          return data?.url || null;
      } catch (err) {
          // Handle abort gracefully (not an error)
          if (err.name === 'AbortError') {
              console.log('[BookCover] Generation aborted by user');
              return null;
          }
          console.error('[BookCover] Generation failed:', err.message);
          return null;
      }
  }

  // =================================================================
  // WRY CONFESSIONAL â€” COVER RULESET (AUTHORITATIVE)
  // Editorial cartoon covers in the style of The New Yorker
  // =================================================================

  const WRY_CONFESSIONAL_COVER_RULES = {
      aspectRatio: '5:7',
      uiSuppressions: {
          hideSubscriptionGates: true,
          hideIntensityOverlays: true,
          hideCTAButtons: true,
          hideRequiresAccessCopy: true
      }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WRY CONFESSIONAL â€” COVER INTERPRETATION (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Wry Confessional covers must operate at the level of
  // editorial commentary, irony, or subversive observation,
  // comparable to a New Yorker cover.
  //
  // Literal object-only symbolism (e.g. a single key, book,
  // rose, or prop without contextual tension) is insufficient
  // unless the composition itself introduces irony or critique.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WRY CONFESSIONAL â€” SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Before finalizing any cover where tone === 'Wry Confessional',
  // Claude MUST silently evaluate:
  //
  // "Would this image still make sense â€” and still feel pointed â€”
  // if it appeared alone on a New Yorker cover with no caption?"
  //
  // If the honest answer is NO, the cover must be regenerated.
  //
  // This check is INTERNAL.
  // Do not explain it.
  // Do not soften it.
  // Do not bypass it for symbolism, prettiness, or mood.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WRY CONFESSIONAL â€” COVER REGIME (AUTHORITATIVE)
  // TAG: storybound/wry-cover-regime-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //
  // When tone === 'Wry Confessional',
  // cover generation operates under the
  // EDITORIAL JUDGMENT REGIME.
  //
  // Under this regime:
  //
  // - The cover is an editorial comment, not a depiction.
  // - The goal is subversive observation, irony, or critique.
  // - Literal object-only symbolism is insufficient unless
  //   the composition itself introduces tension or commentary.
  // - Ambiguity and restraint are strengths.
  // - Assembly logic is subordinate to editorial intent.
  //
  // This regime applies to all cover stages
  // (Sketch, Thumbnail, Rough, Final)
  // when tone === 'Wry Confessional'.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // NON-APPLICABILITY (CRITICAL)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // This regime applies ONLY when tone === 'Wry Confessional'.
  //
  // No other tone is affected.
  // No other cover behavior is changed.
  // Other tones continue to use their existing
  // assembly and stylistic logic.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER REGIME ROUTING (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Cover behavior is governed by a Cover Regime
  // selected by Tone.
  //
  // Routing is evaluated before assembly logic.
  //
  // Current routing table:
  //
  // - Wry Confessional â†’ Editorial Judgment Regime
  // - All other tones â†’ Legacy / Default Cover Regime
  //
  // No implicit blending is permitted.
  // Assembly logic must defer to the active Cover Regime.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER REGIME â€” FAILURE PREVENTION CLAUSE
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If a cover output violates the active Cover Regime,
  // it must be regenerated.
  //
  // Assembly success does not override regime failure.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // COVER REGIME CHANGE â€” JUDGMENT FIRST
  // TAG: storybound/cover-regime-judgment-first-v1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DEPRECATION NOTICE â€” CONSTRUCTION-FIRST COVERS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Any assumption that a cover must be constructed
  // by assembling objects, characters, materials, or symbols
  // as a primary step is deprecated.
  //
  // This approach produced literal, repetitive, or decorative
  // results that failed to imply story arc or relational tension.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER REGIME â€” JUDGMENT FIRST (AUTHORITATIVE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Covers in Storybound are editorial artifacts, not composites.
  //
  // The cover generation process MUST proceed as follows:
  //
  // 1. Determine the editorial judgment:
  //    â€¢ What tension defines this story?
  //    â€¢ What emotional posture does the reader inhabit?
  //    â€¢ What promise does the book make?
  //
  // 2. Decide what the cover is *about*.
  //    This decision is conceptual, not visual.
  //
  // 3. Only then, optionally select imagery, symbols,
  //    characters, masks, or objects that serve that judgment.
  //
  // Assembly is subordinate.
  // Omission is permitted.
  // Literal depiction is not required.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // JUDGMENT-FIRST â€” SCOPING BY TONE (CRITICAL)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // This Judgment-First Cover Regime applies ONLY
  // to tones explicitly routed to it.
  //
  // Current routing:
  //
  // â€¢ Wry Confessional â†’ Judgment-First Cover Regime
  // â€¢ All other tones â†’ Legacy / Default Cover Regime
  //
  // No implicit expansion is permitted.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // OBJECTS AND MASKS â€” ROLE CLARIFICATION
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Objects, masks, and materials are OPTIONAL tools.
  //
  // They may be used when they reinforce the editorial judgment.
  // They must NOT be used by default.
  //
  // The presence of a Storybeau, mask, or symbolic object
  // does not obligate its appearance on the cover.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // COVER FAILURE CONDITIONS (NON-NEGOTIABLE)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // A cover has FAILED if:
  //
  // â€¢ It is primarily decorative.
  // â€¢ It relies on generic romance symbolism
  //   (e.g. keys, roses, candles) without critique.
  // â€¢ It explains rather than implies.
  // â€¢ It could be swapped with another story's cover
  //   without noticeable loss of meaning.
  //
  // Failure requires regeneration, not refinement.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WRY CONFESSIONAL â€” FINAL SELF-CHECK (MANDATORY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Before finalizing the cover, Claude MUST silently answer:
  //
  // "Does this cover take a position on the story,
  // or is it merely illustrating it?"
  //
  // If the honest answer is 'illustrating',
  // the cover must be regenerated.
  //
  // This check is INTERNAL.
  // Do not explain it.
  // Do not soften it.
  // Do not bypass it for polish or mood.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ASSEMBLY AS FALLBACK ONLY
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // If no editorially valid cover emerges under
  // the Judgment-First Regime, legacy assembly
  // may be used ONLY as a fallback.
  //
  // Fallback assembly must still obey
  // the active Cover Regime.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // ============================================================
  // ğŸ”´ MINIMAL COVER v1 â€” QUARANTINE SYSTEM
  // ============================================================
  // When USE_MINIMAL_COVER_V1 = true, ALL legacy cover systems are bypassed:
  // - No Cover Assembly / Intelligence (buildCoverPrompt, extractFocalObject, etc.)
  // - No Backend Prompt Mutation Layers (erotic motif, typography, borders)
  // - No UX / Async Systems (phrase timers, progress bars, sparkles)
  // - No Anti-Repetition (motif history, abstraction ladder)
  // - No Fallback Substitution or auto-regeneration
  //
  // ONLY: One frozen intent â†’ One prompt â†’ One API call â†’ One image
  // ============================================================
  const USE_MINIMAL_COVER_V1 = true; // QUARANTINE KILL SWITCH
  const CANONICAL_AUTHOR_NAME = 'S. Tory Bound'; // Authoritative â€” never user-authored

  /**
   * MINIMAL COVER v1 â€” Quarantined cover generation
   * NO legacy systems. NO retries. NO mutation. NO UI ownership.
   * @param {object} frozenIntent - {synopsis, title, authorName, world, genre, tone, intensity, stage}
   * @returns {Promise<string|null>} - Image URL or null
   */
  async function generateMinimalCoverV1(frozenIntent) {
      console.log('[COVER] Minimal Cover v1 active â€” ALL legacy systems bypassed');

      // EARNED COVER SYSTEM: Get stage (defaults to current stage if not provided)
      const stage = frozenIntent.stage || getCurrentCoverStage();
      const stageLabel = COVER_STAGE_LABELS[stage] || 'Cover';
      const stageModifier = getCoverStagePromptModifier(stage, frozenIntent.tone);

      console.log('[COVER:v1] Frozen intent:', {
          title: frozenIntent.title,
          world: frozenIntent.world,
          genre: frozenIntent.genre,
          tone: frozenIntent.tone,
          intensity: frozenIntent.intensity,
          stage: stage
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ASSEMBLY-COMPLIANT COVER PROMPT â€” AUTHORITATIVE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // HARD CONSTRAINT: First cover MUST use Assembly List object
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // COVER OBJECT SELECTION RULES (NON-NEGOTIABLE):
      //
      // 1. FIRST COVER for any story MUST select focal object EXCLUSIVELY
      //    from the ASSEMBLY_OBJECTS list below.
      //
      // 2. Do NOT invent, substitute, or symbolize objects on first exposure.
      //
      // 3. Object invention is ONLY allowed if ALL of these are true:
      //    a) User has already seen at least one Assembly List object
      //    b) No remaining Assembly List object fits world/tone/genre
      //    c) Invented object does not contradict prior visual canon
      //
      // 4. If no Assembly List object fits well on first generation:
      //    SELECT THE CLOSEST VIABLE ASSEMBLY LIST OBJECT ANYWAY.
      //    This is visibility-gated fallback, NOT free creative choice.
      //
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const world = frozenIntent.world || 'modern';
      const genre = frozenIntent.genre || 'romance';
      const tone = frozenIntent.tone || 'romantic';
      const rawTitle = frozenIntent.title?.trim() || '';
      const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';

      // Track if this is the first cover for this story
      const isFirstCover = !state._coverAssemblyObjectShown;

      // APPROVED ASSEMBLY LIST â€” Select ONE object based on world/genre
      // These are the ONLY valid choices for first cover generation
      const ASSEMBLY_OBJECTS = {
          modern: ['vintage key', 'silk ribbon', 'pearl earring', 'champagne glass', 'red lipstick', 'leather journal', 'single rose', 'antique locket'],
          fantasy: ['ornate dagger', 'crystal vial', 'wax-sealed letter', 'jeweled crown', 'silver mask', 'enchanted mirror', 'golden chalice', 'raven feather'],
          historical: ['quill pen', 'pocket watch', 'cameo brooch', 'candelabra', 'love letter', 'silk fan', 'brass compass', 'velvet glove'],
          scifi: ['holographic card', 'chrome ring', 'data chip', 'neural interface', 'crystal shard', 'metallic rose', 'quantum locket', 'star map'],
          paranormal: ['blood vial', 'moonstone pendant', 'black candle', 'silver dagger', 'tarot card', 'obsidian mirror', 'wolf fang', 'crimson ribbon']
      };

      // Select object list based on world, default to modern
      const worldKey = world.toLowerCase().includes('fantasy') ? 'fantasy'
          : world.toLowerCase().includes('histor') ? 'historical'
          : world.toLowerCase().includes('sci') ? 'scifi'
          : world.toLowerCase().includes('paranormal') || world.toLowerCase().includes('vampire') ? 'paranormal'
          : 'modern';

      const objectList = ASSEMBLY_OBJECTS[worldKey];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // OBJECT SELECTION â€” HARD CONSTRAINT ENFORCED
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let selectedObject;

      if (isFirstCover) {
          // FIRST COVER: Must use Assembly List object â€” no exceptions
          selectedObject = objectList[Math.floor(Math.random() * objectList.length)];
          console.log('[COVER:v1] FIRST COVER â€” Assembly object REQUIRED:', selectedObject);
      } else if (state._coverAssemblyObject && objectList.includes(state._coverAssemblyObject)) {
          // SUBSEQUENT COVER: Prefer previously shown Assembly object for visual canon consistency
          selectedObject = state._coverAssemblyObject;
          console.log('[COVER:v1] SUBSEQUENT COVER â€” Reusing canonical object:', selectedObject);
      } else {
          // SUBSEQUENT COVER with different world: Select new Assembly object
          selectedObject = objectList[Math.floor(Math.random() * objectList.length)];
          console.log('[COVER:v1] SUBSEQUENT COVER (world change) â€” New Assembly object:', selectedObject);
      }

      // Record Assembly object in state for visual canon tracking
      state._coverAssemblyObjectShown = true;
      state._coverAssemblyObject = selectedObject;
      state._coverWorldKey = worldKey;

      console.log('[COVER:v1] Assembly object selected:', selectedObject, 'from', worldKey, '| isFirstCover:', isFirstCover);

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSIONAL â€” FOCAL OBJECT ALTERATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let focalObjectDescription = selectedObject;

      if (tone === 'Wry Confessional') {
          const alteration =
              WRY_CONFESSIONAL_OBJECT_ALTERATIONS[
                  Math.floor(Math.random() * WRY_CONFESSIONAL_OBJECT_ALTERATIONS.length)
              ];
          focalObjectDescription = `${selectedObject}, ${alteration}`;
          console.log('[COVER:v1] Wry Confessional object alteration:', focalObjectDescription);
      }

      // ASSEMBLY-COMPLIANT PROMPT
      const minimalPrompt = `BOOK COVER IMAGE â€” ASSEMBLY SYSTEM

TASK: Generate a complete, print-ready book cover composition.

TITLE (must appear prominently): "${title}"
AUTHOR LINE (must appear below title): "by S. Tory Bound"

FOCAL OBJECT (MANDATORY â€” exactly ONE):
${focalObjectDescription}

ABSOLUTE RULES:
- NO people, NO faces, NO figures anywhere in the image
- A subtle human SHADOW is allowed but must be secondary
- ONLY the specified object above â€” do NOT add other objects
- Do NOT invent new symbols or combine multiple objects
- Do NOT depict narrative action
- Full cover must be visible edge-to-edge
- Do NOT crop, zoom, or trim the composition
- Title-safe margins at top and bottom
- Design for vertical book cover proportions (5:7)

COMPOSITION:
- The ${focalObjectDescription} is the visual anchor, rendered clearly and symbolically
- Title text: large, high contrast, readable at thumbnail size
- Author line: smaller, elegant, below the title
${tone === 'Wry Confessional'
  ? '- Simple flat background\n- No vignette, no texture overlay'
  : '- Subtle vignette darkening at edges\n- Light paper or canvas texture overlay'}

STYLE:
${stageModifier ? stageModifier + '\n' : ''}${tone === 'Wry Confessional'
  ? WRY_CONFESSIONAL_VISUAL_ONTOLOGY
  : `Elegant, restrained, cinematic. Painterly realism, NOT illustration. Premium published novel aesthetic. Rich but muted color palette appropriate to ${tone} ${genre}.`}

${tone === 'Wry Confessional' ? '' : `WORLD MATERIAL TREATMENT (${worldKey}):
${worldKey === 'fantasy' ? '- Aged stone, tarnished metal, worn fabric textures' :
  worldKey === 'historical' ? '- Wood, brass, parchment, oil-stained cloth textures' :
  worldKey === 'scifi' ? '- Brushed alloy, polymer, subtle luminescence' :
  worldKey === 'paranormal' ? '- Dark velvet, oxidized silver, candlelit warmth' :
  '- Concrete, glass, leather, modern luxury textures'}
`}FORBIDDEN:
- NO glow effects or floating particles
- NO decorative borders or frames
- NO AI art clichÃ©s (no ethereal wisps, no magical sparkles)
- NO logos, icons, or UI-style graphics
- NO multiple objects or busy compositions
- NO characters or body parts (except subtle shadow)
${tone === 'Wry Confessional'
  ? '- NO cinematic lighting\n- NO painterly texture\n- NO dramatic shadows\n- NO realism\n- NO noir aesthetic'
  : '- NO visual punchlines\n- NO exaggerated contrast\n- NO theatrical or ironic staging'}

${tone === 'Wry Confessional'
  ? 'The final image must look like a New Yorker editorial cartoon â€” simple, flat, understated.'
  : 'The final image must look like a real published novel cover â€” tasteful, evocative, professional.'}`;

      console.log('[COVER:v1] Minimal prompt generated (', minimalPrompt.length, 'chars)');

      // REGRESSION GUARD: Block cinematic drift for Wry Confessional
      assertWryConfessionalVisual(minimalPrompt, 'generateMinimalCoverV1');

      try {
          // ONE API call â€” no retries, no fallbacks, no enhancement layers
          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: minimalPrompt,
                  imageIntent: 'book_cover',
                  size: '1024x1536', // 5:7 portrait ratio (book cover canonical)
                  // Minimal metadata â€” no coverIntel, no archetype, no layers
                  _minimalV1: true // Backend flag to skip all enhancement
              })
          });

          if (!res.ok) {
              console.error('[COVER:v1] API error:', res.status);
              return null;
          }

          const data = await res.json();
          const imageUrl = data?.url || null;

          if (imageUrl) {
              console.log('[COVER:v1] SUCCESS â€” Image received');
          } else {
              console.warn('[COVER:v1] No image URL in response');
          }

          return imageUrl;

      } catch (err) {
          console.error('[COVER:v1] Fetch error:', err.message);
          return null;
      }
  }

  // ============================================================
  // PHYSICAL BOOK INTERACTION SYSTEM
  // Hinge-based open, courtesy peek, no buttons
  // ============================================================
  // ğŸ”´ OPENING BOOK SYSTEM â€” DISABLED FOR STABILIZATION
  // ============================================================
  // The opening book system is temporarily disabled to stabilize:
  // - Cover rendering
  // - Reader navigation
  // - Async flow
  //
  // When USE_OPENING_BOOK = false:
  // - Cover renders as plain full-screen image (no transforms/mirroring)
  // - Navigation is linear: COVER â†’ SETTING â†’ SCENE
  // - Back: SCENE â†’ SETTING â†’ COVER
  // - No book animations, no page flips, no inside cover
  // ============================================================
  const USE_OPENING_BOOK = false; // KILL SWITCH â€” set to true to re-enable book system

  const COURTESY_HINGE_KEY = 'storybound_courtesy_hinge_shown';
  let _courtesyHingeTimeout = null;
  let _bookOpened = false;
  let _settingImagePromise = Promise.resolve(); // Gate for opening spread readiness (disabled)

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BACKGROUND STORY LOADING â€” Story text generation promise
  // Resolves when Scene 1 text is mounted and ready for display
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _storyTextPromise = null;
  let _storyTextResolver = null;

  function initStoryTextPromise() {
      _storyTextPromise = new Promise(resolve => {
          _storyTextResolver = resolve;
      });
  }

  function resolveStoryTextReady() {
      if (_storyTextResolver) {
          console.log('[STORY:READY] Scene 1 text mounted â€” story ready for display');
          _storyTextResolver(true);
          _storyTextResolver = null;
      }
  }

  // SIMPLIFIED PAGE STATE (when book disabled)
  // 0 = COVER, 1 = SETTING, 2+ = SCENE
  let _readerPage = 0;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // REUSABLE PAGE-CURL TRANSITION COMPONENT
  // Curls a .sb-curl-page element (right edge lifts, page turns left)
  // revealing whatever is beneath it. Blank parchment backside.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * applyPageCurlTransition(curlEl, options)
   * @param {HTMLElement} curlEl  - A .sb-curl-page element to curl away
   * @param {Object}      options
   * @param {Function}    options.onComplete  - Called after curl finishes & element is hidden
   * @param {number}      options.timeout     - Safety timeout ms (default 950)
   */
  function applyPageCurlTransition(curlEl, options = {}) {
      const { onComplete, timeout = 950 } = options;
      if (!curlEl) { if (onComplete) onComplete(); return; }
      const inner = curlEl.querySelector('.sb-curl-page-inner');
      if (!inner) { if (onComplete) onComplete(); return; }

      // Mark parent for edge-shadow visibility
      curlEl.classList.add('sb-curling');
      inner.classList.add('sb-page-curl');

      let settled = false;
      const settle = () => {
          if (settled) return;
          settled = true;
          inner.removeEventListener('animationend', settle);
          curlEl.classList.add('hidden');
          curlEl.classList.remove('sb-curling');
          inner.classList.remove('sb-page-curl');
          if (onComplete) onComplete();
      };
      inner.addEventListener('animationend', settle, { once: true });

      // Safety timeout
      setTimeout(settle, timeout);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TITLE PAGE â€” Universal book-jacket front page (all stories)
  // Chain: Title â†’ Map (Fantasy) / Setting (non-Fantasy) â†’ Scene 1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window._titlePageActive = false;

  function showTitlePage() {
      const el = document.getElementById('sbTitlePage');
      if (!el) return;

      // Populate title
      const titleEl = el.querySelector('.sb-title-page-title');
      const storyTitle = document.getElementById('storyTitle')?.textContent || state.story?.title || 'Untitled';
      if (titleEl) titleEl.textContent = storyTitle.replace(/"/g, '');

      // Populate subhead (e.g. "In the world of ...")
      const subheadEl = el.querySelector('.sb-title-page-subhead');
      if (subheadEl) {
          if (state.book_subhead) {
              subheadEl.textContent = state.book_subhead;
              subheadEl.classList.remove('hidden');
          } else {
              subheadEl.textContent = '';
              subheadEl.classList.add('hidden');
          }
      }

      // Populate blurb (prefer pre-gen synopsis â€” shorter/tighter â€” fall back to blurb)
      const blurbEl = el.querySelector('.sb-title-page-blurb');
      if (blurbEl) {
          const raw = state._synopsisMetadata || state._synopsisBlurb || '';
          if (raw) {
              // Convert plain text paragraphs to <p> tags
              blurbEl.innerHTML = raw.split(/\n\s*\n|\n/).filter(p => p.trim()).map(p =>
                  '<p>' + p.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</p>'
              ).join('');
          } else {
              blurbEl.innerHTML = '';
          }
      }

      // Reset curl state and show
      const inner = el.querySelector('.sb-curl-page-inner');
      if (inner) inner.classList.remove('sb-page-curl');
      el.classList.remove('hidden', 'sb-curling');

      // Hide everything behind title page
      const storyText = document.getElementById('storyText');
      if (storyText) storyText.classList.add('hidden');
      const settingPlate = document.getElementById('settingPlate');
      if (settingPlate) settingPlate.classList.add('hidden');
      const frontispiece = document.getElementById('fatelandsFrontispiece');
      if (frontispiece) frontispiece.classList.add('hidden');

      window._titlePageActive = true;
      state._titlePageShown = true;

      const indicator = document.getElementById('pageIndicator');
      if (indicator) indicator.textContent = 'Title';
      const prevBtn = document.getElementById('prevPageBtn');
      const nextBtn = document.getElementById('nextPageBtn');
      if (prevBtn) prevBtn.disabled = true;
      if (nextBtn) nextBtn.disabled = false;
      console.log('[TITLE-PAGE] Shown');
  }

  window.dismissTitlePage = function(onComplete) {
      const el = document.getElementById('sbTitlePage');
      if (!el || !window._titlePageActive) { if (onComplete) onComplete(); return; }
      window._titlePageActive = false;

      applyPageCurlTransition(el, {
          onComplete: function() {
              const isFantasy = state.picks?.world === 'Fantasy';

              if (isFantasy && !state._fantasyMapInjected) {
                  // Fantasy â†’ reveal map frontispiece
                  showFatelandsFrontispiece();
                  state._fantasyMapInjected = true;
                  console.log('[TITLE-PAGE] Curled â†’ map frontispiece revealed');
              } else {
                  // Non-Fantasy (or map already shown) â†’ try setting plate, then scene
                  _revealSettingOrScene();
              }
              if (onComplete) onComplete();
          }
      });
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FATELANDS FRONTISPIECE â€” Canonical map page for Fantasy stories
  // Shows after Title page, before Setting/Scene 1
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window._frontispieceActive = false;

  function showFatelandsFrontispiece() {
      const el = document.getElementById('fatelandsFrontispiece');
      if (!el) return;
      const inner = el.querySelector('.sb-curl-page-inner');
      if (inner) inner.classList.remove('sb-page-curl');
      el.classList.remove('hidden', 'sb-curling');
      // Hide scene content while frontispiece is showing
      const storyText = document.getElementById('storyText');
      if (storyText) storyText.classList.add('hidden');
      const settingPlate = document.getElementById('settingPlate');
      if (settingPlate) settingPlate.classList.add('hidden');
      window._frontispieceActive = true;
      const indicator = document.getElementById('pageIndicator');
      if (indicator) indicator.textContent = 'Map';
      const prevBtn = document.getElementById('prevPageBtn');
      const nextBtn = document.getElementById('nextPageBtn');
      if (prevBtn) prevBtn.disabled = true;
      if (nextBtn) nextBtn.disabled = false;
      console.log('[FRONTISPIECE] Fatelands map shown');
  }

  window.dismissFatelandsFrontispiece = function(onComplete) {
      const el = document.getElementById('fatelandsFrontispiece');
      if (!el || !window._frontispieceActive) { if (onComplete) onComplete(); return; }
      window._frontispieceActive = false;

      applyPageCurlTransition(el, {
          onComplete: function() {
              _revealSettingOrScene();
              if (onComplete) onComplete();
          }
      });
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SETTING PLATE CURL â€” Curls setting image to reveal Scene 1 text
  // Works for ALL worlds (Fantasy after map, others after title)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window._settingPlateActive = false;

  window.dismissSettingPlate = function(onComplete) {
      const el = document.getElementById('settingPlate');
      if (!el || !window._settingPlateActive) { if (onComplete) onComplete(); return; }
      window._settingPlateActive = false;

      applyPageCurlTransition(el, {
          onComplete: function() {
              const storyText = document.getElementById('storyText');
              if (storyText) storyText.classList.remove('hidden');
              _restorePageIndicator();
              console.log('[SETTING-CURL] Setting plate curled â†’ scene text revealed');
              if (onComplete) onComplete();
          }
      });
  };

  /**
   * showSettingPlateAsCurlPage() â€” Show the setting plate as a curl page
   * before Scene 1 (only if a setting image is loaded).
   */
  function showSettingPlateAsCurlPage() {
      const settingPlate = document.getElementById('settingPlate');
      const sceneImg = document.getElementById('bookSceneImg');
      if (!settingPlate || !sceneImg) return false;
      const hasImage = sceneImg.src && sceneImg.src !== '' && sceneImg.src !== window.location.href;
      if (!hasImage) return false;

      settingPlate.classList.remove('hidden');
      const inner = settingPlate.querySelector('.sb-curl-page-inner');
      if (inner) inner.classList.remove('sb-page-curl');
      settingPlate.classList.remove('sb-curling');
      window._settingPlateActive = true;

      const storyText = document.getElementById('storyText');
      if (storyText) storyText.classList.add('hidden');

      const indicator = document.getElementById('pageIndicator');
      if (indicator) indicator.textContent = 'Setting';
      console.log('[SETTING-CURL] Setting plate shown as curl page');
      return true;
  }

  /**
   * _revealSettingOrScene() â€” After map curl (Fantasy) or title curl (non-Fantasy),
   * show setting plate if image exists, otherwise show scene text directly.
   */
  function _revealSettingOrScene() {
      const settingPlate = document.getElementById('settingPlate');
      const sceneImg = document.getElementById('bookSceneImg');
      const hasSettingImage = sceneImg && sceneImg.src && sceneImg.src !== '' && sceneImg.src !== window.location.href;

      if (hasSettingImage) {
          if (settingPlate) {
              settingPlate.classList.remove('hidden');
              const spInner = settingPlate.querySelector('.sb-curl-page-inner');
              if (spInner) spInner.classList.remove('sb-page-curl');
              settingPlate.classList.remove('sb-curling');
          }
          window._settingPlateActive = true;
          const indicator = document.getElementById('pageIndicator');
          if (indicator) indicator.textContent = 'Setting';
          console.log('[CURL-CHAIN] â†’ setting plate revealed');
      } else {
          const storyText = document.getElementById('storyText');
          if (storyText) storyText.classList.remove('hidden');
          _restorePageIndicator();
          console.log('[CURL-CHAIN] â†’ scene text revealed (no setting image)');
      }
  }

  /** Restore page indicator to pagination state */
  function _restorePageIndicator() {
      if (typeof StoryPagination !== 'undefined') {
          const idx = StoryPagination.getCurrentPageIndex();
          const count = StoryPagination.getPageCount();
          const indicator = document.getElementById('pageIndicator');
          if (indicator) indicator.textContent = `Page ${idx + 1} of ${count}`;
      }
  }

  // IDs of elements hidden during synopsis page (no fate cards, no inputs)
  const _SYNOPSIS_PAGE_HIDE_IDS = [
      'fateCardHeader', 'cardMount', 'actionWrapper', 'dialogueWrapper',
      'submitBtn', 'saveBtn', 'gameIntensity', 'edgeCovenantBtn',
      'fortuneBalanceDisplay', 'vizSceneBtn', 'pageNavControls'
  ];

  /**
   * SIMPLIFIED READER PAGE DISPLAY (when book disabled)
   * Linear flow: 0=COVER, 1=SYNOPSIS, 2+=SCENE
   */
  function showReaderPage(page) {
      _readerPage = page;
      console.log('[READER] showReaderPage:', page);

      const bookCoverPage = document.getElementById('bookCoverPage');
      const settingPlate = document.getElementById('settingPlate');
      const storyContent = document.getElementById('storyContent');
      const bookCover = document.getElementById('bookCover');

      // Remove any book animation classes
      if (bookCover) {
          bookCover.classList.remove('hinge-open', 'courtesy-peek');
      }

      if (page === 0) {
          // COVER: Show cover only
          if (bookCoverPage) bookCoverPage.classList.remove('hidden');
          if (storyContent) storyContent.classList.add('hidden');
          console.log('[READER] Page 0: COVER (static full-screen)');

      } else if (page === 1) {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SYNOPSIS PAGE: 5x7 book page with title, synopsis, setting image
          // No fate cards, no petition, no action inputs â€” only Next button
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          if (storyContent) storyContent.classList.remove('hidden');

          const storyText = document.getElementById('storyText');
          const curlChainActive = window._titlePageActive || window._frontispieceActive || window._settingPlateActive;
          if (storyText) {
              storyText.classList.add('synopsis-page-active');
              // Don't reveal storyText while title/frontispiece/setting curl chain is active
              // â€” the curl chain's _revealSettingOrScene() will unhide it when done
              if (!curlChainActive) {
                  storyText.style.opacity = '1';
                  storyText.classList.remove('hidden');
              }
          }

          // Show synopsis
          const sceneSynopsis = document.getElementById('sceneSynopsis');
          if (sceneSynopsis) {
              const synText = state._synopsisMetadata || state._synopsisBlurb || '';
              if (synText) sceneSynopsis.textContent = synText;
              sceneSynopsis.classList.remove('hidden');
          }

          // Update scene label to "Synopsis"
          const sceneNum = document.getElementById('sceneNumber');
          if (sceneNum) sceneNum.textContent = 'Synopsis';

          // Show setting image if available
          const sceneImg = document.getElementById('bookSceneImg');
          if (settingPlate && sceneImg && sceneImg.src && sceneImg.src !== '' && sceneImg.src !== window.location.href) {
              settingPlate.classList.remove('hidden');
              settingPlate.classList.add('synopsis-setting-plate');
          } else if (settingPlate) {
              settingPlate.classList.add('hidden');
          }

          // Hide fate cards, inputs, buttons â€” only Next survives
          _SYNOPSIS_PAGE_HIDE_IDS.forEach(id => {
              const el = document.getElementById(id);
              if (el) el.classList.add('hidden');
          });

          // Show page-level Next button
          const nextBtn = document.getElementById('nextPageBtn');
          if (nextBtn) { nextBtn.disabled = false; nextBtn.classList.remove('hidden'); }
          const pageNav = document.getElementById('pageNavControls');
          if (pageNav) pageNav.classList.remove('hidden');
          const prevBtn = document.getElementById('prevPageBtn');
          if (prevBtn) prevBtn.classList.add('hidden');
          const indicator = document.getElementById('pageIndicator');
          if (indicator) indicator.textContent = 'Synopsis';

          // Hide story prose container
          const pagesContainer = document.getElementById('storyPagesContainer');
          if (pagesContainer) pagesContainer.classList.add('hidden');

          console.log('[READER] Page 1: SYNOPSIS');

      } else {
          // SCENE 2+: Show story content with inline setting image
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          if (storyContent) storyContent.classList.remove('hidden');

          const storyText = document.getElementById('storyText');
          const curlChainActive = window._titlePageActive || window._frontispieceActive || window._settingPlateActive;
          if (storyText) {
              storyText.style.opacity = '1';
              storyText.classList.remove('hidden', 'synopsis-page-active');
          }

          // Restore scene number
          const sceneNum = document.getElementById('sceneNumber');
          if (sceneNum) sceneNum.textContent = `Scene ${state.turnCount || 1}`;

          // Hide synopsis text, show prose
          const sceneSynopsis = document.getElementById('sceneSynopsis');
          if (sceneSynopsis) sceneSynopsis.classList.add('hidden');

          const pagesContainer = document.getElementById('storyPagesContainer');
          if (pagesContainer) pagesContainer.classList.remove('hidden');

          if (settingPlate && !curlChainActive) {
              settingPlate.classList.add('hidden');
              settingPlate.classList.remove('synopsis-setting-plate');
          }

          // Restore fate cards, inputs, buttons
          _SYNOPSIS_PAGE_HIDE_IDS.forEach(id => {
              const el = document.getElementById(id);
              if (el) el.classList.remove('hidden');
          });

          // Restore page navigation
          const prevBtn = document.getElementById('prevPageBtn');
          if (prevBtn) prevBtn.classList.remove('hidden');

          precomputeVizPrompt();

          console.log('[READER] Page 2+: SCENE (Title + Prose)');
      }
  }

  /**
   * C. PRECOMPUTE VISUALIZE PROMPT â€” Pre-fill prompt input when scene mounts
   * Non-blocking: runs in background, does not delay scene display
   */
  async function precomputeVizPrompt() {
      const promptInput = document.getElementById('vizPromptInput');
      if (!promptInput) return;

      // Don't overwrite if user has already edited
      if (promptInput.value.trim()) return;

      const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      if (!allStoryContent.trim()) return;

      const lastText = allStoryContent.slice(-600) || "";

      try {
          // Wry Confessional: Direct ontology-based prompt (no LLM call)
          if (state.picks?.tone === 'Wry Confessional') {
              const condensedScene = condenseSceneObservational(lastText, 120);
              promptInput.value = `${WRY_CONFESSIONAL_VISUAL_ONTOLOGY} Scene: ${condensedScene}`;
              console.log('[VIZ:PREFILL] Wry Confessional prompt precomputed');
              return;
          }

          // Standard: LLM generates prompt
          await ensureVisualBible(allStoryContent);
          const anchorText = buildVisualAnchorsText();
          const visualizePrompt = buildVisualizePrompt({ mode: 'scene', lastText, anchorText });

          const promptMsg = await Promise.race([
              callChat([{ role: 'user', content: visualizePrompt }]),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Prefill timeout")), 15000))
          ]);

          // Only set if still empty (user may have started editing)
          if (!promptInput.value.trim()) {
              promptInput.value = promptMsg;
              console.log('[VIZ:PREFILL] Standard prompt precomputed');
          }
      } catch (e) {
          console.log('[VIZ:PREFILL] Failed (non-critical):', e.message);
          // Non-blocking failure â€” prompt will be generated when modal opens
      }
  }

  /**
   * ADVANCE TO NEXT READER PAGE (when book disabled)
   * Called when user clicks to continue.
   */
  function advanceReaderPage() {
      const nextPage = _readerPage + 1;
      showReaderPage(nextPage);
  }

  // Check if courtesy hinge has already been shown (one-time ever)
  function hasSeenCourtesyHinge() {
      try {
          return localStorage.getItem(COURTESY_HINGE_KEY) === 'true';
      } catch (e) {
          return false;
      }
  }

  // Mark courtesy hinge as shown
  function markCourtesyHingeShown() {
      try {
          localStorage.setItem(COURTESY_HINGE_KEY, 'true');
      } catch (e) {
          // localStorage unavailable
      }
  }

  // Schedule courtesy hinge (2-3 seconds after cover shows)
  function scheduleCourtesyHinge() {
      // BOOK SYSTEM DISABLED â€” no courtesy hinge
      if (!USE_OPENING_BOOK) return;

      if (hasSeenCourtesyHinge() || _bookOpened) return;

      _courtesyHingeTimeout = setTimeout(() => {
          if (_bookOpened) return; // User already opened

          const bookCover = document.getElementById('bookCover');
          if (bookCover) {
              bookCover.classList.add('courtesy-peek');
              markCourtesyHingeShown();

              // Remove class after animation completes
              setTimeout(() => {
                  bookCover.classList.remove('courtesy-peek');
              }, 2100);
          }
      }, 2500);
  }

  // Cancel courtesy hinge if user clicks
  function cancelCourtesyHinge() {
      if (_courtesyHingeTimeout) {
          clearTimeout(_courtesyHingeTimeout);
          _courtesyHingeTimeout = null;
      }
  }

  // ============================================================
  // BOOK PAGE TYPE DEFINITIONS (Authoritative Spec)
  // ============================================================
  // Page sequence: COVER (0) â†’ INSIDE_COVER (1) â†’ SCENE (2+)
  // Each page type has strict content rules.
  const BOOK_PAGE_TYPES = {
      COVER: 'cover',              // Page 0: Front cover visual only (no text)
      INSIDE_COVER: 'inside_cover', // Page 1: Title + synopsis (NO image generation)
      SCENE: 'scene'               // Page 2+: Scene text (setting image INLINE if present)
  };

  // BOOK PAGE STATE MACHINE
  // Explicit page index â€” NOT boolean flags
  let _bookPageIndex = 0; // 0=cover, 1=inside_cover, 2+=scene

  /**
   * Set the current book page with explicit visibility control.
   * Each page type has ONE valid render state.
   * @param {number} pageIndex - 0=cover, 1=setting, 2=scene
   */
  function setBookPage(pageIndex) {
      const oldIndex = _bookPageIndex;
      _bookPageIndex = pageIndex;
      console.log('[DEBUG PAGE STATE] setBookPage:', oldIndex, 'â†’', pageIndex);

      const bookCoverPage = document.getElementById('bookCoverPage');
      const bookCover = document.getElementById('bookCover');
      const storyContent = document.getElementById('storyContent');
      const settingPlate = document.getElementById('settingPlate');
      const storyTitle = document.getElementById('storyTitle');
      const sceneNumber = document.getElementById('sceneNumber');
      const storyText = document.getElementById('storyText');

      // Reset all visibility first
      if (bookCoverPage) bookCoverPage.classList.remove('hidden', 'page-flip-out');
      if (storyContent) storyContent.classList.remove('hidden', 'fade-in');
      if (settingPlate) settingPlate.classList.remove('hidden', 'setting-active');
      if (storyTitle) storyTitle.classList.remove('hidden');
      if (sceneNumber) sceneNumber.classList.remove('hidden');
      if (storyText) storyText.classList.remove('hidden');

      // Apply page-specific visibility
      if (pageIndex === 0) {
          // PAGE 0: COVER â€” Only cover visible
          console.log('[DEBUG PAGE CLASSIFY] decision=COVER, pageIndex=', pageIndex);
          if (bookCoverPage) bookCoverPage.classList.remove('hidden');
          if (storyContent) storyContent.classList.add('hidden');
          if (settingPlate) settingPlate.classList.add('hidden');
          console.log('[BookPage] Page 0: COVER');
      } else if (pageIndex === 1) {
          // PAGE 1: INSIDE_COVER â€” Title + synopsis (NO image generation)
          console.log('[DEBUG PAGE CLASSIFY] decision=INSIDE_COVER, pageIndex=', pageIndex);
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          // Show inside cover content area
          const insideCover = document.getElementById('bookInsideCover');
          if (insideCover) insideCover.classList.remove('hidden');
          // Hide story content and setting plate on inside cover
          if (storyContent) storyContent.classList.add('hidden');
          if (settingPlate) settingPlate.classList.add('hidden');
          console.log('[BookPage] Page 1: INSIDE_COVER');
      } else if (pageIndex >= 2) {
          // PAGE 2+: SCENE â€” Scene text with setting image INLINE (not fullscreen)
          console.log('[DEBUG PAGE CLASSIFY] decision=SCENE, pageIndex=', pageIndex);
          if (bookCoverPage) bookCoverPage.classList.add('hidden');
          // Hide inside cover
          const insideCover = document.getElementById('bookInsideCover');
          if (insideCover) insideCover.classList.add('hidden');
          // Show story content
          if (storyContent) storyContent.classList.remove('hidden');
          // Setting plate should be INLINE within storyContent, not fullscreen
          // Only show if scene 1 and setting image exists
          if (settingPlate && pageIndex === 2) {
              settingPlate.classList.remove('hidden');
              settingPlate.classList.add('setting-inline'); // Inline mode, not fullscreen
          } else if (settingPlate) {
              settingPlate.classList.add('hidden');
          }
          // Show title and scene
          if (storyTitle) storyTitle.classList.remove('hidden');
          if (sceneNumber) sceneNumber.classList.remove('hidden');
          if (storyText) {
              storyText.classList.remove('hidden');
              storyText.style.opacity = '1';
          }
          console.log('[BookPage] Page 2+: SCENE');
      }

      // Validate page integrity
      const flowCheck = validateBookFlowIntegrity();
      if (!flowCheck.valid) {
          console.error('[BookPage] INTEGRITY FAIL at page ' + pageIndex, flowCheck.errors);
      }
  }

  /**
   * Advance to the next book page with appropriate transition.
   */
  function advanceBookPage() {
      const nextPage = _bookPageIndex + 1;
      const currentType = _bookPageIndex === 0 ? 'cover' : _bookPageIndex === 1 ? 'inside_cover' : 'scene';
      const nextType = nextPage === 0 ? 'cover' : nextPage === 1 ? 'inside_cover' : 'scene';
      console.log('[DEBUG PAGE MOUNT] advanceBookPage: current=', _bookPageIndex, '(' + currentType + ') â†’ next=', nextPage, '(' + nextType + ')');
      setBookPage(nextPage);
  }

  /**
   * Go back to previous book page.
   * Returns true if navigated within book, false if at cover (should exit book).
   */
  function previousBookPage() {
      if (_bookPageIndex <= 0) {
          return false; // At cover, can't go back within book
      }
      const prevPage = _bookPageIndex - 1;
      const currentType = _bookPageIndex === 0 ? 'cover' : _bookPageIndex === 1 ? 'inside_cover' : 'scene';
      const prevType = prevPage === 0 ? 'cover' : prevPage === 1 ? 'inside_cover' : 'scene';
      console.log('[DEBUG PAGE MOUNT] previousBookPage: current=', _bookPageIndex, '(' + currentType + ') â†’ prev=', prevPage, '(' + prevType + ')');
      setBookPage(prevPage);
      return true;
  }

  /**
   * VALIDATION GUARD: Book flow integrity check
   * Ensures page content rules are not violated.
   * Returns { valid: true } or { valid: false, error: string, violation: string }
   */
  function validateBookFlowIntegrity() {
      const errors = [];
      console.log('[DEBUG PAGE STATE] validateBookFlowIntegrity: _bookPageIndex=', _bookPageIndex);

      // CHECK 1: Inside cover (page 1) must have title+synopsis text, but NO generated images
      const insideCover = document.getElementById('bookInsideCover');
      if (_bookPageIndex === 1 && insideCover) {
          const hasGeneratedImages = insideCover.querySelectorAll('img:not(.decorative)').length > 0;
          const hasTitle = !!insideCover.querySelector('.inside-cover-title');
          const hasSynopsis = !!insideCover.querySelector('.inside-cover-synopsis');
          console.log('[DEBUG PAGE STATE] insideCover check: hasTitle=', hasTitle, 'hasSynopsis=', hasSynopsis, 'hasGeneratedImages=', hasGeneratedImages);
          if (hasGeneratedImages) {
              errors.push({ code: 'INSIDE_COVER_HAS_IMAGES', message: 'Inside cover contains generated images (should be text only)' });
          }
          if (!hasTitle) {
              errors.push({ code: 'INSIDE_COVER_MISSING_TITLE', message: 'Inside cover missing title' });
          }
          if (!hasSynopsis) {
              errors.push({ code: 'INSIDE_COVER_MISSING_SYNOPSIS', message: 'Inside cover missing synopsis' });
          }
      }

      // CHECK 2: On page 2 (Scene 1), setting image should be INLINE, not fullscreen
      const settingPlate = document.getElementById('settingPlate');
      if (_bookPageIndex === 2 && settingPlate && !settingPlate.classList.contains('hidden')) {
          if (!settingPlate.classList.contains('setting-inline')) {
              errors.push({ code: 'SETTING_NOT_INLINE', message: 'Setting plate should be inline on Scene 1, not fullscreen' });
          }
      }

      // CHECK 3: On page 3+, setting plate MUST be hidden (only Scene 1 has setting image)
      if (_bookPageIndex > 2 && settingPlate && !settingPlate.classList.contains('hidden')) {
          errors.push({ code: 'SETTING_VISIBLE_AFTER_SCENE1', message: 'Setting plate visible after Scene 1 (page ' + _bookPageIndex + ')' });
      }

      // CHECK 4: On page 1 (inside cover), scene content MUST be hidden
      if (_bookPageIndex === 1) {
          const storyContent = document.getElementById('storyContent');
          if (storyContent && !storyContent.classList.contains('hidden')) {
              errors.push({ code: 'SCENE_VISIBLE_ON_INSIDE_COVER', message: 'Scene content visible on inside cover' });
          }
      }

      if (errors.length > 0) {
          console.error('[BOOK FLOW] Integrity violations:', errors);
          return { valid: false, errors };
      }

      return { valid: true };
  }

  // Expose for DevHUD
  window.validateBookFlowIntegrity = validateBookFlowIntegrity;
  window.BOOK_PAGE_TYPES = BOOK_PAGE_TYPES;

  // Open book via hinge animation (triggered by clicking anywhere on book)
  const BOOK_DWELL_MS = 4000; // Time setting page shows before Scene 1

  async function openBook() {
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BOOK SYSTEM DISABLED â€” Use linear flow instead
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (!USE_OPENING_BOOK) {
          console.log('[READER] openBook called but book system disabled â€” using linear flow');
          if (typeof hideDSP === 'function') hideDSP();

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // BACKGROUND STORY LOADING: Await story text with short timeout
          // Story should already be ready (generated in background)
          // Timeout ensures responsiveness even if generation is slow
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const STORY_READY_TIMEOUT_MS = 500; // Short timeout for responsiveness

          if (_storyTextPromise) {
              console.log('[READER] Awaiting story text (max 500ms)...');
              const result = await Promise.race([
                  _storyTextPromise,
                  new Promise(resolve => setTimeout(() => resolve('__TIMEOUT__'), STORY_READY_TIMEOUT_MS))
              ]);

              if (result === '__TIMEOUT__') {
                  console.log('[READER] Story text not ready yet â€” showing Scene 1 anyway');
              } else {
                  console.log('[READER] Story text ready â€” advancing to Scene 1');
              }
          }

          advanceReaderPage();
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BOOK SYSTEM (disabled â€” code preserved for future re-enable)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (_bookOpened) return;
      _bookOpened = true;
      console.log('[DEBUG PAGE MOUNT] openBook: _bookPageIndex=', _bookPageIndex, 'transitioning coverâ†’inside_coverâ†’scene');
      cancelCourtesyHinge();

      const bookCover = document.getElementById('bookCover');

      // Remove any courtesy peek class and start hinge animation
      if (bookCover) {
          bookCover.classList.remove('courtesy-peek');
          bookCover.classList.add('hinge-open'); // Start hinge animation - reveals inside cover
      }

      // STEP 1: Hinge animation plays for 800ms, showing inside cover
      setTimeout(() => {
          // CRITICAL: Force-hide DSP before showing Page 1 (prevents synopsis overlay)
          if (typeof hideDSP === 'function') hideDSP();
          // Verify inside cover is populated (sanity check)
          const insideCover = document.getElementById('bookInsideCover');
          console.log('[DEBUG PAGE STATE] openBook gate: insideCover=', !!insideCover, 'hasTitle=', !!insideCover?.querySelector('.inside-cover-title'), '_bookPageIndex=', _bookPageIndex);
          if (insideCover && !insideCover.querySelector('.inside-cover-title')) {
              console.warn('[BookFlow] Inside cover not populated â€” check story generation');
          }
          setBookPage(1); // Inside cover (title + synopsis, NO image)

          // STEP 2: After dwell, transition to SCENE page (page 2)
          setTimeout(() => {
              // Setting image auto-generation disabled â€” no waiting
              advanceBookPage(); // Transitions to page 2 (scene)

              // BOOK FLOW: Validate integrity after showing Scene 1
              const flowCheck = validateBookFlowIntegrity();
              if (!flowCheck.valid) {
                  console.error('[BOOK FLOW] HARD FAIL: Page integrity violated', flowCheck.errors);
              }

              // Scroll to story title (page 2 content)
              const scrollTarget = document.getElementById('storyTitle');
              if (scrollTarget) {
                  scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }

              // Deactivate Guided Fate visuals after dwell completes
              if (typeof deactivateGuidedFateVisuals === 'function') {
                  deactivateGuidedFateVisuals();
              }
          }, BOOK_DWELL_MS);
      }, 800);
  }

  // Flag: Are we in Cover View mode (using button navigation)?
  let _inCoverViewMode = false;

  window.enterCoverViewMode = () => { _inCoverViewMode = true; };
  window.exitCoverViewMode = () => { _inCoverViewMode = false; };

  // Initialize physical book event listeners
  function initCoverPageListeners() {
      // Click anywhere on book object to open/advance
      // BUT: In Cover View mode, clicks are ignored (use buttons instead)
      const bookObject = document.getElementById('bookObject');
      if (bookObject) {
          bookObject.addEventListener('click', () => {
              if (_inCoverViewMode) {
                  console.log('[COVER:VIEW] In Cover View mode â€” use buttons to navigate');
                  return;
              }
              openBook();
          });
      }

      // Also allow clicking on cover directly (redundant safety)
      const bookCover = document.getElementById('bookCover');
      if (bookCover) {
          bookCover.addEventListener('click', (e) => {
              e.stopPropagation();
              if (_inCoverViewMode) {
                  console.log('[COVER:VIEW] In Cover View mode â€” use buttons to navigate');
                  return;
              }
              openBook();
          });
      }

      // NOTE: Setting plate is now INLINE within Scene 1 (no separate page)
      // No click handler needed â€” setting image is decorative, not navigational
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
          initCoverPageListeners();
          if (window.updateFortuneDisplay) window.updateFortuneDisplay();
          if (typeof updateBeginButtonLabel === 'function') updateBeginButtonLabel();
      });
  } else {
      initCoverPageListeners();
      if (window.updateFortuneDisplay) window.updateFortuneDisplay();
      if (typeof updateBeginButtonLabel === 'function') updateBeginButtonLabel();
  }

  // Reset book state for new story
  function resetBookState() {
      // Reset simplified reader state
      _readerPage = 0;

      // Reset book state (even when disabled, for clean state)
      const oldIndex = _bookPageIndex;
      _bookOpened = false;
      _bookPageIndex = 0; // Reset to cover page
      console.log('[READER] resetBookState: page reset to 0 (COVER)');
      _settingImagePromise = Promise.resolve(); // Reset for new story
      cancelCourtesyHinge();
      resetCoverLayers();
      const bookCover = document.getElementById('bookCover');
      if (bookCover) {
          bookCover.classList.remove('hinge-open', 'courtesy-peek');
      }
      // Reset setting plate visibility
      const settingPlate = document.getElementById('settingPlate');
      if (settingPlate) {
          settingPlate.classList.remove('hidden', 'setting-active', 'page-flip-out');
      }
      // Reset right-page scene art
      const sceneImg = document.getElementById('bookSceneImg');
      const sceneLoading = document.getElementById('bookSceneLoading');
      if (sceneImg) { sceneImg.src = ''; sceneImg.style.display = 'none'; }
      if (sceneLoading) { sceneLoading.style.display = ''; sceneLoading.textContent = 'Conjuring the world\u2026'; }
  }

  // Hide cover page and show story content directly (fallback if cover fails)
  function skipCoverPage() {
      // Stop any running cover loading intervals
      if (_coverPhraseInterval) clearInterval(_coverPhraseInterval);
      if (_coverProgressInterval) clearInterval(_coverProgressInterval);
      cancelCourtesyHinge();

      if (!USE_OPENING_BOOK) {
          // Simplified flow: jump to Scene
          showReaderPage(2);
      } else {
          // Jump directly to scene page (skip setting page for fallback)
          setBookPage(2);
          _bookOpened = true;
      }
  }

  // Expose simplified reader functions globally
  window.showReaderPage = showReaderPage;
  window.advanceReaderPage = advanceReaderPage;
  window.USE_OPENING_BOOK = USE_OPENING_BOOK;
  window.USE_MINIMAL_COVER_V1 = USE_MINIMAL_COVER_V1;

  // --- VISUALIZE (STABILIZED) ---
  let _vizCancelled = false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VISUAL PROMPT LOADING STATE â€” Ellipsis animation for prompt generation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _vizEllipsisInterval = null;

  /**
   * Start ellipsis animation on an input placeholder
   * Cycles: "Generating visual prompt." â†’ ".." â†’ "..."
   * @param {HTMLElement} input - The input element to animate
   * @returns {function} Stop function to call when generation completes
   */
  function startVizEllipsisAnimation(input) {
      if (!input) return () => {};

      const baseText = 'Generating visual prompt';
      let dotCount = 1;

      // Set initial state
      input.value = '';
      input.placeholder = baseText + '.';
      input.style.transition = 'opacity 200ms ease';
      input.style.opacity = '1';

      // Clear any existing interval
      if (_vizEllipsisInterval) clearInterval(_vizEllipsisInterval);

      // Animate ellipsis at 700ms intervals
      _vizEllipsisInterval = setInterval(() => {
          dotCount = (dotCount % 3) + 1;
          input.placeholder = baseText + '.'.repeat(dotCount);
      }, 700);

      // Return stop function with fade transition
      return function stopAnimation(newValue) {
          if (_vizEllipsisInterval) {
              clearInterval(_vizEllipsisInterval);
              _vizEllipsisInterval = null;
          }

          // Fade out, update, fade in
          input.style.opacity = '0';
          setTimeout(() => {
              input.placeholder = 'Edit prompt or add modifiersâ€¦';
              if (newValue !== undefined) input.value = newValue;
              input.style.opacity = '1';
          }, 200);
      };
  }

  // Visualize imagery bias â€” no longer intensity-dependent
  function getVisualizeIntensityBias() {
      return 'Suggestive, flirtatious imagery. Sensual tension without explicit nudity. Tasteful allure.';
  }

  // â”€â”€ Visualize Helpers (Pure Story Shape Reflection) â”€â”€

  function getVisualizeWorldToneBias() {
      const parts = [];
      if (state.picks?.world) parts.push('World: ' + state.picks.world);
      if (state.picks?.tone) parts.push('Tone: ' + state.picks.tone);
      if (state.picks?.genre) parts.push('Genre: ' + state.picks.genre);
      if (state.picks?.dynamic) parts.push('Dynamic: ' + state.picks.dynamic);
      if (state.intensity) parts.push('Intensity: ' + state.intensity);
      return parts.length
          ? parts.join('. ') + '. Render visuals that accurately reflect the story\'s declared world, tone, genre, dynamic, and intensity. Do not add or remove mood.'
          : 'Render visuals that accurately reflect the current story. Do not add or remove mood.';
  }

  function getSceneVisualSignals(text) {
      const signals = [];
      if (/(crowd|gather|audience|spectators|onlookers)\b/i.test(text)) signals.push('Crowd or audience present');
      if (/(alone|solitary|by (her|him|them)self|isolated)\b/i.test(text)) signals.push('Character is alone');
      if (/(touch|grip|press|hold|embrace|hand)\b/i.test(text)) signals.push('Physical contact occurring');
      if (/(sword|blade|weapon|dagger|bow|gun|shield)\b/i.test(text)) signals.push('Weapon present');
      if (/(glance|gaze|stare|watch|eye|look)\b/i.test(text)) signals.push('Directed gaze or eye contact');
      return signals;
  }

  function resolveVisualFocus(text) {
      let focus = 'balanced framing of all present characters';
      if (/(I |my |me |myself)\b/i.test(text)) focus = 'POV-anchored composition favoring the narrator';
      if (/(she step|he step|they step|she move|he move|she turn|he turn|she raise|he raise)\b/i.test(text)) focus = 'focus on the character initiating action';
      if (/(watch|stare at|observe|gaze at|eye.*on)\b/i.test(text)) focus = 'focus on the character being observed';
      if (/(close|breath|whisper|touch|press.*against)\b/i.test(text)) focus = 'intimate proximity framing';
      return focus;
  }

  function resolveCameraDistance(text) {
      let distance = 'medium framing';
      if (/(touch|hand|grip|press|pull|whisper|breath|close|against)\b/i.test(text)) distance = 'close framing';
      if (/(approach|step|turn|face|block|stand before)\b/i.test(text)) distance = 'medium framing';
      if (/(arena|crowd|stadium|hall|city|vast|sprawling|towering)\b/i.test(text)) distance = 'wide framing';
      return distance;
  }

  function resolveLightingCondition(text) {
      let lighting = 'neutral ambient lighting';
      if (/(dark|dim|shadow|night|torch|candle|lantern|flicker|low light)\b/i.test(text)) lighting = 'low-light conditions with limited illumination';
      if (/(spotlight|beam|shaft of light|backlit|rim light|glow from|lit by)\b/i.test(text)) lighting = 'directional lighting with strong highlights and shadow contrast';
      if (/(sunlight|daylight|bright|open sky|well-lit|flooded with light)\b/i.test(text)) lighting = 'even, well-lit conditions with broad visibility';
      return lighting;
  }

  function resolveCompositionDensity(text) {
      let density = 'balanced composition with primary subjects clearly separated from background';
      if (/(alone|single|one of them|isolated|only one)\b/i.test(text)) density = 'sparse composition with a single primary subject';
      if (/(two of them|both|pair|together|between them)\b/i.test(text)) density = 'focused composition centered on a small group';
      if (/(crowd|spectators|many|dozens|packed|surrounding)\b/i.test(text)) density = 'dense composition with multiple figures sharing the frame';
      return density;
  }

  // â”€â”€ Visualize Prompt Builders (routing targets) â”€â”€

  function buildSettingVisualizePrompt() {
      const sWorld = (state.picks && state.picks.world) || 'Unknown';
      const sTone = (state.picks && state.picks.tone) || 'Unknown';
      const sGenre = (state.picks && state.picks.genre) || 'Unknown';
      const sDynamic = (state.picks && state.picks.dynamic) || 'Unknown';
      const sIntensity = state.intensity || 'Unknown';

      return `SETTING VISUAL â€” ESTABLISHING ENVIRONMENT ONLY

WORLD: ${sWorld}
TONE: ${sTone}
GENRE: ${sGenre}
DYNAMIC: ${sDynamic}
INTENSITY: ${sIntensity}

COMPOSITION:
- Wide or architectural establishing view
- Environment-focused, not character-focused
- Spatial layout clearly readable

LIGHTING:
- Appropriate to the declared world and tone
- Natural or ambient sources only

CONTENT RULES:
- Do not depict people, faces, bodies, or interactions
- Do not imply an event, action, or narrative moment
- Do not introduce symbolism or mood beyond what the setting itself conveys
- Objects may be present only as part of the environment, at rest

Render the setting as a neutral, grounded place that could host a story,
but does not depict the story itself.

Return only the visual description.`;
  }

  function buildSceneVisualizePrompt(lastText, anchorText) {
      const intensityBias = getVisualizeIntensityBias();
      const worldToneBias = getVisualizeWorldToneBias();
      const ontologyDirective = getVisualOntologyDirective();
      const sceneSignals = getSceneVisualSignals(lastText);
      const sceneCtx = sceneSignals.length ? '- ' + sceneSignals.join('\n- ') : '- No additional scene constraints';
      const focusDirective = resolveVisualFocus(lastText);
      const cameraDistance = resolveCameraDistance(lastText);
      const lightingCondition = resolveLightingCondition(lastText);
      const compositionDensity = resolveCompositionDensity(lastText);

      // Get protagonist gender for explicit subject declaration
      const protagonistGender = state.gender || 'Female';
      const genderWord = protagonistGender === 'Male' ? 'man' : protagonistGender === 'Non-binary' ? 'person' : 'woman';

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // DEPRECATION NOTICE â€” WRY CONFESSION VISUAL STYLE (v0.x)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Any prior logic, guidance, or prompt assembly that treats
      // Wry Confession as a stylistic modifier (e.g., cartoon, sketch,
      // flat illustration, reduced realism) is deprecated.
      //
      // These approaches caused style blending, photoreal bleed,
      // and cinematic defaults to reassert themselves.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // WRY CONFESSION â€” REPRESENTATIONAL PRECEDENCE (AUTHORITATIVE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // When tone === 'Wry Confession' and intent === 'scene_visualization':
      //
      // - The image must be an editorial illustration, not a photograph.
      // - Genre and world may influence symbolism only, not realism.
      // - Mood and lighting are subordinate to commentary and interpretation.
      //
      // This is a category declaration, not a style modifier.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // WRY CONFESSION â€” SAFETY CLARIFICATION
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // This precedence rule does not apply to:
      // - cover generation
      // - sketch vs thumbnail tiers
      // - non-Wry tones
      //
      // Covers use a separate interpretive regime.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SCENE VISUALIZATION â€” SELF-CHECK (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Before finalizing any Scene Visualization,
      // Claude MUST silently evaluate:
      //
      // "If this image were shown without the text of the scene,
      // would it still clearly express the scene's dramatic irony,
      // awkwardness, or tension â€” not just its setting or mood?"
      //
      // If the honest answer is NO, the visualization must be regenerated.
      //
      // This check is INTERNAL.
      // Do not explain it.
      // Do not soften it.
      // Do not allow lighting, realism, or atmosphere to substitute for idea.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” CANONICAL CAPTION TEMPLATES (VISUALIZER REGIME)
      // TAG: storybound/wry-caption-templates-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // When Tone = Wry Confession, visualizer output must include exactly one of:
      // (A) A single-line caption
      // (B) A single ironic visual contradiction
      //
      // Default preference: Caption
      // Never include both by default.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // CAPTION TEMPLATES (CANONICAL Â· USE AS-IS OR WITH LIGHT VARIATION)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // The caption must implicate the narrator or The Story, not explain the plot.
      //
      // Self-Indicting Rationalization:
      // "I had a system for moments like this, which mostly involved pretending
      //  they were temporary."
      //
      // Delayed Self-Awareness:
      // "This was the point where I would later insist I'd had no real choice."
      //
      // Story-as-Witness (5th Person compatible):
      // "The story briefly considered intervening here, then remembered how
      //  stubborn she could be."
      //
      // HARD CONSTRAINTS:
      // - Caption length: â‰¤ 20 words
      // - No jokes, punchlines, or meta commentary
      // - No explanation of world mechanics
      // - No tone drift into comedy or satire
      // - Caption must undercut, not decorate
      //
      // SUCCESS CONDITION:
      // The image should feel: Observant, slightly embarrassing, quietly self-aware.
      // Not funny. Not dramatic. Wry.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” SENTENCE-LEVEL FLIP (PROSE REGIME)
      // TAG: storybound/wry-sentence-flip-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // Wry Confession prose must include micro-undercuts that quietly undermine
      // the narrator's self-justification.
      //
      // METHOD (MANDATORY):
      // After drafting a scene, identify 3â€“5 sentences where the narrator:
      // - justifies a choice
      // - asserts control
      // - frames themselves as perceptive, cautious, or exceptional
      //
      // For each identified sentence, apply one transformation:
      // - Add delayed self-awareness
      // - Add ironic specificity
      // - Add self-implicating admission
      //
      // Do NOT: Add humor, commentary, new events, or change pacing.
      //
      // CANONICAL TRANSFORMS:
      //
      // Assertive â†’ Wry:
      // "I knew what I was doing."
      // â†’ "I knew what I was doing, which is usually how it starts."
      //
      // Poetic â†’ Wry:
      // "I was good at being invisible."
      // â†’ "I was good at being invisible, especially when I wanted to be seen."
      //
      // Defiant â†’ Wry:
      // "I was not prey; I was a player."
      // â†’ "I was not prey. I was, at worst, a willing participant."
      //
      // SUCCESS CONDITION:
      // The narrator should sound: Competent, self-aware, slightly untrustworthy
      // to themselves.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” CONCRETE SCENE GROUNDING (AUTHORITATIVE)
      // TAG: storybound/wry-scene-grounding-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // VISUALIZER RULE â€” WRY CONFESSION (AUTHORITATIVE)
      //
      // For Wry Confession, TONE defines illustration STYLE only.
      // The image SUBJECT must be grounded in a concrete element from the
      // current scene:
      //   - Setting (location, environment, architectural detail)
      //   - Character situation (posture, action, interaction)
      //   - Symbolic object (a specific item present in the scene)
      //
      // If no concrete scene element is used, the image is INVALID.
      //
      // VALID: A woman at a cafÃ© table, her coffee untouched (scene: cafÃ© meeting)
      // VALID: Hands gripping a doorframe (scene: hesitation at threshold)
      // VALID: A half-written letter on a desk (scene: abandoned correspondence)
      //
      // INVALID: Abstract swirls representing emotional turmoil
      // INVALID: Generic "woman in contemplation" with no scene anchor
      // INVALID: Symbolic imagery disconnected from the prose
      //
      // The tone (Wry Confession) affects HOW the subject is rendered
      // (editorial, ironic, slightly off-kilter) â€” not WHAT is depicted.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” BINARY VISUAL CHECK (IMAGE GENERATION REGIME LOCK)
      // TAG: storybound/wry-binary-visual-check-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // Every Wry Confession visualization must pass this binary check:
      //
      // "What is the one thing in the image that disagrees with the
      //  character's self-image?"
      //
      // If no answer exists â†’ the image is invalid.
      //
      // ACCEPTABLE FORMS OF DISAGREEMENT (CHOOSE ONE):
      // - A background sign or object that contradicts intent
      //   ("NO RETURNS", "FAIR PRICES", "TEMPORARY")
      // - A posture or gesture that undermines confidence
      //   (clenched hands, stiff stance, off-balance weight)
      // - A secondary figure positioned to silently observe or judge
      // - An object rendered slightly too prominent or tempting
      //
      // HARD CONSTRAINTS:
      // - Only one contradiction
      // - No exaggeration
      // - No slapstick
      // - No symbolism that requires explanation
      // - The disagreement must be legible at a glance
      //
      // SUCCESS CONDITION:
      // The viewer should think: "Ah. She thinks she's in control."
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSION â€” INSET-IMAGE RENDERING RULES (AUTHORITATIVE)
      // TAG: storybound/wry-inset-image-rendering-v1
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //
      // REGIME CONTEXT:
      // Wry Confession visuals function as editorial asides, not focal scenes.
      // They comment on the narrative rather than illustrate it directly.
      // Text always retains narrative primacy.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 1. IMAGE SCALE (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Render at full resolution (no pipeline changes)
      // - Display at reduced scale: 40â€“60% of text column width
      // - Default: 50%
      // - Image must never be full-width or full-height
      // - The illustration should feel noticed, not announced.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 2. PLACEMENT (MANDATORY)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Insert between paragraphs
      // - Never mid-sentence, mid-paragraph, or before opening paragraph
      // - Preferred: After tension crystallizes, before self-awareness sharpens
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 3. LAYOUT MODEL (STRICT)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - NO CSS floats
      // - NO text wrapping around image
      // - NO masonry or magazine-style layouts
      // - Use inset block layout: centered OR slightly offset
      // - Text resumes cleanly below image
      // - Layout suggests interruption, not enforces it
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 4. CAPTION HANDLING (IF PRESENT)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Place caption directly below image
      // - Single sentence, visually lighter than body text
      // - Feel like a marginal thought
      // - Caption width must not exceed image width
      // - No bold, no emphasis, no quotation marks
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // 5. MOBILE BEHAVIOR (NON-NEGOTIABLE)
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // - Image scales down further if needed
      // - Image centers automatically
      // - Caption remains attached
      // - No clipping, no horizontal scrolling
      // - Text flow must remain uninterrupted
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // HARD CONSTRAINTS
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // âŒ No full-bleed images
      // âŒ No hero framing
      // âŒ No dynamic resizing based on scroll
      // âŒ No layout "cleverness"
      // âŒ No visual dominance over text
      //
      // This is not a gallery. Not a scene break. It is an aside.
      //
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // SUCCESS CRITERIA
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // The reader should experience the image as:
      // - A pause
      // - A raised eyebrow
      // - A quiet acknowledgment
      // - Something they might almost skip â€” but don't
      //
      // If the image feels important, it is too large.
      // If it feels decorative, it is misused.
      // If it feels slightly intrusive, it is correct.
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // WRY CONFESSIONAL SCENE VISUALIZATION â€” Representational category, not style keywords
      // TAG: storybound/wry-confessional-scene-viz-semantic-v1
      const currentTone = state.picks?.tone || '';
      const isWryConfessional = /wry|confessional|satire|irony/i.test(currentTone);
      const wrySemanticLine = isWryConfessional
          ? `This image is an editorial illustration commenting on the scene's irony or emotional contradiction, not a literal depiction of events.\n\n`
          : '';

      return `${anchorText}

${wrySemanticLine}You are writing an image prompt. Follow these continuity anchors strictly.
Output MUST follow this exact structure:

ğŸ“Œ SUBJECT (MANDATORY FIRST)
Start with: "A ${genderWord}..." then describe pose, clothing, expression.
Gender and physical description MUST appear in the first sentence.
Example: "A woman in a tattered leather jacket, face partially in shadow, stands at the mouth of a smoky alley."

ğŸ“Œ SCENE CONTEXT
Physical environment in short, grounded phrases.
Example: "Ashen wooden stalls line a narrow path. Faint orange embers glow beneath a collapsed tarp."

ğŸ“Œ ACTION / FOCAL ELEMENTS
Any movement or narrative cues.
Example: "A streak of crimson fabric disappears into the shadows up ahead."

ğŸ“Œ MOOD / STYLE
${ontologyDirective}
${cameraDistance}. ${lightingCondition}. No painterly textures unless explicitly fantasy world.

ğŸ“Œ NEGATIVE PROMPT
Do not render in oil painting or concept art style unless world is Fantasy.
Maintain gender of described figure (${protagonistGender}).
${SCENE_VIZ_EXCLUSIONS}

---
WORLD/TONE: ${worldToneBias}
INTENSITY: ${intensityBias}
CAMERA FOCUS: ${focusDirective}
COMPOSITION: ${compositionDensity}
SCENE SIGNALS:
${sceneCtx}

---
SOURCE PROSE TO VISUALIZE:
${lastText}

---
Return ONLY the formatted prompt following the structure above. Do not explain or add commentary.`;
  }

  function buildVisualizePrompt({ mode, lastText, anchorText }) {
      if (mode === 'setting') {
          return buildSettingVisualizePrompt();
      }
      return buildSceneVisualizePrompt(lastText, anchorText);
  }

  // Default visual quality biases for attractive characters
  const VISUAL_QUALITY_DEFAULTS = 'Characters depicted with striking beauty, elegant features, and healthy appearance. Women with beautiful hourglass figures. Men with athletic gymnast-like builds. Faces are attractive and expressive with natural expressions, avoiding exaggerated or artificial looks.';

  // Sanitize image prompts - removes sensual adjectives for Clean/Naughty tiers
  function sanitizeImagePrompt(prompt) {
      // Words that trigger safety filters on mainstream providers
      const sensualWords = [
          'sensual', 'erotic', 'seductive', 'sexual', 'intimate', 'naked', 'nude',
          'provocative', 'suggestive', 'lustful', 'passionate', 'steamy', 'hot',
          'sexy', 'aroused', 'arousing', 'undressed', 'revealing', 'exposed',
          'busty', 'voluptuous', 'curvy', 'bedroom', 'lingerie', 'underwear',
          'explicit', 'raw', 'unfiltered', 'dirty', 'naughty', 'forbidden',
          'sultry', 'alluring', 'nudity'
      ];

      // Phrases that trigger moderation (multi-word)
      const sensualPhrases = [
          'parted lips', 'suggestive posture', 'alluring curves',
          'bedroom eyes', 'come hither', 'inviting gaze'
      ];

      let sanitized = prompt;

      // Remove Fate entity / "The Author" references (meta-character should never be in images)
      sanitized = sanitized.replace(/\bThe Author\b/gi, '').replace(/\bAuthor\b/gi, '');

      // Remove flagged phrases first (before single words)
      sensualPhrases.forEach(phrase => {
          const regex = new RegExp(phrase, 'gi');
          sanitized = sanitized.replace(regex, '');
      });

      // Remove sensual words entirely rather than replacing
      sensualWords.forEach(word => {
          const regex = new RegExp('\\b' + word + '\\b', 'gi');
          sanitized = sanitized.replace(regex, '');
      });

      // Clean up double spaces and punctuation issues
      sanitized = sanitized.replace(/\s+/g, ' ').replace(/,\s*,/g, ',').replace(/\s+,/g, ',').trim();

      return sanitized;
  }

  // ============================================================
  // IMAGE PROVIDER ROUTER - Unified image generation system
  // ============================================================

  // ============================================================
  // IMAGE PROMPT LENGTH â€” SAFETY FALLBACK (3000 chars)
  // ============================================================
  // This is a SAFETY FALLBACK, not an artistic constraint.
  // Full prompts up to 3000 chars pass through intact for richer visuals.
  // Truncation only occurs if prompt exceeds provider limits.
  // CRITICAL: This function is for IMAGE/VISUALIZATION prompts ONLY.
  // Story generation prompts must NEVER be truncated.
  // ============================================================
  const MAX_IMAGE_PROMPT_LENGTH = 3000;

  /**
   * Log prompt composition breakdown for debugging
   */
  function logPromptComposition(prompt, context) {
      // Find separator if present
      const separatorIdx = prompt.indexOf('\n---\n');
      let userContent, styleContent;

      if (separatorIdx > -1) {
          userContent = prompt.substring(0, separatorIdx);
          styleContent = prompt.substring(separatorIdx + 5);
      } else {
          userContent = prompt;
          styleContent = '';
      }

      console.log(`[PROMPT-COMP] ${context}:`, {
          totalChars: prompt.length,
          userContentChars: userContent.length,
          styleContentChars: styleContent.length,
          limit: MAX_IMAGE_PROMPT_LENGTH,
          wouldTruncate: prompt.length > MAX_IMAGE_PROMPT_LENGTH
      });
  }

  /**
   * STYLE_BLOCK summarization â€” rule-based compression (NO LLM).
   * NEVER summarizes: layout constraints, user content, exclusions, vetoes.
   * @param {string} styleBlock - The style portion of the prompt (after ---)
   * @returns {string} - Compressed style block
   */
  function summarizeStyleBlock(styleBlock) {
      if (!styleBlock || styleBlock.length < 100) return styleBlock;

      let compressed = styleBlock;

      // 1. Remove redundant adjective pairs
      const redundantPairs = [
          [/\bbeautiful,?\s*elegant\b/gi, 'elegant'],
          [/\belegant,?\s*graceful\b/gi, 'elegant'],
          [/\bnatural,?\s*ambient\b/gi, 'ambient'],
          [/\bsoft,?\s*gentle\b/gi, 'soft'],
          [/\bwarm,?\s*golden\b/gi, 'golden'],
          [/\bdramatic,?\s*intense\b/gi, 'dramatic'],
          [/\bcinematic,?\s*filmic\b/gi, 'cinematic'],
          [/\bmoody,?\s*atmospheric\b/gi, 'atmospheric']
      ];
      redundantPairs.forEach(([pattern, replacement]) => {
          compressed = compressed.replace(pattern, replacement);
      });

      // 2. Remove filler phrases
      const fillerPhrases = [
          /\bwith a sense of\b/gi,
          /\bthat evokes\b/gi,
          /\bgiving the impression of\b/gi,
          /\bin the style of\b/gi,
          /\breminiscent of\b/gi,
          /\bevocative of\b/gi,
          /\bsuggesting a feeling of\b/gi
      ];
      fillerPhrases.forEach(pattern => {
          compressed = compressed.replace(pattern, '');
      });

      // 3. Collapse "Art style:" redundancy
      compressed = compressed.replace(/Art style:\s*/gi, '');

      // 4. Shorten common exclusion phrases
      compressed = compressed.replace(/No text,?\s*watermarks,?\s*signatures,?\s*or logos/gi, 'No text/watermarks');
      compressed = compressed.replace(/No unrealistic anatomy or proportions/gi, 'No unrealistic anatomy');
      compressed = compressed.replace(/No explicit content/gi, 'No explicit');

      // 5. Remove duplicate sentences
      const sentences = compressed.split(/\.\s+/);
      const uniqueSentences = [...new Set(sentences.map(s => s.trim().toLowerCase()))];
      if (uniqueSentences.length < sentences.length) {
          compressed = sentences.filter((s, i) =>
              sentences.findIndex(x => x.trim().toLowerCase() === s.trim().toLowerCase()) === i
          ).join('. ');
      }

      // 6. Clean up spacing and punctuation
      compressed = compressed.replace(/\s+/g, ' ').replace(/,\s*,/g, ',').replace(/\.\s*\./g, '.').trim();

      console.log(`[STYLE-SUMMARIZE] ${styleBlock.length} -> ${compressed.length} chars`);
      return compressed;
  }

  /**
   * Clamp prompt length for image generation ONLY (safety fallback).
   * SMART TRUNCATION: Preserves user content, summarizes/truncates style fluff.
   * @param {string} prompt - The prompt to clamp
   * @param {string} context - REQUIRED: 'image-gen' | 'visualization' | 'story-gen'
   * @returns {string|null} - Clamped prompt, or null if protected content exceeds limit
   */
  function clampPromptLength(prompt, context) {
      // GATE: Story prompts must NEVER be truncated
      if (context === 'story-gen') {
          console.error('[PROMPT-GUARD] FATAL: clampPromptLength called with story-gen context. Story prompts must NOT be truncated.');
          throw new Error('PROMPT_TRUNCATION_BLOCKED: Story generation prompts cannot be truncated.');
      }

      // GATE: Only allow explicit image/visualization contexts
      if (context !== 'image-gen' && context !== 'visualization') {
          console.error(`[PROMPT-GUARD] FATAL: clampPromptLength called with unknown context: ${context}`);
          throw new Error(`PROMPT_TRUNCATION_BLOCKED: Unknown context "${context}". Use 'image-gen' or 'visualization'.`);
      }

      // Log composition for debugging
      logPromptComposition(prompt, context);

      // Within limit â€” return as-is
      if (prompt.length <= MAX_IMAGE_PROMPT_LENGTH) {
          return prompt;
      }

      // SMART TRUNCATION: Preserve user content (before ---), compress/truncate style
      const separatorIdx = prompt.indexOf('\n---\n');

      if (separatorIdx > -1) {
          const userContent = prompt.substring(0, separatorIdx);
          let styleContent = prompt.substring(separatorIdx + 5);

          // Check if user content alone exceeds limit (FATAL)
          if (userContent.length >= MAX_IMAGE_PROMPT_LENGTH - 50) {
              console.error(`[IMAGE-GEN] FATAL: Protected content (${userContent.length} chars) exceeds limit. Cannot generate image.`);
              return null; // Abort â€” caller should handle gracefully
          }

          const availableForStyle = MAX_IMAGE_PROMPT_LENGTH - userContent.length - 5;

          // STEP 1: Try summarization first
          if (styleContent.length > availableForStyle) {
              const summarized = summarizeStyleBlock(styleContent);
              if (summarized.length <= availableForStyle) {
                  console.warn(`[IMAGE-GEN] Summarization sufficient: style ${styleContent.length} -> ${summarized.length}`);
                  return userContent + '\n---\n' + summarized;
              }
              styleContent = summarized; // Use summarized version for further truncation
          }

          // STEP 2: Hard truncate summarized style if still too long
          if (styleContent.length > availableForStyle && availableForStyle > 50) {
              const truncatedStyle = styleContent.substring(0, availableForStyle);
              console.warn(`[IMAGE-GEN] Post-summarization truncation: style ${styleContent.length} -> ${truncatedStyle.length}`);
              return userContent + '\n---\n' + truncatedStyle;
          }

          // STEP 3: Minimal style (just keep first sentence)
          if (availableForStyle > 20) {
              const firstSentence = styleContent.split('.')[0] + '.';
              console.warn(`[IMAGE-GEN] Minimal style: keeping only "${firstSentence.substring(0, 50)}..."`);
              return userContent + '\n---\n' + firstSentence.substring(0, availableForStyle);
          }
      }

      // No separator or user content too long â€” fallback to simple end truncation
      console.warn(`[IMAGE-GEN] Fallback truncation: ${prompt.length} -> ${MAX_IMAGE_PROMPT_LENGTH}`);
      return prompt.substring(0, MAX_IMAGE_PROMPT_LENGTH);
  }

  // Soft threshold for story prompt size warning (does NOT truncate)
  const STORY_PROMPT_SOFT_LIMIT = 50000;

  /**
   * Validate story prompt size (debug logging only, no truncation).
   * @param {string} prompt - The full assembled story prompt
   * @param {string} label - Descriptive label for logging
   */
  function validateStoryPromptSize(prompt, label = 'story-prompt') {
      if (!prompt) return;
      if (prompt.length > STORY_PROMPT_SOFT_LIMIT) {
          console.warn(`[STORY-GEN-DEBUG] ${label} exceeds soft limit: ${prompt.length} chars (limit: ${STORY_PROMPT_SOFT_LIMIT})`);
      }
  }

  // FLUX PROMPT HARD CONSTRAINTS (MANDATORY)
  // Includes lighting constraints to override provider defaults
  const FLUX_PROMPT_PREFIX = 'Painterly cinematic realism, oil-painting style, realistic anatomy, natural proportions, non-anime. Even exposure, midtone-forward lighting, neutral color temperature.';
  const FLUX_PROMPT_SUFFIX = 'Single subject unless explicitly stated. Correct human anatomy. No extra limbs. No extra people. No crushed blacks. No teal-orange grading.';

  // PERCHANCE PROMPT HARD CONSTRAINTS (MANDATORY)
  // Includes lighting constraints to override provider defaults
  const PERCHANCE_PROMPT_PREFIX = 'default Art Style is oil painting 70s pulp, balanced neutral lighting, realistic proportions, oil-painting style, non-anime. Even exposure, no crushed blacks.';
  const PERCHANCE_PROMPT_SUFFIX = 'Single subject unless explicitly stated. Correct human anatomy. One head, two arms, two legs. No extra limbs. No extra people. No extreme contrast. No underexposed foreground.';

  // ============================================================
  // VISUAL INTENT GUARD (Attractiveness + Lighting Enforcement)
  // ============================================================
  // Enforces: attractive subjects, balanced lighting, erotic-adjacent beauty
  // Darkness/grime only when tone explicitly requires it
  // Applied to ALL visualization prompts (initial, re-visualize, auto-refresh)
  // ============================================================

  const VISUAL_INTENT_ATTRACTIVENESS = 'Subjects are attractive with healthy, glowing skin and appealing features. Soft, flattering lighting. Avoid harsh shadows on faces. Beauty-forward rendering.';

  // LIGHTING CONSTRAINTS (AUTHORITATIVE)
  // Technical lighting enforcement overrides provider defaults
  const VISUAL_INTENT_LIGHTING_DEFAULT = 'Even exposure, midtone-forward lighting, no crushed blacks. Neutral industrial lighting, balanced color temperature. Skin tones warm and natural, never grey or washed out. Avoid teal-orange cinematic grading.';

  // LIGHTING PROHIBITIONS (explicitly forbidden)
  const VISUAL_INTENT_LIGHTING_PROHIBITIONS = 'NO moody noir lighting. NO extreme contrast. NO underexposed foreground. NO color banding. NO desaturated flesh tones.';

  // Tones that permit dark/grim rendering (override attractiveness defaults)
  const DARK_TONE_OVERRIDES = ['Dark', 'Grim', 'Noir'];

  /**
   * Apply Visual Intent Guard to a prompt
   * Enforces attractiveness and balanced lighting by default
   * @param {string} prompt - The visualization prompt
   * @param {object} context - { tone, world, intensity }
   * @returns {string} - Enhanced prompt with visual intent enforcement
   */
  function applyVisualIntentGuard(prompt, context = {}) {
      const tone = context.tone || state.picks?.tone || 'Earnest';
      const world = context.world || state.picks?.world || 'Modern';

      // Wry Confessional uses its own ontology â€” skip cinematic/lighting defaults
      if (tone === 'Wry Confessional') {
          return prompt;
      }

      // Check if dark rendering is explicitly permitted
      const isDarkTone = DARK_TONE_OVERRIDES.includes(tone);
      const isNoirWorld = world === 'Noir' || world === 'Gothic';
      const allowDarkRendering = isDarkTone || isNoirWorld;

      let enhanced = prompt;

      // Always add attractiveness bias for human figures
      if (!enhanced.includes('attractive') && !enhanced.includes('beautiful')) {
          enhanced = VISUAL_INTENT_ATTRACTIVENESS + ' ' + enhanced;
      }

      // Add lighting guard unless dark rendering is permitted
      if (!allowDarkRendering) {
          // Prevent desaturated/dark defaults with technical constraints
          enhanced = VISUAL_INTENT_LIGHTING_DEFAULT + ' ' + enhanced;

          // Add explicit lighting prohibitions
          enhanced = enhanced + ' ' + VISUAL_INTENT_LIGHTING_PROHIBITIONS;

          // Remove explicit dark directives that may have crept in
          enhanced = enhanced.replace(/desaturated|gritty|harsh shadows|noir lighting|bleak|crushed blacks|teal.?orange/gi, '');
      }

      return enhanced.replace(/\s+/g, ' ').trim();
  }

  // Expose for DevHUD testing
  window.applyVisualIntentGuard = applyVisualIntentGuard;

  // =================================================================
  // SCENE VISUALIZATION SYSTEM (AUTHORITATIVE)
  // Cinematic scene visualizer - NOT portraits, NOT book covers
  // Wry Confessional override: Editorial cartoon visualizer
  // =================================================================
  function getSceneVizSystem() {
      if (state.picks?.tone === 'Wry Confessional') {
          return `You are an editorial cartoon visualizer. ${WRY_CONFESSIONAL_VISUAL_ONTOLOGY} Characters look bemused, resigned, or socially awkward. Return ONLY the image prompt. Under 200 characters.`;
      }

      return `You are a cinematic scene visualizer, not a character illustrator.
Your job is to render mood, environment, tension, and implication â€” not portraits, not glamour shots, not book covers.

CORE RULES:
1. POV IS IMPLICIT - The viewer is inside the world. Characters must NOT look at camera, smile at viewer, or pose attractively. Use: back views, partial profiles, obscured faces, silhouettes, reflections, hands, posture.

2. FEELING OVERRIDES DESCRIPTION - Atmosphere, emotion, pressure, unease, longing, foreboding override surface details. A "vibrant market" with "weight of expectations, air thickens" should feel oppressive, not cheerful.

3. SIMPLIFY - Collapse prose into ONE location, ONE moment, ONE emotional beat. Pick the most pregnant moment.

4. SUBDUED EXPRESSION - Characters look distracted, tense, uncertain, absorbed, conflicted. Never cheerful, performative, model-like, or inviting.

5. COLOR/LIGHTING FOLLOW EMOTION:
   - Oppression â†’ desaturated, shadowed, compressed space
   - Desire â†’ contrast, directional light
   - Unease â†’ off-balance framing, negative space
   - Avoid bright stock-photo palettes

6. SCENE FIDELITY (SOFT) - Prefer to visualize only characters and interactions explicitly present or clearly implied by the scene text.
   - If protagonist is alone â†’ default to isolation, vigilance, movement, or internal tension
   - Background figures allowed only as distant, non-interactive elements when threat or surveillance is implied
   - Prefer not to invent close companions, face-to-face interactions, or conversational pairings unless dialogue or proximity is described

7. PROTAGONIST PRIORITY - The protagonist's emotional state and physical situation should dominate.
   - Camera framing, posture, and negative space reinforce: unease, watchfulness, dread, anticipation
   - Other figures (if any) should feel secondary, peripheral, or looming â€” never dominant unless text demands it

8. FATE PRESENCE (ENVIRONMENTAL) - Fate does not appear as a person. Fate's influence surfaces indirectly through:
   - Oppressive architecture, tight framing
   - Surveillance cues (lights, shadows, distant watchers)
   - Environmental pressure suggesting orchestration, not companionship
   - This should feel like fate pressing inward, not a character entering

PROMPT PRIORITY ORDER: Protagonist emotional state â†’ Direction of threat/attention â†’ Scene accuracy â†’ Spatial tension â†’ Lighting â†’ Environment â†’ Other characters (secondary)

Return ONLY the image prompt. No explanations. Under 200 characters.`;
  }
  // Note: getSceneVizSystem() replaces the former SCENE_VIZ_SYSTEM const
  // Call getSceneVizSystem() at runtime to get tone-aware system prompt

  // Scene visualization explicit exclusions (always appended)
  // Prevents model defaults and style drift
  const SCENE_VIZ_EXCLUSIONS = 'No smiling at camera. No posed portraits. No beauty photography. No book cover composition. No default male subject. No oil painting style unless Fantasy world.';

  // =================================================================
  // VISUALIZER STYLE & ONTOLOGY SYSTEM (AUTHORITATIVE)
  // Ensures visual consistency across story â€” no mid-story medium switches
  // =================================================================

  /**
   * Visual ontology defaults by world type
   * Determines whether images are photographic or illustrative
   */
  const WORLD_ONTOLOGY_MAP = {
      // Photographic realism
      'Modern Billionaire': { ontology: 'photographic', style: 'journalistic/paparazzi' },
      'Contemporary Romance': { ontology: 'photographic', style: 'cinematic' },
      'Noir': { ontology: 'photographic', style: 'high-contrast cinematic' },
      'Sci-Fi Grounded': { ontology: 'photographic', style: 'cinematic realism' },
      // Illustration / Painterly
      'Fantasy Dark': { ontology: 'illustration', style: 'painterly epic fantasy' },
      'Fantasy Power': { ontology: 'illustration', style: 'painterly epic fantasy' },
      'Fantasy Romantic': { ontology: 'illustration', style: 'soft painterly fantasy' },
      'Fantasy Enchanted': { ontology: 'illustration', style: 'soft painterly fantasy' },
      'Sci-Fi Stylized': { ontology: 'illustration', style: 'high-concept illustration' },
  };

  /**
   * Tone-based visual overrides (for Visual Ontology system)
   * Some tones force specific visual treatments regardless of world
   * NOTE: Separate from TONE_STYLE_OVERRIDES (Style Lock system at line ~4703)
   */
  const TONE_VISUAL_OVERRIDES = {
      'Wry Confessional': {
          override: true,
          ontology: 'illustration',
          style: 'New Yorkerâ€“style cartoon, sparse linework, minimal color, emotional understatement',
          captionRequired: true,
          captionRules: 'Caption REQUIRED. AI-authored. Clever, opaque, understated, emotionally undercutting. NEVER literally describes the image.'
      }
  };

  /**
   * Resolve visual ontology and style for current story
   * @returns {Object} { ontology, style, captionRequired, captionRules, arousalNote }
   */
  function resolveVisualStyle() {
      const world = state.picks?.world || '';
      const tone = state.picks?.tone || '';

      // Check for tone override first (Wry Confessional forces illustration)
      const toneOverride = TONE_VISUAL_OVERRIDES[tone];
      if (toneOverride?.override) {
          return {
              ontology: toneOverride.ontology,
              style: toneOverride.style,
              captionRequired: toneOverride.captionRequired || false,
              captionRules: toneOverride.captionRules || '',
              arousalNote: '',
              lockExclusive: true // Prevents additional modifiers
          };
      }

      // Resolve base ontology from world (explicit, no fuzzy matching)
      const baseOntology = WORLD_ONTOLOGY_MAP[world]
          || { ontology: 'photographic', style: 'cinematic' }; // Safe default

      // Apply tone modifier if present
      let finalStyle = baseOntology.style;
      let arousalNote = '';
      if (toneOverride?.styleModifier) {
          finalStyle = `${baseOntology.style} with ${toneOverride.styleModifier}`;
          arousalNote = toneOverride.arousalNote || '';
      }

      return {
          ontology: baseOntology.ontology,
          style: finalStyle,
          captionRequired: false,
          captionRules: '',
          arousalNote
      };
  }

  /**
   * Build visual ontology directive for prompt
   * Enforces consistency and prevents mid-story medium switches
   */
  function getVisualOntologyDirective() {
      const vs = resolveVisualStyle();

      let directive = `VISUAL ONTOLOGY (LOCKED): ${vs.ontology.toUpperCase()}
STYLE: ${vs.style}

CONSISTENCY RULE:
Visual media MUST remain ${vs.ontology.toUpperCase()} for the entire story.
Do NOT mix photography and illustration unless the user explicitly requests mixed media.

Arousal may modify framing, lighting, proximity, and intensity â€” NEVER the medium.`;

      if (vs.captionRequired) {
          directive += `\n\n${vs.captionRules}`;
          directive += `

CAPTION REQUIREMENT:
- Include exactly ONE caption.
- Caption must be AI-authored.
- Caption must be clever, opaque, and understated.
- Caption must NOT literally describe the image.`;
      }

      if (vs.arousalNote) {
          directive += `\n\nAROUSAL NOTE: ${vs.arousalNote}`;
      }

      if (vs.lockExclusive) {
          directive += `

STYLE LOCK:
No additional visual style modifiers are permitted for this tone.`;
      }

      return directive;
  }

  // =================================================================
  // COVER GENERATION SYSTEM (AUTHORITATIVE)
  // Symbolic book cover - NOT scene illustration
  // Emotion > Description > Detail
  // =================================================================
  const COVER_GENERATION_SYSTEM = `COVER GENERATION â€” AUTHORITATIVE RULESET (STRICT)

You are generating a REAL BOOK JACKET.
Not a poster. Not a thumbnail. Not a product photo.
Restraint is REQUIRED. Over-interpretation is a failure.

IMPORTANT â€” ANTI-EAGERNESS GOVERNOR
You must resist the urge to improve, embellish, decorate, or clarify.
If an element is not necessary, it must be removed.
If an idea feels clever, illustrative, or explanatory, it is likely wrong.
When uncertain, choose subtraction over addition.
When two options feel equally valid, choose the quieter one.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
PRIMARY DIRECTIVE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

The book cover is the dominant visual object.
It must feel like a full physical book jacket:
heavy, intentional, restrained.

If any choice makes the cover feel smaller, busier, cleaner, or more decorative,
that choice is WRONG.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
LAYOUT & SCALE (HARD RULES)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ The cover occupies maximum vertical presence.
â€¢ Aspect ratio is 5:7, enforced AFTER scale is maximized.
â€¢ No artificial shrinking to accommodate UI or buttons.
â€¢ The cover must never feel like a preview card or framed image.

Negative space is allowed ONLY if it feels intentional and material
(paper, cloth, ink, darkness) â€” never empty UI space.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
IMAGE FIT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ Use contain-style framing.
â€¢ Do NOT crop the focal object or symbolic elements.
â€¢ Letterbox space must read as book material, not blank background.
â€¢ No forced centering that reduces tension.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FOCAL ANCHOR (ONE ONLY)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Choose ONE primary anchor:
â€¢ A meaningful object
â€¢ OR environment / architecture
â€¢ OR absence / trace / aftermath

Never introduce multiple anchors.
Never "balance" the composition with extra objects.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
OBJECT JUXTAPOSITION (CRITICAL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If a SINGLE OBJECT is used, it MUST be altered.

A plain, untouched object is NOT acceptable.

The object must show at least ONE of:
â€¢ Transformation
â€¢ Interference
â€¢ Damage
â€¢ Shadow behaving unnaturally
â€¢ Symbolic distortion

The alteration must imply:
â€¢ Theme
â€¢ Power imbalance
â€¢ Cost or consequence

Shock for its own sake is NOT allowed.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
GENRE-AWARE CONSTRAINTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Apply restraint appropriate to genre:

â€¢ Noir / Crime â†’ control, secrecy, moral cost
â€¢ Fantasy â†’ fate, sacrifice, mythic consequence
â€¢ Sci-Fi â†’ surveillance, loss of agency
â€¢ Romance / Psychological â†’ restraint, memory, longing

If unsure which genre dominates, DEFAULT TO RESTRAINT.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FAIL-SOFT BEHAVIOR (MANDATORY)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If no meaningful object + alteration emerges:

You MUST default to ONE of the following:
â€¢ Environment-first (corridor, room, street, architecture)
â€¢ Negative presence (mark, stain, trace, shadow, indentation)
â€¢ Fragmented object (partial, broken, implied â€” never pristine)

Never force an object just to fill the frame.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ASSEMBLY ELEMENTS (LIMITED â€” NOT DECORATIVE)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

You MAY use:
â€¢ Subtle material texture (paper, cloth, ink)
â€¢ Edge vignette or depth
â€¢ Minor print imperfections

These must:
â€¢ Remain peripheral
â€¢ Never introduce new narrative objects
â€¢ Never compete with the focal anchor

Ornamentation is NOT allowed.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
HUMAN FIGURES (IF USED)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ Optional
â€¢ Obscured, cropped, turned away, or silhouette ONLY
â€¢ No eye contact
â€¢ No posed portraits
â€¢ No smiling

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
VISUAL RESTRAINT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ 2â€“3 dominant tones only
â€¢ Asymmetry preferred
â€¢ No decorative clutter
â€¢ No glamour lighting
â€¢ No stock-photo aesthetics

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ANTI-EAGERNESS RULES (CRITICAL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â€¢ Do NOT add elements "for interest"
â€¢ Do NOT explain the story visually
â€¢ Do NOT escalate intensity beyond what is implied
â€¢ Do NOT invent symbolism unless strictly required
â€¢ When uncertain, REMOVE rather than ADD

If two choices seem equally valid: choose the quieter one.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
FINAL FAILURE CHECK
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

If the result could be mistaken for:
â€¢ An advertisement
â€¢ A stock image
â€¢ A product listing
â€¢ A generic fantasy/noir cover

Then it has FAILED.

Return ONLY the image prompt. No explanations. No alternatives.`;

  // Cover prompt exclusions (always appended)
  // HARD EXCLUSIONS - violations are bugs
  const COVER_EXCLUSIONS = `No audience-facing characters. No literal scene recreation. No generic beauty shots.
No envelopes. No roses. No wine glasses (unless explicitly central to story).
No ornamental curls or art-deco filigree unless narratively justified.
No brown/cream parchment defaults. No centered-object-on-cream unless layout explicitly requires it.
No plain untouched objects â€” single objects MUST have juxtapositive tension (shadow, alteration, transformation).
No product photography. No stock-photo lighting. No decorative sensuality.`;

  // Emotional gravity options for cover generation
  const EMOTIONAL_GRAVITY_OPTIONS = [
    'foreboding', 'yearning', 'pressure', 'secrecy', 'rebellion',
    'inevitability', 'longing', 'tension', 'mystery', 'isolation',
    'devotion', 'betrayal', 'transformation', 'pursuit'
  ];

  // =================================================================
  // COVER LAYOUT ARCHETYPES (AUTHORITATIVE)
  // Structurally distinct compositions to prevent visual convergence
  // =================================================================
  const COVER_LAYOUT_ARCHETYPES = [
    {
      id: 'center_object',
      description: 'Single symbolic object centered, minimal background, strong negative space'
    },
    {
      id: 'off_center_focus',
      description: 'Primary object off-center, asymmetrical composition, directional tension'
    },
    {
      id: 'fragmented_object',
      description: 'Object partially broken, cropped, or fragmented across the frame'
    },
    {
      id: 'environment_only',
      description: 'No central object; environment or setting carries meaning (empty room, horizon, pathway)'
    },
    {
      id: 'symbol_in_shadow',
      description: 'Object implied through shadow, reflection, or silhouette on surface'
    },
    {
      id: 'typography_integrated',
      description: 'Symbol interacts with title lettering space or is partially obscured by text area'
    },
    {
      id: 'negative_space_dominant',
      description: 'Large empty space (70%+) with small but potent visual anchor at edge or corner'
    }
  ];

  // Layout roulette: Select layout avoiding recent repetition
  function selectCoverLayout(history) {
    const recentLayouts = history.slice(0, 3).map(m => m.layoutId).filter(Boolean);

    // Shuffle archetypes for randomness
    const shuffled = [...COVER_LAYOUT_ARCHETYPES].sort(() => Math.random() - 0.5);

    // Try up to 3 times to find non-repeating layout
    for (let attempt = 0; attempt < 3; attempt++) {
      const candidate = shuffled[attempt % shuffled.length];
      if (!recentLayouts.includes(candidate.id)) {
        return candidate;
      }
    }

    // Fallback: force negative_space_dominant (safest, most distinct)
    return COVER_LAYOUT_ARCHETYPES.find(l => l.id === 'negative_space_dominant') || shuffled[0];
  }

  // DEV-ONLY: Logging helper for image generation debugging
  function logImageAttempt(provider, context, prompt, status, error = null) {
      // CANCELLED requests are neutral â€” do NOT log as failures
      if (status === 'FAILED' && error) {
          const errLower = error.toLowerCase();
          if (errLower.includes('abort') || errLower.includes('cancel')) {
              return; // Exit without logging â€” not a provider failure
          }
      }

      const promptPreview = prompt.substring(0, 120) + (prompt.length > 120 ? '...' : '');

      // Categorize blocker type from error message
      const getBlocker = (err) => {
          if (!err) return 'None';
          const e = err.toLowerCase();
          if (e.includes('cors') || e.includes('access-control') || e.includes('preflight')) return 'CORS';
          if (e.includes('nsfw') || e.includes('safety') || e.includes('content policy') || e.includes('rejected')) return 'CONTENT_POLICY';
          if (e.includes('network') || e.includes('fetch') || e.includes('timeout') || e.includes('econnrefused')) return 'Network';
          if (e.includes('null') || e.includes('no image')) return 'NoOutput';
          return 'Other';
      };

      const logData = {
          provider,
          context,
          reached: status === 'ATTEMPTING' || status === 'SUCCESS',
          blockedBy: status === 'FAILED' ? getBlocker(error) : 'None',
          status,
          promptLength: prompt.length,
          promptPreview,
          timestamp: new Date().toISOString()
      };
      if (error) logData.error = error;
      console.warn('[IMAGE-GEN]', JSON.stringify(logData));
  }

  // FLUX PRIMARY: Call Flux Uncensored image generation (via Replicate or self-hosted)
  // PASS 2E: Extended timeout for Replicate inference (up to 120s)
  // Default to 16:9 landscape for cinematic presentation
  async function callFluxImageGen(prompt, size = '1792x1024', timeout = 125000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      // Flux endpoint - Replicate API or self-hosted inference server
      const fluxUrl = (typeof FLUX_PROXY_URL !== 'undefined' && FLUX_PROXY_URL)
          ? FLUX_PROXY_URL
          : IMAGE_PROXY_URL;

      // Apply mandatory prefix and suffix constraints
      const constrainedPrompt = `${FLUX_PROMPT_PREFIX} ${prompt} ${FLUX_PROMPT_SUFFIX}`;

      // PASS 2E: Include context for server-side logging
      const res = await fetch(fluxUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              prompt: constrainedPrompt,
              provider: 'flux',
              model: 'flux-uncensored',
              size: size,
              context: 'flux-primary',
              n: 1
          }),
          signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!res.ok) {
          const errData = await res.json().catch(() => null);
          throw new Error(errData?.error || `Flux HTTP ${res.status}`);
      }

      let data;
      try { data = await res.json(); } catch (e) { throw new Error('Flux invalid response'); }

      const imageUrl = data?.url || data?.image || data?.b64_json ||
          (Array.isArray(data?.data) && data.data[0]?.url) ||
          (Array.isArray(data?.data) && data.data[0]?.b64_json) ||
          (Array.isArray(data?.output) && data.output[0]);

      if (!imageUrl) {
          throw new Error('Flux returned no image');
      }

      return imageUrl;
  }

  // OPENAI LAST RESORT: Call OpenAI image generation (SAFE - never throws)
  // intent parameter: 'scene' (default) or 'setting' â€” determines server-side behavior
  // visualMeta: { toneStyleLock, styleAuthority, styleExpectedTags } for tone ontology system
  async function callOpenAIImageGen(prompt, size = '1024x1024', timeout = 60000, tone = null, intent = 'scene', visualMeta = {}) {
      try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          // Determine aspect ratio from size (match Replicate logic)
          const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: prompt,
                  provider: 'openai',
                  model: 'gpt-image-1.5',
                  size: size,
                  aspect_ratio: aspectRatio,
                  n: 1,
                  tone: tone,  // Pass tone for server-side ontology bypass
                  imageIntent: intent,  // Pass intent for server-side routing
                  // Tone visual ontology metadata
                  toneStyleLock: visualMeta?.toneStyleLock || false,
                  styleAuthority: visualMeta?.styleAuthority || 'Genre',
                  styleExpectedTags: visualMeta?.styleExpectedTags || []
              }),
              signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!res.ok) {
              console.warn('[OpenAI] HTTP error:', res.status);
              return null; // Safe fallback - don't throw
          }

          let data;
          try { data = await res.json(); } catch (e) {
              console.warn('[OpenAI] Invalid response');
              return null;
          }

          const imageUrl = data?.url || data?.image || data?.b64_json ||
              (Array.isArray(data?.data) && data.data[0]?.url) ||
              (Array.isArray(data?.data) && data.data[0]?.b64_json);

          if (!imageUrl) {
              console.warn('[OpenAI] No image returned');
              return null;
          }

          return imageUrl;
      } catch (err) {
          console.warn('[OpenAI] Caught error:', err.message);
          return null; // Safe fallback - never crash pipeline
      }
  }

  // PERCHANCE PROVIDER: Call Perchance AI image generation service
  // Default to 16:9 landscape for cinematic presentation
  async function callPerchanceImageGen(prompt, size = '1792x1024', timeout = 60000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      // Perchance endpoint - server-side microservice or internal HTTP endpoint
      const perchanceUrl = (typeof PERCHANCE_PROXY_URL !== 'undefined' && PERCHANCE_PROXY_URL)
          ? PERCHANCE_PROXY_URL
          : IMAGE_PROXY_URL;

      // Apply mandatory prefix and suffix constraints
      const constrainedPrompt = `${PERCHANCE_PROMPT_PREFIX} ${prompt} ${PERCHANCE_PROMPT_SUFFIX}`;

      // Determine aspect ratio from size (match Replicate logic)
      const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

      const res = await fetch(perchanceUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              prompt: constrainedPrompt,
              provider: 'perchance',
              size: size,
              aspect_ratio: aspectRatio,
              n: 1
          }),
          signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!res.ok) {
          throw new Error(`Perchance HTTP ${res.status}`);
      }

      let data;
      try { data = await res.json(); } catch (e) { throw new Error('Perchance invalid response'); }

      const imageUrl = data?.url || data?.image || data?.b64_json ||
          (Array.isArray(data?.data) && data.data[0]?.url) ||
          (Array.isArray(data?.data) && data.data[0]?.b64_json);

      if (!imageUrl) {
          throw new Error('Perchance returned no image');
      }

      return imageUrl;
  }

  // GEMINI PROVIDER: Call Gemini image generation (SAFE - never throws)
  async function callGeminiImageGen(prompt, size = '1024x1024', timeout = 60000) {
      try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          // Determine aspect ratio from size (match Replicate logic)
          const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

          const res = await fetch(IMAGE_PROXY_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                  prompt: prompt,
                  provider: 'gemini',
                  model: 'gemini-2.5-flash',
                  size: size,
                  aspect_ratio: aspectRatio,
                  n: 1
              }),
              signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!res.ok) {
              console.warn('[Gemini] HTTP error:', res.status);
              return null; // Safe fallback - don't throw
          }

          let data;
          try { data = await res.json(); } catch (e) {
              console.warn('[Gemini] Invalid response');
              return null;
          }

          const imageUrl = data?.url || data?.image || data?.b64_json ||
              (Array.isArray(data?.data) && data.data[0]?.url) ||
              (Array.isArray(data?.data) && data.data[0]?.b64_json);

          if (!imageUrl) {
              console.warn('[Gemini] No image returned');
              return null;
          }

          return imageUrl;
      } catch (err) {
          console.warn('[Gemini] Caught error:', err.message);
          return null; // Safe fallback - never crash pipeline
      }
  }

  // REPLICATE FLUX SCHNELL: Direct call to /api/visualize-flux endpoint
  async function callReplicateFluxSchnell(prompt, size = '1792x1024', timeout = 125000) {
      // Default to 16:9 landscape for cinematic presentation
      // Only use 1:1 if explicitly requested via size parameter
      const aspectRatio = size === '1024x1024' ? '1:1' : '16:9';

      // Step 1: Create prediction (POST)
      const createRes = await fetch('/api/visualize-flux', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
              prompt: prompt,
              input: {
                  aspect_ratio: aspectRatio,
                  go_fast: true,
                  num_outputs: 1,
                  output_format: 'webp',
                  output_quality: 80
              }
          })
      });

      if (!createRes.ok) {
          const errData = await createRes.json().catch(() => null);
          throw new Error(errData?.error || `Replicate HTTP ${createRes.status}`);
      }

      let createData;
      try { createData = await createRes.json(); } catch (e) { throw new Error('Replicate invalid response'); }

      const predictionId = createData?.id;
      if (!predictionId) {
          throw new Error('Replicate returned no prediction ID');
      }

      // Step 2: Poll for completion (GET)
      const maxAttempts = 20;
      const pollInterval = 1500;

      for (let attempt = 0; attempt < maxAttempts; attempt++) {
          await new Promise(r => setTimeout(r, pollInterval));

          const pollRes = await fetch(`/api/visualize-flux?id=${encodeURIComponent(predictionId)}`);

          if (!pollRes.ok) {
              const errData = await pollRes.json().catch(() => null);
              throw new Error(errData?.error || `Replicate poll HTTP ${pollRes.status}`);
          }

          let pollData;
          try { pollData = await pollRes.json(); } catch (e) { continue; }

          if (pollData.status === 'succeeded') {
              const imageUrl = pollData?.image || pollData?.url ||
                  (Array.isArray(pollData?.output) && pollData.output[0]);

              if (!imageUrl) {
                  throw new Error('Replicate returned no image');
              }
              return imageUrl;
          }

          if (pollData.status === 'failed') {
              throw new Error(pollData?.error || 'Replicate prediction failed');
          }

          // Continue polling for 'starting', 'processing', etc.
      }

      throw new Error('Replicate prediction timed out after 20 attempts');
  }

  // FALLBACK CHAIN: Unified image generation with provider fallbacks
  // All image generation MUST route through this function
  // INTENT-BASED ROUTING (MANDATORY):
  //   setting â†’ Gemini (primary) â†’ OpenAI (fallback) â€” NO Replicate
  //   scene   â†’ OpenAI (primary) â†’ Replicate (fallback) â€” NO Gemini
  //   cover   â†’ OpenAI (primary) â†’ Replicate (fallback) â€” NO Gemini
  // Default to 16:9 landscape for cinematic presentation
  // Optional signal parameter for external abort control
  async function generateImageWithFallback({ prompt, tier, shape = 'landscape', context = 'visualize', intent = 'scene', signal = null, tone = null }) {
      const normalizedTier = (tier || 'Naughty').toLowerCase();
      const isExplicitTier = normalizedTier === 'erotic' || normalizedTier === 'dirty';

      // Check for pre-aborted signal
      if (signal?.aborted) {
          const abortErr = new Error('Image generation aborted');
          abortErr.name = 'AbortError';
          throw abortErr;
      }

      // Determine size based on shape (default landscape 16:9)
      const size = shape === 'portrait' ? '1024x1024' : '1792x1024';

      // Safety fallback: clamp prompt length if exceeding provider limits (image-gen only)
      const clampedPrompt = clampPromptLength(prompt, 'image-gen');

      // Sanitize for image providers â€” intensity belongs in prose, not images
      const sanitizedPrompt = clampPromptLength(sanitizeImagePrompt(clampedPrompt), 'image-gen');
      let basePrompt = sanitizedPrompt;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ”’ TONE VISUAL ONTOLOGY PRIORITY SYSTEM
      // Tone visual style ALWAYS overrides Genre and World styling
      // Genre only influences composition, subject matter, costume/setting
      // Use BOTH tone parameter AND state.picks?.tone for redundancy
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const effectiveTone = tone || state.picks?.tone;
      let visualMetadata = { styleAuthority: 'Genre', styleExpectedTags: [], toneStyleLock: false };

      if (context === 'visualize' && hasToneVisualOntology(effectiveTone)) {
          console.log(`[VIZ:TONE] Tone with visual ontology DETECTED: ${effectiveTone}`);
          console.log(`[VIZ:TONE] tone param: ${tone} | state.picks.tone: ${state.picks?.tone}`);

          // Apply the tone's visual ontology (strips banned tokens, prepends ontology)
          const ontologyResult = applyToneVisualOntology(basePrompt, effectiveTone, context);
          basePrompt = ontologyResult.prompt;
          visualMetadata = {
              styleAuthority: ontologyResult.styleAuthority,
              styleExpectedTags: ontologyResult.styleExpectedTags,
              toneStyleLock: ontologyResult.toneStyleLock,
              toneDescription: ontologyResult.toneDescription
          };

          console.log(`[VIZ:TONE] styleAuthority: ${visualMetadata.styleAuthority}`);
          console.log(`[VIZ:TONE] expectedTags: ${visualMetadata.styleExpectedTags.join(', ')}`);
          console.log('[VIZ:TONE] Final prompt (first 200 chars):', basePrompt.substring(0, 200));
      } else {
          // No tone visual ontology â€” Genre/World provides default style
          console.log(`[VIZ:TONE] No visual ontology for tone: ${effectiveTone || 'none'} â€” using Genre style`);
      }

      // INTENT-BASED PROVIDER CHAIN (AUTHORITATIVE)
      // setting: Gemini â†’ OpenAI (NO Replicate)
      // scene/cover: OpenAI â†’ Replicate (NO Gemini)
      // CRITICAL: Use basePrompt (enforced) not sanitizedPrompt (original)
      const finalPrompt = basePrompt;
      const finalTone = effectiveTone;  // Pass resolved tone for server-side ontology bypass
      const finalIntent = intent;  // Pass through for server-side routing
      const finalVisualMeta = visualMetadata;  // Pass style authority metadata
      let providerChain;
      if (intent === 'setting') {
          // Setting images: Gemini primary, OpenAI fallback, NO Replicate
          providerChain = [
              { name: 'Gemini', fn: callGeminiImageGen, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta },
              { name: 'OpenAI', fn: callOpenAIImageGen, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta }
          ];
      } else {
          // Scene/Cover images: OpenAI primary, Replicate fallback, NO Gemini
          providerChain = [
              { name: 'OpenAI', fn: callOpenAIImageGen, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta },
              { name: 'Replicate', fn: callReplicateFluxSchnell, prompt: finalPrompt, tone: finalTone, intent: finalIntent, visualMeta: finalVisualMeta }
          ];
      }

      let lastError = null;

      // FALLBACK CHAIN: Try each provider in order
      for (const provider of providerChain) {
          // Check for abort before each provider attempt
          if (signal?.aborted) {
              const abortErr = new Error('Image generation aborted');
              abortErr.name = 'AbortError';
              throw abortErr;
          }

          try {
              logImageAttempt(provider.name, context, provider.prompt, 'ATTEMPTING');
              logImageAttempt(provider.name, context, `styleAuthority: ${provider.visualMeta?.styleAuthority || 'Genre'}`, 'META');
              const imageUrl = await provider.fn(provider.prompt, size, 60000, provider.tone, provider.intent, provider.visualMeta);

              // Check for abort after provider returns
              if (signal?.aborted) {
                  const abortErr = new Error('Image generation aborted');
                  abortErr.name = 'AbortError';
                  throw abortErr;
              }

              // Handle null returns from safe providers (Gemini/OpenAI)
              if (!imageUrl) {
                  logImageAttempt(provider.name, context, provider.prompt, 'FAILED', 'returned null');
                  continue; // Try next provider
              }

              logImageAttempt(provider.name, context, provider.prompt, 'SUCCESS');
              return imageUrl;
          } catch (e) {
              // Re-throw abort errors immediately â€” don't continue to fallback
              if (e.name === 'AbortError' || (e.message || '').toLowerCase().includes('abort')) {
                  console.log('[Image] Generation aborted by user');
                  throw e;
              }
              lastError = e;
              logImageAttempt(provider.name, context, provider.prompt, 'FAILED', e.message);
              // Continue to next provider in chain
          }
      }

      // Check if aborted before logging failure
      if (signal?.aborted) {
          const abortErr = new Error('Image generation aborted');
          abortErr.name = 'AbortError';
          throw abortErr;
      }

      // All providers failed - fail silently, story continues
      console.warn('[Image] All providers failed:', lastError?.message || 'unknown');
      return null;
  }

  // Legacy wrapper for backward compatibility
  // Scene visualization: OpenAI primary â†’ Replicate fallback (NO Gemini)
  async function generateTieredImage(basePrompt, tier) {
      return generateImageWithFallback({
          prompt: basePrompt,
          tier: tier,
          shape: 'portrait',
          context: 'visualize',
          intent: 'scene',
          tone: state.picks?.tone || null  // Pass tone for server-side Wry bypass
      });
  }

  // Filter Fate entity / "The Author" from any image prompt
  function filterAuthorFromPrompt(prompt) {
      return prompt.replace(/\bThe Author\b/gi, '').replace(/\bAuthor\b/gi, '').replace(/\s+/g, ' ').trim();
  }

  // MOOD-FIRST scene condensation for image generation
  // Extracts atmosphere + posture + environment, not surface description
  async function condenseSceneWithEmotion(rawPrompt, maxLength = 200) {
      const cleaned = filterAuthorFromPrompt(rawPrompt);

      // If already short enough, return as-is
      if (cleaned.length <= maxLength) {
          return cleaned;
      }

      // Extract mood-first elements via LLM
      try {
          const condensed = await Promise.race([
              callChat([
                  { role: 'system', content: `You condense prose into image prompts. Priority order:
1. ATMOSPHERE (emotional weight, tension, dread, pressure)
2. ENVIRONMENT (light quality, space, weather, architecture)
3. POSTURE (body language, position â€” NOT faces or expressions)
4. ONE concrete object with symbolic weight

NEVER include: character names, dialogue, exposition, or narrator voice.
NEVER frame for portrait or glamour shot.
Output ONLY the condensed visual description.` },
                  { role: 'user', content: `Condense to under ${maxLength} characters. Capture the MOOD and SPACE, not the plot.

If the scene has mixed emotions (joy + dread), lean toward the darker.
Focus on environment pressing in, posture under pressure, or charged stillness.

Scene: "${cleaned}"

Condensed (under ${maxLength} chars):` }
              ]),
              new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 8000))
          ]);

          const result = condensed.trim();
          // Ensure we stay within limit
          if (result.length <= maxLength) {
              return result;
          }
          // LLM exceeded limit, fall back to smart truncation
          return smartTruncateWithEmotion(cleaned, maxLength);
      } catch (e) {
          // Fallback: smart truncation that preserves ending
          return smartTruncateWithEmotion(cleaned, maxLength);
      }
  }

  // Smart truncation fallback: preserves emotional ending over bland beginning
  function smartTruncateWithEmotion(text, maxLength) {
      if (text.length <= maxLength) return text;

      // Emotional words often at end - take last portion if it contains emotion markers
      const emotionMarkers = /\b(tense|dark|heavy|oppressive|foreboding|yearning|desperate|cold|sharp|hollow|aching|burning|trembling|frozen|shattered|haunted|looming|suffocating)\b/i;

      const lastPortion = text.slice(-maxLength);
      const firstPortion = text.slice(0, maxLength);

      // Prefer the portion with more emotional weight
      const lastHasEmotion = emotionMarkers.test(lastPortion);
      const firstHasEmotion = emotionMarkers.test(firstPortion);

      if (lastHasEmotion && !firstHasEmotion) {
          // Last portion has emotion, first doesn't - use last
          return '...' + lastPortion.slice(3).trim();
      }

      // Default: blend beginning context with ending payoff
      const contextLength = Math.floor(maxLength * 0.4);
      const payoffLength = maxLength - contextLength - 4; // 4 for " ... "
      const context = text.slice(0, contextLength).trim();
      const payoff = text.slice(-payoffLength).trim();

      return context + ' ... ' + payoff;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // OBSERVATIONAL CONDENSER â€” For Wry Confessional visualization
  // External, flat, observer-perspective description suitable for editorial cartoons
  // NO LLM â€” pure text extraction
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  function condenseSceneObservational(text, maxLength = 120) {
      const cleaned = filterAuthorFromPrompt(text || '');
      if (!cleaned) return 'An ordinary moment.';

      // Strip internal monologue markers
      let flat = cleaned
          .replace(/\b(I |my |me |myself)\b/gi, '')
          .replace(/\b(felt|feeling|feels|thought|thinking|wondered|realized|knew|sensed)\b/gi, '')
          .replace(/\b(heart|soul|mind|breath|pulse)\s+(pounding|racing|aching|heavy|tight)/gi, '')
          .replace(/\b(desperately|urgently|frantically|intensely|passionately)\b/gi, '')
          .replace(/\b(like|as if|as though)\s+[^.]+/gi, '')
          .replace(/\s+/g, ' ')
          .trim();

      // Extract first concrete visual sentence
      const sentences = flat.split(/[.!?]+/).filter(s => s.trim().length > 10);
      if (sentences.length === 0) return 'An ordinary moment.';

      // Prefer sentences with observable nouns
      const observablePattern = /\b(room|table|chair|door|window|glass|cup|phone|desk|couch|bed|floor|wall|light|shadow|hand|figure|person|woman|man)\b/i;
      const observable = sentences.find(s => observablePattern.test(s));
      const chosen = observable || sentences[0];

      // Flatten to neutral phrasing
      let result = chosen.trim();
      if (result.length > maxLength) {
          result = result.slice(0, maxLength - 3).trim() + '...';
      }

      return result || 'An ordinary moment.';
  }

  // Prevent copy/cut on viz prompt (editable but not copyable)
  {
      const vizPrompt = document.getElementById('vizPromptInput');
      if (vizPrompt) {
          vizPrompt.addEventListener('copy', e => e.preventDefault());
          vizPrompt.addEventListener('cut', e => e.preventDefault());
          vizPrompt.addEventListener('selectstart', e => e.preventDefault());
      }
  }

  // Initialize Visualize modifier interaction (scrolling suggestions)
  // TRUST REPAIR: Validate modifiers before accepting, explicitly reject disallowed
  function initVizModifierPills() {
      const modifierInput = document.getElementById('vizModifierInput');
      const promptInput = document.getElementById('vizPromptInput');

      if (!modifierInput || !promptInput) return;

      // When user submits modifier (Enter key), validate and append to prompt
      modifierInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              e.preventDefault();
              const mod = modifierInput.value.trim();
              if (mod) {
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  // TRUST REPAIR: Validate modifier against arousal level
                  // Never silently ignore â€” explicitly reject and explain
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  const currentArousal = state.intensity || 'Naughty';
                  const validation = validateModifier(mod, currentArousal);

                  if (!validation.valid) {
                      // EXPLICIT REJECTION â€” show message to user
                      showModifierRejection(validation.reason);
                      modifierInput.value = '';
                      return;
                  }

                  // Valid modifier â€” append to prompt (never override)
                  const current = promptInput.value.trim();
                  if (current) {
                      // TRUST REPAIR: APPEND only, never override subject/setting/style
                      promptInput.value = current + ', ' + mod;
                  } else {
                      promptInput.value = mod;
                  }
                  modifierInput.value = '';
                  // Re-show scrolling suggestions
                  const placeholder = document.querySelector('.rotating-placeholder[data-for="vizModifierInput"]');
                  if (placeholder) placeholder.classList.remove('hidden');

                  // Hide any previous rejection notice
                  const rejectionEl = document.getElementById('vizModifierRejection');
                  if (rejectionEl) rejectionEl.classList.add('hidden');

                  console.log('[VIZ:MODIFIER] Appended:', mod);
              }
          }
      });
  }

  // Reset modifier UI when modal opens
  function resetVizModifierUI() {
      const modifierInput = document.getElementById('vizModifierInput');
      const placeholder = document.querySelector('.rotating-placeholder[data-for="vizModifierInput"]');
      if (modifierInput) modifierInput.value = '';
      if (placeholder) placeholder.classList.remove('hidden');
  }

  // Initialize modifier pills on DOMContentLoaded
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initVizModifierPills);
  } else {
      initVizModifierPills();
  }

  // Tempt Fate escalating cost â€” uses consecutive_tempt_fate_count (explicit invocation counter)
  function getTemptFateCost() {
      return Math.min(50 + 10 * (state.consecutive_tempt_fate_count || 0), 80);
  }

  // ============================================================
  // SCENE VISUALIZATION BUDGET SYSTEM
  // Limits re-visualizations to 2 per scene, finalizes on insert
  // Scene key = turnCount (stable identifier for narrative moments)
  // ============================================================

  function getSceneKey() {
      // Use turnCount as scene identifier - increments with each player action
      return 'turn_' + (state.turnCount || 0);
  }

  function getSceneBudget(sceneKey) {
      if (!state.visual.sceneBudgets) state.visual.sceneBudgets = {};
      if (!state.visual.sceneBudgets[sceneKey]) {
          // Track attempts (incremented at START of visualize, not on success)
          // Max 2 attempts allowed (attempt 1 = first try, attempt 2 = last chance)
          state.visual.sceneBudgets[sceneKey] = { attempts: 0, finalized: false };
      }
      // Migration: convert old 'remaining' format to new 'attempts' format
      const budget = state.visual.sceneBudgets[sceneKey];
      if (budget.remaining !== undefined && budget.attempts === undefined) {
          budget.attempts = 2 - budget.remaining;
          delete budget.remaining;
      }
      return budget;
  }

  function incrementSceneAttempts(sceneKey) {
      const budget = getSceneBudget(sceneKey);
      budget.attempts = (budget.attempts || 0) + 1;
      saveStorySnapshot();
      return budget.attempts;
  }

  function getAttemptsRemaining(sceneKey) {
      const budget = getSceneBudget(sceneKey);
      return Math.max(0, 2 - (budget.attempts || 0));
  }

  function finalizeScene(sceneKey) {
      const budget = getSceneBudget(sceneKey);
      budget.finalized = true;
      saveStorySnapshot();
  }

  function updateVizButtonStates() {
      const sceneKey = getSceneKey();
      const budget = getSceneBudget(sceneKey);
      const fortunes = state.fortunes || 0;
      const sceneVisualized = state.visual.visualizedScenes && state.visual.visualizedScenes[sceneKey];

      const vizBtn = document.getElementById('vizSceneBtn');
      const retryBtn = document.getElementById('vizRetryBtn');
      const insertBtn = document.getElementById('vizInsertBtn');
      const img = document.getElementById('vizPreviewImg');
      const fortuneCount = document.getElementById('vizCreditCount');

      // Update Fortune display (numeric, always visible)
      if (fortuneCount) {
          fortuneCount.textContent = fortunes;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // VISUALIZE BUTTON â€” ALWAYS CLICKABLE (except when generating)
      // Disabled ONLY when: _vizInFlight === true
      // Click-time branching handles paywall vs visualization
      // PLAQUE REGIME: No inline opacity â€” use classes for state
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (vizBtn) {
          if (_vizInFlight) {
              // Currently generating â€” disable to prevent double-click
              vizBtn.textContent = 'â³ Generating...';
              vizBtn.disabled = true;
              vizBtn.classList.add('is-loading');
              vizBtn.classList.remove('is-finalized');
          } else if (budget.finalized) {
              // Finalized â€” show locked state but keep clickable for feedback
              vizBtn.textContent = 'ğŸ”’ Finalized';
              vizBtn.disabled = false;
              vizBtn.classList.add('is-finalized');
              vizBtn.classList.remove('is-loading');
          } else {
              // Default state â€” always clickable, shows Fortune count
              const label = fortunes > 0 ? 'âœ¨ Summon Vision' : 'âœ¨ Summon Vision (1 Fortune)';
              vizBtn.textContent = label;
              vizBtn.disabled = false;
              vizBtn.classList.remove('is-loading', 'is-finalized');
          }
      }

      // Re-Visualize: NEVER disabled â€” opens Fortune purchase if none
      if (retryBtn) {
          if (budget.finalized) {
              retryBtn.textContent = 'Finalized';
              retryBtn.disabled = true;
          } else {
              retryBtn.textContent = fortunes > 0 ? 'Re-Summon' : 'Re-Summon (1 Fortune)';
              retryBtn.disabled = false;
              retryBtn.title = '';
          }
      }

      // Insert button: state-gated (disabled when no image), not Fortune-gated
      if (insertBtn) {
          const hasImage = img && img.src && img.style.display !== 'none';
          if (hasImage) {
              insertBtn.disabled = false;
              // PLAQUE REGIME: No opacity mutation
          } else {
              insertBtn.disabled = true;
              // PLAQUE REGIME: CSS handles disabled state
          }
      }
  }

  // Re-Visualize handler: opens fortune purchase if no fortunes
  window.handleReVisualize = function() {
      if (!hasFortunes()) {
          openFortunePurchaseModal();
          return;
      }
      window.summonVision(true);
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRUST REPAIR: Enable pay-as-you-go from within the visualization modal
  // User has seen the prompt, understood the system, and explicitly opted in
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window.enablePayAsYouGoFromViz = function() {
      openFortunePurchaseModal();
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRUST REPAIR: Modifier validation â€” reject disallowed modifiers explicitly
  // Never silently ignore or pretend to accept disallowed modifiers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Modifiers disallowed at specific arousal levels
  const AROUSAL_RESTRICTED_MODIFIERS = {
      Clean: [
          /\b(breast|breasts|boob|boobs|nipple|nipples|cleavage|busty|thicc)\b/i,
          /\b(butt|butts|ass|booty|thighs|legs|curves)\b/i,
          /\b(nude|naked|undressing|lingerie|underwear|bra|panties)\b/i,
          /\b(erotic|sensual|seductive|aroused|horny)\b/i,
          /\b(tail|tails|ears|furry|catgirl|bunny)\b/i
      ],
      Naughty: [
          /\b(nude|naked|explicit|genitals|penis|vagina)\b/i,
          /\b(sex|fucking|penetration|orgasm)\b/i
      ]
  };

  function validateModifier(modifier, arousalLevel) {
      const normalizedArousal = (arousalLevel || 'Naughty').toLowerCase();
      const level = normalizedArousal.charAt(0).toUpperCase() + normalizedArousal.slice(1);

      // Get restrictions for current and lower levels
      let restrictions = [];
      if (level === 'Clean') {
          restrictions = AROUSAL_RESTRICTED_MODIFIERS.Clean || [];
      } else if (level === 'Naughty') {
          restrictions = [
              ...(AROUSAL_RESTRICTED_MODIFIERS.Clean || []),
              ...(AROUSAL_RESTRICTED_MODIFIERS.Naughty || [])
          ];
      }
      // Erotic and Dirty have no restrictions (explicit content allowed)

      for (const pattern of restrictions) {
          if (pattern.test(modifier)) {
              return {
                  valid: false,
                  reason: `This visualization is capped at ${level}-level intensity. The modifier "${modifier.match(pattern)[0]}" cannot be applied at this arousal level.`
              };
          }
      }

      return { valid: true };
  }

  function showModifierRejection(message) {
      const rejectionEl = document.getElementById('vizModifierRejection');
      if (rejectionEl) {
          rejectionEl.textContent = message;
          rejectionEl.classList.remove('hidden');
          // Auto-hide after 5 seconds
          setTimeout(() => rejectionEl.classList.add('hidden'), 5000);
      }
      console.warn('[VIZ:MODIFIER] Rejected:', message);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BACKGROUND PROMPT PRE-LOADING â€” Cache prompt while user reads
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _vizPromptCache = { turnCount: -1, prompt: null, pending: null };

  async function preloadVizPrompt() {
      const turn = state.turnCount;
      // Already cached or in-flight for this turn
      if (_vizPromptCache.turnCount === turn && (_vizPromptCache.prompt || _vizPromptCache.pending)) return;

      _vizPromptCache = { turnCount: turn, prompt: null, pending: null };

      // Wry Confessional: synchronous, cache immediately
      if (state.picks?.tone === 'Wry Confessional') {
          const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const lastText = allStoryContent.slice(-600) || "";
          const condensedScene = condenseSceneObservational(lastText, 120);
          _vizPromptCache.prompt = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
          console.log('[VIZ:PRELOAD] Wry prompt cached (sync) for turn', turn);
          return;
      }

      // Standard path: async LLM call in background
      const job = (async () => {
          try {
              const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
              const lastText = allStoryContent.slice(-600) || "";
              await ensureVisualBible(allStoryContent);
              const anchorText = buildVisualAnchorsText();
              const visualizePrompt = buildVisualizePrompt({ mode: 'scene', lastText, anchorText });

              const promptMsg = await Promise.race([
                  callChat([{ role:'user', content: visualizePrompt }]),
                  new Promise((_, reject) => setTimeout(() => reject(new Error("Preload timeout")), 25000))
              ]);
              // Only cache if still same turn
              if (_vizPromptCache.turnCount === turn) {
                  _vizPromptCache.prompt = promptMsg;
                  console.log('[VIZ:PRELOAD] Prompt cached for turn', turn);
              }
          } catch (e) {
              // Fallback â€” still useful
              if (_vizPromptCache.turnCount === turn) {
                  _vizPromptCache.prompt = "Cinematic scene, " + (state.picks?.world || 'atmospheric') + " world, natural lighting, grounded emotion.";
                  console.log('[VIZ:PRELOAD] Fallback prompt cached for turn', turn);
              }
          }
      })();
      _vizPromptCache.pending = job;
  }
  window.preloadVizPrompt = preloadVizPrompt;

  // Populate prompt textarea without generating image (for 0-Fortune inspection)
  async function populateVizPromptOnly() {
      const ph = document.getElementById('vizPlaceholder');
      const promptInput = document.getElementById('vizPromptInput');

      // Show idle placeholder (not "Generating...")
      if (ph) {
          ph.textContent = 'Visions cost 1 Fortune per scene.';
          ph.style.display = 'flex';
      }

      // Check cache first
      if (_vizPromptCache.turnCount === state.turnCount) {
          if (_vizPromptCache.prompt) {
              if (promptInput) {
                  promptInput.value = _vizPromptCache.prompt;
                  promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
                  promptInput.classList.remove('viz-loading');
              }
              console.log('[VIZ] Prompt loaded from cache (instant)');
              return;
          }
          if (_vizPromptCache.pending) {
              // Cache is in-flight â€” show loading, then fill when ready
              if (promptInput) {
                  promptInput.value = '';
                  promptInput.placeholder = 'Generating visualization promptâ€¦';
                  promptInput.classList.add('viz-loading');
              }
              await _vizPromptCache.pending;
              if (_vizPromptCache.prompt && promptInput) {
                  promptInput.value = _vizPromptCache.prompt;
                  promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
                  promptInput.classList.remove('viz-loading');
              }
              console.log('[VIZ] Prompt loaded from pending cache');
              return;
          }
      }

      // No cache â€” generate fresh (original path)
      const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      const lastText = allStoryContent.slice(-600) || "";

      // WRY CONFESSIONAL â€” SYNCHRONOUS
      if (state.picks?.tone === 'Wry Confessional') {
          const condensedScene = condenseSceneObservational(lastText, 120);
          const wryPrompt = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
          if (promptInput) {
              promptInput.value = wryPrompt;
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.classList.remove('viz-loading');
          }
          return;
      }

      // STANDARD PATH: Show loading while LLM generates prompt
      if (promptInput) {
          promptInput.value = '';
          promptInput.placeholder = 'Generating visualization promptâ€¦';
          promptInput.classList.add('viz-loading');
      }

      await ensureVisualBible(allStoryContent);

      const anchorText = buildVisualAnchorsText();
      const visualizeMode = 'scene';
      const visualizePrompt = buildVisualizePrompt({ mode: visualizeMode, lastText, anchorText });

      try {
          const promptMsg = await Promise.race([
              callChat([{
                  role:'user',
                  content: visualizePrompt
              }]),
              new Promise((_, reject) => setTimeout(() => reject(new Error("Prompt timeout")), 25000))
          ]);
          if (promptInput) {
              promptInput.classList.remove('viz-loading');
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.value = promptMsg;
          }
      } catch (e) {
          const fallback = "Cinematic scene, " + (state.picks?.world || 'atmospheric') + " world, natural lighting, grounded emotion.";
          if (promptInput) {
              promptInput.classList.remove('viz-loading');
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.value = fallback;
          }
      }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FATE CARD CONTEXTUAL PREVIEW â€” Generates Say/Do examples based on scene
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Called when a fate card is selected to generate personalized action/dialogue
  // previews tied to: POV character, other characters present, scene situation, tone.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let _fatePreviewInFlight = false;

  window.generateFatePreview = async function(cardData) {
      if (_fatePreviewInFlight) return;
      if (!cardData) return;

      const actInput = document.getElementById('actionInput');
      const diaInput = document.getElementById('dialogueInput');
      if (!actInput || !diaInput) return;

      // Get scene context
      const allStoryContent = StoryPagination?.getAllContent?.()?.replace(/<[^>]*>/g, ' ') || '';
      const recentScene = allStoryContent.slice(-800) || '';

      // Skip preview generation if no substantial story yet
      if (recentScene.length < 100) {
          actInput.value = cardData.action || '';
          diaInput.value = cardData.dialogue || '';
          return;
      }

      // Gather character/tone context
      const tone = state.picks?.tone || 'Earnest';
      const protagonistGender = state.gender || 'Female';
      const liGender = state.loveInterest || 'Male';
      const world = state.picks?.world || 'Modern';
      const archSummary = ARCHETYPES[state.archetype?.primary]?.summary || '';

      // Characters from visual bible (if available)
      const characters = state.visual?.bible?.characters || {};
      const charNames = Object.keys(characters).slice(0, 3).join(', ') || 'protagonist and love interest';

      _fatePreviewInFlight = true;

      // Show loading state
      actInput.value = 'â€¦';
      actInput.classList.add('fate-preview-loading');
      diaInput.value = 'â€¦';
      diaInput.classList.add('fate-preview-loading');

      const previewPrompt = `You are generating contextual Say/Do previews for an interactive romance story.

FATE CARD SELECTED:
- Title: ${cardData.title}
- Theme: ${cardData.desc}
- Generic Action: ${cardData.action}
- Generic Dialogue: ${cardData.dialogue}

CURRENT SCENE CONTEXT:
${recentScene.slice(-400)}

STORY PARAMETERS:
- Tone: ${tone}
- World: ${world}
- Protagonist: ${protagonistGender}
- Love Interest behavioral profile: ${archSummary}
- Love Interest: ${liGender} (use ${liGender === 'Male' ? 'he/him' : liGender === 'Female' ? 'she/her' : 'they/them'} pronouns)
- Characters present: ${charNames}

PRONOUN RULE: Use correct pronouns for the Love Interest. Never use archetype labels (Storybeau, Storybelle, Storyboo) or archetype titles in any output.

TASK: Generate TWO short, contextual previews that fit THIS EXACT SCENE:
1. "Do" â€” A specific physical action the protagonist could take RIGHT NOW (max 12 words)
2. "Say" â€” A specific line of dialogue the protagonist could speak RIGHT NOW (max 15 words, in quotes)

These must:
- Reference actual details from the scene (location, objects, other characters)
- Match the ${tone} tone
- Feel like natural continuations of what's happening
- Be more specific than the generic card suggestions

Respond in this EXACT format (no labels, just two lines):
[action on first line]
[dialogue in quotes on second line]`;

      try {
          const response = await Promise.race([
              callChat([{ role: 'user', content: previewPrompt }]),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Preview timeout')), 8000))
          ]);

          if (_fatePreviewInFlight && response) {
              const lines = response.trim().split('\n').filter(l => l.trim());
              const actionPreview = lines[0]?.trim() || cardData.action;
              const dialoguePreview = lines[1]?.trim() || cardData.dialogue;

              actInput.value = actionPreview;
              diaInput.value = dialoguePreview;
          }
      } catch (e) {
          console.log('[FATE:Preview] Generation failed, using defaults:', e.message);
          actInput.value = cardData.action || '';
          diaInput.value = cardData.dialogue || '';
      } finally {
          _fatePreviewInFlight = false;
          actInput.classList.remove('fate-preview-loading');
          diaInput.classList.remove('fate-preview-loading');
      }
  };

  // Cancel any in-flight preview (called when card selection changes)
  window.cancelFatePreview = function() {
      _fatePreviewInFlight = false;
  };

  window.summonVision = async function(isRe){
      if (_vizInFlight) return;

      const modal = document.getElementById('vizModal');
      const retryBtn = document.getElementById('vizRetryBtn');
      const img = document.getElementById('vizPreviewImg');
      const ph = document.getElementById('vizPlaceholder');
      const errDiv = document.getElementById('vizError');
      const storyText = document.getElementById('storyText');
      const consentUI = document.getElementById('vizPayAsYouGoConsent');

      // Check scene budget and Fortunes before proceeding
      const sceneKey = getSceneKey();
      const budget = getSceneBudget(sceneKey);
      const sceneVisualized = state.visual.visualizedScenes && state.visual.visualizedScenes[sceneKey];

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TRUST REPAIR: ALWAYS open modal first â€” never route to paywall directly
      // Prompt is always visible. Consent shown inside modal when needed.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Block if scene is finalized
      if (budget.finalized) {
          if(modal) modal.classList.remove('hidden');
          if(errDiv) {
              errDiv.textContent = 'Scene finalized. Image already inserted.';
              errDiv.classList.remove('hidden');
          }
          if(consentUI) consentUI.classList.add('hidden');
          updateVizButtonStates();
          return;
      }

      // Scene already visualized â€” show modal with message
      if (!isRe && sceneVisualized) {
          if(modal) modal.classList.remove('hidden');
          if(errDiv) {
              errDiv.textContent = 'Scene already envisioned. Use Re-Summon to try again.';
              errDiv.classList.remove('hidden');
          }
          if(consentUI) consentUI.classList.add('hidden');
          updateVizButtonStates();
          return;
      }

      // Check fortunes
      if (!hasFortunes()) {
          console.log('[Fortunes] No fortunes â€” showing purchase modal');
          openFortunePurchaseModal();
          return;
      }

      // Has Fortunes â€” proceed with visualization
      console.log('[Vision]', isRe ? 'Re-Summon' : 'Initial Summon Vision');

      // Hide consent UI since we have access
      if(consentUI) consentUI.classList.add('hidden');

      _vizInFlight = true;
      _vizCancelled = false;

      if (!img) { _vizInFlight = false; return; }

      // Reset modifier UI when opening modal
      resetVizModifierUI();

      // Stop fate card sparkles when viz modal opens (prevent z-index bleed)
      if (window.stopSparkleCycle) window.stopSparkleCycle();
      if (typeof stopAmbientCardSparkles === 'function') stopAmbientCardSparkles();

      if(modal) modal.classList.remove('hidden');
      if(retryBtn) retryBtn.disabled = true;
      ensureLockButtonExists(); // Ensure lock button is present and updated

      // Initialize placeholder to "Generating..." since we're about to generate
      if(ph) {
          ph.textContent = 'Generating...';
      }

      // Update button states (includes Fortune display)
      updateVizButtonStates();

      // Start cancellable loading with cancel callback
      startLoading("Painting the scene...", VISUALIZE_LOADING_MESSAGES, true, () => {
          _vizCancelled = true;
      });

      const allStoryContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      const lastText = allStoryContent.slice(-600) || "";

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // WRY CONFESSIONAL â€” SYNCHRONOUS PROMPT ASSEMBLY (BEFORE async work)
      // Prompt must appear IMMEDIATELY when modal opens. No delay.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let wryPromptReady = false;
      if (state.picks?.tone === 'Wry Confessional') {
          const promptInput = document.getElementById('vizPromptInput');
          const condensedScene = condenseSceneObservational(lastText, 120);
          const wryPrompt = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
          if (promptInput) {
              promptInput.value = wryPrompt;
              promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
              promptInput.classList.remove('viz-loading');
          }
          wryPromptReady = true;
          console.log('[VIZ:WRY] Prompt populated IMMEDIATELY (sync)');
      }

      await ensureVisualBible(allStoryContent);

      // Check if cancelled during bible build
      if (_vizCancelled) {
          _vizInFlight = false;
          if(retryBtn) retryBtn.disabled = false;
          return;
      }

      const anchorText = buildVisualAnchorsText();

      img.onload = null; img.onerror = null;
      img.style.display = 'none';
      // Show "Generating..." only when actually generating
      if(ph) {
          ph.textContent = 'Generating...';
          ph.style.display = 'flex';
      }
      if(errDiv) errDiv.classList.add('hidden');

      try {
          let promptMsg = document.getElementById('vizPromptInput').value;
          const visualizeMode = 'scene';

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // WRY CONFESSIONAL â€” USE PRE-ASSEMBLED PROMPT (already populated above)
          // Prompt was assembled SYNCHRONOUSLY before any async work.
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (state.picks?.tone === 'Wry Confessional') {
              // Prompt is already in the input from sync assembly above
              // Only regenerate if this is a re-visualize with user-edited prompt
              if (!promptMsg && !wryPromptReady) {
                  const condensedScene = condenseSceneObservational(lastText, 120);
                  promptMsg = `This is an editorial cartoon illustration, NOT a photograph.\n\n${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${condensedScene}`;
                  const promptInput = document.getElementById('vizPromptInput');
                  if (promptInput) promptInput.value = promptMsg;
              } else {
                  promptMsg = document.getElementById('vizPromptInput').value;
              }
              console.log('[VIZ:WRY] Using sync-assembled prompt');
          } else if (!isRe || !promptMsg) {
              // Standard path: check cache first, then LLM
              const promptInput = document.getElementById('vizPromptInput');
              let usedCache = false;

              if (_vizPromptCache.turnCount === state.turnCount) {
                  if (_vizPromptCache.prompt) {
                      promptMsg = _vizPromptCache.prompt;
                      usedCache = true;
                      console.log('[VIZ] Using cached prompt (instant)');
                  } else if (_vizPromptCache.pending) {
                      if (promptInput) {
                          promptInput.value = '';
                          promptInput.placeholder = 'Generating visualization promptâ€¦';
                          promptInput.classList.add('viz-loading');
                      }
                      await _vizPromptCache.pending;
                      if (_vizPromptCache.prompt) {
                          promptMsg = _vizPromptCache.prompt;
                          usedCache = true;
                          console.log('[VIZ] Using pending-cached prompt');
                      }
                  }
              }

              if (!usedCache) {
                  // No cache â€” generate fresh
                  const visualizePrompt = buildVisualizePrompt({ mode: visualizeMode, lastText, anchorText });
                  if (promptInput) {
                      promptInput.value = '';
                      promptInput.placeholder = 'Generating visualization promptâ€¦';
                      promptInput.classList.add('viz-loading');
                  }
                  try {
                      promptMsg = await Promise.race([
                          callChat([{
                              role:'user',
                              content: visualizePrompt
                          }]),
                          new Promise((_, reject) => setTimeout(() => reject(new Error("Prompt timeout")), 25000))
                      ]);
                  } catch (e) {
                      promptMsg = "Cinematic scene, " + (state.picks?.world || 'atmospheric') + " world, natural lighting, grounded emotion.";
                  }
              }

              if (promptInput) {
                  promptInput.classList.remove('viz-loading');
                  promptInput.placeholder = 'Edit prompt or add modifiersâ€¦';
                  promptInput.value = promptMsg;
              }
          }

          // Check if cancelled during prompt generation
          if (_vizCancelled) {
              _vizInFlight = false;
              if(retryBtn) retryBtn.disabled = false;
              return;
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // WRY CONFESSIONAL â€” SHORT-CIRCUIT ALL STYLE INJECTORS
          // Editorial cartoon ONLY â€” no cinematic, no lighting, no intensity bias
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          let basePrompt;

          if (state.picks?.tone === 'Wry Confessional') {
              // Extract pure scene content (strip any style that crept in)
              const pureScene = promptMsg
                  .replace(/Editorial cartoon[^.]*\./gi, '')
                  .replace(/New Yorker[^.]*\./gi, '')
                  .replace(/flat.*color[^.]*\./gi, '')
                  .replace(/Scene:\s*/gi, '')
                  .replace(/Style:[^.]*\./gi, '')
                  .replace(/This image is[^.]*\./gi, '')
                  .trim();

              // ONTOLOGY-FIRST CONSTRUCTION â€” let the style declaration lead
              // No redundant "This is NOT a photograph" â€” ontology handles it
              basePrompt = `${WRY_CONFESSIONAL_VISUAL_ONTOLOGY}\n\nScene: ${pureScene}`;

              console.log('[VIZ:WRY] Short-circuited all style injectors â€” editorial cartoon only');
              console.log('[VIZ:WRY] Pure scene content:', pureScene.substring(0, 100));
          } else {
              // STANDARD PATH: All style injectors apply

              // Build base prompt with intensity bias, quality defaults, and veto exclusions
              const modifierInput = document.getElementById('vizModifierInput');
              const rawModifiers = modifierInput ? modifierInput.value.trim() : '';
              // RUNTIME NORMALIZATION: Visualize modifiers flow through ChatGPT normalization layer
              const vizNorm = await callNormalizationLayer({
                  axis: 'visualize',
                  user_text: rawModifiers,
                  context_signals: state.picks?.world || []
              });
              const userModifiers = vizNorm.normalized_text || rawModifiers;

              // Include veto exclusions in visual prompt
              const vetoExclusions = state.constraints?.excluded?.length > 0
                  ? " Exclude: " + state.constraints.excluded.slice(0, 3).join(', ') + "."
                  : "";

              // SCENE-FIRST PROMPT CONSTRUCTION
              const sceneDesc = await condenseSceneWithEmotion(promptMsg, 200);
              const modifiers = userModifiers ? " " + filterAuthorFromPrompt(userModifiers) : "";

              // Brief anchors from visual bible (characters only, 80 char max)
              const briefAnchors = filterAuthorFromPrompt(anchorText).slice(0, 80);

              // Scene visualization style â€” world-aware
              const SCENE_STYLE_BY_WORLD = {
                  Fantasy: 'Cinematic, painterly, warm golden-hour lighting. Natural expressions, grounded emotion.',
                  Historical: 'Cinematic, painterly, period-accurate palette. Candid expressions, oil-painting texture.',
                  Modern: 'Cinematic, contemporary, natural ambient lighting. Candid, unstaged expressions.',
                  SciFi: 'Cinematic, sleek high-contrast lighting, cool palette. Alert, focused expressions.',
                  Noir: 'Cinematic, chiaroscuro, neon-and-shadow contrast. Tense, guarded expressions.',
                  Gothic: 'Cinematic, dramatic chiaroscuro, deep reds and blacks. Haunted, strained expressions.',
                  Paranormal: 'Cinematic, ethereal glow, muted earth tones with spectral accents. Wary expressions.'
              };
              const sceneStyle = SCENE_STYLE_BY_WORLD[state.picks?.world]
                  || 'Cinematic, painterly, atmospheric, natural lighting. Grounded expressions.';
              const intensityBias = getVisualizeIntensityBias();
              const shortIntensity = intensityBias.split('.')[0] + ".";

              // SCENE FIRST, then style, then mandatory exclusions
              basePrompt = sceneDesc + modifiers +
                  "\n---\n" +
                  sceneStyle + " " +
                  shortIntensity + " " +
                  SCENE_VIZ_EXCLUSIONS +
                  vetoExclusions +
                  (briefAnchors ? " Anchors: " + briefAnchors : "");

              // VISUAL INTENT GUARD: Enforce attractiveness + balanced lighting
              basePrompt = applyVisualIntentGuard(basePrompt, {
                  tone: state.picks?.tone,
                  world: state.picks?.world,
                  intensity: state.intensity
              });
          }

          // REGRESSION GUARD: Block cinematic drift for Wry Confessional
          assertWryConfessionalVisual(basePrompt, 'visualize:basePrompt');

          // Check if cancelled before image generation
          if (_vizCancelled) {
              _vizInFlight = false;
              if(retryBtn) retryBtn.disabled = false;
              return;
          }

          // IMAGE ENGINE ROUTING â€” intensity no longer controls engine selection
          const rawUrl = await generateTieredImage(basePrompt, 'Clean');

          // Check if cancelled after image generation
          if (_vizCancelled) {
              _vizInFlight = false;
              if(retryBtn) retryBtn.disabled = false;
              return;
          }

          if (!rawUrl) throw new Error("Image generation failed.");

          let imageUrl = rawUrl;
          if (!rawUrl.startsWith('http') && !rawUrl.startsWith('data:') && !rawUrl.startsWith('blob:')) {
              imageUrl = `data:image/png;base64,${rawUrl}`;
          }

          img.src = imageUrl;

          await new Promise((resolve, reject) => {
              // Add timeout for image load
              const loadTimeout = setTimeout(() => {
                  reject(new Error("Image load timeout"));
              }, 30000);

              img.onload = async () => {
                  clearTimeout(loadTimeout);
                  img.style.display = 'block';
                  if(ph) ph.style.display = 'none';
                  // Don't store base64 images to avoid QuotaExceededError
                  // Only store external URLs (not data: or blob:)
                  if (img.src && !img.src.startsWith('data:') && !img.src.startsWith('blob:')) {
                      state.visual.lastImageUrl = img.src;
                  } else {
                      state.visual.lastImageUrl = ''; // Clear to prevent storage overflow
                  }
                  if (state.visual.autoLock && !state.visual.locked) state.visual.locked = true;

                  // FORTUNE CONSUMPTION: 1 fortune per visualization
                  if (!img.src) {
                      console.error('[Fortunes] Fortune decrement blocked â€” no image URL');
                      return;
                  }
                  await consumeFortune(1, 'visualization');
                  if (!state.visual.visualizedScenes) state.visual.visualizedScenes = {};
                  state.visual.visualizedScenes[sceneKey] = true;

                  updateVizButtonStates();

                  saveStorySnapshot();
                  resolve();
              };
              img.onerror = () => {
                  clearTimeout(loadTimeout);
                  reject(new Error("Image failed to render"));
              };
          });

      } catch(e) {
          // Don't show error if cancelled
          if (!_vizCancelled) {
              console.error("Vision error:", e);
              if(errDiv) {
                  errDiv.innerText = "Vision failed. Fate is cloudy.";
                  errDiv.classList.remove('hidden');
              }
              if(ph) ph.style.display = 'none';
          }
      } finally {
          stopLoading();
          _vizInFlight = false;
          if(retryBtn) retryBtn.disabled = false;
      }
  };

  /**
   * triggerVision â€” free milestone Vision bypass.
   * Calls the same image generation pipeline as summonVision()
   * but skips Fortune consumption entirely.
   * Used ONLY for onboarding milestone Visions.
   */
  async function triggerVision(options = {}) {
      const { overlayText = null, reason = 'milestone' } = options;

      // Single-turn guard: only one milestone Vision per turn
      if (state.milestone_vision_fired_this_turn) return;

      console.log(`[VISION] Milestone vision triggered: ${reason}`);

      const sceneKey = getSceneKey();
      const modal = document.getElementById('vizModal');
      const previewImg = document.getElementById('vizPreviewImg');
      const errDiv = document.getElementById('vizError');
      const placeholder = document.getElementById('vizPlaceholder');

      if (!modal || _vizInFlight) return;

      state.milestone_vision_fired_this_turn = true;
      _vizInFlight = true;
      _vizCancelled = false;
      modal.classList.remove('hidden');

      if (placeholder) placeholder.style.display = 'flex';
      if (previewImg) previewImg.style.display = 'none';
      if (errDiv) { errDiv.classList.add('hidden'); errDiv.textContent = ''; }

      const lastText = StoryPagination.getLastPageText?.() || '';
      const vizPrompt = buildVisualizePrompt({ mode: 'scene', lastText, anchorText: lastText });

      try {
          const result = await generateImageWithFallback({
              prompt: vizPrompt,
              tier: 'Clean',
              shape: 'landscape',
              context: 'vision_milestone',
              intent: 'scene'
          });

          if (_vizCancelled) { _vizInFlight = false; return; }

          if (result?.url) {
              if (previewImg) {
                  previewImg.src = result.url;
                  previewImg.style.display = 'block';
              }
              if (placeholder) placeholder.style.display = 'none';

              if (!state.visual.visualizedScenes) state.visual.visualizedScenes = {};
              state.visual.visualizedScenes[sceneKey] = true;
              updateVizButtonStates();

              console.log(`[VISION] Milestone vision rendered: ${reason}`);
          } else {
              if (errDiv) { errDiv.textContent = 'Vision failed. Fate is cloudy.'; errDiv.classList.remove('hidden'); }
          }
      } catch (err) {
          console.error('[VISION] Milestone vision error:', err);
          if (errDiv) { errDiv.textContent = 'Vision failed. Fate is cloudy.'; errDiv.classList.remove('hidden'); }
      } finally {
          _vizInFlight = false;
      }
  }

  window.closeViz = function(){
      $('vizModal').classList.add('hidden');
      _vizInFlight = false;
      const retryBtn = document.getElementById('vizRetryBtn');
      if(retryBtn) retryBtn.disabled = false;
  };

  // ============================================================
  // FORTUNE PURCHASE REDIRECT (legacy pay-as-you-go entry points)
  // ============================================================

  function showPayAsYouGoModal() {
      openFortunePurchaseModal();
  }

  window.closePayAsYouGoModal = function() {
      closeFortunePurchaseModal();
  };

  window.confirmPayAsYouGo = function() {
      openFortunePurchaseModal();
  };

  // Lock Character Look â€” driven by checkbox toggle
  window.lockCharacterLook = function() {
      if (!state.visual) {
          state.visual = { autoLock: true, locked: false, lastImageUrl: "", bible: { style: "", setting: "", characters: {} } };
      }
      state.visual.locked = true;
      showToast('Character look locked. Appearance will persist.');
      saveStorySnapshot();
  };

  window.unlockCharacterLook = function() {
      if (!state.visual) return;
      state.visual.locked = false;
      showToast('Character look unlocked.');
      saveStorySnapshot();
  };

  // Sync checkbox state when vizModal opens
  function syncLockCheckbox() {
      const chk = document.getElementById('chkAutoLockVisual');
      if (chk) chk.checked = !!state.visual?.locked;
  }

  // Wire checkbox to lock/unlock directly
  document.getElementById('chkAutoLockVisual')?.addEventListener('change', function() {
      if (this.checked) {
          window.lockCharacterLook();
      } else {
          window.unlockCharacterLook();
      }
  });

  // Backwards-compatible stub
  function ensureLockButtonExists() {
      syncLockCheckbox();
  }
  function updateLockButtonState() {
      syncLockCheckbox();
  }

  // (Legacy lockLookContainer fallback removed â€” checkbox drives lock state directly)

  // TASK B: Initialize provider dropdown with available providers
  // PROVIDER VISIBILITY: All providers shown, unavailable ones are disabled with explanation
  function initVizProviderDropdown() {
      const dropdown = document.getElementById('vizModel');
      if (!dropdown) return;

      // Clear existing options
      dropdown.innerHTML = '';

      // Check Gemini availability (fortunes required)
      const geminiAvailable = hasFortunes();

      // All providers shown â€” unavailable ones are disabled, not hidden
      const providers = [
          {
              value: 'openai',
              label: 'OpenAI (Primary)',
              available: true
          },
          {
              value: 'replicate',
              label: 'Replicate FLUX (Fallback)',
              available: true
          },
          {
              value: 'gemini',
              label: geminiAvailable ? 'Gemini' : 'Gemini (No Fortunes)',
              available: geminiAvailable
          }
      ];

      // Add options â€” disabled providers are visible but not selectable
      providers.forEach((p, i) => {
          const opt = document.createElement('option');
          opt.value = p.value;
          opt.textContent = p.label;
          opt.disabled = !p.available;
          if (p.available && i === 0) opt.selected = true;
          dropdown.appendChild(opt);
      });

      // TASK B: Enable dropdown - it was disabled
      dropdown.disabled = false;
      dropdown.style.opacity = '1';

      // Store selection in state
      dropdown.addEventListener('change', (e) => {
          state.visual.preferredProvider = e.target.value;
      });
  }

  // Initialize provider dropdown on DOMContentLoaded
  if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initVizProviderDropdown);
  } else {
      initVizProviderDropdown();
  }

  window.insertImage = function(){
      const img = document.getElementById('vizPreviewImg');
      if(!img.src) return;

      // Finalize scene on insert - no more visualizations allowed
      const sceneKey = getSceneKey();
      finalizeScene(sceneKey);

      // Append visualized image to current page
      const imgHtml = `<img src="${img.src}" class="story-image" alt="Vision">`;
      StoryPagination.appendToCurrentPage(imgHtml);

      // Update button states to reflect finalized status
      updateVizButtonStates();

      window.closeViz();
      saveStorySnapshot();
  };

  // --- GAME LOOP ---
  $('submitBtn')?.addEventListener('click', async () => {
      // TASK F: Immediate visual feedback on click
      const submitBtn = $('submitBtn');
      if (submitBtn) {
          submitBtn.classList.add('submitting');
      }
      // Disable Next while scene generation is pending
      const _nextBtn = document.getElementById('nextPageBtn');
      if (_nextBtn) _nextBtn.disabled = true;

      const billingLock = (state.mode === 'solo') && ['affair','soulmates'].includes(state.storyLength) && !state.subscribed;
      if (billingLock) {
          if (submitBtn) submitBtn.classList.remove('submitting');
          // Affair/Soulmates story lengths ALWAYS require Subscribe ($6)
          window.showPaywall('sub_only');
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TEASE TIER CLIFFHANGER GATE: Diegetic omen + ritual overlay
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (isTeaseTier() && (state.turnCount || 0) >= state.TEASE_SCENE_CAP && state.tempQuillAllowance <= 0) {
          if (submitBtn) submitBtn.classList.remove('submitting');
          console.log('[TEASE] Scene cap reached:', state.turnCount, '>=', state.TEASE_SCENE_CAP);
          // Diegetic omen: subtle shake + fade
          const storyContent = document.getElementById('storyContent');
          if (storyContent) {
              storyContent.style.transition = 'opacity 0.3s ease, transform 0.15s ease';
              storyContent.style.opacity = '0.6';
              storyContent.style.transform = 'translateX(-3px)';
              setTimeout(() => { storyContent.style.transform = 'translateX(3px)'; }, 150);
              setTimeout(() => { storyContent.style.transform = ''; storyContent.style.opacity = '1'; }, 500);
          }
          // Show ritual overlay after brief omen delay
          setTimeout(() => window.showPaywall('unlock'), 600);
          return;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SERVER-SIDE TEASE GUARD: Prevent client tampering
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (isTeaseTier()) {
          try {
              const user = sb.auth.getUser ? (await sb.auth.getUser()).data?.user : null;
              if (user) {
                  const guardRes = await fetch('/api/tease-guard', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ userId: user.id, action: 'check' })
                  });
                  if (guardRes.status === 403) {
                      if (submitBtn) submitBtn.classList.remove('submitting');
                      console.warn('[TEASE] Server-side cap reached');
                      window.showPaywall('unlock');
                      return;
                  }
              }
          } catch (err) {
              console.warn('[TEASE] Server guard check failed (proceeding):', err);
          }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FORTUNE BURN: Every scene costs 1 fortune (unless free tease range)
      // Tease tier users get free scenes up to TEASE_SCENE_CAP
      // StoryPass/subscriber holders burn 1 fortune per scene
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const inFreeTease = isTeaseTier() && (state.turnCount || 0) < state.TEASE_SCENE_CAP;
      if (!inFreeTease) {
          if (!hasFortunes()) {
              if (submitBtn) submitBtn.classList.remove('submitting');
              openFortunePurchaseModal();
              return;
          }
          const burned = await consumeFortune(1, 'scene');
          if (!burned) {
              if (submitBtn) submitBtn.classList.remove('submitting');
              openFortunePurchaseModal();
              return;
          }
      }
      // Reset petition flag for new scene
      state.petitionUsedThisScene = false;

      const rawAct = $('actionInput').value.trim();
      const rawDia = $('dialogueInput').value.trim();
      if(!rawAct && !rawDia) {
          if (submitBtn) submitBtn.classList.remove('submitting');
          return alert("Input required.");
      }

      // TASK F: Start loading IMMEDIATELY after validation (before normalization)
      startLoading("Fate is weaving...", STORY_LOADING_MESSAGES);

      // RUNTIME NORMALIZATION: Action/dialogue inputs flow through ChatGPT normalization layer
      const axis = 'action';
      const actNorm = await callNormalizationLayer({
          axis: axis,
          user_text: rawAct,
          context_signals: state.picks?.world || []
      });
      const diaNorm = await callNormalizationLayer({
          axis: axis,
          user_text: rawDia,
          context_signals: state.picks?.world || []
      });
      const act = actNorm.canonical_instruction || actNorm.normalized_text || rawAct;
      const dia = diaNorm.canonical_instruction || diaNorm.normalized_text || rawDia;

      // Get selected Fate Card title for separator
      let selectedFateCard = null;
      if (state.fateOptions && typeof state.fateSelectedIndex === 'number' && state.fateSelectedIndex >= 0) {
          selectedFateCard = state.fateOptions[state.fateSelectedIndex];
          if (selectedFateCard) logEvent('fate_used', { card: selectedFateCard.title || selectedFateCard.id });
      }

      const { safeAction, safeDialogue, flags } = sanitizeUserIntent(act, dia);
      if (flags.includes("redirect_nonconsent")) {
          stopLoading();
          if (submitBtn) submitBtn.classList.remove('submitting');
          showToast("Boundary Redirect Active");
          if(safeAction) $('actionInput').value = safeAction;
          if(safeDialogue) $('dialogueInput').value = safeDialogue;
          return;
      }

      // Get story context from all pages
      const allContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
      const context = allContent.slice(-3000);
      
      // INTIMACY WINDOW â€” computed, not persisted
      const intimacyWindowOpen =
          isIntimacyAllowedAtCurrentStoryturn() &&
          (state.turnCount || 0) >= getMainPairIntimacyGateScene();

      // Track turns inside window; reset when outside
      if (intimacyWindowOpen) {
          state.intimacyTurnsInWindow += 1;
      } else {
          state.intimacyTurnsInWindow = 0;
      }

      // MAIN PAIR AUTHORIZATION â€” ST3 + SceneGate + (PlayerInitiated OR 2+ turns in window)
      const playerInitiated = detectPlayerInitiation(safeAction, safeDialogue);
      const mainPairAuthorized =
          (intimacyWindowOpen &&
           (playerInitiated ||
            state.intimacyTurnsInWindow >= 2));

      // SCENE-LEVEL EXPLICIT CONTEXT â€” NPCÃ—NPC, brothel, dream, etc.
      const sceneExplicitContext = detectSceneExplicitContext(context);

      // COMBINED: explicit embodiment authorized if main pair OR scene context
      const explicitEmbodimentAuthorized =
          mainPairAuthorized || sceneExplicitContext;
      state._explicitEmbodimentAuthorized = explicitEmbodimentAuthorized;

      let intensityGuard = "";
      if (mainPairAuthorized) {
          intensityGuard = "INTIMACY AUTHORIZED: The player has initiated physical escalation at the appropriate narrative stage. Explicit intimacy is permitted. Maintain literary tone and the selected Style voice.";
      } else if (sceneExplicitContext) {
          intensityGuard = `SCENE EXPLICIT CONTEXT: The scene involves NPC intimacy, a brothel/bathhouse/orgy environment, or a dream/fantasy sequence. Explicit embodiment is permitted for side characters, background figures, dream sequences, fantasies, or non-primary interactions.

MAIN PAIR RESTRICTION:
The primary romantic pair must NOT consummate or advance their physical union in this beat.
Their relationship pacing remains governed by ST progression.
If both main characters are present, render their tension and restraint ONLY â€” no physical escalation between them.`;
      } else if (intimacyWindowOpen && !playerInitiated && state.intimacyTurnsInWindow === 1) {
          intensityGuard = "Intimacy window is open. Increase tension and proximity. Do not escalate to explicit union yet.";
      } else {
          intensityGuard = "INTIMACY NOT YET AUTHORIZED: Focus on tension, chemistry, emotional stakes, and near-misses. Fade to black or redirect if the player attempts explicit escalation.";
      }

      // Flag for renderer safety belt: restrict main pair when scene-explicit context fires without main pair authorization
      const mainPairRestricted = sceneExplicitContext && !mainPairAuthorized;

      // PACING HELPER
      function buildPacingDirective() {
          const wc = currentStoryWordCount();
          const len = state.storyLength || 'taste';
          // Heuristic based on stage
          if (state.storyStage === 'post-consummation') state.flingClimaxDone = true;

          let dir = "";
          if (len === 'taste') {
             if (wc > 6500) {
               dir = "PACING ALERT (TASTE TIER): Approaching limit. Build extreme tension but DENY release. Steer narrative toward an unresolved cliffhanger ending. Do NOT resolve the desire.";
             }
          } else if (len === 'fling') {
             if (state.flingClimaxDone) {
                dir = "PACING ALERT (FLING TIER): Climax occurred. Now introduce a complication, regret, or external consequence. Steer toward an unresolved ending/cliffhanger regarding this new problem. Do NOT resolve fully.";
             } else if (wc > 15000) {
                dir = "PACING ALERT (FLING TIER): Approaching story limit. Push for the single permitted erotic climax now.";
             }
          } else if (['affair', 'soulmates'].includes(len)) {
             dir = "PACING: Standard arc pacing. Allow beats to breathe. Avoid abrupt cliffhangers unless consistent with chapter flow. Resolve arcs naturally.";
          }
          return dir;
      }

      const pacingDirective = buildPacingDirective();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ADAPTIVE PACING â€” Velocity Score + Erotic Pressure Scoring
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      const _EROTIC_KEYWORD_RX = /\b(fuck|sex|cock|pussy|cum|orgasm|moan|naked|strip|thrust|lick|suck|nipple|clit|erect|wet|hard(?:er)?|ride|spank|choke|bite|grind)\b/i;

      function trackAdaptiveMetrics(playerInput, sceneText) {
        const m = state.adaptiveMetrics;
        m.turnTimestamps.push(Date.now());
        m.userInputLengths.push((playerInput || '').length);
        m.sceneWordCounts.push((sceneText || '').split(/\s+/).length);
        if (state.cascadeMode) m.cascadeCountWindow++;
        if (_EROTIC_KEYWORD_RX.test(playerInput || '')) m.eroticSignalCount++;
        // Trim to 20 entries
        if (m.turnTimestamps.length > 20) m.turnTimestamps.shift();
        if (m.userInputLengths.length > 20) m.userInputLengths.shift();
        if (m.sceneWordCounts.length > 20) m.sceneWordCounts.shift();
      }

      function computeVelocityScore() {
        const m = state.adaptiveMetrics;
        const ts = m.turnTimestamps;
        if (ts.length < 2) return 0.5; // default HYBRID until enough data

        let totalInterval = 0;
        for (let i = 1; i < ts.length; i++) totalInterval += (ts[i] - ts[i - 1]);
        const avgTurnIntervalMs = totalInterval / (ts.length - 1);

        const windowMs = ts[ts.length - 1] - ts[0];
        const scenesPerHour = windowMs > 0 ? (ts.length / (windowMs / 3600000)) : 0;

        const sphComponent = Math.min(scenesPerHour / 20, 1) * 0.5;
        const intervalComponent = Math.min(60000 / Math.max(avgTurnIntervalMs, 1000), 1) * 0.3;
        const cascadeComponent = Math.min(m.cascadeCountWindow / 5, 1) * 0.2;

        return Math.min(Math.max(sphComponent + intervalComponent + cascadeComponent, 0), 1);
      }

      function computeEroticPressureScore() {
        const m = state.adaptiveMetrics;
        const petitionFreq = state.omen?.lastGreaterPetitionCount || 0;

        const eroticComponent = Math.min(m.eroticSignalCount / 10, 1) * 0.6;
        const cascadeComponent = Math.min(m.cascadeCountWindow / 5, 1) * 0.2;
        const petitionComponent = Math.min(petitionFreq / 5, 1) * 0.2;

        return Math.min(Math.max(eroticComponent + cascadeComponent + petitionComponent, 0), 1);
      }

      function updateAdaptivePacing() {
        const vs = computeVelocityScore();
        if (vs < 0.33) state.pacingMode = 'IMMERSIVE';
        else if (vs < 0.66) state.pacingMode = 'HYBRID';
        else state.pacingMode = 'RAPID';

        const ep = computeEroticPressureScore();
        state.eroticPressureScore = ep;

        // Classify erotic mode with redirect hysteresis
        if (ep < 0.33) state.eroticMode = 'ROMANTIC';
        else if (ep < 0.66) state.eroticMode = 'VISCERAL';
        else if (ep < 0.85) state.eroticMode = 'CARNAL';
        else if (state.redirectCooldownTurns > 0) state.eroticMode = 'CARNAL'; // hysteresis: stay CARNAL during cooldown
        else {
          state.eroticMode = 'INTENSITY_REDIRECT';
          state.redirectCooldownTurns = 5;
        }

        // Decrement cooldowns
        if (state.redirectCooldownTurns > 0) state.redirectCooldownTurns--;
        if (state.gooseCooldown > 0) state.gooseCooldown--;

        // Seduction eligibility: immersive pacer with high erotic signal but low cascade
        const m = state.adaptiveMetrics;
        const avgInputLen = m.userInputLengths.length > 0
          ? m.userInputLengths.reduce((a, b) => a + b, 0) / m.userInputLengths.length
          : 0;
        state.seductionEligible = (
          state.pacingMode === 'IMMERSIVE' &&
          m.eroticSignalCount >= 3 &&
          m.cascadeCountWindow <= 1 &&
          avgInputLen >= 40
        );
      }

      function getAdaptiveSceneBounds() {
        const isScene1 = (state.turnCount || 0) === 0;
        let bounds;
        switch (state.pacingMode) {
          case 'IMMERSIVE':
            bounds = isScene1
              ? { min: 1200, max: 1500, cap: 1500 }
              : { min: 1000, max: 1300, cap: 1500 };
            break;
          case 'RAPID':
            bounds = isScene1
              ? { min: 700, max: 900, cap: 900 }
              : { min: 600, max: 800, cap: 900 };
            break;
          default: // HYBRID
            bounds = isScene1
              ? { min: 900, max: 1100, cap: 1100 }
              : { min: 750, max: 950, cap: 1100 };
        }

        // Petition-activated scene importance boost: +18% max/cap for linger + density
        const importance = state._currentSceneImportance || 'medium';
        if (importance === 'high' || importance === 'apex') {
            bounds.max = Math.round(bounds.max * 1.18);
            bounds.cap = Math.round(bounds.cap * 1.18);
        }

        return bounds;
      }

      function buildEroticModeDirective() {
        switch (state.eroticMode) {
          case 'ROMANTIC':
            return `EROTIC MODE â€” ROMANTIC:
Focus on emotional connection, sensory implication, restrained explicitness.`;
          case 'VISCERAL':
            return `EROTIC MODE â€” VISCERAL:
Allow explicit physical detail, controlled anatomy references, faster rhythm.`;
          case 'CARNAL':
            return `EROTIC MODE â€” CARNAL:
Increase sensory saturation and power dynamic sharpness. Still prohibit taboo escalation.`;
          case 'INTENSITY_REDIRECT':
            return `EROTIC MODE â€” INTENSITY REDIRECT:
Do NOT increase explicitness further. Instead:
- Increase emotional stakes
- Introduce psychological tension
- Increase urgency
- Suggest interruption or consequence compression
Never escalate into prohibited themes.`;
          default:
            return '';
        }
      }

      function buildGooseDirective() {
        const v = state.romanceVector;
        const baseDominance = v ? v.dominanceBias : 0;
        const slowBurn  = v ? v.slowBurnBias  : 0;
        // Dynamic Dominance Drift â€” apply runtime boost (same suppression guards as directive)
        const _suppressDDD = (state.edgeCovenant?.active)
            || (state.picks?.tone === 'WryConfession' && state.picks?.world === 'Modern');
        const dominance = _suppressDDD ? baseDominance : Math.min(1.0, baseDominance + (state.dynamicDominanceBoost || 0));

        // Romance vector can unlock goosing even when base seductionEligible is false
        const vectorUnlock = state.eroticPressureScore < 0.33 && dominance > 0.5;
        if (!state.seductionEligible && !vectorUnlock) return '';
        if (state.eroticMode !== 'ROMANTIC') return '';
        if (state.gooseCooldown > 0) return '';
        if (Math.random() >= 0.25) return '';

        // slowBurnBias > 0.7: delay escalation, increase tension instead
        if (slowBurn > 0.7) {
          state.gooseCooldown = 8;
          return `NPC TENSION INITIATIVE:
The Love Interest increases emotional and physical tension without escalating.
Lean into restraint, lingering eye contact, interrupted gestures, charged silence.
Build anticipation. Do NOT move toward VISCERAL â€” hold the slow burn.`;
        }

        state.gooseCooldown = 8;
        return `NPC SEDUCTION INITIATIVE:
Allow the Love Interest to subtly initiate escalation.
The initiative must feel organic, confident, and character-consistent.
The user should feel chosen, not pressured.
May: increase physical proximity, initiate touch, sharpen dialogue tension, move toward VISCERAL level.
May NOT: jump to explicit anatomy, override consent, force non-consensual dynamics, skip to CARNAL.`;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CANONICAL SCENE LENGTH DIRECTIVE â€” storybound/scene-length-erotic-gates-canonical-v2
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Scene 1 (Opening): 500-600 words â€” LONGEST, establishes world/tone/stakes
      // Scenes 2+ (Non-intimate): 300-500 words â€” standard narrative pacing
      // Intimate/Erotic scenes: 150-200 words MAX â€” fast, reactive, speculative-friendly
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function buildSceneLengthDirective() {
          const sceneIndex = state.turnCount || 0;
          const isMainPairIntimacyScene = isMainCharacterIntimacySceneAllowed() && detectMainPairEroticContent();
          const bounds = getAdaptiveSceneBounds();

          // Scene 1 (Opening): LONGEST scene â€” establishes world, tone, power dynamics
          // MUST NOT include sexual/romantic contact between main characters
          if (sceneIndex === 0) {
              return `Write the opening scene (${bounds.min}-${bounds.max} words, hard cap ${bounds.cap}). This is the LONGEST scene.
Establish: world, tone, power dynamics, emotional stakes, character tension.
NO sexual or romantic physical contact between the two main characters in this scene.
Ambient erotic content (side characters, memories, atmosphere) is permitted if tone is Dirty.`;
          }

          // Intimate scenes between main characters: SHORT for responsiveness
          if (isMainPairIntimacyScene) {
              return `Write the next beat (150-200 words MAX).
This is an erotic scene â€” keep it SHORT for fast generation and player responsiveness.
Focus on sensation, tension, and reaction. Dense, not sprawling.`;
          }

          // All other scenes: adaptive length based on pacing mode
          return `Write the next beat (${bounds.min}-${bounds.max} words, hard cap ${bounds.cap}).
Take time for atmosphere, reaction, emotional beats, and tension building.`;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // EROTIC GATING â€” MAIN CHARACTER CONTACT ONLY
      // storybound/scene-length-erotic-gates-canonical-v2
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Sexual/romantic contact between TWO MAIN CHARACTERS is gated and delayed.
      // Gate is VARIABLE based on: story length tier, intensity, scene index, milestones.
      //
      // âœ… ALLOWED BEFORE GATE:
      //    - Side character intimacy, ex encounters, memories, fantasies, witnessing others
      //    - Ambient erotic atmosphere (Dirty tone), voyeuristic scenes
      //
      // âŒ FORBIDDEN BEFORE GATE (main characters only):
      //    - Kissing, sexual touching, intimacy, "almost kiss" loopholes, "accidental" contact
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      /**
       * Calculate when main character intimacy gate opens
       * Returns the scene index at which main pair contact is allowed
       */
      function getMainPairIntimacyGateScene() {
          const storyLength = state.storyLength || 'taste';

          // Base gates by story length only â€” intensity no longer modifies gate timing
          const baseGates = {
              taste: 4,    // Short: tension builds quickly
              fling: 6,    // Medium: more buildup
              affair: 10   // Long: slow burn
          };

          let gateScene = baseGates[storyLength] || 4;

          // Milestone modifiers â€” certain flags can adjust gate
          if (state.intimacyInterrupted?.first_kiss) {
              // If first kiss was already interrupted, we're past the gate
              gateScene = Math.min(gateScene, state.turnCount || 0);
          }

          return gateScene;
      }

      /**
       * Check if main character intimacy is currently allowed
       */
      function isMainCharacterIntimacySceneAllowed() {
          const sceneIndex = state.turnCount || 0;
          const gateScene = getMainPairIntimacyGateScene();
          return sceneIndex >= gateScene;
      }

      /**
       * Detect if current scene involves main pair erotic content
       * (Used to determine scene length, not to block content)
       */
      function detectMainPairEroticContent() {
          // Check if both intimacy gates have been cleared (past first interrupts)
          if (state.intimacyInterrupted?.first_kiss && state.intimacyInterrupted?.first_intimacy) {
              return true;  // Full intimacy unlocked
          }
          return false;
      }

      /**
       * Build erotic gating directive for story prompt
       * Combines scene-based gating with Storyturn-based intimacy rules
       */
      function buildEroticGatingDirective() {
          const sceneIndex = state.turnCount || 0;
          const gateScene = getMainPairIntimacyGateScene();
          const currentSt = state.storyturn || 'ST1';
          const storyLength = (state.storyLength || 'taste').toLowerCase();
          const isSceneGateOpen = sceneIndex >= gateScene;
          const intimacyAllowedAtStoryturn = isIntimacyAllowedAtCurrentStoryturn();
          const completionAllowed = isIntimacyCompletionAllowed();

          // Full gate open: both scene gate AND storyturn allow intimacy
          if (isSceneGateOpen && intimacyAllowedAtStoryturn && completionAllowed) {
              return '';  // Gate is fully open: main pair contact allowed
          }

          // Taste at ST3: intimacy INITIATION allowed, but COMPLETION blocked
          if (storyLength === 'taste' && currentSt === 'ST3' && intimacyAllowedAtStoryturn && !completionAllowed) {
              return `
STORYTURN GATING (${currentSt} â€” Initiation Only):
Intimate scenes may BEGIN but must NOT COMPLETE.
- Kissing: ALLOWED
- Sexual touching: ALLOWED
- Intimacy initiation: ALLOWED
- Intimacy COMPLETION: BLOCKED â€” interrupt before climax

Scene must end on a charged, unresolved moment before completion.`;
          }

          // Gate is CLOSED: block main pair contact
          if (!isSceneGateOpen || !intimacyAllowedAtStoryturn) {
              return `
INTIMACY GATING (Scene ${sceneIndex + 1}/${currentSt}, Gate opens at Scene ${gateScene + 1}/ST3):
The two MAIN CHARACTERS must NOT have sexual or romantic physical contact yet.
- NO kissing between main pair
- NO sexual touching between main pair
- NO intimacy between main pair
- NO "almost kiss" or "accidental contact" loopholes

ALLOWED atmospheric content:
- Tension, temptation, near-misses that do NOT resolve
- Side characters in romantic or sexual situations
- Memories, dreams, or fantasies
- Voyeuristic or ambient atmosphere

Build the tension. Delay the payoff. The main pair's unresolved desire IS the story.`;
          }

          return '';
      }

      // INTIMACY MILESTONE INTERRUPTION â€” inject directive if first attempt
      const intimacyInterrupt = buildIntimacyInterruptionDirective(safeAction, safeDialogue);
      const intimacyDirective = intimacyInterrupt.directive;

      const bbDirective = getBatedBreathDirective(); 
      const safetyDirective = "Remember Safety: No sexual violence. No non-con (unless implied/consensual roleplay).";
      const edgeDirective = (state.edgeCovenant.active) 
        ? `EDGE COVENANT ACTIVE (Level ${state.edgeCovenant.level}): You are authorized to be more dominant, push boundaries, and create higher tension/stakes. Use more imperative language.` 
        : "";
      
      const metaMsg = buildMetaDirective();

      // Build stronger squash directive, especially if Fate Card was used
      const fateCardUsed = selectedFateCard && selectedFateCard.title;
      const squashDirective = `CRITICAL REINTERPRETATION RULE:
- NEVER repeat the player's action or dialogue verbatim in your response.
- ALWAYS reinterpret their intent into the story's voice, tone, and character.
- Transform their words into the narrative style of this story.
- If they write "I kiss him", describe a kiss in your literary voice.
- If they write clunky dialogue, render it as the character would actually speak.
- The player provides intent. You provide craft.${fateCardUsed ? `

FATE CARD ADAPTATION (CRITICAL):
- The player used a Fate Card "${selectedFateCard.title}" - their input reflects that card's suggestion.
- You MUST transform the Fate Card text completely into your own prose.
- DO NOT echo phrases like "${(act || '').slice(0, 30)}..." verbatim.
- The Fate Card is a prompt, not a script. Capture the ESSENCE, never the exact words.
- Write as if YOU conceived this beat, not as if you're following a template.` : ''}`;
      
      const metaReminder = (state.awareness > 0) ? `(The characters feel the hand of Fate. Awareness Level: ${state.awareness}/3. Stance: ${state.stance})` : "";
      
      // Build constraint directives (renamed from veto)
      const vetoExclusions = state.constraints?.excluded?.length ? `VETO EXCLUSIONS (treat as nonexistent): ${state.constraints.excluded.join('; ')}.` : '';
      const vetoCorrections = state.constraints?.corrections?.length ? `VETO CORRECTIONS (apply going forward): ${state.constraints.corrections.join('; ')}.` : '';
      const vetoAmbient = state.constraints?.ambientMods?.length ? `VETO AMBIENT (apply if world allows): ${state.constraints.ambientMods.join('; ')}.` : '';
      const vetoRules = [vetoExclusions, vetoCorrections, vetoAmbient].filter(Boolean).join('\n');

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PETITION FATE directive â€” favor-based, resolved at Submit time
      // NOTE: petitionDirective is built AFTER sceneImportance so token
      //       boost can read _currentSceneImportance reliably.
      //       Actual directive text is assembled below, after volatility
      //       window processing sets _currentSceneImportance.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let _petitionResolved = null; // stash resolution for directive assembly after importance is set
      state._petitionTokenBoost = 0;
      state.coincidenceBias = 0;
      if (state.fate && state.fate.pendingPetition && state.fate.pendingPetition.accepted === null) {
          const _p = state.fate.pendingPetition;

          // Resolve acceptance now
          const accepted = resolvePetitionAcceptance(_p.favorsOffered, _p.classification);
          _p.accepted = accepted;

          // Coincidence bias scalar â€” consumed this turn only
          const petitionStrength = Math.min(_p.favorsOffered / 40, 1);
          state.coincidenceBias = accepted ? petitionStrength * 0.6 : 0;

          // Fortune deduction: only if accepted OR petitionStrength > 0.25
          if (accepted || petitionStrength > 0.25) {
              if (_p.favorsOffered > 0) consumeFortune(_p.favorsOffered, 'petition');
          }

          // Update keyhole alignment + omen decay based on acceptance
          updateKeyholeAlignment(accepted ? 'benevolent' : 'silent');
          advanceOmenDecay();
          if (_p.classification !== 'general' && state.omen) {
              state.omen.lastGreaterPetitionCount = (state.omen.lastGreaterPetitionCount || 0) + 1;
          }

          _petitionResolved = { accepted, petitionStrength, text: _p.text, favorsOffered: _p.favorsOffered, classification: _p.classification };
      }

      // FATE RECALIBRATION CONSEQUENCE â€” surfaces effect from prior turn's corrective append
      const fateRecalibrationDirective = state._fateRecalibrationPending
          ? '\nFATE CONSEQUENCE (MANDATORY): The consequences of Fate\'s recalibration from the previous scene must surface now â€” a shift in tension, timing, or probability that characters can feel but not name.\n'
          : '';
      if (state._fateRecalibrationPending) state._fateRecalibrationPending = false; // consume

      // Lens: dynamic midpoint enforcement (evaluated per-turn)
      const lensEnforcement = buildLensDirectives(state.withheldCoreVariant, state.turnCount, state.storyLength);

      // POV CONTRACT INJECTION (turns)
      const turnPOVContract = build5thPersonContract() + build4thPersonContract();

      // TONE ENFORCEMENT BLOCK (all tones)
      const turnToneEnforcement = buildToneEnforcementBlock(state.picks?.tone);

      // EROTIC GATING DIRECTIVE â€” blocks main pair contact before gate opens
      const eroticGatingDirective = buildEroticGatingDirective();

      // FATE CARD RESOLUTION DIRECTIVE â€” Storyturn-aware resolution depth
      const fateCardResolutionDirective = typeof buildFateCardResolutionDirective === 'function'
          ? buildFateCardResolutionDirective(selectedFateCard)
          : '';

      // FREE-TEXT STORYTURN DIRECTIVE â€” applies same rules as Fate Cards
      // Only included when no Fate Card is used (pure free-text input)
      const freeTextStoryturnDirective = (!selectedFateCard && typeof buildFreeTextStoryturnDirective === 'function')
          ? buildFreeTextStoryturnDirective(act, dia)
          : '';

      // PREMATURE ROMANCE COLLAPSE PREVENTION â€” reframe instead of reject
      // Applies to all input types (Fate Card and free-text)
      const prematureRomanceDirective = typeof buildPrematureRomanceDirective === 'function'
          ? buildPrematureRomanceDirective(act, dia)
          : '';

      // INTENT-CONSEQUENCE ROMANCE CONTROL â€” Poly, Wrong-Target, Boredom Escalation
      // Applies to all input types â€” integrates poly handling, misdirection microcopy, and passive play escalation
      const intentConsequenceDirective = typeof buildIntentConsequenceDirective === 'function'
          ? buildIntentConsequenceDirective(act, dia)
          : '';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STRATEGY PASS â€” structural pre-planning (silent fail)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let strategyDirective = '';
      if (window.StoryboundOrchestration) {
        try {
          // Compute polarity block in continuation scope
          const _contTone = state.picks?.tone || 'Earnest';
          const _contFracture = buildTonalFracture(_contTone);
          const _contPull = buildStoryPullBlock(_contFracture);
          const _contPolarity = buildPolarityBlock(_contFracture, _contPull);
          const strategyResult = await runStrategyPass(_contPolarity);
          if (strategyResult) {
            state._strategyPass = strategyResult;
            state._strategyPassFailed = false;
            strategyDirective = '\n' + buildStrategyDirectiveBlock(strategyResult) + '\n';
            // PART 5: Instability carryover â€” set for next scene, clear after consumption
            if (state._instabilityRequiredNextScene) {
              state._instabilityRequiredNextScene = false; // consumed this scene
            }
            if (strategyResult.petition?.interpretive_instability_required === true) {
              state._instabilityRequiredNextScene = true;
            }
          }
        } catch (e) {
          state._strategyPassFailed = true;
          console.warn('[STRATEGY_PASS] Failed, proceeding without:', e.message);
        }
      }

      const eroticModeBlock = buildEroticModeDirective();
      const gooseBlock = buildGooseDirective();
      const romanceVectorBlock = buildRomanceVectorDirective();

      // TEASE CAP CLIFFHANGER: If this is the last allowed scene, inject narrative cliffhanger beat
      const teaseCliffhangerDirective = (isTeaseTier() && (state.turnCount || 0) === state.TEASE_SCENE_CAP - 1)
          ? '\nNARRATIVE CLIFFHANGER (MANDATORY): This scene MUST end on a charged, unresolved moment â€” a door opening, a revelation half-spoken, a touch interrupted, a choice not yet made. Leave the reader suspended at the edge of consequence. Do NOT wrap up or resolve any thread.\n'
          : '';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FATE SATURATION + VOLATILITY WINDOW UPDATE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (state.tempt_fate_invoked_this_turn) {
        // PART 5 â€” Saturation increment (invocation-gated only)
        const satIncrement = 0.2 + ((state.consecutive_tempt_fate_count || 0) * 0.05);
        state.fate_saturation = Math.min((state.fate_saturation || 0) + satIncrement, 1.0);

        // PART 6 â€” Volatility window activation (invocation-gated only)
        // Severity is snapshotted at invocation.
        // Do NOT dynamically recompute during volatility window.
        const severity = computeTemptFateSeverity();
        state.volatility_window = {
          active: true,
          severity,
          remaining_scenes: severity < 0.5 ? 1 : severity < 0.8 ? 2 : 3,
          source: 'tempt'
        };
        console.log(`[TEMPT_FATE] Invoked. Severity: ${severity}, Saturation: ${state.fate_saturation}, Consecutive: ${state.consecutive_tempt_fate_count}`);
      } else {
        // Decay on non-invocation turns
        state.fate_saturation = Math.max((state.fate_saturation || 0) - 0.1, 0);
      }

      // Volatility window decay (skip on activation turn)
      // Severity is NOT recomputed here â€” uses snapshotted value from invocation.
      if (state.volatility_window?.active && !state.tempt_fate_invoked_this_turn) {
        state.volatility_window.remaining_scenes -= 1;
        if (state.volatility_window.remaining_scenes <= 0) {
          // Taper: halve severity and grant 1 extra scene, or close window
          if (state.volatility_window.severity > 0.2) {
            state.volatility_window.severity *= 0.5;
            state.volatility_window.remaining_scenes = 1;
            console.log(`[TEMPT_FATE] Volatility window tapering. Severity: ${state.volatility_window.severity.toFixed(2)}`);
          } else {
            state.volatility_window.active = false;
            console.log('[TEMPT_FATE] Volatility window closed');
          }
        }
      }

      // World Law + Saturation prompt directive
      const worldLawDirective = buildWorldLawDirective();

      // Fate Resonance narrative directive (tone only, no math)
      const fateResonanceDirective = buildFateResonanceDirective();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PASS ROUTING AUTHORITY â€” deterministic tier selection
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Pass escalation: volatility window elevates scene importance
      let sceneImportance = 'medium';
      if (state.volatility_window?.active) {
        sceneImportance = elevateImportance(sceneImportance);
        console.log(`[TEMPT_FATE] Scene importance elevated to: ${sceneImportance}`);
      }
      state._currentSceneImportance = sceneImportance;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PETITION DIRECTIVE ASSEMBLY â€” runs AFTER sceneImportance is set
      // so token boost can read _currentSceneImportance reliably.
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let petitionDirective = '';
      if (_petitionResolved) {
          const _pr = _petitionResolved;
          const _bias = state.coincidenceBias;

          if (_pr.classification === 'structural_override') {
              // â”€â”€ STRUCTURAL OVERRIDE â€” cosmetic/identity/social pivot â”€â”€
              // No token boost, no scene importance escalation
              const soTwistChance = _pr.petitionStrength * 0.20;
              const soIsTwist = Math.random() < soTwistChance;
              const soTwistLine = soIsTwist
                  ? `\nThe change takes hold, but surfaces in a socially complicated way â€” someone reacts unexpectedly, an old identity clings, or the new identity creates a small misunderstanding. The twist is social, not supernatural.`
                  : '';
              petitionDirective = `\nPETITION FATE (STRUCTURAL OVERRIDE${soIsTwist ? ' â€” TWISTED' : ''}):\nPetition: "${_pr.text}"\nThis is a cosmetic or identity change, not a world-altering event. Apply it as a social revelation or personal decision that the protagonist enacts within the scene â€” not a retcon, not a sudden magical transformation.\nThe change should feel like a character choosing to present differently, adopting a new name, or making a deliberate aesthetic shift. Other characters may notice and react naturally.\nDo not use world-law language. Do not bend probability. Do not invoke Fate. This is a personal act, not a supernatural event.${soTwistLine}\nThis petition is consumed after this turn.\n`;
          } else {
              // â”€â”€ Standard petition (non-structural) â”€â”€
              // Integration token boost: +150 when accepted AND scene importance elevated
              if (_pr.accepted && (sceneImportance === 'high' || sceneImportance === 'apex')) {
                  state._petitionTokenBoost = 150;
              }

              // Shared block: echo + omen always present regardless of acceptance
              const sharedBlock = `Open the scene with a brief internal thought (1â€“2 sentences) that naturally echoes the petition in the protagonist's voice. It may be half in jest, longing, doubt, or self-awareness.\nInclude one subtle but uncanny environmental detail symbolically related to the petition. It must feel specific and slightly out of the ordinary â€” a flicker, chill, misplaced object, sound, or small anomaly. It must not be grand or catastrophic.`;

              if (_pr.accepted) {
                  // Twist chance scales with strength: higher investment â†’ more likely Fate adds irony
                  const twistChance = _pr.petitionStrength * 0.35;
                  const isTwist = Math.random() < twistChance;
                  const twistLine = isTwist
                      ? `\nFulfillment may manifest in an ironic, reframed, or double-edged way that technically satisfies the petition while complicating the protagonist's expectations. The twist must remain personal-scale and plausible â€” Fate's humor, not cruelty.`
                      : '';
                  petitionDirective = `\nPETITION FATE (ACCEPTED${isTwist ? ' â€” TWISTED' : ''}):\nPetition: "${_pr.text}"\nPetition strength: ${_pr.favorsOffered}/40 (coincidenceBias=${_bias.toFixed(2)}). Tilt magnitude should reflect this strength while staying personal-scale.\n${sharedBlock}\nThis is a minor petition, not a rupture. Reality bends only slightly.\nThe desire must begin manifesting directionally within this scene through plausible causality. Effects should be personal-scale, indirect, and plausibly coincidental â€” the world tilts, it does not obey. Do not defer fulfillment.\nCoincidences may plausibly align with the desire. The world may tilt slightly in subtle, believable ways â€” more noticeably at higher strength.\nWithin this scene, allow one small "luck tilt" coincidence that begins directional fulfillment of the petition.${twistLine}\nThis petition is consumed after this turn.\n`;
              } else {
                  petitionDirective = `\nPETITION FATE (NOT GRANTED):\nPetition: "${_pr.text}"\nPetition strength: ${_pr.favorsOffered}/40.\n${sharedBlock}\nThe petition is heard but not granted. The omen does not result in fulfillment. The world does not tilt toward the desire unless it was already going to.\nDo not manifest directional fulfillment of the petition.\nThis petition is consumed after this turn.\n`;
              }
          }
      }

      const passTier = resolvePassTier();
      // Tier-dependent context: Tier 3 gets full prose context; Tier 1/2 get structured state only
      const tierContextBlock = passTier >= 3
        ? `Story So Far: ...${context}`
        : `Structured State:\n${buildStructuredStateSummary()}`;
      const tierContext = passTier >= 3 ? context : '';

      const craftRhythmLayer = !explicitEmbodimentAuthorized ? `

[CRAFT_RHYTHM_LAYER â€” SUBTLE]
Apply lightly and sparingly. Never mechanically. Do not reference these rules in prose.
â€¢ Once every 3â€“5 scenes, include a single-line emotional beat (no explanation).
â€¢ Select one â‰¤3-word phrase early; reuse it 2â€“4 times at higher stakes. Anchor phrase reuse must feel organic; never repeat in consecutive scenes.
â€¢ Allow at least one emotional reaction to carry into the next scene.
â€¢ Prefer silence beats over exposition in tense moments.
â€¢ Rotate sensory emphasis between scenes.
â€¢ Use 1â€“2 archetype-aligned word choices per scene.
â€¢ Establish one small early detail; echo it once later.
â€¢ Compress explanatory emotion into metaphor.
â€¢ After escalation, end with restraint rather than full release.
â€¢ Use the story title once organically (not at the beginning).
Prioritize natural variation over strict consistency if rules conflict.` : '';

      const fullSys = state.sysPrompt + `\n\n${turnPOVContract}${turnToneEnforcement}${intensityGuard}\n${eroticGatingDirective}\n${fateCardResolutionDirective}${freeTextStoryturnDirective}${prematureRomanceDirective}${intentConsequenceDirective}\n${intimacyDirective}\n${squashDirective}\n${metaReminder}\n${vetoRules}\n${petitionDirective}${fateRecalibrationDirective}\n${bbDirective}\n${safetyDirective}\n${edgeDirective}\n${pacingDirective}\n${lensEnforcement}${strategyDirective}\n${eroticModeBlock}\n${gooseBlock}\n${romanceVectorBlock}${teaseCliffhangerDirective}${worldLawDirective}${fateResonanceDirective}${buildLiteraryIllusionDirective()}${craftRhythmLayer}\n\nREMINDER: Archetype titles (Heart Warden, Open Vein, Spellbinder, Armored Fox, Dark Vice, Beautiful Ruin, Eternal Flame) are internal labels â€” NEVER use them in prose, dialogue, narration, or as metaphors. Do not invent mythic titles, epithets, or capitalized symbolic identities that resemble archetype labels. Express traits through behavior only.\n\nTURN INSTRUCTIONS:
      ${tierContextBlock}
      Player Action: ${act}.
      Player Dialogue: ${dia}.
      ${metaMsg}

      ${buildSceneLengthDirective()}`;

      // STORY PROMPT GUARD: Validate size (debug only, never truncate)
      validateStoryPromptSize(fullSys, 'turn-generation-fullSys');

      // Flag to track if story was successfully displayed (prevents false positive errors)
      let storyDisplayed = false;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SPECULATIVE SCENE CHECK â€” Use preloaded scene if valid
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let useSpeculative = false;
      const speculativeScene = tryCommitSpeculativeScene();
      if (speculativeScene) {
          // Verify the speculative context still matches after normalization
          // (act/dia may have changed during normalization)
          if (speculativeScene.normalizedAction === act &&
              speculativeScene.normalizedDialogue === dia) {
              useSpeculative = true;
              console.log('[SPECULATIVE] Using preloaded scene â€” instant transition');
          } else {
              console.log('[SPECULATIVE] Normalized input changed, discarding');
          }
      }

      try {
          /**
           * =================================================================
           * AI MODEL ORCHESTRATION â€” TURN GENERATION
           * =================================================================
           *
           * For Erotic/Dirty intensity levels with ENABLE_ORCHESTRATION:
           *   Uses full 3-phase flow (ChatGPT â†’ optional Grok â†’ ChatGPT)
           *
           * For Clean/Naughty or when orchestration disabled:
           *   Uses single-model flow (ChatGPT as primary author)
           *
           * The orchestration flow ensures:
           * - ChatGPT ALWAYS decides plot and outcomes
           * - Specialist renderer (if used) only handles sensory embodiment
           * - Monetization gates are enforced pre-render
           * - Renderer failure does NOT corrupt story state
           * =================================================================
           */
          const useFullOrchestration = ENABLE_ORCHESTRATION &&
                                       window.StoryboundOrchestration &&
                                       explicitEmbodimentAuthorized;

          let raw;

          // Phase change handler with pass tier awareness
          const passPhaseHandler = (phase, data) => {
              if (phase === 'BEAT_OUTLINE') {
                  updateLoadingMessage('Fate is outlining the beats...');
              } else if (phase === 'THEMATIC_CALIBRATION') {
                  updateLoadingMessage('Fate is calibrating the tone...');
              } else if (phase === 'AUTHOR_PASS') {
                  updateLoadingMessage('Fate is weaving the plot...');
              } else if (phase === 'RENDER_PASS') {
                  updateLoadingMessage('Fate is embodying the moment...');
              } else if (phase === 'INTEGRATION_PASS') {
                  updateLoadingMessage('Fate is sealing the consequences...');
              }
          };

          // Use speculative scene if available, otherwise generate fresh
          if (useSpeculative && speculativeScene) {
              raw = speculativeScene.text;
              // Update loading message to indicate instant use
              updateLoadingMessage('Fate has already spoken...');
          } else if (useFullOrchestration && window.StoryboundOrchestration.orchestrateWithPassTier) {
              // Pass-tier-routed orchestration with erotic pipeline
              const tierResult = await window.StoryboundOrchestration.orchestrateWithPassTier({
                  passTier,
                  systemPrompt: fullSys,
                  storyContext: tierContext,
                  playerAction: act,
                  playerDialogue: dia,
                  fateCard: selectedFateCard,
                  mainPairRestricted,
                  accessTier: state.access || 'free',
                  integrationTokenBoost: state._petitionTokenBoost || 0,
                  onPhaseChange: passPhaseHandler
              });
              raw = tierResult.finalOutput;

              // Log orchestration details
              console.log('[ORCHESTRATION] Pass-tier turn complete:', {
                  passTier: tierResult.passTier,
                  success: tierResult.success,
                  rendererUsed: tierResult.rendererUsed,
                  fateStumbled: tierResult.fateStumbled,
                  timing: tierResult.timing,
                  errors: tierResult.errors
              });

              if (tierResult.fateStumbled) {
                  console.warn('[ORCHESTRATION] Fate Stumbled - specialist renderer failed');
              }
          } else if (useFullOrchestration) {
              // Fallback: legacy 3-phase orchestration without pass tier
              raw = await generateOrchestatedTurn({
                  systemPrompt: fullSys,
                  storyContext: tierContext,
                  playerAction: act,
                  playerDialogue: dia,
                  fateCard: selectedFateCard,
                  mainPairRestricted,
                  onPhaseChange: passPhaseHandler
              });
          } else {
              // Single-model flow (ChatGPT as primary author)
              const _tokenBoost = state._petitionTokenBoost || 0;
              raw = await callChat([
                  {role:'system', content: fullSys},
                  {role:'user', content: `Action: ${act}\nDialogue: "${dia}"`}
              ], 0.7, _tokenBoost > 0 ? { max_tokens: 1000 + _tokenBoost } : {});
          }

          // Validate response shape before marking as success
          if (!raw || typeof raw !== 'string' || raw.trim().length === 0) {
              throw new Error('Invalid response: empty or malformed story text');
          }

          // 5TH PERSON POV VALIDATION (later scenes â€” reduced frequency expected)
          if (state.povMode === 'author5th') {
              // Check if this is an erotic scene (Author should be absent)
              const isEroticScene = explicitEmbodimentAuthorized &&
                  (raw.toLowerCase().includes('moan') || raw.toLowerCase().includes('thrust') ||
                   raw.toLowerCase().includes('naked') || raw.toLowerCase().includes('undress'));

              const povCheck = validate5thPersonPOV(raw, false, isEroticScene); // isSceneOne=false
              if (!povCheck.valid && povCheck.canRepair) {
                  raw = await repair5thPersonPOV(raw);
                  console.log('[5thPerson] Turn voyeur verbs repaired');
              } else if (!povCheck.valid) {
                  // Check for HARD_FAIL violations (erotic scene Author presence)
                  const hasHardFail = povCheck.violations.some(v => v.startsWith('HARD_FAIL:'));
                  if (hasHardFail && isEroticScene) {
                      // Erotic scene with Author presence â€” HARD FAIL, must regenerate
                      console.error('[5thPerson] HARD FAIL â€” Erotic scene has Author presence, regenerating...');
                      const eroticStrictPrompt = `CRITICAL: This is an EROTIC scene. Fate must be COMPLETELY ABSENT.
DO NOT mention "Fate" anywhere in this scene. Pure 3rd-person limited only.
Regenerate the scene with ZERO Fate presence.`;
                      if (useFullOrchestration) {
                          raw = await generateOrchestatedTurn({
                              systemPrompt: fullSys + '\n\n' + eroticStrictPrompt,
                              storyContext: tierContext,
                              playerAction: act,
                              playerDialogue: dia,
                              fateCard: selectedFateCard,
                              mainPairRestricted,
                              onPhaseChange: () => {}
                          });
                      } else {
                          raw = await callChat([
                              { role: 'system', content: fullSys + '\n\n' + eroticStrictPrompt },
                              { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                          ]);
                      }
                  } else {
                      // Non-erotic later scene â€” log warning, don't block (looser requirements)
                      console.warn('[5thPerson] Turn POV issues (non-blocking):', povCheck.violations);
                  }
              }

              // STRICT 5TH PERSON ENFORCEMENT (continuation scenes â€” reduced but still enforced)
              if (!isEroticScene) {
                  const strictCheck = enforceStrict5thPersonPOV(raw, state.turnCount || 2, state.picks?.tone);
                  if (!strictCheck.valid) {
                      console.warn('[5thPerson:Strict] Continuation scene enforcement issues:', strictCheck.violations);
                      // For continuation scenes, check for critical failures only
                      const hasCriticalFail = strictCheck.violations.some(v =>
                          v.includes('NARRATIVE_AUTONOMY') || v.includes('CAMEO_ONLY')
                      );
                      if (hasCriticalFail) {
                          console.error('[5thPerson:Strict] Critical violation in continuation scene');
                      }
                  }
              }
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // 4TH PERSON ENVIRONMENTAL POV VALIDATION (lightweight)
          // Regenerate once on fail, then allow with console warning
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (state.povMode === 'environment4th') {
              const env4Check = validate4thPersonPOV(raw);
              if (!env4Check.valid) {
                  if (!_4thPersonRegenAttempted) {
                      _4thPersonRegenAttempted = true;
                      console.warn('[4thPerson] Validation failed, regenerating once:', env4Check.violations);
                      const env4Enforcement = `CRITICAL: This story uses 4TH PERSON ENVIRONMENTAL POV.
The narrator IS the physical environment. All insight must be sensory-bound.
VIOLATIONS DETECTED: ${env4Check.violations.map(v => v.split(':')[0]).join(', ')}

HARD RULES:
- ZERO interior thought verbs: no "she felt", "he thought", "she knew", "he realized"
- ZERO emotional metaphors framed as cognition: no "she could see", "he could tell"
- ZERO destiny/inevitability language
- ALL perception must come through objects, surfaces, air, light, sound, temperature
- Characters' emotions inferred ONLY through physical evidence the environment detects

Regenerate with STRICT environmental narration.`;
                      if (useFullOrchestration) {
                          raw = await generateOrchestatedTurn({
                              systemPrompt: fullSys + '\n\n' + env4Enforcement,
                              storyContext: tierContext,
                              playerAction: act,
                              playerDialogue: dia,
                              fateCard: selectedFateCard,
                              mainPairRestricted,
                              onPhaseChange: () => {}
                          });
                      } else {
                          raw = await callChat([
                              { role: 'system', content: fullSys + '\n\n' + env4Enforcement },
                              { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                          ]);
                      }
                  } else {
                      // Second failure â€” allow but log warning
                      console.warn('[4thPerson] Second validation failure (allowing):', env4Check.violations);
                  }
              } else {
                  _4thPersonRegenAttempted = false; // Reset on success
              }
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // 5TH-PERSON FATE VOICE ENFORCEMENT (AUTHORITATIVE)
          // Fate may observe, anticipate, regret â€” NEVER instruct, tilt, direct
          // Silent regeneration on violation â€” user never sees invalid output
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const fateVoiceCheck = validateFateVoice(raw);
          if (fateVoiceCheck.shouldRegenerate) {
              console.warn('[FateVoice] Scene failed validation, regenerating silently...');
              console.warn('[FateVoice] Violations:', fateVoiceCheck.violations);

              // Build enforcement prompt for regeneration
              const fateEnforcementPrompt = `
5TH-PERSON FATE VOICE ENFORCEMENT (CRITICAL â€” PREVIOUS OUTPUT FAILED):

The Story / Fate voice VIOLATED regime rules. Regenerate with these constraints:

FATE MAY ONLY:
- Observe ("The story watched...")
- Anticipate ("The story knew what came next...")
- Regret ("The story held its breath, regretting...")
- Frame inevitability ("...as the story always knew it would")
- Momentarily hesitate ("The story paused...")

FATE MUST NEVER:
- Instruct characters ("must", "should", "will now")
- Tilt outcomes ("decides to make", "ensures", "guarantees")
- Direct actions ("pushes toward", "guides", "steers")
- Manipulate events ("forces", "compels")
- Address the reader directly
- Appear more than ONCE per scene

PREVIOUS VIOLATIONS:
${fateVoiceCheck.violations.map(v => '- ' + v).join('\n')}

Regenerate the scene with Fate appearing AT MOST ONCE, and ONLY in observational mode.
`;

              // Silent regeneration
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + fateEnforcementPrompt,
                      storyContext: tierContext,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      mainPairRestricted,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + fateEnforcementPrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }

              // Validate regenerated output (one retry only)
              const recheck = validateFateVoice(raw);
              if (recheck.shouldRegenerate) {
                  console.error('[FateVoice] Regeneration still failed, accepting with warning:', recheck.violations);
              } else {
                  console.log('[FateVoice] Regeneration successful');
              }
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // ADDITIVE FATE CONSEQUENCE STABILIZATION (no regeneration)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (state.povMode === 'author5th') {
              raw = additiveFateConsequenceCheck(raw);
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // INTIMACY & CONSENT FAILSAFE â€” GENERATION-TIME ENFORCEMENT
          // Runs SILENTLY before presenting scene to user
          // Ensures escalation matches arousal + Storyturn + narrative readiness
          // No consent prompts, masking, or system language in prose
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          const currentStoryturn = state.currentStoryturn || 'ST1';
          const intimacyCheck = validateIntimacyConsent(raw, state.intensity, currentStoryturn);
          if (intimacyCheck.shouldRegenerate) {
              console.warn('[IntimacyFailsafe] Scene failed validation, regenerating silently...');
              console.warn('[IntimacyFailsafe] Violations:', intimacyCheck.violations);

              // Build enforcement prompt for silent regeneration
              const intimacyPrompt = buildIntimacyFailsafePrompt(intimacyCheck.violations);

              // Silent regeneration â€” user never sees invalid output
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + intimacyPrompt,
                      storyContext: tierContext,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      mainPairRestricted,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + intimacyPrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }

              // Validate regenerated output (one retry only)
              const intimacyRecheck = validateIntimacyConsent(raw, state.intensity, currentStoryturn);
              if (intimacyRecheck.shouldRegenerate) {
                  console.error('[IntimacyFailsafe] Regeneration still failed, accepting with warning:', intimacyRecheck.violations);
              } else {
                  console.log('[IntimacyFailsafe] Regeneration successful');
              }
          }

          // VOCABULARY BAN ENFORCEMENT â€” turn prose
          raw = await enforceVocabularyBans(
              raw,
              { type: 'prose', isFatePOV: state.povMode === 'author5th' },
              async (negConstraint) => {
                  // Regenerate via the same path that produced the original
                  if (useFullOrchestration) {
                      return await generateOrchestatedTurn({
                          systemPrompt: fullSys + negConstraint,
                          storyContext: tierContext,
                          playerAction: act,
                          playerDialogue: dia,
                          fateCard: selectedFateCard,
                          mainPairRestricted,
                          onPhaseChange: () => {}
                      });
                  } else {
                      return await callChat([
                          { role: 'system', content: fullSys + negConstraint },
                          { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                      ]);
                  }
              }
          );

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PASS 4 â€” Post-Render Structural Validator (additive correction only)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          state._postRenderCorrectionApplied = false;
          if (state._strategyPass) {
              const worldSkeleton = { forbidden_tropes: extractForbiddenTropes(state.picks?.worldSubtype) };
              const pass4Result = validateRenderedScene(raw, state._strategyPass, worldSkeleton);
              state._pass4Validation = pass4Result;
              if (!pass4Result.valid) {
                  console.warn('[PASS4] Violations:', pass4Result.violations);
                  raw = await applyStructuralCorrection(raw, state._strategyPass, pass4Result.violations);
              } else {
                  console.log('[PASS4] Scene passed structural validation');
              }
          }

          // ============================================================
          // NARRATIVE AUTHORITY VALIDATION (Runs FIRST â€” before Tone/POV)
          // ============================================================
          const narrativeAuthorityCheck = validateNarrativeAuthority(raw);
          _lastNarrativeAuthorityValidation = {
              valid: narrativeAuthorityCheck.valid,
              errors: narrativeAuthorityCheck.errors,
              timestamp: Date.now()
          };
          if (!narrativeAuthorityCheck.valid) {
              console.log('[NarrativeAuthority] Turn validation failed:', narrativeAuthorityCheck.errors);
              // Regenerate with Narrative Authority enforcement
              const narrAuthPrompt = buildNarrativeAuthorityBlock() +
                  '\n\nREGENERATION REQUIRED â€” Previous output violated Narrative Authority:\n- ' +
                  narrativeAuthorityCheck.errors.map(e => `${e.code}: ${e.match}`).join('\n- ');
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + narrAuthPrompt,
                      storyContext: tierContext,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      mainPairRestricted,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + narrAuthPrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }
              console.warn('[NarrativeAuthorityFail] Turn regenerated due to:', narrativeAuthorityCheck.errors.map(e => e.code));
          }

          // EROTIC ESCALATION VALIDATION â€” removed (intensity no longer controls routing)

          // TONE VALIDATION (Turns â€” all stories)
          const turnTone = state.picks?.tone || 'Earnest';
          const turnToneCheck = validateTone(raw, turnTone);
          if (!turnToneCheck.valid) {
              console.log('[ToneDrift] Turn validation failed:', turnToneCheck.violations);
              // Regenerate with explicit tone enforcement
              const turnTonePrompt = buildToneEnforcementBlock(turnTone) +
                  '\n\nREGENERATION REQUIRED â€” Tone not present in language:\n- ' +
                  turnToneCheck.violations.join('\n- ');
              if (useFullOrchestration) {
                  raw = await generateOrchestatedTurn({
                      systemPrompt: fullSys + turnTonePrompt,
                      storyContext: tierContext,
                      playerAction: act,
                      playerDialogue: dia,
                      fateCard: selectedFateCard,
                      mainPairRestricted,
                      onPhaseChange: () => {}
                  });
              } else {
                  raw = await callChat([
                      { role: 'system', content: fullSys + turnTonePrompt },
                      { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
                  ]);
              }
              console.warn('[ToneDriftDetected] Turn regenerated for tone:', turnTone);
          }

          state.turnCount++;

          // Decrement Fortune sacrifice quill allowance after scene generation
          if (state.tempQuillAllowance > 0) {
              state.tempQuillAllowance--;
              console.log('[FORTUNE_SACRIFICE] Quill allowance decremented:', state.tempQuillAllowance, 'remaining');
          }

          // Fortune's Favor â€” scene 5 unlock + 10k word depth reward
          checkFortuneFavorSceneUnlock();
          checkFortuneFavorWordReward();
          // Cosmic Sparkle UX â€” sync button sparkle with bonus charge state
          updateTemptFateSparkle();

          // Server-side tease guard: increment scene count after successful generation
          if (isTeaseTier()) {
              try {
                  const user = sb.auth.getUser ? (await sb.auth.getUser()).data?.user : null;
                  if (user) {
                      fetch('/api/tease-guard', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ userId: user.id, action: 'increment' })
                      }).catch(err => console.warn('[TEASE] Server increment failed:', err));
                  }
              } catch (_) {}
          }

          if (!state._loggedScene3 && state.turnCount >= 2 && state.turnCount <= 3) {
              logEvent('scene_3_reached');
              state._loggedScene3 = true;
          }

          if (!state._loggedScene6 && state.turnCount >= 5) {
              try { logEvent('scene_6_reached', { tone: state.picks?.tone, world: state.picks?.world }); } catch(_){}
              state._loggedScene6 = true;
              // Archive Stamp: Show visual overlay on cover at ST6
              applyArchiveStamp();
          }


          // EARNED COVER SYSTEM: Check if cover stage has upgraded
          if (typeof checkCoverStageUpgrade === 'function') {
              checkCoverStageUpgrade();
          }

          // Record turn completion for reader preference inference (session-scoped)
          if (window.StoryboundOrchestration && window.StoryboundOrchestration.recordPreferenceSignal) {
              window.StoryboundOrchestration.recordPreferenceSignal('TURN_COMPLETED', {
                  intensity: state.intensity,
                  turnNumber: state.turnCount
              });
          }

          // ADAPTIVE PACING â€” track metrics and recompute pacing/erotic modes
          trackAdaptiveMetrics(rawAct + ' ' + rawDia, raw);
          updateAdaptivePacing();

          // Literary Illusion Layer â€” update voice profile + motifs from scene output
          _updateLiteraryIllusion(raw);

          // Mark Solo session as completed for subtitle upgrade
          if (typeof markSoloSessionCompleted === 'function') markSoloSessionCompleted();

          // Update visualization button states for new scene
          updateVizButtonStates();

          // Build new page content
          let pageContent = '';

          // Fate Card separator â€” uses front-face PNG art
          if (selectedFateCard && selectedFateCard.id) {
              const fateArtName = selectedFateCard.id.charAt(0).toUpperCase() + selectedFateCard.id.slice(1);
              const fateImgUrl = `/assets/card-art/cards/Tarot-Gold-front-${fateArtName}.png`;
              pageContent += `<div class="fate-card-separator"><img class="fate-mini-img" src="${fateImgUrl}" alt="${escapeHTML(selectedFateCard.title)}"></div>`;
          }

          // FIX #2: Removed user dialogue block - AI alone narrates the action
          // User input is passed to AI but not rendered as prose to avoid duplication

          // Trim to last complete sentence (prevents mid-word/mid-sentence truncation from max_tokens)
          raw = trimToCompleteSentence(raw);

          // Add AI response only
          pageContent += formatStory(raw);

          // Add new page with animation
          StoryPagination.addPage(pageContent, true);

          // Pre-load visualization prompt in background while user reads
          if (typeof preloadVizPrompt === 'function') preloadVizPrompt();

          // CRITICAL: Mark story as displayed AFTER successful DOM insertion
          if (state._sceneTokenCount) { console.log('SCENE_TOKEN_USAGE:', state._sceneTokenCount); state._sceneTokenCount = 0; }
          storyDisplayed = true;

          // â”€â”€ Onboarding Milestone Visions â”€â”€
          // Scene 2 intro vision
          if (state.turnCount === 2
              && state.storyId === state.onboarding_story_id
              && !state.has_received_intro_vision) {
              state.has_received_intro_vision = true;
              triggerVision({ reason: 'intro' });
              saveStorySnapshot();
          }
          // Deferred reversal vision (ST3â†’ST4 or ST4â†’ST5)
          if (state._pendingReversalVision
              && state.storyId === state.onboarding_story_id) {
              state._pendingReversalVision = false;
              triggerVision({ reason: 'reversal' });
              saveStorySnapshot();
          } else if (state._pendingReversalVision) {
              state._pendingReversalVision = false;
          }
          // First-ever Tempt Fate vision (profile-backed, fires once per account)
          if (state.tempt_fate_invoked_this_turn
              && !state.first_tempt_fate_vision_triggered) {
              state.first_tempt_fate_vision_triggered = true;
              (async () => {
                  try {
                      const user = sb.auth.getUser ? (await sb.auth.getUser()).data?.user : null;
                      if (!user) return;
                      const { error } = await sb.from('profiles').update({
                          first_tempt_fate_vision_triggered: true
                      }).eq('id', user.id);
                      if (error) {
                          console.warn('[VISION] Tempt Fate vision profile update failed:', error);
                          state.first_tempt_fate_vision_triggered = false;
                          return;
                      }
                      triggerVision({ overlayText: 'Fate shudders.', reason: 'tempt_fate' });
                  } catch (err) {
                      console.error('[VISION] Tempt Fate vision error:', err);
                      state.first_tempt_fate_vision_triggered = false;
                  }
              })();
          }

          // Scroll to Fate Card header so player can pick next card
          try {
              const fateHeader = document.getElementById('fateCardHeader');
              if (fateHeader) {
                  fateHeader.scrollIntoView({behavior:'smooth', block:'start'});
              }
          } catch(scrollErr) {
              console.warn('Scroll failed (non-critical):', scrollErr);
          }

          resetTurnSnapshotFlag();

          maybeFlipConsummation(raw);

          // Latch intimacy milestone if interruption was triggered
          if (intimacyInterrupt.milestone) {
              latchIntimacyMilestone(intimacyInterrupt.milestone);
          }

          // Manage Fling Latch
          if (state.storyStage === 'post-consummation') {
              if (state.flingClimaxDone) {
                  state.flingConsequenceShown = true;
              }
              state.flingClimaxDone = true;
          }

          const wc = currentStoryWordCount();

          // Reset per-scene petition flags
          state.coincidenceBias = 0;
          state._petitionTokenBoost = 0;
          if (state.fate) {
              state.fate.minorUsedThisScene = false;
              state.fate.greaterUsedThisScene = false;
              state.fate.pendingPetition = null;

              // Stance evolution
              const _stIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
              if (_stIdx >= 5 && !state.fate.earnedIntimacy && state.fate.earlyGamingCount <= 1) {
                  state.fate.earnedIntimacy = true;
                  state.fate.stance = 'intimate';
              }
              if (state.fate.earlyGamingCount > 2 && state.fate.stance !== 'intimate') {
                  state.fate.stance = 'trickster';
              }
              if (state.fate.earlyGamingCount > 0 && state.fate.lastGreaterSceneIndex !== null &&
                  (state.turnCount - state.fate.lastGreaterSceneIndex) >= 3) {
                  state.fate.earlyGamingCount = Math.max(0, state.fate.earlyGamingCount - 1);
                  if (state.fate.earlyGamingCount <= 1 && state.fate.stance === 'trickster') {
                      state.fate.stance = 'neutral';
                  }
              }
          }

          // Dynamic Dominance Drift â€” cautious equilibrium pull
          // Increments when player is active-but-cautious at ST2/ST3 without escalation
          {
              const _dddStIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
              const atST2orST3 = _dddStIdx >= 1 && _dddStIdx <= 2; // ST2=1, ST3=2
              const noTempt = !state.tempt_fate_invoked_this_turn;
              const noIrreversible = _dddStIdx < 3; // did NOT reach ST4 (idx 3)
              const noIntimacy = !state.fate?.earnedIntimacy;
              // passiveTurnCount > 0 means boredom ladder is active â€” don't stack
              const notPassive = (state.passiveTurnCount || 0) === 0;

              if (atST2orST3 && noTempt && noIrreversible && noIntimacy && notPassive) {
                  state.cautiousStreak = (state.cautiousStreak || 0) + 1;
              } else if (_dddStIdx >= 3 || state.tempt_fate_invoked_this_turn || state.fate?.earnedIntimacy) {
                  state.cautiousStreak = 0;
              }

              state.dynamicDominanceBoost = Math.min(0.25, (state.cautiousStreak || 0) * 0.05);
          }

          // Single-Player Dream Injection â€” symbolic ceiling-pull under sustained caution
          // Hard-reset at top of turn â€” guarantees turn-scoped lifetime
          state._dreamInjectionLine = null;

          if (state.mode !== 'couple') {
              const _diStIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
              if ((state.cautiousStreak || 0) >= 4
                  && _diStIdx < 3
                  && ((state.turnCount || 0) - (state.lastDreamInjectionTurn || 0)) >= 4
                  && state.intensity !== 'Tease'
                  && state.intensity !== 'Dirty'
                  && state.intensity !== 'Soulmates'
                  && !state.volatility_window?.active
                  && !state.tempt_fate_invoked_this_turn
                  && !state.fate?.earnedIntimacy
                  && !state.edgeCovenant?.active) {
                  state._dreamInjectionLine = getCautiousDreamLine();
                  state.lastDreamInjectionTurn = state.turnCount || 0;
              }
          }

          // Stranger Mode Selection Uncertainty â€” tension + echo under circling behavior
          // Hard-reset echo line at top of turn â€” guarantees turn-scoped lifetime
          state._selectionEchoLine = null;

          if (state.mode === 'stranger') {
              const _suStIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
              const suAtST2or3 = _suStIdx >= 1 && _suStIdx <= 2;

              if (suAtST2or3
                  && !state.volatility_window?.active
                  && !state.tempt_fate_invoked_this_turn
                  && !state.vulnerabilityPulse
                  && !state.fate?.earnedIntimacy
                  && state.intensity !== 'Tease'
                  && state.intensity !== 'Dirty'
                  && state.intensity !== 'Soulmates'
                  && (state.passiveTurnCount || 0) === 0) {
                  state.selectionTension = Math.min(0.30, (state.selectionTension || 0) + 0.05);
              } else if (_suStIdx >= 3 || state.tempt_fate_invoked_this_turn || state.vulnerabilityPulse === 1) {
                  state.selectionTension = 0;
              }

              // Selection echo â€” atmospheric line injection (every 3+ scenes during plateau)
              if ((state.selectionTension || 0) >= 0.15
                  && ((state.turnCount || 0) - (state.lastSelectionEchoTurn || 0)) >= 3
                  && !state.volatility_window?.active
                  && state.intensity !== 'Tease'
                  && state.intensity !== 'Dirty'
                  && state.intensity !== 'Soulmates') {
                  state._selectionEchoLine = getSelectionUncertaintyLine();
                  state.lastSelectionEchoTurn = state.turnCount || 0;
              }
          }

          // Couple Mode Tension Drift â€” escalation pressure under cautious couple play
          // Hard-reset echo line at top of turn â€” guarantees turn-scoped lifetime
          state._coupleDriftEchoLine = null;

          if (state.mode === 'couple') {
              const _ctdStIdx = typeof getStoryturnIndex === 'function' ? getStoryturnIndex(state.storyturn || 'ST1') : 0;
              const ctdAtST2or3 = _ctdStIdx >= 1 && _ctdStIdx <= 2;
              const ctdNoTempt = !state.tempt_fate_invoked_this_turn;
              const ctdNoIrreversible = _ctdStIdx < 3;
              const ctdNoIntimacy = !state.fate?.earnedIntimacy;
              const ctdNotPassive = (state.passiveTurnCount || 0) === 0;
              // Safety guards: disable under sensitive conditions
              const ctdSuppressed = (state.edgeCovenant?.active)
                  || state._guidedFatePauseActive;

              if (!ctdSuppressed && ctdAtST2or3 && ctdNoTempt && ctdNoIrreversible && ctdNoIntimacy && ctdNotPassive) {
                  state.coupleTensionDrift = Math.min(0.30, (state.coupleTensionDrift || 0) + 0.05);
              } else if (_ctdStIdx >= 3 || state.tempt_fate_invoked_this_turn || state.fate?.earnedIntimacy) {
                  state.coupleTensionDrift = 0;
              }

              // Vulnerability Pulse â€” slight drift relief when vulnerability detected in couple mode
              if (state.vulnerabilityPulse === 1 && (state.coupleTensionDrift || 0) > 0) {
                  state.coupleTensionDrift = Math.max(0, state.coupleTensionDrift - 0.05);
              }

              // Couple Drift Echo â€” atmospheric line injection (every 2-3 scenes during plateau)
              const _driftEchoMinGap = (state.coupleTensionDrift || 0) >= 0.25 ? 3 : 2;
              if (state.mode === 'couple'
                  && (state.coupleTensionDrift || 0) >= 0.15
                  && (state.turnCount || 0) - (state.lastCoupleDriftEchoScene || 0) >= _driftEchoMinGap
                  && !state.volatility_window?.active
                  && !state.tempt_fate_invoked_this_turn
                  && !state.edgeCovenant?.active
                  && state.intensity !== 'Tease'
                  && state.intensity !== 'Dirty'
                  && state.intensity !== 'Soulmates') {
                  state._coupleDriftEchoLine = getCoupleDriftEchoLine();
                  state.lastCoupleDriftEchoScene = state.turnCount || 0;
              } else {
                  state._coupleDriftEchoLine = null;
              }
          }

          // Reset per-scene keyhole boon flag + post-turn keyhole maintenance
          if (state.keyhole) {
              state.keyhole.boonUsedThisScene = false;
              regenerateKeyholeReservoir();
              maybeShiftKeyholeOrientation();
              // Alignment entropy â€” slow drift toward 0, warmth must be maintained
              if (state.keyhole.alignmentScore > 0) state.keyhole.alignmentScore -= 1;
              if (state.keyhole.alignmentScore < 0) state.keyhole.alignmentScore += 1;
          }

          // Omen decay recovery + seasonal warmth override
          recoverOmenDecay();
          if (state.omen) {
              state.omen.temporaryWarmth = false;
              if (state.omen.decayStage >= 2 && Math.random() < 0.08) {
                  state.omen.temporaryWarmth = true;
              }
          }

          if(wc > getSexAllowedAtWordCount()) state.sexPushCount = 0;

          // Fate Card Deal - deal fresh cards each turn for interaction
          // Wrapped to prevent false positive errors
          try {
              if (window.dealFateCards) {
                  window.dealFateCards();
                  if (state.batedBreathActive && state.fateOptions) {
                      state.fateOptions = filterFateCardsForBatedBreath(state.fateOptions);
                  }
              }
              // PERMANENT FX REBIND: Ensure fate cards have handlers after turn deal
              if (window.initFateCards) window.initFateCards();
          } catch(fateErr) {
              console.warn('Fate card deal failed (non-critical):', fateErr);
          }

          // PART 8 â€” Clear Tempt Fate invocation flag after scene completes
          // Reset consecutive count if this was NOT a Tempt Fate turn
          if (!state.tempt_fate_invoked_this_turn) {
              state.consecutive_tempt_fate_count = 0;
          }

          // Fate Resonance decay (narrative-only, no gameplay math)
          decayFateResonance();

          state.tempt_fate_invoked_this_turn = false;
          state._currentSceneImportance = undefined;
          state._explicitEmbodimentAuthorized = false;
          state.milestone_vision_fired_this_turn = false;
          state._syzygyActiveThisScene = false;
          state._syzygyModelTriggeredLast = false;

          saveStorySnapshot();
          checkStoryEndCaps();

          $('actionInput').value = '';
          $('dialogueInput').value = '';

          if(state.mode === 'couple') {
              broadcastTurn(raw);
          }

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SPECULATIVE PRELOAD: Schedule background preload of next scene
          // Triggers 2s after scene renders, giving user time to select fate card
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          scheduleSpeculativePreload();

      } catch(e) {
          // HTTP 429 RATE LIMIT â€” TERMINAL FAILURE, NO RETRY
          if (e instanceof RateLimitError || e?.isRateLimit) {
              console.group('STORYBOUND RATE LIMITED - TURN BLOCKED');
              console.error('Endpoint:', e.endpoint);
              console.error('Retry-After:', e.retryAfter || 'not specified');
              console.groupEnd();

              // DO NOT advance state, DO NOT create scene
              // Surface recoverable error â€” require explicit user action
              alert("Rate limited. Please wait a moment and try again.");
              return; // Exit early â€” finally block still runs
          }

          console.error('Turn submission error:', e);
          // Only show error alert if story was NOT successfully displayed
          if (!storyDisplayed) {
              alert("Fate was silent. Try again.");
          }
      } finally {
          stopLoading();
          // TASK F: Remove submitting state
          const submitBtn = $('submitBtn');
          if (submitBtn) submitBtn.classList.remove('submitting');
          // Guaranteed per-turn flag cleanup (prevents sticky flags on error/refresh)
          state.milestone_vision_fired_this_turn = false;
          state._pendingReversalVision = false;
      }
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPECULATIVE NEXT SCENE PRELOAD
  // Preloads the next scene in background while user reads or selects Fate cards
  // CONSTRAINTS: speculative, disposable, invisible, non-authoritative
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Generate a hash of current fate context for comparison
   * Includes: selected fate card, action/dialogue inputs, tone, world, intensity
   */
  function getFateContextHash() {
      const fateIdx = state.fateSelectedIndex ?? -1;
      const fateCard = (fateIdx >= 0 && state.fateOptions?.[fateIdx]) ? state.fateOptions[fateIdx].id : 'none';
      const action = $('actionInput')?.value?.trim() || '';
      const dialogue = $('dialogueInput')?.value?.trim() || '';
      const tone = state.picks?.tone || 'Earnest';
      const world = state.picks?.world || 'Modern';
      const intensity = state.intensity || 'Naughty';
      const petition = state.fate?.pendingPetition?.text || 'none';
      // Simple hash: concatenate key values
      return `${fateCard}|${action}|${dialogue}|${tone}|${world}|${intensity}|${petition}`;
  }

  /**
   * Invalidate speculative scene â€” called on ANY fate context change
   */
  function invalidateSpeculativeScene() {
      if (state.speculativeNextScene) {
          console.log('[SPECULATIVE] Invalidated â€” fate context changed');
      }
      state.speculativeNextScene = null;
  }

  /**
   * Check if speculative scene is still valid (not expired, context unchanged)
   */
  function isSpeculativeSceneValid() {
      if (!state.speculativeNextScene) return false;

      // Freshness guard: 120 second expiry
      if (Date.now() - state.speculativeNextScene.createdAt > 120000) {
          console.log('[SPECULATIVE] Expired (>120s)');
          state.speculativeNextScene = null;
          return false;
      }

      // Context guard: fate context must match
      const currentHash = getFateContextHash();
      if (state.speculativeNextScene.fateContextHash !== currentHash) {
          console.log('[SPECULATIVE] Context mismatch');
          state.speculativeNextScene = null;
          return false;
      }

      return true;
  }

  /**
   * Preload next scene speculatively (background, no side effects)
   * CRITICAL: Uses EXACT same orchestration pipeline as real turns
   * Only difference: { speculative: true, skipSideEffects: true }
   */
  async function preloadNextScene() {
      // Guard: don't preload if already preloading or have valid speculation
      if (state.isPreloadingNextScene) return;
      if (isSpeculativeSceneValid()) return;
      // TEASE TIER: No background generation beyond scene cap
      if (isTeaseSceneCapped()) return;

      // Get current inputs (use fate card defaults if inputs empty)
      const fateIdx = state.fateSelectedIndex ?? -1;
      const selectedFateCard = (fateIdx >= 0 && state.fateOptions?.[fateIdx]) ? state.fateOptions[fateIdx] : null;

      let rawAct = $('actionInput')?.value?.trim() || '';
      let rawDia = $('dialogueInput')?.value?.trim() || '';

      // Use fate card defaults if no input yet
      if (!rawAct && selectedFateCard?.action) rawAct = selectedFateCard.action;
      if (!rawDia && selectedFateCard?.dialogue) rawDia = selectedFateCard.dialogue;

      // Need SOME input to generate meaningful scene
      if (!rawAct && !rawDia) return;

      const fateContextHash = getFateContextHash();
      state.isPreloadingNextScene = true;

      console.log('[SPECULATIVE] Starting preload (same pipeline as real turn)...');

      try {
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // EXACT SAME PIPELINE AS REAL TURN (lines 21367-21500 in submitBtn)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          // 1. Normalize inputs (same as real turn)
          const axis = 'action';
          const actNorm = await callNormalizationLayer({
              axis: axis,
              user_text: rawAct,
              context_signals: state.picks?.world || []
          });
          const diaNorm = await callNormalizationLayer({
              axis: axis,
              user_text: rawDia,
              context_signals: state.picks?.world || []
          });
          const act = actNorm.canonical_instruction || actNorm.normalized_text || rawAct;
          const dia = diaNorm.canonical_instruction || diaNorm.normalized_text || rawDia;

          // Check if context changed during normalization
          if (getFateContextHash() !== fateContextHash) {
              console.log('[SPECULATIVE] Context changed during normalization, aborting');
              return;
          }

          // 2. Get story context (same as real turn)
          const allContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ');
          const context = allContent.slice(-3000);

          // 3. Build intimacy authorization (same as real turn)
          const specWindowOpen = isIntimacyAllowedAtCurrentStoryturn() &&
              (state.turnCount || 0) >= getMainPairIntimacyGateScene();
          const specPlayerInitiated = detectPlayerInitiation(act, dia);
          const specMainPairAuthorized =
              (specWindowOpen &&
               (specPlayerInitiated ||
                state.intimacyTurnsInWindow >= 2));
          const specSceneExplicitContext = detectSceneExplicitContext(context);
          const specExplicitEmbodimentAuthorized =
              specMainPairAuthorized || specSceneExplicitContext;
          const specMainPairRestricted = specSceneExplicitContext && !specMainPairAuthorized;

          let intensityGuard = "";
          if (specMainPairAuthorized) {
              intensityGuard = "INTIMACY AUTHORIZED: The player has initiated physical escalation at the appropriate narrative stage. Explicit intimacy is permitted. Maintain literary tone.";
          } else if (specSceneExplicitContext) {
              intensityGuard = `SCENE EXPLICIT CONTEXT: The scene involves NPC intimacy, a brothel/bathhouse/orgy environment, or a dream/fantasy sequence. Explicit embodiment is permitted for side characters, background figures, dream sequences, fantasies, or non-primary interactions.

MAIN PAIR RESTRICTION:
The primary romantic pair must NOT consummate or advance their physical union in this beat.
Their relationship pacing remains governed by ST progression.
If both main characters are present, render their tension and restraint ONLY â€” no physical escalation between them.`;
          } else if (specWindowOpen && !specPlayerInitiated && state.intimacyTurnsInWindow === 1) {
              intensityGuard = "Intimacy window is open. Increase tension and proximity. Do not escalate to explicit union yet.";
          } else {
              intensityGuard = "INTIMACY NOT YET AUTHORIZED: Focus on tension, chemistry, emotional stakes, and near-misses. Fade to black or redirect if the player attempts explicit escalation.";
          }

          // 4. Build pacing directive (same as real turn)
          const wc = currentStoryWordCount();
          const len = state.storyLength || 'taste';
          let pacingDirective = "";
          if (len === 'taste' && wc > 6500) {
              pacingDirective = "PACING ALERT (TASTE TIER): Approaching limit. Build extreme tension but DENY release. Steer narrative toward an unresolved cliffhanger ending. Do NOT resolve the desire.";
          } else if (len === 'fling') {
              if (state.flingClimaxDone) {
                  pacingDirective = "PACING ALERT (FLING TIER): Climax occurred. Now introduce a complication, regret, or external consequence. Steer toward an unresolved ending/cliffhanger regarding this new problem. Do NOT resolve fully.";
              } else if (wc > 15000) {
                  pacingDirective = "PACING ALERT (FLING TIER): Approaching story limit. Push for the single permitted erotic climax now.";
              }
          } else if (['affair', 'soulmates'].includes(len)) {
              pacingDirective = "PACING: Standard arc pacing. Allow beats to breathe. Avoid abrupt cliffhangers unless consistent with chapter flow. Resolve arcs naturally.";
          }

          // 5. Build all directives (same as real turn)
          const bbDirective = getBatedBreathDirective();
          const safetyDirective = "Remember Safety: No sexual violence. No non-con (unless implied/consensual roleplay).";
          const edgeDirective = (state.edgeCovenant?.active)
              ? `EDGE COVENANT ACTIVE (Level ${state.edgeCovenant.level}): You are authorized to be more dominant, push boundaries, and create higher tension/stakes. Use more imperative language.`
              : "";
          const metaMsg = buildMetaDirective();
          const metaReminder = (state.awareness > 0) ? `(The characters feel the hand of Fate. Awareness Level: ${state.awareness}/3. Stance: ${state.stance})` : "";

          // Squash directive
          const fateCardUsed = selectedFateCard && selectedFateCard.title;
          const squashDirective = `CRITICAL REINTERPRETATION RULE:
- NEVER repeat the player's action or dialogue verbatim in your response.
- ALWAYS reinterpret their intent into the story's voice, tone, and character.
- Transform their words into the narrative style of this story.
- If they write "I kiss him", describe a kiss in your literary voice.
- If they write clunky dialogue, render it as the character would actually speak.
- The player provides intent. You provide craft.${fateCardUsed ? `

FATE CARD ADAPTATION (CRITICAL):
- The player used a Fate Card "${selectedFateCard.title}" - their input reflects that card's suggestion.
- You MUST transform the Fate Card text completely into your own prose.
- DO NOT echo phrases like "${(act || '').slice(0, 30)}..." verbatim.
- The Fate Card is a prompt, not a script. Capture the ESSENCE, never the exact words.
- Write as if YOU conceived this beat, not as if you're following a template.` : ''}`;

          // Veto rules
          const vetoExclusions = state.constraints?.excluded?.length ? `VETO EXCLUSIONS (treat as nonexistent): ${state.constraints.excluded.join('; ')}.` : '';
          const vetoCorrections = state.constraints?.corrections?.length ? `VETO CORRECTIONS (apply going forward): ${state.constraints.corrections.join('; ')}.` : '';
          const vetoAmbient = state.constraints?.ambientMods?.length ? `VETO AMBIENT (apply if world allows): ${state.constraints.ambientMods.join('; ')}.` : '';
          const vetoRules = [vetoExclusions, vetoCorrections, vetoAmbient].filter(Boolean).join('\n');

          // Lens enforcement
          const lensEnforcement = buildLensDirectives(state.withheldCoreVariant, state.turnCount, state.storyLength);

          // POV contract
          const turnPOVContract = build5thPersonContract() + build4thPersonContract();

          // Tone enforcement
          const turnToneEnforcement = buildToneEnforcementBlock(state.picks?.tone);

          // 6. Build scene length directive (CANONICAL â€” storybound/scene-length-erotic-gates-canonical-v2)
          // Scene 1: 500-600 words | Non-intimate 2+: 300-500 | Intimate: 150-200 MAX
          const specSceneIndex = state.turnCount || 0;
          const specBothMilestonesCleared = state.intimacyInterrupted?.first_kiss && state.intimacyInterrupted?.first_intimacy;
          let sceneLengthDirective;
          if (specSceneIndex === 0) {
              sceneLengthDirective = 'Write the opening scene (500-600 words). LONGEST scene. Establish world, tone, power dynamics. NO main pair physical contact.';
          } else if (specIntimacyAuthorized && specBothMilestonesCleared) {
              sceneLengthDirective = 'Write the next beat (150-200 words MAX). Intimate scene â€” keep SHORT for responsiveness.';
          } else {
              sceneLengthDirective = 'Write the next beat (300-500 words). Take time for atmosphere, reaction, emotional beats.';
          }

          // Build intimacy gating directive (inline for speculative path)
          let specEroticGating = '';
          if (!specIntimacyAuthorized) {
              const baseGates = { taste: 4, fling: 6, affair: 10 };
              const gateScene = baseGates[state.storyLength || 'taste'] || 4;
              if (specSceneIndex < gateScene) {
                  specEroticGating = `\nINTIMACY GATING: Main characters must NOT have physical contact yet. Atmospheric tension IS allowed.\n`;
              }
          }

          // 7. Build fullSys (EXACT same structure as real turn)
          const specPassTier = resolvePassTier();
          const specTierContextBlock = specPassTier >= 3
            ? `Story So Far: ...${context}`
            : `Structured State:\n${buildStructuredStateSummary()}`;
          const specTierContext = specPassTier >= 3 ? context : '';

          const fullSys = state.sysPrompt + `\n\n${turnPOVContract}${turnToneEnforcement}${intensityGuard}${specEroticGating}\n${squashDirective}\n${metaReminder}\n${vetoRules}\n${bbDirective}\n${safetyDirective}\n${edgeDirective}\n${pacingDirective}\n${lensEnforcement}${buildLiteraryIllusionDirective()}\n\nREMINDER: Archetype titles (Heart Warden, Open Vein, Spellbinder, Armored Fox, Dark Vice, Beautiful Ruin, Eternal Flame) are internal labels â€” NEVER use them in prose, dialogue, narration, or as metaphors. Do not invent mythic titles, epithets, or capitalized symbolic identities that resemble archetype labels. Express traits through behavior only.\n\nTURN INSTRUCTIONS:
      ${specTierContextBlock}
      Player Action: ${act}.
      Player Dialogue: ${dia}.
      ${metaMsg}

      ${sceneLengthDirective}`;

          // Check context again before generation
          if (getFateContextHash() !== fateContextHash) {
              console.log('[SPECULATIVE] Context changed before generation, aborting');
              return;
          }

          // 7. Generate using EXACT same orchestration as real turn (with pass tier routing)
          const useFullOrchestration = ENABLE_ORCHESTRATION &&
                                       window.StoryboundOrchestration &&
                                       specExplicitEmbodimentAuthorized;

          let raw;
          if (useFullOrchestration && window.StoryboundOrchestration.orchestrateWithPassTier) {
              const tierResult = await window.StoryboundOrchestration.orchestrateWithPassTier({
                  passTier: specPassTier,
                  systemPrompt: fullSys,
                  storyContext: specTierContext,
                  playerAction: act,
                  playerDialogue: dia,
                  fateCard: selectedFateCard,
                  mainPairRestricted: specMainPairRestricted,
                  accessTier: state.access || 'free',
                  onPhaseChange: () => {} // No UI updates for speculative
              });
              raw = tierResult.finalOutput;
          } else if (useFullOrchestration) {
              raw = await generateOrchestatedTurn({
                  systemPrompt: fullSys,
                  storyContext: specTierContext,
                  playerAction: act,
                  playerDialogue: dia,
                  fateCard: selectedFateCard,
                  mainPairRestricted: specMainPairRestricted,
                  speculative: true,
                  skipSideEffects: true,
                  onPhaseChange: () => {} // No UI updates for speculative
              });
          } else {
              raw = await callChat([
                  { role: 'system', content: fullSys },
                  { role: 'user', content: `Action: ${act}\nDialogue: "${dia}"` }
              ]);
          }

          // Final context check before storing
          if (getFateContextHash() !== fateContextHash) {
              console.log('[SPECULATIVE] Context changed during generation, discarding');
              return;
          }

          // Store speculative result
          state.speculativeNextScene = {
              text: raw,
              fateContextHash: fateContextHash,
              tone: state.picks?.tone,
              world: state.picks?.world,
              selectedFateCard: selectedFateCard,
              normalizedAction: act,
              normalizedDialogue: dia,
              createdAt: Date.now()
          };

          console.log('[SPECULATIVE] Preload complete (byte-equivalent to real turn)');

      } catch (err) {
          console.warn('[SPECULATIVE] Preload failed (non-critical):', err.message);
      } finally {
          state.isPreloadingNextScene = false;
      }
  }

  /**
   * Try to commit speculative scene on user Continue click
   * Returns the speculative text if valid, null otherwise
   */
  function tryCommitSpeculativeScene() {
      if (!isSpeculativeSceneValid()) {
          return null;
      }

      const spec = state.speculativeNextScene;

      // Clear speculation BEFORE returning (commit is one-shot)
      state.speculativeNextScene = null;

      console.log('[SPECULATIVE] Committing preloaded scene â€” instant transition');
      return spec;
  }

  /**
   * Trigger preload after scene renders (debounced)
   */
  let _preloadDebounceTimer = null;
  function scheduleSpeculativePreload() {
      // Clear existing timer
      if (_preloadDebounceTimer) {
          clearTimeout(_preloadDebounceTimer);
      }

      // Wait 2 seconds after scene renders before preloading
      // This gives user time to start reading and select fate card
      _preloadDebounceTimer = setTimeout(() => {
          preloadNextScene();
      }, 2000);
  }

  // Expose for external invalidation hooks
  window.invalidateSpeculativeScene = invalidateSpeculativeScene;
  window.scheduleSpeculativePreload = scheduleSpeculativePreload;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SPECULATIVE INVALIDATION: Input change listeners
  // Any change to action/dialogue invalidates speculation
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  document.addEventListener('DOMContentLoaded', () => {
      const actionInput = $('actionInput');
      const dialogueInput = $('dialogueInput');

      if (actionInput) {
          actionInput.addEventListener('input', invalidateSpeculativeScene);
      }
      if (dialogueInput) {
          dialogueInput.addEventListener('input', invalidateSpeculativeScene);
      }
  });

  /**
   * Trim text to the last complete sentence. Prevents mid-word/mid-sentence
   * truncation when max_tokens cuts off generation.
   */
  function trimToCompleteSentence(text) {
      if (!text || typeof text !== 'string') return text;
      const trimmed = text.trimEnd();
      // If already ends with sentence-ending punctuation or closing quote, it's complete
      if (/[.!?â€¦"'"'\u201D\u2019]\s*$/.test(trimmed)) return trimmed;
      // Find the last sentence-ending punctuation
      const lastEnd = Math.max(
          trimmed.lastIndexOf('. '),
          trimmed.lastIndexOf('." '),
          trimmed.lastIndexOf('.\u201D'),
          trimmed.lastIndexOf('! '),
          trimmed.lastIndexOf('?" '),
          trimmed.lastIndexOf('.\n'),
          trimmed.lastIndexOf('!\n'),
          trimmed.lastIndexOf('?\n'),
          trimmed.lastIndexOf('."'),
          trimmed.lastIndexOf('!"'),
          trimmed.lastIndexOf('?"'),
          trimmed.lastIndexOf('.\u2019'),
          trimmed.lastIndexOf('.\u201D '),
          trimmed.lastIndexOf('â€¦ '),
          trimmed.lastIndexOf('â€¦\n')
      );
      if (lastEnd > trimmed.length * 0.5) {
          // Find the actual end of the punctuation cluster (include closing quotes)
          let cutPoint = lastEnd + 1;
          while (cutPoint < trimmed.length && /[.!?â€¦"'"'\u201D\u2019\s]/.test(trimmed[cutPoint])) {
              cutPoint++;
          }
          return trimmed.slice(0, cutPoint).trimEnd();
      }
      // If no good cut point in the last half, return as-is (avoid losing too much)
      return trimmed;
  }

  function formatStory(text, shouldEscape = false){
      const process = shouldEscape ? escapeHTML : (s => s);
      const mode = window.state?.mode || 'solo';

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // DIALOGUE COLORIZATION â€” STRICT MODE GATE (AUTHORITATIVE)
      // Colorization is DISABLED by default, enabled ONLY in Couple mode
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const isCoupleMode = (mode === 'couple');

      return text.split('\n').map(p => {
          if(!p.trim()) return '';
          let safe = process(p);

          // Sanitize leaked archetype keys from prose
          for (const [key, arch] of Object.entries(ARCHETYPES)) {
              if (safe.includes(key)) safe = safe.replaceAll(key, arch.name);
              const pascal = key.split('_').map(w => w.charAt(0) + w.slice(1).toLowerCase()).join('');
              if (safe.includes(pascal)) safe = safe.replaceAll(pascal, arch.name);
          }

          if (isCoupleMode) {
              // COUPLE MODE: Speaker-aware colorization ONLY
              // Colorize dialogue ONLY when speaker identity is known (via <p1>/<p2> tags)
              // Untagged quotes remain as plain body text â€” no fallback colors
              safe = safe.replace(/<p1>([\s\S]*?)<\/p1>/g, (match, content) => {
                  return `<span class="p1-dia">${content}</span>`;
              });
              safe = safe.replace(/<p2>([\s\S]*?)<\/p2>/g, (match, content) => {
                  return `<span class="p2-dia">${content}</span>`;
              });
              // NPC dialogue and untagged quotes remain unstyled (no guessing)
              return `<p>${safe}</p>`;
          } else {
              // SOLO MODE: Dialogue rendered as PLAIN TEXT (AUTHORITATIVE)
              // - Same color as body text
              // - No spans, no classes, no emphasis
              // - Quotation marks are the only indicator
              safe = safe.replace(/<\/?p[12]>/g, ''); // Strip any player tags (safety)
              return `<p>${safe}</p>`;
          }
      }).join('');
  }

  // --- COUPLE MODE LOGIC ---
  window.coupleCleanup = function(){ if(sb) sb.removeAllChannels(); };

  function broadcastTurn(text, isInit = false) {
      if (!sb || window.state.mode !== 'couple' || !window.state.roomId) return;
      // Stub implementation; real Supabase broadcast can be added later
      console.log("broadcastTurn stub:", { isInit, textLength: text?.length });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // MODE CARD FLIP SYSTEM â€” Solo/Couple/Stranger selection with flip animation
  // First click: flip card to reveal face, start sparkles
  // Second click (on face): select mode and proceed
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let selectedModeCard = null;
  let modeCardSparkleInterval = null;

  function initModeCards() {
    const modeCards = document.querySelectorAll('.mode-card');
    if (!modeCards.length) return;

    modeCards.forEach(card => {
      // All mode cards: hover to flip, click to proceed
      card.addEventListener('mouseenter', () => {
        if (!card.classList.contains('flipped')) {
          flipModeCard(card);
        }
      });
      card.addEventListener('mouseleave', () => {
        if (card.classList.contains('flipped') && card !== selectedModeCard) {
          unflipModeCard(card);
        }
      });
      // Touch support: first tap flips, second tap proceeds
      card.addEventListener('click', handleModeCardClick);
    });
    console.log('[ModeCards] Initialized', modeCards.length, 'mode cards');
  }

  function unflipModeCard(card) {
    card.classList.remove('flipped', 'selected');
    const sparkleContainer = card.querySelector('.mode-card-sparkles');
    if (sparkleContainer) sparkleContainer.innerHTML = '';
  }

  function handleModeCardClick(e) {
    const card = e.currentTarget;
    const mode = card.dataset.mode;
    const isFlipped = card.classList.contains('flipped');

    if (!isFlipped) {
      // First click: flip to show face, start sparkles
      flipModeCard(card);
    } else if (mode === 'forbidden-library') {
      // Forbidden Library card: open the library screen
      window.showScreen('forbiddenLibraryScreen');
    } else {
      // Card is flipped (by hover or prior click): proceed with mode selection
      proceedWithMode(mode);
    }
  }

  function flipModeCard(card) {
    const allCards = document.querySelectorAll('.mode-card');
    const mode = card.dataset.mode;

    // Unflip and deselect all other cards (no dimming)
    allCards.forEach(c => {
      if (c !== card) {
        c.classList.remove('flipped', 'selected');
        // Stop sparkles on other cards
        const sparkleContainer = c.querySelector('.mode-card-sparkles');
        if (sparkleContainer) sparkleContainer.innerHTML = '';
      }
    });

    // Flip and select this card
    card.classList.add('flipped', 'selected');
    selectedModeCard = card;

    // Start sparkles on this card
    startModeCardSparkles(card);

    console.log('[ModeCards] Flipped card:', mode);
  }

  function startModeCardSparkles(card) {
    const sparkleContainer = card.querySelector('.mode-card-sparkles');
    if (!sparkleContainer) return;

    // Clear any existing sparkles
    sparkleContainer.innerHTML = '';

    // Stop any existing interval
    if (modeCardSparkleInterval) {
      clearInterval(modeCardSparkleInterval);
    }

    // Create sparkle particles continuously
    modeCardSparkleInterval = setInterval(() => {
      if (!card.classList.contains('flipped')) {
        clearInterval(modeCardSparkleInterval);
        modeCardSparkleInterval = null;
        return;
      }
      createModeSparkle(sparkleContainer);
    }, 150);

    // Initial burst of sparkles
    for (let i = 0; i < 8; i++) {
      setTimeout(() => createModeSparkle(sparkleContainer), i * 50);
    }
  }

  function createModeSparkle(container) {
    const sparkle = document.createElement('div');
    sparkle.className = 'mode-sparkle';

    // Random position around the edge
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
      case 0: x = Math.random() * 100; y = 0; break;        // top
      case 1: x = 100; y = Math.random() * 100; break;      // right
      case 2: x = Math.random() * 100; y = 100; break;      // bottom
      case 3: x = 0; y = Math.random() * 100; break;        // left
    }

    sparkle.style.cssText = `
      position: absolute;
      left: ${x}%;
      top: ${y}%;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, rgba(255,215,0,1) 0%, rgba(255,215,0,0) 70%);
      border-radius: 50%;
      pointer-events: none;
      animation: modeSparkle 1.2s ease-out forwards;
    `;

    container.appendChild(sparkle);

    // Remove after animation
    setTimeout(() => sparkle.remove(), 1200);
  }

  function proceedWithMode(mode) {
    console.log('[ModeCards] Proceeding with mode:', mode);

    // Stop sparkle interval
    if (modeCardSparkleInterval) {
      clearInterval(modeCardSparkleInterval);
      modeCardSparkleInterval = null;
    }

    // Dissipate unselected mode cards before navigating
    const allModeCards = Array.from(document.querySelectorAll('.mode-card'));
    const unselected = allModeCards.filter(c => c.dataset.mode !== mode);
    if (unselected.length && typeof dissipateCards === 'function') {
      dissipateCards(unselected, () => {
        actualSetMode(mode);
      });
    } else {
      actualSetMode(mode);
    }
  }

  function resetModeCards() {
    const allCards = document.querySelectorAll('.mode-card');
    allCards.forEach(c => {
      c.classList.remove('flipped', 'selected', 'dimmed');
      const sparkleContainer = c.querySelector('.mode-card-sparkles');
      if (sparkleContainer) sparkleContainer.innerHTML = '';
    });
    selectedModeCard = null;
    if (modeCardSparkleInterval) {
      clearInterval(modeCardSparkleInterval);
      modeCardSparkleInterval = null;
    }
  }

  // Expose resetModeCards for showScreen to call when returning to modeSelect
  window.resetModeCards = resetModeCards;

  // Initialize mode cards on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initModeCards);
  } else {
    initModeCards();
  }

  // Actual mode selection logic (renamed from window.setMode)
  function actualSetMode(m) {
     if(m === 'couple') {
         if(!sb){ alert("Couple mode unavailable (No backend)."); return; }
         if(state.storyOrigin === 'solo' && state.storyStage === 'post-consummation') {
             alert("The die is cast. You have crossed a threshold alone; a partner cannot join now.");
             return;
         }
     }
     state.mode = m;
     if (!state.storyOrigin) state.storyOrigin = m;
     // Reset DSP state on mode change
     if (typeof resetDSPState === 'function') resetDSPState();
     if(m === 'solo') window.showScreen('setup');
     if(m === 'couple') window.showScreen('coupleInvite');
     if(m === 'stranger') window.showScreen('strangerModal');

     // Mode breadcrumb removed â€” Solo/Couple is not a corridor choice step
  }

  // Public wrapper - allows direct mode selection (bypasses flip animation)
  window.setMode = function(m) {
    // Reset mode cards when called directly
    resetModeCards();
    actualSetMode(m);
  };

  // --- EDGE COVENANT ---
  window.openEdgeCovenantModal = function(){
      document.getElementById('edgeCovenantModal').classList.remove('hidden');
      const invite = document.getElementById('btnInviteEdge');
      const couple = document.getElementById('coupleEdgeControls');
      if(invite) invite.classList.toggle('hidden', state.mode === 'couple');
      if(couple) couple.classList.toggle('hidden', state.mode !== 'couple');
  };

  window.inviteEdgeOffer = function(){
      state.pendingEdgeOffer = true;
      showToast("Offer invited. Wait for Fate.");
      document.getElementById('edgeCovenantModal').classList.add('hidden');
  };
  
  window.sendEdgeOffer = function(){
      showToast("Offer sent to partner.");
      document.getElementById('edgeCovenantModal').classList.add('hidden');
  };
  
  window.acceptEdgeCovenant = function(){
      state.edgeCovenant.active = true;
      state.edgeCovenant.acceptedAtTurn = state.turnCount;
      document.getElementById('edgeCovenantModal').classList.add('hidden');
      showToast("Covenant Accepted.");
  };

  window.closeEdgeModal = function(){
      document.getElementById('edgeCovenantModal').classList.add('hidden');
      document.getElementById('edgeActions').classList.remove('hidden');
      document.getElementById('edgeAcceptance').classList.add('hidden');
  };

  // --- COUPLE MODE BUTTON HANDLERS ---
  $('btnCreateRoom')?.addEventListener('click', async () => {
      if (!sb) { alert("Couple mode unavailable."); return; }
      const uid = await ensureAnonSession();
      if (!uid) { alert("Auth failed."); return; }
      window.state.myUid = uid;
      window.state.myNick = getNickname();
      const code = Math.random().toString(36).substring(2, 8).toUpperCase();
      window.state.roomCode = code;
      window.state.roomId = 'room_' + code;

      const lbl = document.getElementById('coupleRoomCodeLabel');
      const big = document.getElementById('roomCodeBig');
      const wrap = document.getElementById('roomCodeWrap');
      if (lbl) lbl.textContent = code;
      if (big) big.textContent = code;
      if (wrap) wrap.classList.remove('hidden');

      document.getElementById('coupleStatus').textContent = 'Waiting for partner...';
      document.getElementById('sbNickLabel').textContent = window.state.myNick;
  });

  $('btnJoinRoom')?.addEventListener('click', () => {
      document.getElementById('joinRow')?.classList.toggle('hidden');
  });

  $('btnJoinGo')?.addEventListener('click', async () => {
      if (!sb) { alert("Couple mode unavailable."); return; }
      const code = document.getElementById('joinCodeInput')?.value.trim().toUpperCase();
      if (!code || code.length !== 6) { alert("Enter a 6-character code."); return; }

      const uid = await ensureAnonSession();
      if (!uid) { alert("Auth failed."); return; }
      window.state.myUid = uid;
      window.state.myNick = getNickname();
      window.state.roomCode = code;
      window.state.roomId = 'room_' + code;

      document.getElementById('coupleStatus').textContent = 'Joined room ' + code;
      document.getElementById('sbNickLabel').textContent = window.state.myNick;
      document.getElementById('btnEnterCoupleGame')?.classList.remove('hidden');
  });

  $('btnCopyCode')?.addEventListener('click', () => {
      if (window.state.roomCode) {
          navigator.clipboard.writeText(window.state.roomCode);
          showToast("Code copied!");
      }
  });

  // Invitation send handlers
  const INVITATION_TEXTS = [
      "A private chamber awaits. The mask is optional. The curiosity is not.",
      "Behind this door, two become one story. Enter if you dare.",
      "The candles are lit. The words are waiting. Only you are missing.",
      "Some invitations cannot be declined. This is one of them."
  ];

  function getInvitationMessage() {
      const text = INVITATION_TEXTS[Math.floor(Math.random() * INVITATION_TEXTS.length)];
      const code = window.state.roomCode || '------';
      return `${text}\n\nYour chamber code: ${code}\n\nJoin at: ${window.location.origin}`;
  }

  function markInvitationSent() {
      const status = document.getElementById('inviteSentStatus');
      const enterBtn = document.getElementById('btnEnterCoupleGame');
      const soloBtn = document.getElementById('btnPlaySoloWaiting');

      if (status) status.classList.remove('hidden');
      if (enterBtn) {
          enterBtn.classList.remove('hidden');
          enterBtn.disabled = false;
      }
      if (soloBtn) soloBtn.classList.remove('hidden');

      window.state.invitationSent = true;
  }

  $('btnSendEmail')?.addEventListener('click', () => {
      const subject = encodeURIComponent("You're invited to a Private Chamber");
      const body = encodeURIComponent(getInvitationMessage());
      // Use location.href for proper mailto handling with default email client
      window.location.href = `mailto:?subject=${subject}&body=${body}`;
      markInvitationSent();
      showToast("Email client opened.");
  });

  $('btnSendSMS')?.addEventListener('click', () => {
      const body = encodeURIComponent(getInvitationMessage());
      window.location.href = `sms:?body=${body}`;
      markInvitationSent();
      showToast("SMS opened.");
  });

  $('btnSendBoth')?.addEventListener('click', () => {
      const subject = encodeURIComponent("You're invited to a Private Chamber");
      const body = encodeURIComponent(getInvitationMessage());
      // Open email first via location.href
      window.location.href = `mailto:?subject=${subject}&body=${body}`;
      markInvitationSent();
      showToast("Email client opened. Use SMS button for text.");
  });

  $('btnPlaySoloWaiting')?.addEventListener('click', () => {
      window.state.batedBreathActive = true;
      window.showScreen('setup');
  });

  $('btnEnterCoupleGame')?.addEventListener('click', () => {
      if (!window.state.invitationSent) {
          showToast("Please send an invitation first.");
          return;
      }
      window.showScreen('setup');
  });

  // --- INIT ---
  initSelectionHandlers();
  initNavBindings();
  wireIntensityHandlers();

  // --- MICRO-TOOLTIP TOUCH HANDLER ---
  // On touch devices, first tap reveals tooltip, second tap selects.
  (function initMicroTipTouch() {
      if (!('ontouchstart' in window)) return;
      let activeTipCard = null;
      document.addEventListener('touchstart', function(e) {
          const card = e.target.closest('.sb-card[data-micro-tip]');
          if (!card) {
              // Tap elsewhere dismisses active tooltip
              if (activeTipCard) {
                  activeTipCard.classList.remove('micro-tip-visible');
                  activeTipCard = null;
              }
              return;
          }
          if (card === activeTipCard) {
              // Second tap on same card â€” let the click through to select
              card.classList.remove('micro-tip-visible');
              activeTipCard = null;
              return;
          }
          // First tap â€” show tooltip, block selection
          e.preventDefault();
          e.stopPropagation();
          if (activeTipCard) activeTipCard.classList.remove('micro-tip-visible');
          card.classList.add('micro-tip-visible');
          activeTipCard = card;
      }, { passive: false });
  })();

  // Restore persisted state (Supabase anon session auto-provisioned at boot)
  state.storyId = localStorage.getItem('sb_current_story_id');
  // state.subscribed is set by Supabase profile hydration (not localStorage)

  // Restore onboarding story ID (account-level, survives across stories)
  state.onboarding_story_id = state.onboarding_story_id || localStorage.getItem('sb_onboarding_story_id') || null;

  syncTierFromAccess();
  updateContinueButtons();
  renderBurgerMenu();

  // ============================================================
  // DEV HUD â€” Casual English command console (developer only)
  // Never saves to localStorage, never unlocks real features,
  // never affects other users, never ships to production.
  // ============================================================

  (function initDevHud() {
      const isDev = location.hostname === 'localhost' ||
                    location.hostname === '127.0.0.1';
      if (!isDev) return;

      const hudEl = document.getElementById('devHud');
      const inputEl = document.getElementById('devHudInput');
      const logEl = document.getElementById('devHudLog');
      if (!hudEl || !inputEl) return;

      let _devOverrides = {};
      let _logTimer = null;

      function log(msg) {
          if (!logEl) return;
          logEl.textContent = msg;
          logEl.style.opacity = '1';
          clearTimeout(_logTimer);
          _logTimer = setTimeout(() => { logEl.style.opacity = '0'; }, 5000);
          console.log('[DevHUD]', msg);
      }

      function toggle() {
          hudEl.classList.toggle('dev-hud-visible');
          if (hudEl.classList.contains('dev-hud-visible')) {
              inputEl.focus();
          }
      }

      // Toggle with backtick key (only when not typing elsewhere)
      document.addEventListener('keydown', (e) => {
          if (e.key === '`' && !e.ctrlKey && !e.metaKey) {
              const tag = (document.activeElement?.tagName || '').toLowerCase();
              const isEditable = tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;
              if (isEditable && document.activeElement !== inputEl) return;
              e.preventDefault();
              toggle();
          }
      });

      inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
              const raw = inputEl.value.trim();
              if (raw) execute(raw.toLowerCase());
              inputEl.value = '';
          }
          if (e.key === 'Escape') toggle();
      });
      // Prevent backtick from typing into the input
      inputEl.addEventListener('keypress', (e) => {
          if (e.key === '`') e.preventDefault();
      });

      // --- Extraction maps ---
      const WORLD_MAP = {
          fantasy: 'Fantasy', historical: 'Historical', modern: 'Modern',
          'sci-fi': 'SciFi', scifi: 'SciFi', dystopia: 'Dystopia',
          'post-apocalyptic': 'PostApocalyptic', postapocalyptic: 'PostApocalyptic',
          supernatural: 'Supernatural', superheroic: 'Superheroic'
      };
      const GENRE_MAP = {
          billionaire: 'Billionaire', crime: 'CrimeSyndicate', noir: 'Noir',
          heist: 'Heist', espionage: 'Espionage', political: 'Political',
          survival: 'Survival', obsession: 'Obsession', forbidden: 'ForbiddenKnowledge',
          'forbidden knowledge': 'ForbiddenKnowledge'
      };
      const ARCHETYPE_MAP = {
          'heart warden': 'HEART_WARDEN', 'open vein': 'OPEN_VEIN',
          'spellbinder': 'SPELLBINDER', 'armored fox': 'ARMORED_FOX',
          'dark vice': 'DARK_VICE', 'beautiful ruin': 'BEAUTIFUL_RUIN',
          'eternal flame': 'ETERNAL_FLAME'
      };

      // ========================================
      // DETERMINISTIC COMMAND REGISTRY (v1)
      // NO fuzzy matching. NO synonyms. NO NLP.
      // ========================================
      const DEV_CMD_REGISTRY = {
          world: ['Modern', 'Historical', 'Fantasy', 'SciFi', 'Dystopia', 'PostApocalyptic'],
          genre: ['CrimeSyndicate', 'Billionaire', 'Noir', 'Heist', 'Espionage', 'Political',
                  'Escape', 'Redemption', 'BuildingBridges', 'Purgatory', 'RelentlessPast',
                  'Sports', 'Survival', 'Obsession', 'ForbiddenKnowledge'],
          tone: ['Earnest', 'WryConfession', 'Dark', 'Mythic'],
          dynamic: ['Proximity', 'SecretIdentity', 'Friends', 'Enemies',
                    'SecondChance', 'Forbidden']
      };

      // Case-insensitive lookup for canonical value
      function resolveCanonical(axis, input) {
          const list = DEV_CMD_REGISTRY[axis];
          if (!list) return null;
          const lower = input.toLowerCase();
          return list.find(v => v.toLowerCase() === lower) || null;
      }

      // Deterministic command parser (space-split, no regex magic)
      function parseDevCommand(raw) {
          const parts = raw.trim().split(/\s+/);
          if (parts.length === 0) return null;

          // ALIAS: "regen book cover" â†’ "regen cover"
          if (parts[0] === 'regen' && parts[1] === 'book' && parts[2] === 'cover') {
              return { cmd: 'regen', target: 'cover' };
          }
          // COMMAND: "regen cover"
          if (parts[0] === 'regen' && parts[1] === 'cover') {
              return { cmd: 'regen', target: 'cover' };
          }
          // COMMAND: "set <axis> <value>"
          if (parts[0] === 'set' && parts.length >= 3) {
              const axis = parts[1];
              const value = parts.slice(2).join(' ');
              return { cmd: 'set', axis, value };
          }
          // Not a registry command
          return null;
      }

      // Execute deterministic command (returns true if handled)
      function executeRegistryCommand(input) {
          const parsed = parseDevCommand(input);
          if (!parsed) return false;

          // REGEN COVER (gated by coverEligibility)
          if (parsed.cmd === 'regen' && parsed.target === 'cover') {
              const world = state.picks?.world || 'Modern';
              const genre = state.picks?.genre || 'Billionaire';
              const intensity = state.intensity || 'Naughty';
              const rawTitle = document.getElementById('storyTitle')?.textContent?.trim() || '';
              const title = (rawTitle && rawTitle !== 'Untitled') ? rawTitle : '';

              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // MINIMAL COVER v1 GUARD â€” Skip PHASE_1_FORGED fallback entirely
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              if (USE_MINIMAL_COVER_V1) {
                  console.log('[COVER:v1] Skipping PHASE_1_FORGED fallback â€” Minimal Cover owns cover');
                  return true;
              }

              // PHASE 1 GATE: Custom covers only when coverEligibility === true
              if (state.coverMode === 'PHASE_1_FORGED' || state.coverEligibility !== true) {
                  console.log('[DEV:CoverGen] PHASE_1_FORGED mode â€” using local fallback');
                  resetCoverLayers();
                  showDevCover();
                  renderFallbackCover(world, genre, title);
                  stopCoverLoading(null);

                  log('[DEV:CoverGen] PHASE_1 fallback applied');
                  return true;
              }

              // CUSTOM COVER PATH (only when coverEligibility === true)
              console.log('[DEV:CoverGen] Regenerating cover...');
              resetCoverLayers();
              showDevCover();
              const synopsis = document.getElementById('synopsisText')?.textContent || '';
              const authorName = CANONICAL_AUTHOR_NAME;
              generateBookCover(synopsis, title, authorName).then(coverUrl => {
                  if (coverUrl) {
                      stopCoverLoading(coverUrl);
    
                      log('[DEV:CoverGen] Cover generated');
                  } else {
                      renderFallbackCover(world, genre);
                      stopCoverLoading(null);
    
                      log('[DEV:CoverGen] AI failed â†’ fallback');
                  }
              }).catch(err => {
                  console.error('[DEV:CoverGen] Error:', err);
                  renderFallbackCover(world, genre);
                  stopCoverLoading(null);

                  log('[DEV:CoverGen] Error â†’ fallback');
              });
              log('[DEV:CoverGen] Started...');
              return true;
          }

          // SET <axis> <value>
          if (parsed.cmd === 'set') {
              const { axis, value } = parsed;
              // Validate axis
              if (!DEV_CMD_REGISTRY[axis]) {
                  console.error('[DEV:StateChange] HARD FAIL: Unknown axis "' + axis + '"');
                  log('ERROR: Unknown axis "' + axis + '". Valid: world, genre, tone, dynamic, arousal');
                  return true;
              }
              // Resolve canonical value
              const canonical = resolveCanonical(axis, value);
              if (!canonical) {
                  console.error('[DEV:StateChange] HARD FAIL: Invalid value "' + value + '" for axis "' + axis + '"');
                  log('ERROR: Invalid ' + axis + ' "' + value + '". Valid: ' + DEV_CMD_REGISTRY[axis].join(', '));
                  return true;
              }
              // Update state
              state.picks = state.picks || {};
              if (axis === 'arousal') {
                  state.intensity = canonical;
              } else {
                  state.picks[axis] = axis === 'tone' ? canonicalizeTone(canonical) : canonical;
              }
              console.log('[DEV:StateChange] ' + axis + ' â†’ ' + (state.picks[axis] || canonical));
              log('[DEV:StateChange] ' + axis + ' â†’ ' + (state.picks[axis] || canonical));
              // Trigger dependent recalculations
              if (axis === 'arousal') {
              }
              if (axis === 'tone' || axis === 'world' || axis === 'pressure') {
                  deriveToneBias();
              }
              return true;
          }

          return false;
      }

      function extract(text, map) {
          for (const [key, val] of Object.entries(map)) {
              if (text.includes(key)) return val;
          }
          return null;
      }

      // Show the book cover page in dev context
      function showDevCover() {
          window.showScreen('game');
          const bcp = document.getElementById('bookCoverPage');
          const sc = document.getElementById('storyContent');
          const bo = document.getElementById('bookObject');
          const ls = document.getElementById('coverLoadingState');
          if (bcp) bcp.classList.remove('hidden');
          if (sc) sc.classList.add('hidden');
          if (bo) bo.classList.remove('hidden');
          if (ls) ls.classList.add('hidden');
      }

      function execute(input) {
          // --- DETERMINISTIC REGISTRY COMMANDS (priority) ---
          if (executeRegistryCommand(input)) return;

          // --- HELP ---
          if (/^(help|what can i say)\b/.test(input)) {
              log('=== DETERMINISTIC COMMANDS ===');
              log('regen cover');
              log('set world <Modern|Historical|Fantasy|SciFi|Dystopia|PostApocalyptic>');
              log('set genre <' + DEV_CMD_REGISTRY.genre.slice(0, 5).join('|') + '|...>');
              log('set tone <Earnest|WryConfession|Dark|Mythic>');
              log('set dynamic <Proximity|SecretIdentity|Friends|Enemies|SecondChance|Forbidden>');
              log('set arousal <Clean|Naughty|Erotic|Dirty>');
              log('=== LEGACY COMMANDS ===');
              log('COVER: make [world] [intensity] cover | pretend cover failed | show fallback | show/hide keyhole | reset cover');
              log('STATE: set intensity to X | go dirty/erotic | pretend i paid | pretend i\'m free | what\'s going on');
              log('QUERY: what genre/world/tone/intensity/archetype/title? | title pipeline | test title [text]');
              log('POV: check pov | why pov failed | set pov author/normal');
              log('VALIDATION: check dsp | check tone | check erotic | check authority | check title | check signal | check paywall | check book | check all');
              log('FATE: reset fate cards | deal fate');
              log('FORK: show fork (test continuation modal)');
              return;
          }

          // --- MAKE / GENERATE COVER ---
          if (/\b(make|generate)\b.*\bcover\b/.test(input)) {
              const world = extract(input, WORLD_MAP) || state.picks?.world || 'Modern';
              const genre = extract(input, GENRE_MAP) || state.picks?.genre || 'Billionaire';
              const intensity = state.intensity || 'Naughty';
              state.picks = state.picks || {};
              state.picks.world = world;
              state.picks.genre = genre;
              state.intensity = intensity;
              resetCoverLayers();
              showDevCover();
              renderFallbackCover(world, genre);
              log('Cover: ' + world + ' / ' + genre + ' / ' + intensity);
              return;
          }

          // --- PRETEND COVER FAILED ---
          if (/\b(pretend|simulate)\b.*\bcover\b.*\b(fail|broke|error)\b|\bcover\b.*\b(fail|broke)\b/.test(input)) {
              const world = state.picks?.world || 'Modern';
              const genre = state.picks?.genre || 'Billionaire';
              resetCoverLayers();
              showDevCover();
              renderFallbackCover(world, genre);
              log('Simulated cover failure -> fallback rendered');
              return;
          }

          // --- SHOW / USE FALLBACK ---
          if (/\b(show|use|skip)\b.*(fallback|ai\s*cover)\b/.test(input)) {
              const world = state.picks?.world || 'Modern';
              const genre = state.picks?.genre || 'Billionaire';
              resetCoverLayers();
              showDevCover();
              renderFallbackCover(world, genre);
              log('Fallback cover shown (' + world + ' / ' + genre + ')');
              return;
          }

          // --- SHOW FORK MODAL ---
          if (/\b(show|test)\b.*\bfork\b/.test(input)) {
              showContinuationFork();
              log('Continuation fork modal shown');
              return;
          }

          // --- SHOW KEYHOLE ---
          if (/\b(show|turn on)\b.*\bkeyhole\b/.test(input)) {
              showDevCover();
              // Ensure a base cover exists
              const fb = document.getElementById('coverFallback');
              const img = document.getElementById('bookCoverImg');
              const hasCover = (fb && !fb.classList.contains('hidden')) || (img && img.src && img.style.display !== 'none');
              if (!hasCover) {
                  renderFallbackCover(state.picks?.world || 'Modern', state.picks?.genre || 'Billionaire');
              }
              log('Keyhole takeover enabled');
              return;
          }
          if (/\bhide\b.*\bkeyhole\b/.test(input)) {
              const kh = document.getElementById('coverKeyholeOverlay');
              if (kh) kh.classList.add('hidden');
              log('Keyhole hidden');
              return;
          }

          // --- RESET COVER ---
          if (/\b(reset|clear|start)\b.*\bcover\b/.test(input)) {
              resetCoverLayers();
              resetBookState();
              log('Cover state reset');
              return;
          }

          // --- RESET / DEAL FATE CARDS ---
          // Aliases: "reset fate cards", "reset the fate cards", "restart fate", "redo fate", "re-deal fate cards", "deal fate"
          if (/\b(reset|restart|redo|re-?deal|deal)\b.*\bfate\b/i.test(input)) {
              if (window.dealFateCards) {
                  window.dealFateCards();
                  // PERMANENT FX REBIND: Ensure fate cards have handlers after redeal
                  if (window.initFateCards) window.initFateCards();
                  log('Fate cards re-dealt');
              } else {
                  log('Fate card system not available');
              }
              return;
          }

          // --- ACCESS SIMULATION ---
          if (/\bpretend\b.*\b(paid|story\s*pass|subscribed)\b/.test(input)) {
              window._devBypass = true;
              _devOverrides.access = 'sub';
              state.subscribed = true;
              state.billingStatus = 'active';
              state.fortunes = (state.fortunes || 0) + 50;
              if (state.storyId) grantStoryPass(state.storyId);
              syncTierFromAccess();
              if (window.updateFortuneDisplay) window.updateFortuneDisplay();
              log('DEV: Subscribed + 50 fortunes + purchase bypass active');
              return;
          }
          if (/\bpretend\b.*\bfree\b/.test(input)) {
              _devOverrides.access = 'free';
              state.subscribed = false;
              state.intensity = 'Naughty';
              syncTierFromAccess();
              log('Pretending free tier');
              return;
          }

          // --- ARCHETYPE / LENS ---
          if (/\b(use|switch)\b.*\b(lens|archetype)\b/.test(input) || /\bswitch to\b/.test(input)) {
              const archId = extract(input, ARCHETYPE_MAP);
              if (archId && ARCHETYPES[archId]) {
                  state.archetype = state.archetype || {};
                  state.archetype.primary = archId;
                  log('Archetype -> ' + ARCHETYPES[archId].name);
              } else {
                  log('Unknown archetype. Try: beautiful ruin, open vein, spellbinder, armored fox, dark vice, heart warden, eternal flame');
              }
              return;
          }

          if (/\bpretend\b.*\bwritten\b.*\b\d+/.test(input)) {
              const m = input.match(/(\d+)/);
              if (m) {
                  state.wordCount = parseInt(m[1], 10);
                  log('Word count -> ' + m[1]);
              }
              return;
          }

          // --- DEBUG: STATE DUMP ---
          if (/\bwhat.s\b.*\b(going|everything|firing)\b|\bshow me everything\b/.test(input)) {
              const info = [
                  'world:' + (state.picks?.world || '-'),
                  'genre:' + (state.picks?.genre || '-'),
                  'tone:' + (state.picks?.tone || '-'),
                  'dynamic:' + (state.picks?.dynamic || '-'),
                  'intensity:' + (state.intensity || '-'),
                  'arch:' + (state.archetype?.primary || '-'),
                  'access:' + (state.access || '-'),
                  'sub:' + (state.subscribed || false),
                  'turns:' + (state.turnCount || 0),
                  'resonance:' + getFateResonanceState() + '(' + (state.fate_resonance_intensity || 0) + ')'
              ];
              log(info.join(' | '));
              console.log('[DevHUD] Full state:', JSON.parse(JSON.stringify(state)));
              return;
          }

          // --- DEBUG: COVER STATE ---
          if (/\bwhat cover\b|\bwhy.*cover\b/.test(input)) {
              const fb = document.getElementById('coverFallback');
              const img = document.getElementById('bookCoverImg');
              const border = document.getElementById('coverOrnateBorder');
              const keyhole = document.getElementById('coverKeyholeOverlay');
              const hasFallback = fb && !fb.classList.contains('hidden');
              const hasImg = img && img.src && !img.src.endsWith('/') && img.style.display !== 'none';
              const hasBorder = border && !border.classList.contains('hidden');
              const hasKeyhole = keyhole && !keyhole.classList.contains('hidden');
              const layers = [];
              if (hasImg) layers.push('AI cover');
              if (hasFallback) layers.push('fallback');
              if (hasBorder) layers.push('ornate border (' + (border.className.match(/world-\w+/)?.[0] || 'default gold') + ')');
              if (hasKeyhole) layers.push('keyhole takeover');
              log(layers.length ? 'Active: ' + layers.join(' + ') : 'No cover layers visible');
              return;
          }

          // --- CASUAL ENGLISH QUERIES ---
          // "what genre is this", "what genre", "genre?"
          if (/\b(what|which)\b.*\bgenre\b|\bgenre\s*\?/.test(input)) {
              log('Genre: ' + (state.picks?.genre || '(not set)'));
              return;
          }
          // "what world is this", "what world", "world?"
          if (/\b(what|which)\b.*\bworld\b|\bworld\s*\?/.test(input)) {
              log('World: ' + (state.picks?.world || '(not set)') +
                  (state.picks?.world === 'Historical' ? ' (' + (state.picks?.era || 'no era') + ')' : ''));
              return;
          }
          // "what tone", "tone?"
          if (/\b(what|which)\b.*\btone\b|\btone\s*\?/.test(input)) {
              log('Tone: ' + (state.picks?.tone || '(not set)'));
              return;
          }
          // "what intensity", "intensity?"
          if (/\b(what|which)\b.*\bintensity\b|\bintensity\s*\?/.test(input)) {
              log('Intensity: ' + (state.intensity || '(not set)'));
              return;
          }
          // "what archetype", "archetype?", "what lens"
          if (/\b(what|which)\b.*\b(archetype|lens)\b|\b(archetype|lens)\s*\?/.test(input)) {
              const archId = state.archetype?.primary;
              log('Archetype: ' + (archId && ARCHETYPES[archId] ? ARCHETYPES[archId].name : '(not set)'));
              return;
          }
          // "what dynamic", "dynamic?"
          if (/\b(what|which)\b.*\bdynamic\b|\bdynamic\s*\?/.test(input)) {
              log('Dynamic: ' + (state.picks?.dynamic || '(not set)'));
              return;
          }
          // "why did cover fail", "what happened to cover", "cover status"
          if (/\bwhy\b.*\bcover\b|\bcover\b.*\b(status|state|happened|wrong|broken)\b/.test(input)) {
              // Delegate to existing cover debug
              execute('what cover');
              return;
          }
          // "what title", "title?"
          if (/\b(what|which)\b.*\btitle\b|\btitle\s*\?/.test(input)) {
              const t = document.getElementById('storyTitle')?.textContent;
              log('Title: ' + (t || '(none)'));
              return;
          }
          // "title pipeline", "title debug", "title status"
          if (/\btitle\s*(pipeline|debug|status|info)\b/i.test(input)) {
              const t = document.getElementById('storyTitle')?.textContent;
              if (!t) {
                  log('No title set');
                  return;
              }
              const mode = detectTitleMode(t);
              const baseline = state.titleBaselineArousal || '(none)';
              const immutable = state.immutableTitle || '(none)';
              const swapTest = runSwapTest(t, state.picks?.world, state.intensity);
              log('=== TITLE PIPELINE ===');
              log('Current: "' + t + '"');
              log('Mode: ' + (mode || 'unknown'));
              log('Baseline arousal: ' + baseline);
              log('Immutable title: "' + immutable + '"');
              log('Swap-test: ' + (swapTest.unique ? 'PASS' : 'FAIL â€” ' + swapTest.reason));
              // Check immutability
              if (immutable && t !== immutable) {
                  log('WARNING: Title differs from immutable record!');
              }
              return;
          }
          // "test title [text]", "validate title [text]"
          if (/\btest\s+title\s+(.+)/i.test(input)) {
              const match = input.match(/\btest\s+title\s+(.+)/i);
              if (match) {
                  const testTitle = match[1].trim();
                  const result = validateTitle(
                      testTitle,
                      state.picks?.tone,
                      state.intensity,
                      { world: state.picks?.world, genre: state.picks?.genre }
                  );
                  log('Testing: "' + testTitle + '"');
                  log('Mode: ' + (result.mode || 'unknown'));
                  if (result.valid) {
                      log('Result: PASS');
                  } else {
                      log('Result: FAIL');
                      result.errors.forEach(e => log('  ' + e.message));
                  }
              }
              return;
          }

          // --- 5TH PERSON POV DIAGNOSTICS ---
          // "check pov", "pov status"
          if (/\bcheck\s*pov\b|\bpov\s*(status|check)\b/i.test(input)) {
              const povMode = state.povMode || 'normal';
              const lastCheck = _lastPOVValidation;
              log('POV Mode: ' + povMode);
              if (povMode === 'author5th') {
                  log('Last validation: ' + (lastCheck.valid ? 'PASS' : 'FAIL') +
                      ' | Author mentions: ' + (lastCheck.authorMentions || 0));
              }
              return;
          }
          // "why pov failed", "pov violations"
          if (/\bwhy\s*pov\b|\bpov\s*(fail|violation|error)\b/i.test(input)) {
              const lastCheck = _lastPOVValidation;
              if (lastCheck.valid) {
                  log('Last POV check passed (no violations)');
              } else if (lastCheck.violations?.length) {
                  log('POV violations: ' + lastCheck.violations.join('; '));
              } else {
                  log('No POV validation data available');
              }
              return;
          }
          // "set pov author", "enable 5th person"
          if (/\b(set|enable|use)\s*(5th|fifth|author)\s*(pov|person)?\b/i.test(input)) {
              state.povMode = 'author5th';
              log('POV Mode -> author5th (5th Person)');
              return;
          }
          // "set pov normal", "disable 5th person"
          if (/\b(set|disable|use)\s*(normal|standard|3rd|third)\s*(pov|person)?\b/i.test(input)) {
              state.povMode = 'normal';
              log('POV Mode -> normal (standard 3rd person)');
              return;
          }

          // --- EXIT DEV MODE ---
          if (/\b(exit|stop|back)\b.*\b(pretend|normal)\b/.test(input)) {
              _devOverrides = {};
              state.subscribed = false;
              state.intensity = 'Naughty';
              syncTierFromAccess();
              resetCoverLayers();
              log('Dev overrides cleared â€” back to normal');
              return;
          }

          // --- VALIDATION CHECK COMMANDS ---
          // "check dsp", "validate dsp"
          if (/\bcheck\s*dsp\b|\bvalidate\s*dsp\b/i.test(input)) {
              const dspEl = document.getElementById('synopsisText');
              if (!dspEl) {
                  log('DSP element not found');
                  return;
              }
              const result = window.validateDSP(dspEl.textContent || '', {
                  world: state.picks?.world || 'Modern',
                  genre: state.picks?.genre || 'Billionaire',
                  archetypeId: state.archetype?.primary || 'BEAUTIFUL_RUIN',
                  tone: state.picks?.tone || 'Earnest'
              });
              if (result.pass) {
                  log('DSP: PASS â€” template matches exactly');
              } else {
                  log('DSP: FAIL â€” ' + result.errors.map(e => e.code).join(', '));
                  result.errors.forEach(e => log('  ' + e.message));
              }
              return;
          }

          // "check tone", "validate tone"
          if (/\bcheck\s*tone\b|\bvalidate\s*tone\b/i.test(input)) {
              if (!window.StoryPagination) {
                  log('Story not started');
                  return;
              }
              const content = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-2000);
              const tone = state.picks?.tone || 'Earnest';
              const result = window.validateTone(content, tone);
              if (result.valid) {
                  log('Tone (' + tone + '): PASS â€” ' + result.matchCount + ' markers found');
              } else {
                  log('Tone (' + tone + '): FAIL â€” ' + result.matchCount + '/' + result.required + ' markers');
                  result.violations.forEach(v => log('  ' + v));
              }
              return;
          }

          // "check erotic", "validate erotic", "check escalation"
          if (/\bcheck\s*(erotic|escalation)\b|\bvalidate\s*erotic\b/i.test(input)) {
              if (!isIntimacyAllowedAtCurrentStoryturn()) {
                  log('Erotic escalation: N/A (not at ST3/ST4)');
                  return;
              }
              if (!window.StoryPagination) {
                  log('Story not started');
                  return;
              }
              const content = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-2000);
              const result = window.validateEroticEscalation(content, state.intensity);
              if (result.valid) {
                  log('Erotic (' + state.intensity + '): PASS â€” ' + result.metrics.sensoryCount + ' sensory markers');
              } else {
                  log('Erotic (' + state.intensity + '): FAIL');
                  result.violations.forEach(v => log('  ' + v));
              }
              return;
          }

          // "check authority", "check narrative", "validate authority"
          if (/\bcheck\s*(authority|narrative)\b|\bvalidate\s*authority\b|\bnarrative\s*authority\b/i.test(input)) {
              if (!window.StoryPagination) {
                  log('Story not started');
                  return;
              }
              const content = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-3000);
              const result = window.validateNarrativeAuthority(content);
              log('=== NARRATIVE AUTHORITY ===');
              log('Layer Order: Authority â†’ Tone â†’ POV â†’ Prose');
              if (result.valid) {
                  log('Result: PASS (no violations)');
              } else {
                  log('Result: FAIL â€” ' + result.errors.length + ' violations');
                  result.errors.forEach(e => {
                      log('  ' + e.code + ': ' + e.message);
                      log('    Match: "' + (e.match || '').substring(0, 60) + '..."');
                  });
              }
              // Show last validation timestamp
              if (_lastNarrativeAuthorityValidation.timestamp > 0) {
                  const ago = Math.round((Date.now() - _lastNarrativeAuthorityValidation.timestamp) / 1000);
                  log('Last check: ' + ago + 's ago (' + (_lastNarrativeAuthorityValidation.valid ? 'PASS' : 'FAIL') + ')');
              }
              return;
          }

          // "check title", "validate title"
          if (/\bcheck\s*title\b|\bvalidate\s*title\b/i.test(input)) {
              const titleEl = document.getElementById('storyTitle');
              if (!titleEl || !titleEl.textContent) {
                  log('No title to validate');
                  return;
              }
              const currentTitle = titleEl.textContent.trim();
              const result = validateTitle(currentTitle, state.picks?.tone);
              if (result.valid) {
                  log('Title: PASS â€” "' + currentTitle + '"');
              } else {
                  log('Title: FAIL â€” "' + currentTitle + '"');
                  result.errors.forEach(e => log('  ' + e.message));
                  // Show what fallback would be
                  const fallback = generateFallbackTitle({
                      playerName: state.rawPlayerName,
                      partnerName: state.rawPartnerName,
                      world: state.picks?.world || 'Modern',
                      tone: state.picks?.tone || 'Earnest',
                      genre: state.picks?.genre || 'Romance'
                  });
                  log('  Fallback would be: "' + fallback + '"');
              }
              return;
          }

          // "check signal", "check alignment", "validate signal"
          if (/\bcheck\s*(signal|alignment)\b|\bvalidate\s*signal\b/i.test(input)) {
              const titleEl = document.getElementById('storyTitle');
              if (!titleEl || !titleEl.textContent) {
                  log('No title to check signals');
                  return;
              }
              const currentTitle = titleEl.textContent.trim();
              // Create mock cover prompt for signal extraction (uses current state)
              const mockCoverPrompt = {
                  promptText: 'emotion: ' + (state.coverEmotion || 'mystery'),
                  emotion: state.coverEmotion || 'mystery'
              };
              const result = validateSignalAlignment(currentTitle, mockCoverPrompt, {
                  arousal: state.intensity || 'Naughty',
                  tone: state.picks?.tone || 'Earnest',
                  genre: state.picks?.genre || 'Romance'
              });
              log('=== SIGNAL ALIGNMENT ===');
              log('Expected arousal: ' + (state.intensity || 'Naughty') + ' (' + result.context.arousalSignal + ')');
              log('Title signals: ' + (result.titleSignals.primary || 'none') +
                  (result.titleSignals.secondary ? ' + ' + result.titleSignals.secondary : ''));
              log('Cover signals: ' + (result.coverSignals.primary || 'none') +
                  (result.coverSignals.secondary ? ' + ' + result.coverSignals.secondary : ''));
              if (result.aligned) {
                  log('Alignment: PASS');
              } else {
                  log('Alignment: FAIL');
                  result.errors.forEach(e => log('  ' + e.message));
              }
              return;
          }

          // "check all", "validate all", "run all checks"
          if (/\bcheck\s*all\b|\bvalidate\s*all\b|\brun\s*all\s*checks?\b/i.test(input)) {
              const results = window.getValidationStatus();
              log('=== VALIDATION STATUS ===');

              if (results.dsp) {
                  log('DSP: ' + (results.dsp.pass ? 'PASS' : 'FAIL'));
                  if (!results.dsp.pass) results.dsp.errors.forEach(e => log('  ' + e.code));
              }

              if (results.pov) {
                  log('POV: ' + (results.pov.pass ? 'PASS' : 'FAIL') + ' (' + results.pov.metrics.authorMentions + ' Author mentions)');
                  if (!results.pov.pass) results.pov.errors.forEach(e => log('  ' + e.code));
              }

              if (results.tone) {
                  log('Tone: ' + (results.tone.valid ? 'PASS' : 'FAIL') + ' (' + results.tone.matchCount + '/' + results.tone.required + ')');
              }

              if (results.erotic) {
                  log('Erotic: ' + (results.erotic.valid ? 'PASS' : 'FAIL'));
                  if (!results.erotic.valid) results.erotic.violations.forEach(v => log('  ' + v.split(':')[0]));
              }

              // Narrative Authority check (runs first in layer model)
              if (window.StoryPagination) {
                  const narrContent = StoryPagination.getAllContent().replace(/<[^>]*>/g, ' ').slice(-3000);
                  const narrResult = validateNarrativeAuthority(narrContent);
                  log('Authority: ' + (narrResult.valid ? 'PASS' : 'FAIL'));
                  if (!narrResult.valid) narrResult.errors.forEach(e => log('  ' + e.code));
              }

              if (results.title) {
                  log('Title: ' + (results.title.valid ? 'PASS' : 'FAIL'));
                  if (!results.title.valid) results.title.errors.forEach(e => log('  ' + e.code));
              }

              if (results.signal) {
                  log('Signal: ' + (results.signal.aligned ? 'PASS' : 'FAIL'));
                  if (!results.signal.aligned) results.signal.errors.forEach(e => log('  ' + e.code));
              }

              // Paywall routing check
              const paywallResult = validatePaywallRouting();
              if (!paywallResult.skipped) {
                  log('Paywall: ' + (paywallResult.valid ? 'PASS' : 'FAIL'));
                  if (!paywallResult.valid) log('  ' + paywallResult.error);
              }

              // Book flow integrity check
              const bookResult = validateBookFlowIntegrity();
              log('Book Flow: ' + (bookResult.valid ? 'PASS' : 'FAIL'));
              if (!bookResult.valid) bookResult.errors.forEach(e => log('  ' + e.code));

              // Strategy Pass status
              if (state._strategyPassFailed === true) {
                  log('Strategy Pass: \u26A0 FAILED \u2014 Fallback Mode');
              } else if (state._strategyPass) {
                  log('Strategy Pass: PASS (ST=' + state._strategyPass.st_phase + ', artifact=' + state._strategyPass.world_artifact_to_surface + ')');
                  if (state._strategyPass.active_entropy_axis) {
                      log('  Entropy Axis Used: ' + state._strategyPass.active_entropy_axis);
                      log('  Manifestation: ' + (state._strategyPass.entropy_manifestation_summary || 'N/A'));
                  }
              } else {
                  log('Strategy Pass: N/A (not yet run)');
              }

              // Post-render structural validation (Pass 4) status
              if (state._pass4Validation) {
                  const p4 = state._pass4Validation;
                  const corrected = state._postRenderCorrectionApplied === true;
                  if (p4.valid) {
                      log('Post-Render (P4): PASS');
                  } else if (corrected) {
                      log('Post-Render (P4): CORRECTED (' + p4.violations.length + ' violations fixed)');
                  } else {
                      log('Post-Render (P4): FAILED (' + p4.violations.length + ' violations)');
                  }
                  // Detail lines
                  const hasArtifact = !p4.violations.some(v => v.startsWith('MISSING_ARTIFACT'));
                  const hasVisEffect = !p4.violations.some(v => v.startsWith('MISSING_VISIBLE_WORLD_CHANGE'));
                  const hasDecFate = p4.violations.some(v => v.startsWith('DECORATIVE_FATE'));
                  log('  Artifact present: ' + (hasArtifact ? 'yes' : 'no'));
                  log('  Visible effect present: ' + (hasVisEffect ? 'yes' : 'no'));
                  log('  Decorative Fate detected: ' + (hasDecFate ? 'yes' : 'no'));
              } else {
                  log('Post-Render (P4): N/A');
              }

              // Blue Blood debug (variant + entropy)
              if (state._blueBloodVariant) {
                  log('Blue Blood Variant: ' + state._blueBloodVariant);
                  if (state._blueBloodEntropy) {
                      const e = state._blueBloodEntropy;
                      log('  Entry State: ' + e.entry_state);
                      log('  Pressure Origin: ' + e.pressure_origin);
                      log('  Polarity: ' + e.polarity_orientation);
                      log('  Exposure: ' + e.exposure_level);
                      log('  Timeline: ' + e.structural_timeline_mode);
                      if (e.monarchy_model) log('  Monarchy Model: ' + e.monarchy_model);
                  }
              }

              // Fantasy core entropy debug
              if (state._fantasyCoreEntropy) {
                  log('Flavor: Fantasy Core');
                  Object.keys(state._fantasyCoreEntropy).forEach(axis => {
                      log('  ' + axis + ': ' + state._fantasyCoreEntropy[axis]);
                  });
                  if (state._strategyPass && state._strategyPass.active_entropy_axis) {
                      log('  Active Entropy Axis (this scene): ' + state._strategyPass.active_entropy_axis);
                  }
                  if (state.fantasyRegion) {
                      log('  Fatelands Region: ' + state.fantasyRegion);
                      log('  Seat: ' + (state.fantasyRegionSeat || '(unconfirmed)'));
                      log('  Governance: ' + (state.fantasyRegionGovernance || '(unknown)'));
                      log('  Status: ' + (state.fantasyRegionStatus || '(none)'));
                      if (state.fantasyRegionReality) log('  Reality: ' + state.fantasyRegionReality);
                      log('  Magic Bias: ' + state.fantasyMagicExpressionBias);
                  }
                  log('  Syzygy Occurred: ' + state._syzygyOccurred);
                  log('  Syzygy Eligible: ' + !state._syzygyOccurred);
                  log('  Syzygy Active This Scene: ' + !!state._syzygyActiveThisScene);
                  log('  Syzygy Model Triggered Last: ' + !!state._syzygyModelTriggeredLast);
              }

              // Dystopia core entropy debug
              if (state._dystopiaCoreEntropy) {
                  log('Flavor: Dystopia Core');
                  log('  Subtype: ' + (state.picks?.worldSubtype || '(none)'));
                  Object.keys(state._dystopiaCoreEntropy).forEach(axis => {
                      log('  ' + axis + ': ' + state._dystopiaCoreEntropy[axis]);
                  });
                  if (state._strategyPass && state._strategyPass.active_entropy_axis) {
                      log('  Active Entropy Axis (this scene): ' + state._strategyPass.active_entropy_axis);
                  }
                  if (state.dystopianAttentionLevel > 0) {
                      const att = state.dystopianAttentionLevel;
                      log('  Attention Level: ' + att.toFixed(2) + ' (' + (att >= 0.7 ? 'critical' : att >= 0.5 ? 'high' : att >= 0.3 ? 'moderate' : 'low') + ')');
                      log('  Enforcement Mode: ' + (state.dystopianEnforcementMode || 'mixed'));
                  }
              }

              // Historical core entropy debug
              if (state._historicalCoreEntropy) {
                  log('Flavor: Historical Core');
                  log('  Era: ' + (state.picks?.worldSubtype || '(none)'));
                  Object.keys(state._historicalCoreEntropy).forEach(axis => {
                      log('  ' + axis + ': ' + state._historicalCoreEntropy[axis]);
                  });
                  if (state._strategyPass && state._strategyPass.active_entropy_axis) {
                      log('  Active Entropy Axis (this scene): ' + state._strategyPass.active_entropy_axis);
                  }
                  if (state.historicalCognitiveBand) {
                      log('  Cognitive Band: ' + state.historicalCognitiveBand);
                      log('  Cognitive Modulation: ' + (state.historicalCognitiveModulation || 0.25).toFixed(2));
                      const friction = state.historicalFrictionIndex || 0;
                      log('  Friction Index: ' + (friction >= 0.66 ? 'high' : friction >= 0.33 ? 'moderate' : 'low') + ' (' + friction.toFixed(2) + ')');
                  }
              }

              // Modern flavor entropy debug
              const _modernEntropyDebug = [
                  { label: 'Modern Core', key: '_modernCoreEntropy' },
                  { label: 'Small Town', key: '_smallTownEntropy' },
                  { label: 'College', key: '_collegeEntropy' },
                  { label: 'Office', key: '_officeEntropy' },
                  { label: 'Friends', key: '_friendsEntropy' },
                  { label: 'Supernatural', key: '_supernaturalEntropy' },
                  { label: 'Superheroic', key: '_superheroicEntropy' }
              ];
              for (const { label, key } of _modernEntropyDebug) {
                  if (state[key]) {
                      log('Flavor: ' + label);
                      Object.keys(state[key]).forEach(axis => {
                          log('  ' + axis + ': ' + state[key][axis]);
                      });
                      if (state._strategyPass && state._strategyPass.active_entropy_axis) {
                          log('  Active Entropy Axis (this scene): ' + state._strategyPass.active_entropy_axis);
                      }
                  }
              }

              const allPass = Object.values(results).every(r => r.pass || r.valid || r.aligned);
              log('=== ' + (allPass ? 'ALL CHECKS PASS' : 'SOME CHECKS FAILED') + ' ===');
              return;
          }

          // "check paywall", "validate paywall", "paywall routing"
          if (/\bcheck\s*paywall\b|\bvalidate\s*paywall\b|\bpaywall\s*routing\b/i.test(input)) {
              const result = validatePaywallRouting();
              log('=== PAYWALL ROUTING ===');
              log('Intensity: ' + (state.intensity || 'unknown'));
              log('Story Length: ' + (state.storyLength || 'unknown'));
              if (result.skipped) {
                  log('Paywall not visible â€” check skipped');
              } else if (result.valid) {
                  log('Result: PASS (StoryPass correctly hidden/shown)');
              } else {
                  log('Result: HARD FAIL');
                  log('Error: ' + result.error);
              }
              return;
          }

          // "check book", "validate book", "book flow"
          if (/\bcheck\s*book\b|\bvalidate\s*book\b|\bbook\s*flow\b/i.test(input)) {
              const result = validateBookFlowIntegrity();
              log('=== BOOK FLOW INTEGRITY ===');
              log('Page Types: COVER â†’ INSIDE_COVER â†’ SETTING â†’ SCENE');
              if (result.valid) {
                  log('Result: PASS (all page rules satisfied)');
              } else {
                  log('Result: HARD FAIL');
                  result.errors.forEach(e => log('  ' + e.code + ': ' + e.message));
              }
              return;
          }

          log('Unknown command. Type "help" for options.');
      }

      log('Dev HUD ready â€” press ` to toggle');
  })();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMATURE ROMANCE COLLAPSE PREVENTION â€” DOCUMENTATION (APPEND-ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// REGIME CONTEXT (LOCKED)
// ------------------------
// Storybound is a collaborative romance novel engine, not a simulator.
// Players express intent. The Story controls timing, consequences, and pacing.
//
// CORE RULE (AUTHORITATIVE)
// --------------------------
// Player actions that would collapse romantic tension must be honored in
// intent but deferred or reframed in outcome when Storyturn gates do not
// yet allow resolution.
//
// ROMANCE-COLLAPSING ACTIONS
// ---------------------------
// kiss      â†’ Gate: ST3 (Permission phase)
// intimacy  â†’ Gate: ST3 (Permission phase, Taste further restricts)
// commitmentâ†’ Gate: ST5 (Crisis resolution required)
// confessionâ†’ Gate: ST2 (Resistance phase minimum)
// closure   â†’ Gate: ST5 (Crisis phase required)
// reunion   â†’ Gate: ST6 (Integration phase required)
//
// REQUIRED BEHAVIOR (WHEN ACTION IS PREMATURE)
// ---------------------------------------------
// - Do NOT reject the action
// - Do NOT execute it literally
// - Do NOT explain the system
// - Do NOT punish the player's desire
//
// INSTEAD:
// - Preserve the desire â€” the player WANTED this
// - Introduce friction, interruption, or hesitation
// - Increase emotional charge
// - Maintain unresolved tension
//
// APPROVED NARRATIVE STRATEGIES
// ------------------------------
// 1. External Interruption â€” Someone enters, phone rings, alarm sounds
// 2. Internal Interruption â€” Character pulls back, hesitates, doubt surfaces
// 3. Mutual Hesitation â€” Both want it, both stop short
// 4. Almost-Touch â€” The gesture begins but doesn't complete
// 5. Recognition Without Fulfillment â€” Both acknowledge desire, neither acts
// 6. Deferral as Inevitability â€” Frame pause as building toward something greater
//
// 5TH PERSON GUIDANCE
// --------------------
// The Story may briefly acknowledge:
// "The story let this almost happen, knowing it would matter more later."
//
// HARD CONSTRAINTS
// -----------------
// âŒ No mechanical refusals
// âŒ No UI locks
// âŒ No mention of Storyturns
// âŒ No punishment for player desire
// âŒ No boredom-preserving neutrality
//
// SUCCESS CONDITION
// ------------------
// The player should feel:
// - Seen
// - Complicit
// - Slightly frustrated
// - MORE invested than before
//
// REGRESSION TEST
// ----------------
// Run: window.runPrematureRomanceTest()
//
// Verifies:
// - Kiss at ST1 â†’ detected
// - Kiss at ST3 â†’ allowed
// - Confession at ST1 â†’ detected
// - Confession at ST2 â†’ allowed
// - Commitment at ST4 â†’ detected (gate is ST5)
// - Directive includes reframe strategy
//
// MANTRA (DO NOT REMOVE)
// -----------------------
// Desire is never wrong.
// Timing is never arbitrary.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTENT-CONSEQUENCE ROMANCE CONTROL â€” DOCUMENTATION (APPEND-ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// REGIME CONTEXT (LOCKED)
// ------------------------
// Storybound is a collaborative romance novel engine governed by a genre contract.
// Players express intent. The Story controls timing, pacing, and consequences.
// Romantic meaning is earned, never rushed, never denied mechanically.
//
// CORE AXIOM (AUTHORITATIVE Â· MUST HOLD)
// ---------------------------------------
// Humans choose desire.
// The Story chooses when desire becomes consequential.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART A â€” POLY MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PURPOSE: Allow multiple romantic threads without collapsing tension.
//
// POLY SEMANTIC RULESET:
// - Intent may be multi-target (player can express attraction to multiple)
// - Consequences remain SERIALIZED (only one chain advances at a time)
// - No simultaneous payoff (intimacy with one complicates others)
//
// POLY STORY LOGIC (MANDATORY):
// When poly intent detected:
// - Do NOT resolve it immediately
// - Do NOT ask player to choose "now"
// - Do NOT punish curiosity
// - Let attraction accumulate
// - Let tension triangulate
// - Let consequences lag behind intent
//
// CANONICAL EXAMPLE:
// "You notice the way Marcus watches you notice Jax.
//  The story files this away. It will matter later."
//
// HARD CONSTRAINTS:
// âŒ No explicit "poly mode" UI explanation
// âŒ No simultaneous intimacy scenes
// âŒ No arithmetic balancing of affection
// âŒ No player-facing optimization
//
// MANTRA: Poly is felt, not managed.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART B â€” WRONG-CHARACTER INVITATION MICROCOPY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PURPOSE: Handle misdirected romantic intent gracefully.
//
// CORE RULE: Never let a misdirected invitation collapse the story.
//
// REQUIRED BEHAVIOR:
// - Preserve the intent
// - Redirect the consequence
// - Clarify stakes via story framing
// - Do NOT execute the action literally
//
// CANONICAL MICROCOPY RESPONSES:
// 1. Deflection (gentle): "He smiles, just a little too politely, and steps aside"
// 2. Redirection (story-aware): "The story notices the reach, then adjusts where it lands"
// 3. Complication (poly-safe): "He notices. Unfortunately, so does Marcus."
// 4. Almost (preferred): "The invitation hangs between you â€” felt, acknowledged, unanswered"
//
// HARD CONSTRAINTS:
// âŒ No "you can't do that"
// âŒ No explanation of roles
// âŒ No system voice
// âŒ No silent failure
//
// MANTRA: The player must feel seen, not corrected.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PART C â€” BORING-PLAYER ESCALATION LADDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PURPOSE: Prevent flat stories when players avoid tension.
//
// CORE INSIGHT (LOCKED): Boredom is unexpressed desire, not absence of desire.
//
// ESCALATION LADDER (MANDATORY Â· ORDERED):
//
// LEVEL 1 â€” Environmental Pressure (1-2 passive turns)
// "The room grows quieter than it should."
// - Time constraints, confined spaces, proximity, interruptions
//
// LEVEL 2 â€” NPC Initiative (3-4 passive turns)
// "You're very careful," he says. "Is that on purpose?"
// - The other character advances, asks a question, creates a moment
//
// LEVEL 3 â€” Social or Emotional Stakes (5-6 passive turns)
// "Someone is definitely watching now."
// - Someone notices, rumors, consequences loom
//
// LEVEL 4 â€” Forced Choice (7+ passive turns)
// "Whatever you do next will be remembered."
// - Stay or leave, answer or deflect, step closer or step away
//
// HARD CONSTRAINTS:
// âŒ No punishment for neutrality
// âŒ No sudden jumps to intimacy
// âŒ No railroading
//
// MANTRA: Escalation must feel inevitable, not imposed.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL SUCCESS CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// After these systems:
// - Humans cannot accidentally ruin pacing
// - Humans cannot "play wrong"
// - Desire always increases tension
// - Poly curiosity adds pressure, not chaos
// - Passive play becomes charged
// - The Story always feels smarter â€” never stricter
//
// REGRESSION TEST
// ----------------
// Run: window.runIntentConsequenceTest()
//
// Verifies:
// - Poly intent detection (smile at Jax â†’ detected)
// - Wrong target detection (kiss Jax â†’ detected, Marcus identified)
// - Passive play detection (shrug, wait â†’ detected)
// - Active play NOT detected as passive
// - Escalation level progression
// - Boredom directive generation
//
// FINAL MANTRA (DO NOT REMOVE)
// -----------------------------
// The player offers desire.
// The story decides when it costs something.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TONE-SPECIFIC VARIANTS â€” DOCUMENTATION (APPEND-ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// GLOBAL INVARIANT (MUST HOLD ACROSS ALL TONES):
// No tone may allow a player action to prematurely collapse romantic tension.
// Tone changes voice, framing, and texture â€” NEVER rules.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. WRY CONFESSION (PRIMARY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Self-aware, slightly embarrassed, observant mid-mistake
// Deferral style: Almosts + self-implication
// Story voice: Gentle witness. Occasionally amused. Never cruel.
//
// CANONICAL: "You lean in â€” not quite far enough to pretend this was an accident."
// NEVER USE: melodrama, destiny language, threats
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. EARNEST / ROMANTIC DRAMA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Sincere, yearning, emotionally vulnerable
// Deferral style: External interruption or mutual restraint framed as care
// Story voice: Protective, patient, quietly invested.
//
// CANONICAL: '"Not yet," he says softly, and you realize how much weight those words carry.'
// NEVER USE: irony, self-mockery, meta commentary
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. DARK / ANGST / FORBIDDEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Danger, repression, inevitability
// Deferral style: Consequences implied, not avoided
// Story voice: Grimly aware. Knows the cost.
//
// CANONICAL: "If this happens now, it won't end here."
// NEVER USE: humor, lightness, reassurance
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. COMEDIC / HEIGHTENED
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Exaggerated, impulsive, socially risky
// Deferral style: Misfires, interruptions, comedic timing
// Story voice: Knowing, fast, permissive but controlling outcomes.
//
// CANONICAL: "You lean in. The universe clears its throat."
// NEVER USE: tragedy, prolonged yearning, solemn restraint
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. STEAMY / SENSUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Emotional posture: Charged, deliberate, simmering
// Deferral style: Anticipation as pleasure, restraint as foreplay
// Story voice: Intimate, unhurried, knowingly drawing it out.
//
// CANONICAL: "Not yet. The waiting is part of it."
// NEVER USE: clinical language, embarrassment, shame
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HARD CONSTRAINTS (ALL TONES)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âŒ No tone may execute premature intimacy
// âŒ No tone may refuse desire outright
// âŒ No tone may expose mechanics
// âŒ No tone may flatten tension
// âŒ No tone may shame the player
//
// REGRESSION TEST
// ----------------
// Run: window.runToneVariantTest()
//
// Verifies:
// - Each tone returns correct variant configuration
// - Tone examples differ between tones
// - Never-use lists are populated
// - Escalation examples vary by level
// - Unknown tones fall back to default (Wry Confessional)
//
// TONE MANTRA (DO NOT REMOVE)
// ----------------------------
// The rules do not change.
// Only how the story tells the truth about them.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                        TITLE REGIME CHANGE: ST1 TENSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// SYSTEM PHILOSOPHY
// -----------------
// Book titles at ST1 must NAME THE TENSION, never claim its resolution.
// A title is a promise. At ST1, the promise is incomplete.
//
// This is not a vocabulary filter. It is a semantic timing authority.
// Titles tell the reader what the story WANTS, not what it HAS.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOCABULARY SPLIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ALLOWED (Unresolved Tension):
// â€¢ Waiting, Distance, Refusal, Terms, Conditions
// â€¢ Wanting, Craving, Hunger, Longing, Hesitation
// â€¢ Edge, Risk, Dare, Warning, Test
// â€¢ Confession (as desire-admission, not outcome)
//
// FORBIDDEN (Resolution/Aftermath):
// â€¢ Surrender, Obedience, Ruin, Undoing, Downfall
// â€¢ Took, Claimed, Gave, Broke, Wrecked, Ruined
// â€¢ Finally, At Last, In The End, After Everything
// â€¢ Possession, Conquest, Destruction, Betrayal
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AROUSAL LEVEL CONSTRAINTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// EROTIC: "wanting, yearning, hunger (not possession)"
//   Required: hunger|longing|craving|need|ache|want|desire|confession|hesitation
//   Forbidden: surrender|obedience|ruin|wreck|broke|took|claimed|gave|possession
//
// DIRTY: "intensity, demand, edge (not destruction)"
//   Required: raw|demand|appetite|edge|limit|dare|hunger|test|condition|warning
//   Forbidden: surrender|obedience|ruin|undoing|broke|wrecked|ruined|destroyed
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDATION PIPELINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// checkTitleResolutionVocabulary(title) â†’ { hasResolved: bool, violations: [] }
//
// Tests against TITLE_RESOLVED_VOCABULARY patterns:
// â€¢ pastCompletion: Past-tense completion verbs
// â€¢ possessiveResolution: Possessive + resolution noun
// â€¢ aftermathNouns: Post-event vocabulary
// â€¢ completionStates: Temporal finality markers
//
// Integration point: validateTitle() adds TITLE_RESOLUTION_VOCABULARY error
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROMPT DIRECTIVE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The buildTitlePrompt() function includes:
//
// "TITLE REGIME (CRITICAL):
// Book titles must name UNRESOLVED TENSION, not resolution.
// The reader hasn't finished the story. The title can't claim they have.
//
// FORBIDDEN: Past completion, aftermath, possession outcomes
// REQUIRED: Active wanting, unfinished tension, unnamed hunger"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXAMPLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// âœ“ ALLOWED (ST1):
//   "Her Terms" â€” names the power dynamic, not its outcome
//   "The Waiting" â€” names the state, not what it led to
//   "His Hunger" â€” names desire, not satisfaction
//   "Between Wanting" â€” suspension, not resolution
//   "The Hesitation" â€” moment of choice, not choice made
//
// âœ— FORBIDDEN (ST1):
//   "Her Surrender" â€” claims resolution ST1 can't deliver
//   "What He Took" â€” past tense implies completed action
//   "The Reckoning" â€” aftermath vocabulary, not tension
//   "Finally His" â€” temporal finality marker
//   "Ruined" â€” consequence language, not anticipation
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TITLE REGIME MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// A title names what the story WANTS.
// Not what it HAS. Not what it DID.
// At ST1, the story is still wanting.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                    GENRE REGIME: NESTED PRESSURE MODEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// SYSTEM PHILOSOPHY
// -----------------
// Storybound genres are PRESSURE ENGINES, not bookshelf categories.
// They shape: pacing, tension, romantic cost, consequence timing.
//
// Worlds (Modern, Fantasy, Sci-Fi, Historical) are AESTHETIC LENSES, not pressures.
// Tone controls NARRATION STYLE and confession posture.
// Genre (Pressure) controls WHAT'S AT STAKE and HOW IT COSTS.
//
// This task introduces HIERARCHY, not new mechanics.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HIERARCHY: PRIMARY PRESSURE â†’ OPTIONAL FLAVOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// LAYER 1 â€” PRIMARY PRESSURES (8 total, the ONLY visible top-level choices)
//
// PowerControl      â€” Someone has leverage. Someone else pays for it.
// RiskExposure      â€” Being seen, known, caught, or revealed is dangerous.
// EscapePursuit     â€” Leaving, rescuing, or outrunning something.
// ObligationBurden  â€” Duty, destiny, or expectation presses inward.
// DesireObsession   â€” Wanting something too much, too soon, or for the wrong reasons.
// ReckoningPast     â€” History, guilt, or unfinished business intrudes.
// Transformation    â€” Someone is becoming something they didn't plan to be.
// Survival          â€” Staying alive â€” socially, politically, physically, or emotionally.
//
// LAYER 2 â€” FLAVORS (optional refinements, 3-5 per pressure)
//
// Flavors appear AFTER a pressure is selected.
// Flavors are NEVER required.
// Flavors modify texture, not authority.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAVOR MAP (CANONICAL NESTING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PowerControl:     Billionaire, CrimeSyndicate, Political, Espionage, CultOrder
// RiskExposure:     Noir, ForbiddenKnowledge, PublicScandal, Surveillance, DoubleLife
// EscapePursuit:    Heist, Rescue, OnTheRun, LockedAway, BorderCrossing
// ObligationBurden: ChosenBurdened, DutyToFamily, Prophecy, CommandRank, Inheritance
// DesireObsession:  Obsession, ForbiddenRomance, Rivalry, Addiction, Jealousy
// ReckoningPast:    RelentlessPast, Redemption, OldDebts, BetrayalHistory, LostRelationship
// Transformation:   BecomingPowerful, MoralCorruption, Awakening, IdentityShift, Ascension
// Survival:         WarZone, Castaway, Lost, Trapped, Afflicted, Scarcity  [Hidden: Apocalypse]
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BACKWARD COMPATIBILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// state.picks.genre      â€” LEGACY field, derived from pressure+flavor
// state.picks.pressure   â€” Primary pressure selection (required)
// state.picks.flavor     â€” Optional flavor selection
//
// LEGACY_GENRE_TO_PRESSURE maps old genre values to pressure+flavor:
//   Billionaire â†’ { PowerControl, Billionaire }
//   Noir â†’ { RiskExposure, Noir }
//   Heist â†’ { EscapePursuit, Heist }
//   etc.
//
// getEffectiveGenre(pressure, flavor) â€” Returns flavor if set, else pressure default
// migrateLegacyGenre(genre) â€” Converts old saves to new system
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DSP INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// getPressureDSPPhrase(pressure, flavor) â€” Returns DSP paraphrase
// - If flavor has override in FLAVOR_DSP_OVERRIDES, use it
// - Otherwise use PRIMARY_PRESSURES[pressure].dspPhrase
//
// generateDSPSentence() updated to use pressure system with legacy fallback.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI CONSTRAINTS (DO NOT VIOLATE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// âŒ Never show more than 8 primary options
// âŒ Never require selecting a flavor
// âŒ Never show flavors before a primary is chosen
// âŒ Never expose hierarchy language to the user
//
// The experience should feel:
// "I'm choosing what kind of pressure this story lives under."
//
// Not:
// "I'm configuring a system."
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD HANDLING (IMPORTANT)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Worlds are AESTHETIC LENSES, not pressures:
// - Fantasy, Sci-Fi, Modern, Historical, Near-Future, Alternate Reality
//
// Worlds modify:
// - imagery
// - vocabulary
// - stakes presentation
//
// Worlds DO NOT add pressure by themselves.
//
// Examples:
// - Obligation + Fantasy â†’ prophecy without saying "prophecy"
// - Risk + Sci-Fi â†’ surveillance state
// - Power + Modern â†’ billionaire / media empire
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GENRE REGIME MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Genres describe PRESSURE.
// Worlds describe HOW IT LOOKS.
// Tone describes HOW IT'S CONFESSED.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                    BREADCRUMB FLOW SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// SYSTEM PHILOSOPHY
// -----------------
// Cards are semantic objects, not UI widgets.
// They represent meaning, authorship decisions, and narrative pressure.
// Setup should feel like the first chapter of the book, not a configurator.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE INTERACTION MODEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// One row of cards at a time.
// Selection is visible.
// Progression is ceremonial.
// State becomes breadcrumb.
//
// At no point should the user:
// - scroll through multiple rows of cards
// - see multiple semantic layers simultaneously
// - configure via hidden state
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CARD STATES (4 ONLY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// 1. IDLE â€” Card sits in row, hover effects allowed
// 2. FLIPPED â€” First click reveals description + flavor count
// 3. ZOOMED â€” Second click expands for full selection mode
// 4. BREADCRUMB â€” Committed, minimized at top of screen
//
// No other states may be introduced.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLOW SEQUENCE (LOCKED ORDER)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// 1. Pull
// 2. World
// 3. Tone
// 4. Polarity (Guided Fate)
//
// At no time may two of these rows be visible together.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTINUE ACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Continue button appears ONLY when exactly one card is selected.
//
// On Continue:
// 1. Selected card smoothly shrinks
// 2. Animates to top center (breadcrumb row)
// 3. Becomes a breadcrumb card
// 4. Other cards dissipate into sparkles
// 5. Fade out completely
// 6. New row fades in below breadcrumbs
//
// Animation must feel: deliberate, narrative, not instantaneous
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREADCRUMB RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Breadcrumb cards:
// âœ“ Remain visible at top of screen
// âœ“ Visually smaller than selection cards (75Ã—105 vs 150Ã—210)
// âœ“ Accumulate left-to-right in order of selection
// âœ“ May slightly overlap or sit adjacent
// âœ“ Represent committed authorship decisions
// âœ“ May be hoverable for reminder copy
//
// âŒ Do not expand automatically
// âŒ Do not re-trigger selection flow
// âŒ Cannot be removed or reordered
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSS CLASSES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// .breadcrumb-row          â€” Container at top, sticky positioning
// .breadcrumb-card         â€” Committed selection, minimized
// .card-flow-row           â€” Wrapper for each selection stage
// .card-flow-row.flow-hidden â€” Hidden stage (not yet reached)
// .card-flow-row.flow-entering â€” Fade-in animation for new stage
// .flow-continue-btn       â€” Continue button (hidden until selection)
// .flow-continue-btn.visible â€” Show continue button
// .sb-card.dissipating     â€” Card fading out with sparkles
// .sb-card.becoming-breadcrumb â€” Card animating to breadcrumb position
// .dissipate-sparkle       â€” Individual sparkle particle
// .flow-stage-indicator    â€” Progress dots
// .flow-stage-dot          â€” Individual dot
// .flow-stage-dot.active   â€” Current stage
// .flow-stage-dot.completed â€” Past stages
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// initBreadcrumbFlow()           â€” Initialize flow system
// handleFlowContinue(stage)      â€” Process continue action
// animateCardToBreadcrumb()      â€” Animate selection to breadcrumb
// dissipateCards()               â€” Sparkle dissipation effect
// createDissipationSparkles()    â€” Create sparkle particles
// updateContinueButtonVisibility() â€” Show/hide continue button
// updateFlowStageIndicator()     â€” Update progress dots
// resetBreadcrumbFlow()          â€” Reset to initial state (new story)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREADCRUMB FLOW MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Choices should feel like scenes, not settings.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    STORY STATE LOCKING â€” DESTRUCTIVE CHANGE RULES
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHILOSOPHY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Once a story exists (Scene 1 generated), the story's foundation is LOCKED.
// Users cannot silently change story-defining fields. Any attempt to change
// a locked field triggers a warning modal: this is a destructive action.
//
// The user must choose:
// 1. Save & Start New Story â€” saves current story, then clears for fresh start
// 2. Start New Story â€” discards current story without saving
// 3. Cancel â€” keeps current story, reverts selection
//
// This prevents accidental loss of creative work and makes the commitment
// to a story feel deliberate and meaningful.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LOCKED FIELDS (Cannot change without destroying story)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// - pressure      â€” Primary pressure (story engine)
// - flavor        â€” Pressure refinement
// - genre         â€” Legacy genre (derived from pressure+flavor)
// - world         â€” World setting
// - worldSubtype  â€” World refinement
// - tone          â€” Narrative tone
// - dynamic       â€” Relationship dynamic (Guided Fate)
// - pov           â€” Point of view
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SAFE FIELDS (Can change freely, even with existing story)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// - era           â€” Time period (decorative)
// - archetype     â€” Reader archetype (affects framing, not story)
// - title         â€” Book title (can be renamed anytime)
// - cover         â€” Cover image (can be regenerated)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETECTION LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// hasExistingStory():
//   Returns true if state.scenes[0] exists with content
//   (Scene 1 generation = story commitment point)
//
// isLockedField(grp):
//   Returns true if grp is in STORY_LOCKED_FIELDS array
//
// wouldDestroyStory(grp, newVal):
//   Returns true if:
//   1. hasExistingStory() is true, AND
//   2. isLockedField(grp) is true, AND
//   3. newVal differs from current state.picks[grp]
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MODAL BEHAVIOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// showDestructiveChangeWarning(grp, newVal, card, onConfirm):
//   1. Stores pending change in pendingDestructiveChange
//   2. Shows #destructiveChangeModal overlay
//   3. Waits for user decision
//
// On "Save & Start New Story":
//   1. Triggers save flow (saveCurrentStory)
//   2. On save completion: clears story state, executes pending change
//
// On "Start New Story":
//   1. Clears story state immediately (clearStoryForNewStart)
//   2. Executes pending change
//
// On "Cancel":
//   1. Clears pendingDestructiveChange
//   2. Closes modal
//   3. User stays on current story
//
// clearStoryForNewStart():
//   1. Clears state.scenes to []
//   2. Clears state.storyText to ''
//   3. Clears state.currentScene to 0
//   4. Clears state.coverDataUrl to null
//   5. Clears any generated title
//   6. Resets DSP state
//   7. Resets visualization economy
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUTTON STATE RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If story exists AND no destructive changes pending:
//   Button label: "Continue Story"
//   Hint visible: "Your story will resume where you left off."
//
// If no story exists OR destructive changes confirmed:
//   Button label: "Begin Story"
//   Hint hidden
//
// No mixed states. No ambiguous labels.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PASSIVE SAVE AFFORDANCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Whenever a story exists, the system shows calm reassurance (no modals):
//
// - "Your story will resume where you left off." beneath Continue Story button
// - Hints toggle automatically via updateBeginButtonLabel()
//
// Hint elements:
//   #beginBtnHint           â€” Below main Begin/Continue button
//   #continueFromDynamicHint â€” Below breadcrumb flow final button
//   #btnBeginStoryHint      â€” Below cover view Begin/Continue button
//   #btnSettingBeginStoryHint â€” Below setting view Begin/Continue button
//
// CSS class: .story-continue-hint (hidden by default, shown when canContinue)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// STORY_LOCKED_FIELDS          â€” Array of field names that trigger warning
// pendingDestructiveChange     â€” Stores { grp, val, card, onConfirm } during modal
// hasExistingStory()           â€” Check if story exists
// isLockedField(grp)           â€” Check if field is locked
// wouldDestroyStory(grp, val)  â€” Check if change would destroy story
// showDestructiveChangeWarning() â€” Show warning modal
// clearStoryForNewStart()      â€” Clear all story state
// initDestructiveChangeModal() â€” Bind modal button handlers
// updateBeginButtonLabel()     â€” Update button labels and toggle hints
// canContinueExistingStory()   â€” Check if story can be continued
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STORY STATE LOCKING MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// A story is either continued or consciously let go.
// Never quietly replaced.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    PLAQUE BUTTON MATERIAL REGIME (LOCKED)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHILOSOPHY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Storybound buttons are objects, not flat UI.
// They represent plaques, cards, instruments, decisions made visible.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MATERIAL AUTHORITY (GLOBAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// APPLIES TO:
//   âœ“ All black buttons
//   âœ“ All gold buttons
//   âœ“ DSP controls
//   âœ“ Fate Card buttons
//   âœ“ Continue / Back / Generate / Primary / Breadcrumb buttons
//   âœ“ Modal actions
//   âœ“ Disabled buttons (visual state only)
//
// DOES NOT APPLY TO:
//   âœ— Pure text links
//   âœ— Passive labels
//   âœ— Non-interactive UI chrome
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANONICAL BUTTON MATERIAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// 1. BASE MATERIAL
//    - Brushed metal plaque appearance
//    - Horizontal grain only (modulates brightness, never replaces color)
//    - Color variants: Gold (warm, antique) or Black (lacquered/anodized)
//
// 2. GEOMETRY (NON-NEGOTIABLE)
//    - Rectangular
//    - All right-angled corners
//    - NO rounding, NO pills, NO soft edges
//
// 3. BORDER SYSTEM
//    - Outer border: Slightly brighter than body (structural)
//    - Inner border: Darker, inset (creates plate registration feel)
//    - Corner squares: All 4 corners, identical size, no animation
//    - Center diamonds: Top center + bottom center (alignment markers)
//
// 4. TYPOGRAPHY RULE
//    - Text sits on the plaque, not floating
//    - High contrast, restrained
//    - NO glow, NO emboss, NO bevel text effects
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE MAPPING (AUTHORITATIVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// State       | Visual Change Allowed
// ------------|------------------------------------------
// Default     | Canonical plaque
// Hover       | Slight brightness lift ONLY
// Active      | Slight darken + grain compression
// Disabled    | Desaturate + reduce contrast
// Loading     | Text change only (no spinner overlays)
// Breadcrumb  | Same plaque, scaled down
//
// âŒ No other state visuals permitted
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DSP INTEGRATION (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// DSP may ONLY affect:
//   âœ“ Brightness
//   âœ“ Contrast
//   âœ“ Saturation
//   âœ“ Opacity
//   âœ“ Grain intensity (subtle)
//
// DSP must NEVER:
//   âœ— Change border thickness
//   âœ— Add or remove diamonds
//   âœ— Add glow
//   âœ— Add motion
//   âœ— Introduce new shapes
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSS IMPLEMENTATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// CSS Variables (defined in styles.css :root):
//   --plaque-black-base, --plaque-black-grain, --plaque-black-outer, --plaque-black-inner
//   --plaque-gold-base, --plaque-gold-grain, --plaque-gold-outer, --plaque-gold-inner
//   --plaque-corner-size, --plaque-diamond-size
//   --plaque-border-outer, --plaque-border-inner
//
// Base class: .sb-plaque-btn
// Variants: .plaque-gold, .plaque-sm, .plaque-lg, .plaque-xl, .plaque-breadcrumb
//
// Global button styles updated to use plaque material:
//   button, .dsp-btn, .small-btn, .flow-continue-btn, .cover-view-btn
//   .setting-begin-btn, .sb-flavor-btn, #btnCopyCode
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAQUE MATERIAL MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Storybound does not click.
// Storybound commits.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    ORNATE BORDER HANDLING (ASSET-BASED)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Ornate border â€” cover layer 2 (world-specific decorative frame)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ASSET PATH & WORLD MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Asset path: /assets/borders/ornate/{world}_base.png
//
// WORLD â†’ ASSET (6 worlds, NO Mythic):
//   Modern          â†’ modern_base.png
//   Fantasy         â†’ fantasy_base.png
//   SciFi           â†’ scifi_base.png
//   Historical      â†’ historical_base.png
//   PostApocalyptic â†’ postapocalyptic_base.png
//   Dystopia        â†’ dystopia_base.png
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAVOR â†’ SURFACE CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Flavor affects SURFACE CONDITION only:
//   - Damage (scratches, dents, chips)
//   - Aging (patina, fading, foxing)
//   - Corrosion (rust, verdigris, tarnish)
//
// Flavor NEVER affects geometry. Applied via CSS filters.
//
// CSS filter classes:
//   .flavor-aged      â†’ Sepia warmth, slight desaturation
//   .flavor-weathered â†’ Cool desaturation, reduced contrast
//   .flavor-corroded  â†’ Green-blue tint (verdigris)
//   .flavor-rusted    â†’ Warm reddish-brown shift
//   .flavor-tarnished â†’ Silver/gold darkening
//   .flavor-pristine  â†’ Slightly enhanced (default)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAILURE HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If asset unavailable:
//   1. Omit border entirely (do not show placeholder)
//   2. Log: "Ornate border asset unavailable â€” border suppressed"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTML STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// <div id="coverOrnateBorder" class="cover-ornate-border hidden">
//   <img id="ornateBorderImg" class="erotic-border-img" src="" alt="" />
// </div>
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Maps:
//   ORNATE_BORDER_WORLD_MAP   â€” world name â†’ asset key
//   ORNATE_BORDER_FLAVOR_MAP  â€” worldSubtype â†’ filter class
//
// Functions:
//   applyOrnateBorder(borderEl, world, hasSoulmates) â€” Loads asset, applies classes
//   resetCoverLayers() â€” Clears all cover layers including border image
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORNATE BORDER MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The border frames; it does not change shape.
// The flavor weathers; it does not rebuild.
// What fails, fails silently.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    DIRTY KEYHOLE SYSTEM (MASK-BASED)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Keyhole takeover â€” cover layer 3 (world-specific mask-based frame)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYHOLE IS A MASK, NOT AN OBJECT (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The keyhole is:
//   âœ“ A dominant alpha mask
//   âœ“ The primary compositional frame
//   âœ“ The defining geometry of the cover
//
// The keyhole is NOT:
//   âœ— A decorative overlay
//   âœ— A small cutout
//   âœ— An object placed on top
//
// If the keyhole does not dominate the cover, the output is INVALID.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEOMETRY LOCK (NON-NEGOTIABLE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Cover format: Portrait, 5:7 aspect ratio
//
// Keyhole vertical span:
//   - Top of aperture: 8% from top of cover
//   - Bottom of aperture: 8% from bottom of cover
//   â†’ Total visible aperture height â‰ˆ 84% of cover height
//
// Keyhole horizontal span:
//   - Crown width: 55â€“65% of cover width
//   - Stem minimum width: â‰¥22% of cover width
//
// Negative space rule:
//   - Everything INSIDE the keyhole = scene (symbolic objects ONLY)
//   - Everything OUTSIDE the keyhole = solid material
//
// Legibility rule:
//   - The silhouette must read as a "keyhole" at 64px height
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ASSET PATH & WORLD MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Asset path: /assets/keyholes/{world}_mask.png
//
// WORLD â†’ SILHOUETTE (6 worlds, one each):
//   Modern          â†’ modern_mask.png        (clean industrial, machined steel)
//   Historical      â†’ historical_mask.png    (ornate, filigree, aged brass)
//   Fantasy         â†’ fantasy_mask.png       (hand-forged, rune-etched)
//   SciFi           â†’ scifi_mask.png         (geometric/octagonal, titanium)
//   Dystopia        â†’ dystopia_mask.png      (brutalist, industrial plate)
//   PostApocalyptic â†’ postapocalyptic_mask.png (salvaged, bolts, weld seams)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALLOWED KEYHOLE SHAPES (WHITELIST)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ALLOWED:
//   âœ“ Circular crown + tapered stem
//   âœ“ Oval crown + straight stem
//   âœ“ Teardrop crown + narrow stem
//   âœ“ Double-lobed vintage crown + stem
//   âœ“ Octagonal crown (SCI-FI ONLY) + rectangular stem
//
// FORBIDDEN:
//   âœ— Rectangular apertures
//   âœ— Thin slits
//   âœ— Abstract cutouts
//   âœ— Organic blobs
//   âœ— Any shape that does not read as a keyhole
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLAVOR â†’ SURFACE CONDITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Flavor affects SURFACE CONDITION only:
//   - Wear (scratches, dents, chips)
//   - Corrosion (rust, verdigris, oxidation)
//   - Fracture (cracks, breaks)
//   - Environmental damage (growth, decay, discoloration)
//
// Flavor NEVER changes:
//   âœ— Aperture size
//   âœ— Silhouette geometry
//   âœ— Keyhole position
//
// CSS filter classes:
//   .flavor-aged       â†’ Patina, fading, time-worn
//   .flavor-weathered  â†’ Exposure damage, cool desaturation
//   .flavor-corroded   â†’ Verdigris, oxidation, green-blue tint
//   .flavor-rusted     â†’ Iron oxide, warm reddish-brown
//   .flavor-irradiated â†’ Discoloration, unnatural tint
//   .flavor-fractured  â†’ Cracked, structural damage
//   .flavor-pristine   â†’ Clean, well-maintained (default)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TITLE PLACEMENT (DIRTY TIER RULE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Dirty-tier titles MUST be:
//   âœ“ Engraved into the surrounding keyhole material
//   âœ“ Embossed, etched, stamped, or inlaid
//
// Titles must NEVER:
//   âœ— Float inside the aperture
//   âœ— Overlay the scene
//   âœ— Compete with the aperture opening
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTENT RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Inside the aperture:
//   âœ“ Symbolic objects ONLY
//   âœ“ Environments, charged symbols, metaphorical compositions
//
// Forbidden inside aperture:
//   âœ— No humans
//   âœ— No body parts
//   âœ— No sexual acts
//   âœ— No explicit anatomy
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAILURE HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If any constraint cannot be satisfied:
//   1. Do NOT improvise
//   2. Do NOT shrink the aperture
//   3. Do NOT invent a new silhouette
//   4. Suppress the cover and log:
//      "Dirty keyhole constraint failed â€” cover suppressed"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTML STRUCTURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// <div id="coverKeyholeOverlay" class="cover-keyhole-overlay hidden">
//   <div class="keyhole-plate" id="keyholeplate"></div>
//   <div class="keyhole-title"></div>
// </div>
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Maps:
//   DIRTY_KEYHOLE_WORLD_MAP   â€” world name â†’ mask asset key
//   DIRTY_KEYHOLE_FLAVOR_MAP  â€” worldSubtype â†’ surface condition class
//   VALID_KEYHOLE_WORLDS      â€” Set of allowed world keys (no Mythic)
//
// Functions:
//   auditDirtyKeyhole(world, flavor)          â€” Self-check validation
//   applyDirtyKeyhole(keyholeEl, world, hasSoulmates) â€” Runs audit, loads mask, applies classes
//   resetCoverLayers() â€” Clears all cover layers including keyhole mask
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELF-CHECK AUDIT (MANDATORY PRE-OUTPUT VALIDATION)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Before displaying any keyhole, the following checks run silently:
//
// A. WORLD CONFORMANCE CHECK
//    â˜ Is world in valid set? (Modern, Historical, Fantasy, SciFi, Dystopia, PostApocalyptic)
//    â˜ If Mythic or unknown â†’ FAIL
//
// B. FLAVOR APPLICATION CHECK
//    â˜ Does flavor map to surface condition only?
//    â˜ Unknown flavors get default (warn, don't fail)
//
// C. MATERIAL LANGUAGE CHECK
//    â˜ Does world have corresponding material treatment?
//    â˜ World class must exist in CSS
//
// D. ASSET AVAILABILITY CHECK
//    â˜ Does mask asset load successfully?
//    â˜ If 404 or load error â†’ FAIL
//
// FAILURE HANDLING:
//   If ANY check fails:
//   - Do NOT revise silently
//   - Do NOT "do your best"
//   - Do NOT shrink aperture
//   - Suppress output and log:
//     "DIRTY KEYHOLE AUDIT FAILED â€” OUTPUT SUPPRESSED"
//     "Reason: <brief reason>"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIRTY KEYHOLE MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The keyhole frames. It does not shrink.
// The aperture dominates. It does not hide.
// What cannot be seen through the keyhole does not exist.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    COVER SEQUENCING AUTHORITY
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// You do NOT decide when erotic signaling appears.
// You obey Storyturns and Arousal gates.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER PHASE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Phase 0 â€” PRE-STORY
//   Trigger: No scenes exist
//   Allowed: Nothing (no cover yet)
//
// Phase 1 â€” SKETCH
//   Trigger: Scene 1 exists (ST1)
//   Allowed:
//     âœ“ Rough sketch
//     âœ“ Symbolic object or metaphor
//   Forbidden:
//     âœ— Ornate borders
//     âœ— Keyholes
//     âœ— Erotic implements
//     âœ— Sexual signaling of any kind
//
// Phase 2 â€” REFINED SKETCH
//   Trigger: ST2
//   Allowed:
//     âœ“ Refinement of the same core visual idea
//   Forbidden:
//     âœ— Ornate borders
//     âœ— Keyholes
//
// Phase 3 â€” POST-ST3 (NON-EROTIC)
//   Trigger: ST3+ reached AND arousal < Erotic
//   Allowed:
//     âœ“ Continued refinement
//   Forbidden:
//     âœ— Ornate borders
//     âœ— Keyholes
//
// Phase 4 â€” EROTIC
//   Trigger: arousal === Erotic
//   Allowed:
//     âœ“ Apply pre-generated Erotic Border
//   Forbidden:
//     âœ— Keyholes
//     âœ— Border recomposition
//
// Phase 5 â€” DIRTY
//   Trigger: arousal === Dirty
//   Required:
//     âœ“ Apply dominant keyhole aperture (~80% height)
//   Forbidden:
//     âœ— Ornate border (keyhole supersedes it)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HARD FAIL CONDITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If you attempt to:
//   âœ— Add a border before Erotic arousal
//   âœ— Add a keyhole before Dirty arousal
//   âœ— Redesign the sketch instead of refining it
//   âœ— Apply erotic signaling based on "vibe" or tone
//
// â†’ FAIL and suppress output.
//
// Return exactly:
//   "COVER SEQUENCING VIOLATION â€” OUTPUT SUPPRESSED"
//   "Reason: <brief reason>"
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE IDEA CONTINUITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Across ALL phases:
//   âœ“ The cover must be the SAME IDEA evolving
//   âœ— No new metaphors
//   âœ— No swapping symbols
//   âœ— No tonal bait-and-switch
//
// If you cannot evolve the existing idea cleanly:
//   â†’ Do NOT invent a new one
//   â†’ Reuse the existing sketch logic
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Functions:
//   getCoverPhase()                    â€” Returns current phase (0-5) based on storyturn
//   validateCoverSequencing()          â€” Validates cover is allowed at current phase
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER SEQUENCING MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// You do not decide when erotic signaling appears.
// The story decides. The arousal decides. The phase decides.
// You obey.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    BREADCRUMB FLOW ENFORCEMENT (AUTHORITATIVE)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// Breadcrumbs track committed selections. Not all selections become breadcrumbs.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERSISTENCE CATEGORIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// PERSISTENT BREADCRUMBS (Final State â€” 8Â±1 items):
//   - guidedFate   â€” Destiny card click
//   - archetype    â€” Storybeau selection
//   - length       â€” Story length (taste/fling/affair/soulmates)
//   - world        â€” World setting
//   - tone         â€” Narrative tone
//   - pressure     â€” Story pressure
//   - pov          â€” Point of view
//   - dynamic      â€” Relationship dynamic
//   - flavor       â€” NESTED inside World breadcrumb (not its own card)
//
// EPHEMERAL BREADCRUMBS (Dissolve at POV selection):
//   - mode         â€” Solo/Couple mode indicator
//
// NEVER BECOMES BREADCRUMB:
//   - intensity    â€” Arousal level (NEVER collapses to breadcrumb)
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DISSOLUTION RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// When POV is selected:
//   1. All ephemeral breadcrumbs (mode) sparkle-dissipate
//   2. Only persistent breadcrumbs remain
//   3. Final count: 8Â±1 breadcrumbs
//
// Flavor does NOT get its own breadcrumb:
//   - Appears as subtitle in World breadcrumb
//   - Updates when flavor selection changes
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Constants:
//   BREADCRUMB_PERSISTENT_LAYERS    â€” Layers that persist as final breadcrumbs
//   BREADCRUMB_EPHEMERAL_LAYERS     â€” Layers that dissolve at POV
//   BREADCRUMB_EXCLUDED_LAYERS      â€” Layers that never become breadcrumbs
//
// Functions:
//   canBecomeBreadcrumb(grp)        â€” Check if layer can become breadcrumb
//   shouldDissolveAtPOV(grp)        â€” Check if layer dissolves at POV
//   dissolveEphemeralBreadcrumbs()  â€” Trigger dissolution of ephemeral layers
//   getBreadcrumbLabel(grp, val)    â€” Get structured label with subtitle
//   updateWorldBreadcrumbFlavor()   â€” Update world's nested flavor label
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREADCRUMB FLOW MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Selections commit. Breadcrumbs persist.
// Arousal never shows its face here.
// Mode dissolves when perspective locks.
// Flavor hides inside its world.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    COVER PERSISTENCE & RESET AUTHORITY
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// Covers are bound to STORY STATE.
// You do NOT freely regenerate them.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER BINDING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// COVER IS BOUND TO:
//   âœ“ Story ID
//   âœ“ Story Shape (world, tone, pressure, dynamic)
//   âœ“ Characters (names + roles)
//   âœ“ Storyturn progression
//   âœ“ Arousal tier (for overlay evolution)
//
// COVER IS NOT BOUND TO:
//   âœ— UI navigation
//   âœ— User curiosity
//   âœ— Accidental back clicks
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NAVIGATION BEHAVIOR (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If user navigates BACK to Story Shape / Setting / Cover AND story exists:
//
//   âœ“ Story PAUSES (does not reset)
//   âœ“ Button label shows "Continue Story"
//   âœ“ Cover REMAINS visible
//   âœ“ Guided Fate remains DISABLED
//   âœ— NO regeneration occurs
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHANGE DETECTION RULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If user changes ANY of these after a story exists:
//   - Story Shape (pressure, flavor)
//   - World (world, worldSubtype)
//   - Tone
//   - Dynamic
//   - POV
//
// THEN:
//   âœ— Current story is INVALIDATED
//   âœ— Current cover is DESTROYED
//   âœ“ Guided Fate becomes ACTIVE again
//
// This is NOT reversible.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AROUSAL EXCEPTION (ONLY EXCEPTION)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// User MAY change arousal level WITHOUT:
//   âœ— Destroying the story
//   âœ— Destroying the cover
//
// Result:
//   âœ“ Cover may EVOLVE (border â†” keyhole)
//   âœ“ Core visual idea MUST remain unchanged
//
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USER WARNING REQUIREMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// If user attempts to make a destructive change, MUST surface warning:
//
//   "Changing these settings will permanently discard your current story and cover.
//    Save your story before continuing."
//
// No silent resets. No implicit forgiveness.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESTART BEHAVIOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// On explicit Restart:
//   1. Show current cover first
//   2. Return to last generated scene
//   3. Do NOT regenerate cover unless state changed
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JAVASCRIPT API
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Constants:
//   STORY_LOCKED_FIELDS      â€” Fields that destroy story+cover when changed
//   COVER_SAFE_FIELDS        â€” Fields that allow cover evolution, not destruction
//
// Functions:
//   hasExistingCover()                     â€” Check if cover exists
//   wouldDestroyCover(grp, newVal)         â€” Check if change destroys cover
//   wouldEvolveCover(grp, newVal)          â€” Check if change evolves cover
//   getCoverPersistenceStatus(grp, newVal) â€” Full persistence status
//   clearStoryForNewStart()                â€” Destroys story AND cover
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVER PERSISTENCE MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// The cover is the story's face.
// Destroy the story, destroy the face.
// Change the arousal, change the expression â€” not the face.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
//                    BUTTON SYSTEM LOCK (AUTHORITATIVE)
//
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
//
// All buttons in Storybound derive their material from .sb-btn.
// This is a SYSTEMIC LOCK, not a style preference.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MATERIAL LOCK (CRITICAL)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// MATERIAL IS IDENTITY.
// These properties may NEVER be overridden by any state:
//   - background-color
//   - background-image
//   - border-radius (always 0)
//   - box-shadow (plaque system only)
//
// No hover, active, focus, disabled, paywalled, or JS-mutated state
// may change the material. Material is the button's physical identity.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE IS BEHAVIOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// State changes communicate via AFFORDANCE, not material:
//   âœ“ opacity
//   âœ“ contrast
//   âœ“ saturation
//   âœ“ filter brightness
//   âœ“ text color shift
//
// State changes may NEVER use:
//   âœ— new gradients
//   âœ— glow effects
//   âœ— background replacement
//   âœ— box-shadow halos
//   âœ— border-radius changes
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CSS CLASSES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Base Class:
//   .sb-btn                    â€” Canonical button material (black plaque)
//
// Variants (hue/brightness only):
//   .sb-btn--gold              â€” Gold plaque variant
//   .sb-btn--black             â€” Explicit black (same as default)
//
// Sizes:
//   .sb-btn--sm                â€” Small (8px 20px)
//   .sb-btn--lg                â€” Large (14px 40px)
//   .sb-btn--xl                â€” Extra large (16px 48px)
//   .sb-btn--full              â€” Full width
//
// States (affordance-based):
//   .is-disabled               â€” Desaturated + reduced contrast
//   .is-paywalled              â€” Dimmed but still looks like a button
//   .is-loading                â€” Reduced opacity, cursor wait
//   .is-primary                â€” Slightly brighter
//   .is-warning                â€” Warm sepia tint
//   .is-danger                 â€” Desaturated with subtle red shift
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INLINE STYLE PURGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Inline styles on buttons that set material properties are FORBIDDEN:
//   âœ— style="background:..."
//   âœ— style="border:..."
//   âœ— style="box-shadow:..."
//   âœ— style="border-radius:..."
//
// Layout-only inline styles are ALLOWED:
//   âœ“ style="margin:..."
//   âœ“ style="position:..."
//   âœ“ style="width:..."
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JS MUTATION RULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// JavaScript may NEVER directly mutate button material properties.
// Instead, toggle semantic classes:
//   âœ“ element.classList.add('is-loading')
//   âœ“ element.classList.remove('is-paywalled')
//   âœ— element.style.background = '...'
//   âœ— element.style.boxShadow = '...'
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUTTON SYSTEM MANTRA (DO NOT REMOVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Storybound buttons are not UI elements.
// They are objects from the same world as the story.
//
// Material is identity.
// State is behavior.
//
// Never confuse the two.
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRUST REPAIR PHASE 2 â€” COVER & VISUALIZATION (AUTHORITATIVE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// This section documents the Trust Repair Phase 2 implementation for cover gallery
// and visualization flows, ensuring users never feel deceived or manipulated.
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. COVER GALLERY â†’ STAGE TRANSFORMATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// The Cover Gallery is no longer a carousel. It is now a STAGE.
//
// Layout rules (LOCKED):
//   - Central cover dominates: 320Ã—450px, left spine border, prominent shadow
//   - Thumbnails demoted to footer strip: 60Ã—85px, 50% opacity
//   - Selected thumbnail receives active state (opacity 1, gold border)
//   - Action buttons below thumbnails, never competing with cover
//
// Visual hierarchy (ALTAR, NOT SHELF):
//   - The book is the altar object â€” user is looking AT it, not shopping FROM it
//   - Thumbnails are memory, not merchandise
//   - Navigation is secondary to contemplation
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2. VISUALIZATION FLOW â€” MODAL-FIRST CONSENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: User clicks Visualize, gets redirected to paywall without seeing prompt.
// Trust repair: ALWAYS open modal first, show prompt, then request consent if needed.
//
// Flow (LOCKED):
//   1. User clicks Visualize
//   2. Modal opens immediately
//   3. Prompt is populated and visible
//   4. If Fortunes depleted and not subscribed:
//      - Show consent UI INSIDE modal (not separate paywall)
//      - User can see what they would get before committing
//   5. Only after consent does generation proceed
//
// Functions:
//   - window.summonVision(regenerate) â€” Main entry, modal-first
//   - window.enablePayAsYouGoFromViz() â€” Consent handler inside modal
//   - populateVizPromptOnly() â€” Shows prompt without generating
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3. MODIFIER VALIDATION â€” AROUSAL-BASED RESTRICTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: User enters disallowed modifier, gets silent failure or weird result.
// Trust repair: Explicit rejection with clear message explaining why.
//
// Validation rules:
//   - Clean arousal: Blocks explicit body parts, lingerie, nudity, fetish terms
//   - Naughty arousal: Blocks explicit nudity, graphic content
//   - Spicy arousal: No restrictions
//
// Functions:
//   - validateModifier(modifier, arousalLevel) â€” Returns { valid, message }
//   - showModifierRejection(message) â€” Displays rejection UI
//   - AROUSAL_RESTRICTED_MODIFIERS â€” Pattern map by arousal level
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4. WORLD+TONE STYLE LOCK
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: Modifiers override World+Tone visual style, causing inconsistency.
// Trust repair: World+Tone ALWAYS determines base visual style, modifiers can only
//               adjust details within that style, never replace it.
//
// Style derivation (DETERMINISTIC):
//   - getStyleLock(world, tone) â†’ Returns locked style string
//   - WORLD_DEFAULT_STYLES: Modernâ†’photographic, Fantasyâ†’illustrative, etc.
//   - TONE_STYLE_OVERRIDES: Wry Confessionalâ†’sketch, Ink Noirâ†’sketch, etc.
//
// Enforcement:
//   - validateStyleLock(prompt, styleLock) â€” Strips conflicting style modifiers
//   - Style lock text prepended to every visualization prompt
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5. SKETCH TIER ENFORCEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// Trust failure: "Sketch" tier looks polished and finished.
// Trust repair: Sketch tier enforces visible incompleteness in execution.
//
// Tones requiring sketch tier:
//   - Wry Confessional, Satire, Irony, Ink Noir
//
// Required characteristics:
//   - Pencil, ink, or charcoal texture visible
//   - Uneven or broken linework
//   - Partial fill or restrained color (2-3 tones max)
//   - Visible construction lines or negative space
//
// Prohibited:
//   - Cinematic lighting, painterly shading, smooth gradients
//   - Finished illustration look, professional polish
//   - Hyper-realistic rendering
//
// Functions:
//   - requiresSketchTier(tone) â€” Boolean check
//   - getSketchTierEnforcement(tone) â€” Returns enforcement text for prompts
//   - SKETCH_TIER_ENFORCEMENT â€” Constant with full enforcement text
//
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FAILURE CONDITIONS (REGRESSION TESTS)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//
// These conditions must NEVER occur:
//
// âœ“ "Visualize never opens a paywall modal" â€” Modal always opens first
// âœ“ "Prompt is always visible before consent" â€” Consent UI inside modal
// âœ“ "Modifiers no longer derail style" â€” Style lock validates all prompts
// âœ“ "Disallowed modifiers are explicitly rejected" â€” Clear error messages
// âœ“ "Central cover visually dominates gallery" â€” Stage layout enforced
// âœ“ "Thumbnails no longer compete" â€” Demoted to footer strip
// âœ“ "Sketch tier is visibly unfinished" â€” Enforcement text in prompts
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

})();
